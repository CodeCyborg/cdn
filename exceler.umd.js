(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.exceler = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],2:[function(require,module,exports){

},{}],3:[function(require,module,exports){
(function (global,Buffer){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)

},{"base64-js":1,"buffer":3,"ieee754":7,"isarray":11}],4:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

},{"../../is-buffer/index.js":10}],5:[function(require,module,exports){
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).dayjs=e()}(this,(function(){"use strict";var t=1e3,e=6e4,n=36e5,r="millisecond",i="second",s="minute",u="hour",a="day",o="week",f="month",h="quarter",c="year",d="date",$="Invalid Date",l=/^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,y=/\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,M={name:"en",weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_")},m=function(t,e,n){var r=String(t);return!r||r.length>=e?t:""+Array(e+1-r.length).join(n)+t},g={s:m,z:function(t){var e=-t.utcOffset(),n=Math.abs(e),r=Math.floor(n/60),i=n%60;return(e<=0?"+":"-")+m(r,2,"0")+":"+m(i,2,"0")},m:function t(e,n){if(e.date()<n.date())return-t(n,e);var r=12*(n.year()-e.year())+(n.month()-e.month()),i=e.clone().add(r,f),s=n-i<0,u=e.clone().add(r+(s?-1:1),f);return+(-(r+(n-i)/(s?i-u:u-i))||0)},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t)},p:function(t){return{M:f,y:c,w:o,d:a,D:d,h:u,m:s,s:i,ms:r,Q:h}[t]||String(t||"").toLowerCase().replace(/s$/,"")},u:function(t){return void 0===t}},D="en",v={};v[D]=M;var p=function(t){return t instanceof _},S=function(t,e,n){var r;if(!t)return D;if("string"==typeof t)v[t]&&(r=t),e&&(v[t]=e,r=t);else{var i=t.name;v[i]=t,r=i}return!n&&r&&(D=r),r||!n&&D},w=function(t,e){if(p(t))return t.clone();var n="object"==typeof e?e:{};return n.date=t,n.args=arguments,new _(n)},O=g;O.l=S,O.i=p,O.w=function(t,e){return w(t,{locale:e.$L,utc:e.$u,x:e.$x,$offset:e.$offset})};var _=function(){function M(t){this.$L=S(t.locale,null,!0),this.parse(t)}var m=M.prototype;return m.parse=function(t){this.$d=function(t){var e=t.date,n=t.utc;if(null===e)return new Date(NaN);if(O.u(e))return new Date;if(e instanceof Date)return new Date(e);if("string"==typeof e&&!/Z$/i.test(e)){var r=e.match(l);if(r){var i=r[2]-1||0,s=(r[7]||"0").substring(0,3);return n?new Date(Date.UTC(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)):new Date(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)}}return new Date(e)}(t),this.$x=t.x||{},this.init()},m.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds()},m.$utils=function(){return O},m.isValid=function(){return!(this.$d.toString()===$)},m.isSame=function(t,e){var n=w(t);return this.startOf(e)<=n&&n<=this.endOf(e)},m.isAfter=function(t,e){return w(t)<this.startOf(e)},m.isBefore=function(t,e){return this.endOf(e)<w(t)},m.$g=function(t,e,n){return O.u(t)?this[e]:this.set(n,t)},m.unix=function(){return Math.floor(this.valueOf()/1e3)},m.valueOf=function(){return this.$d.getTime()},m.startOf=function(t,e){var n=this,r=!!O.u(e)||e,h=O.p(t),$=function(t,e){var i=O.w(n.$u?Date.UTC(n.$y,e,t):new Date(n.$y,e,t),n);return r?i:i.endOf(a)},l=function(t,e){return O.w(n.toDate()[t].apply(n.toDate("s"),(r?[0,0,0,0]:[23,59,59,999]).slice(e)),n)},y=this.$W,M=this.$M,m=this.$D,g="set"+(this.$u?"UTC":"");switch(h){case c:return r?$(1,0):$(31,11);case f:return r?$(1,M):$(0,M+1);case o:var D=this.$locale().weekStart||0,v=(y<D?y+7:y)-D;return $(r?m-v:m+(6-v),M);case a:case d:return l(g+"Hours",0);case u:return l(g+"Minutes",1);case s:return l(g+"Seconds",2);case i:return l(g+"Milliseconds",3);default:return this.clone()}},m.endOf=function(t){return this.startOf(t,!1)},m.$set=function(t,e){var n,o=O.p(t),h="set"+(this.$u?"UTC":""),$=(n={},n[a]=h+"Date",n[d]=h+"Date",n[f]=h+"Month",n[c]=h+"FullYear",n[u]=h+"Hours",n[s]=h+"Minutes",n[i]=h+"Seconds",n[r]=h+"Milliseconds",n)[o],l=o===a?this.$D+(e-this.$W):e;if(o===f||o===c){var y=this.clone().set(d,1);y.$d[$](l),y.init(),this.$d=y.set(d,Math.min(this.$D,y.daysInMonth())).$d}else $&&this.$d[$](l);return this.init(),this},m.set=function(t,e){return this.clone().$set(t,e)},m.get=function(t){return this[O.p(t)]()},m.add=function(r,h){var d,$=this;r=Number(r);var l=O.p(h),y=function(t){var e=w($);return O.w(e.date(e.date()+Math.round(t*r)),$)};if(l===f)return this.set(f,this.$M+r);if(l===c)return this.set(c,this.$y+r);if(l===a)return y(1);if(l===o)return y(7);var M=(d={},d[s]=e,d[u]=n,d[i]=t,d)[l]||1,m=this.$d.getTime()+r*M;return O.w(m,this)},m.subtract=function(t,e){return this.add(-1*t,e)},m.format=function(t){var e=this,n=this.$locale();if(!this.isValid())return n.invalidDate||$;var r=t||"YYYY-MM-DDTHH:mm:ssZ",i=O.z(this),s=this.$H,u=this.$m,a=this.$M,o=n.weekdays,f=n.months,h=function(t,n,i,s){return t&&(t[n]||t(e,r))||i[n].substr(0,s)},c=function(t){return O.s(s%12||12,t,"0")},d=n.meridiem||function(t,e,n){var r=t<12?"AM":"PM";return n?r.toLowerCase():r},l={YY:String(this.$y).slice(-2),YYYY:this.$y,M:a+1,MM:O.s(a+1,2,"0"),MMM:h(n.monthsShort,a,f,3),MMMM:h(f,a),D:this.$D,DD:O.s(this.$D,2,"0"),d:String(this.$W),dd:h(n.weekdaysMin,this.$W,o,2),ddd:h(n.weekdaysShort,this.$W,o,3),dddd:o[this.$W],H:String(s),HH:O.s(s,2,"0"),h:c(1),hh:c(2),a:d(s,u,!0),A:d(s,u,!1),m:String(u),mm:O.s(u,2,"0"),s:String(this.$s),ss:O.s(this.$s,2,"0"),SSS:O.s(this.$ms,3,"0"),Z:i};return r.replace(y,(function(t,e){return e||l[t]||i.replace(":","")}))},m.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},m.diff=function(r,d,$){var l,y=O.p(d),M=w(r),m=(M.utcOffset()-this.utcOffset())*e,g=this-M,D=O.m(this,M);return D=(l={},l[c]=D/12,l[f]=D,l[h]=D/3,l[o]=(g-m)/6048e5,l[a]=(g-m)/864e5,l[u]=g/n,l[s]=g/e,l[i]=g/t,l)[y]||g,$?D:O.a(D)},m.daysInMonth=function(){return this.endOf(f).$D},m.$locale=function(){return v[this.$L]},m.locale=function(t,e){if(!t)return this.$L;var n=this.clone(),r=S(t,e,!0);return r&&(n.$L=r),n},m.clone=function(){return O.w(this.$d,this)},m.toDate=function(){return new Date(this.valueOf())},m.toJSON=function(){return this.isValid()?this.toISOString():null},m.toISOString=function(){return this.$d.toISOString()},m.toString=function(){return this.$d.toUTCString()},M}(),b=_.prototype;return w.prototype=b,[["$ms",r],["$s",i],["$m",s],["$H",u],["$W",a],["$M",f],["$y",c],["$D",d]].forEach((function(t){b[t[1]]=function(e){return this.$g(e,t[0],t[1])}})),w.extend=function(t,e){return t.$i||(t(e,_,w),t.$i=!0),w},w.locale=S,w.isDayjs=p,w.unix=function(t){return w(1e3*t)},w.en=v[D],w.Ls=v,w.p={},w}));
},{}],6:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],7:[function(require,module,exports){
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],8:[function(require,module,exports){
(function (global){
'use strict';
var Mutation = global.MutationObserver || global.WebKitMutationObserver;

var scheduleDrain;

{
  if (Mutation) {
    var called = 0;
    var observer = new Mutation(nextTick);
    var element = global.document.createTextNode('');
    observer.observe(element, {
      characterData: true
    });
    scheduleDrain = function () {
      element.data = (called = ++called % 2);
    };
  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {
    var channel = new global.MessageChannel();
    channel.port1.onmessage = nextTick;
    scheduleDrain = function () {
      channel.port2.postMessage(0);
    };
  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {
    scheduleDrain = function () {

      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var scriptEl = global.document.createElement('script');
      scriptEl.onreadystatechange = function () {
        nextTick();

        scriptEl.onreadystatechange = null;
        scriptEl.parentNode.removeChild(scriptEl);
        scriptEl = null;
      };
      global.document.documentElement.appendChild(scriptEl);
    };
  } else {
    scheduleDrain = function () {
      setTimeout(nextTick, 0);
    };
  }
}

var draining;
var queue = [];
//named nextTick for less confusing stack traces
function nextTick() {
  draining = true;
  var i, oldQueue;
  var len = queue.length;
  while (len) {
    oldQueue = queue;
    queue = [];
    i = -1;
    while (++i < len) {
      oldQueue[i]();
    }
    len = queue.length;
  }
  draining = false;
}

module.exports = immediate;
function immediate(task) {
  if (queue.push(task) === 1 && !draining) {
    scheduleDrain();
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],9:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],10:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],11:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],12:[function(require,module,exports){
'use strict';
var utils = require('./utils');
var support = require('./support');
// private property
var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";


// public method for encoding
exports.encode = function(input) {
    var output = [];
    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
    var i = 0, len = input.length, remainingBytes = len;

    var isArray = utils.getTypeOf(input) !== "string";
    while (i < input.length) {
        remainingBytes = len - i;

        if (!isArray) {
            chr1 = input.charCodeAt(i++);
            chr2 = i < len ? input.charCodeAt(i++) : 0;
            chr3 = i < len ? input.charCodeAt(i++) : 0;
        } else {
            chr1 = input[i++];
            chr2 = i < len ? input[i++] : 0;
            chr3 = i < len ? input[i++] : 0;
        }

        enc1 = chr1 >> 2;
        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
        enc3 = remainingBytes > 1 ? (((chr2 & 15) << 2) | (chr3 >> 6)) : 64;
        enc4 = remainingBytes > 2 ? (chr3 & 63) : 64;

        output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));

    }

    return output.join("");
};

// public method for decoding
exports.decode = function(input) {
    var chr1, chr2, chr3;
    var enc1, enc2, enc3, enc4;
    var i = 0, resultIndex = 0;

    var dataUrlPrefix = "data:";

    if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {
        // This is a common error: people give a data url
        // (data:image/png;base64,iVBOR...) with a {base64: true} and
        // wonders why things don't work.
        // We can detect that the string input looks like a data url but we
        // *can't* be sure it is one: removing everything up to the comma would
        // be too dangerous.
        throw new Error("Invalid base64 input, it looks like a data url.");
    }

    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

    var totalLength = input.length * 3 / 4;
    if(input.charAt(input.length - 1) === _keyStr.charAt(64)) {
        totalLength--;
    }
    if(input.charAt(input.length - 2) === _keyStr.charAt(64)) {
        totalLength--;
    }
    if (totalLength % 1 !== 0) {
        // totalLength is not an integer, the length does not match a valid
        // base64 content. That can happen if:
        // - the input is not a base64 content
        // - the input is *almost* a base64 content, with a extra chars at the
        //   beginning or at the end
        // - the input uses a base64 variant (base64url for example)
        throw new Error("Invalid base64 input, bad content length.");
    }
    var output;
    if (support.uint8array) {
        output = new Uint8Array(totalLength|0);
    } else {
        output = new Array(totalLength|0);
    }

    while (i < input.length) {

        enc1 = _keyStr.indexOf(input.charAt(i++));
        enc2 = _keyStr.indexOf(input.charAt(i++));
        enc3 = _keyStr.indexOf(input.charAt(i++));
        enc4 = _keyStr.indexOf(input.charAt(i++));

        chr1 = (enc1 << 2) | (enc2 >> 4);
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
        chr3 = ((enc3 & 3) << 6) | enc4;

        output[resultIndex++] = chr1;

        if (enc3 !== 64) {
            output[resultIndex++] = chr2;
        }
        if (enc4 !== 64) {
            output[resultIndex++] = chr3;
        }

    }

    return output;
};

},{"./support":41,"./utils":43}],13:[function(require,module,exports){
'use strict';

var external = require("./external");
var DataWorker = require('./stream/DataWorker');
var DataLengthProbe = require('./stream/DataLengthProbe');
var Crc32Probe = require('./stream/Crc32Probe');
var DataLengthProbe = require('./stream/DataLengthProbe');

/**
 * Represent a compressed object, with everything needed to decompress it.
 * @constructor
 * @param {number} compressedSize the size of the data compressed.
 * @param {number} uncompressedSize the size of the data after decompression.
 * @param {number} crc32 the crc32 of the decompressed file.
 * @param {object} compression the type of compression, see lib/compressions.js.
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the compressed data.
 */
function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {
    this.compressedSize = compressedSize;
    this.uncompressedSize = uncompressedSize;
    this.crc32 = crc32;
    this.compression = compression;
    this.compressedContent = data;
}

CompressedObject.prototype = {
    /**
     * Create a worker to get the uncompressed content.
     * @return {GenericWorker} the worker.
     */
    getContentWorker : function () {
        var worker = new DataWorker(external.Promise.resolve(this.compressedContent))
        .pipe(this.compression.uncompressWorker())
        .pipe(new DataLengthProbe("data_length"));

        var that = this;
        worker.on("end", function () {
            if(this.streamInfo['data_length'] !== that.uncompressedSize) {
                throw new Error("Bug : uncompressed data size mismatch");
            }
        });
        return worker;
    },
    /**
     * Create a worker to get the compressed content.
     * @return {GenericWorker} the worker.
     */
    getCompressedWorker : function () {
        return new DataWorker(external.Promise.resolve(this.compressedContent))
        .withStreamInfo("compressedSize", this.compressedSize)
        .withStreamInfo("uncompressedSize", this.uncompressedSize)
        .withStreamInfo("crc32", this.crc32)
        .withStreamInfo("compression", this.compression)
        ;
    }
};

/**
 * Chain the given worker with other workers to compress the content with the
 * given compression.
 * @param {GenericWorker} uncompressedWorker the worker to pipe.
 * @param {Object} compression the compression object.
 * @param {Object} compressionOptions the options to use when compressing.
 * @return {GenericWorker} the new worker compressing the content.
 */
CompressedObject.createWorkerFrom = function (uncompressedWorker, compression, compressionOptions) {
    return uncompressedWorker
    .pipe(new Crc32Probe())
    .pipe(new DataLengthProbe("uncompressedSize"))
    .pipe(compression.compressWorker(compressionOptions))
    .pipe(new DataLengthProbe("compressedSize"))
    .withStreamInfo("compression", compression);
};

module.exports = CompressedObject;

},{"./external":17,"./stream/Crc32Probe":36,"./stream/DataLengthProbe":37,"./stream/DataWorker":38}],14:[function(require,module,exports){
'use strict';

var GenericWorker = require("./stream/GenericWorker");

exports.STORE = {
    magic: "\x00\x00",
    compressWorker : function (compressionOptions) {
        return new GenericWorker("STORE compression");
    },
    uncompressWorker : function () {
        return new GenericWorker("STORE decompression");
    }
};
exports.DEFLATE = require('./flate');

},{"./flate":18,"./stream/GenericWorker":39}],15:[function(require,module,exports){
'use strict';

var utils = require('./utils');

/**
 * The following functions come from pako, from pako/lib/zlib/crc32.js
 * released under the MIT license, see pako https://github.com/nodeca/pako/
 */

// Use ordinary array, since untyped makes no boost here
function makeTable() {
    var c, table = [];

    for(var n =0; n < 256; n++){
        c = n;
        for(var k =0; k < 8; k++){
            c = ((c&1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
        }
        table[n] = c;
    }

    return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();


function crc32(crc, buf, len, pos) {
    var t = crcTable, end = pos + len;

    crc = crc ^ (-1);

    for (var i = pos; i < end; i++ ) {
        crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
    }

    return (crc ^ (-1)); // >>> 0;
}

// That's all for the pako functions.

/**
 * Compute the crc32 of a string.
 * This is almost the same as the function crc32, but for strings. Using the
 * same function for the two use cases leads to horrible performances.
 * @param {Number} crc the starting value of the crc.
 * @param {String} str the string to use.
 * @param {Number} len the length of the string.
 * @param {Number} pos the starting position for the crc32 computation.
 * @return {Number} the computed crc32.
 */
function crc32str(crc, str, len, pos) {
    var t = crcTable, end = pos + len;

    crc = crc ^ (-1);

    for (var i = pos; i < end; i++ ) {
        crc = (crc >>> 8) ^ t[(crc ^ str.charCodeAt(i)) & 0xFF];
    }

    return (crc ^ (-1)); // >>> 0;
}

module.exports = function crc32wrapper(input, crc) {
    if (typeof input === "undefined" || !input.length) {
        return 0;
    }

    var isArray = utils.getTypeOf(input) !== "string";

    if(isArray) {
        return crc32(crc|0, input, input.length, 0);
    } else {
        return crc32str(crc|0, input, input.length, 0);
    }
};

},{"./utils":43}],16:[function(require,module,exports){
'use strict';
exports.base64 = false;
exports.binary = false;
exports.dir = false;
exports.createFolders = true;
exports.date = null;
exports.compression = null;
exports.compressionOptions = null;
exports.comment = null;
exports.unixPermissions = null;
exports.dosPermissions = null;

},{}],17:[function(require,module,exports){
/* global Promise */
'use strict';

// load the global object first:
// - it should be better integrated in the system (unhandledRejection in node)
// - the environment may have a custom Promise implementation (see zone.js)
var ES6Promise = null;
if (typeof Promise !== "undefined") {
    ES6Promise = Promise;
} else {
    ES6Promise = require("lie");
}

/**
 * Let the user use/change some implementations.
 */
module.exports = {
    Promise: ES6Promise
};

},{"lie":47}],18:[function(require,module,exports){
'use strict';
var USE_TYPEDARRAY = (typeof Uint8Array !== 'undefined') && (typeof Uint16Array !== 'undefined') && (typeof Uint32Array !== 'undefined');

var pako = require("pako");
var utils = require("./utils");
var GenericWorker = require("./stream/GenericWorker");

var ARRAY_TYPE = USE_TYPEDARRAY ? "uint8array" : "array";

exports.magic = "\x08\x00";

/**
 * Create a worker that uses pako to inflate/deflate.
 * @constructor
 * @param {String} action the name of the pako function to call : either "Deflate" or "Inflate".
 * @param {Object} options the options to use when (de)compressing.
 */
function FlateWorker(action, options) {
    GenericWorker.call(this, "FlateWorker/" + action);

    this._pako = null;
    this._pakoAction = action;
    this._pakoOptions = options;
    // the `meta` object from the last chunk received
    // this allow this worker to pass around metadata
    this.meta = {};
}

utils.inherits(FlateWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
FlateWorker.prototype.processChunk = function (chunk) {
    this.meta = chunk.meta;
    if (this._pako === null) {
        this._createPako();
    }
    this._pako.push(utils.transformTo(ARRAY_TYPE, chunk.data), false);
};

/**
 * @see GenericWorker.flush
 */
FlateWorker.prototype.flush = function () {
    GenericWorker.prototype.flush.call(this);
    if (this._pako === null) {
        this._createPako();
    }
    this._pako.push([], true);
};
/**
 * @see GenericWorker.cleanUp
 */
FlateWorker.prototype.cleanUp = function () {
    GenericWorker.prototype.cleanUp.call(this);
    this._pako = null;
};

/**
 * Create the _pako object.
 * TODO: lazy-loading this object isn't the best solution but it's the
 * quickest. The best solution is to lazy-load the worker list. See also the
 * issue #446.
 */
FlateWorker.prototype._createPako = function () {
    this._pako = new pako[this._pakoAction]({
        raw: true,
        level: this._pakoOptions.level || -1 // default compression
    });
    var self = this;
    this._pako.onData = function(data) {
        self.push({
            data : data,
            meta : self.meta
        });
    };
};

exports.compressWorker = function (compressionOptions) {
    return new FlateWorker("Deflate", compressionOptions);
};
exports.uncompressWorker = function () {
    return new FlateWorker("Inflate", {});
};

},{"./stream/GenericWorker":39,"./utils":43,"pako":48}],19:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var GenericWorker = require('../stream/GenericWorker');
var utf8 = require('../utf8');
var crc32 = require('../crc32');
var signature = require('../signature');

/**
 * Transform an integer into a string in hexadecimal.
 * @private
 * @param {number} dec the number to convert.
 * @param {number} bytes the number of bytes to generate.
 * @returns {string} the result.
 */
var decToHex = function(dec, bytes) {
    var hex = "", i;
    for (i = 0; i < bytes; i++) {
        hex += String.fromCharCode(dec & 0xff);
        dec = dec >>> 8;
    }
    return hex;
};

/**
 * Generate the UNIX part of the external file attributes.
 * @param {Object} unixPermissions the unix permissions or null.
 * @param {Boolean} isDir true if the entry is a directory, false otherwise.
 * @return {Number} a 32 bit integer.
 *
 * adapted from http://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute :
 *
 * TTTTsstrwxrwxrwx0000000000ADVSHR
 * ^^^^____________________________ file type, see zipinfo.c (UNX_*)
 *     ^^^_________________________ setuid, setgid, sticky
 *        ^^^^^^^^^________________ permissions
 *                 ^^^^^^^^^^______ not used ?
 *                           ^^^^^^ DOS attribute bits : Archive, Directory, Volume label, System file, Hidden, Read only
 */
var generateUnixExternalFileAttr = function (unixPermissions, isDir) {

    var result = unixPermissions;
    if (!unixPermissions) {
        // I can't use octal values in strict mode, hence the hexa.
        //  040775 => 0x41fd
        // 0100664 => 0x81b4
        result = isDir ? 0x41fd : 0x81b4;
    }
    return (result & 0xFFFF) << 16;
};

/**
 * Generate the DOS part of the external file attributes.
 * @param {Object} dosPermissions the dos permissions or null.
 * @param {Boolean} isDir true if the entry is a directory, false otherwise.
 * @return {Number} a 32 bit integer.
 *
 * Bit 0     Read-Only
 * Bit 1     Hidden
 * Bit 2     System
 * Bit 3     Volume Label
 * Bit 4     Directory
 * Bit 5     Archive
 */
var generateDosExternalFileAttr = function (dosPermissions, isDir) {

    // the dir flag is already set for compatibility
    return (dosPermissions || 0)  & 0x3F;
};

/**
 * Generate the various parts used in the construction of the final zip file.
 * @param {Object} streamInfo the hash with information about the compressed file.
 * @param {Boolean} streamedContent is the content streamed ?
 * @param {Boolean} streamingEnded is the stream finished ?
 * @param {number} offset the current offset from the start of the zip file.
 * @param {String} platform let's pretend we are this platform (change platform dependents fields)
 * @param {Function} encodeFileName the function to encode the file name / comment.
 * @return {Object} the zip parts.
 */
var generateZipParts = function(streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {
    var file = streamInfo['file'],
    compression = streamInfo['compression'],
    useCustomEncoding = encodeFileName !== utf8.utf8encode,
    encodedFileName = utils.transformTo("string", encodeFileName(file.name)),
    utfEncodedFileName = utils.transformTo("string", utf8.utf8encode(file.name)),
    comment = file.comment,
    encodedComment = utils.transformTo("string", encodeFileName(comment)),
    utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment)),
    useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,
    useUTF8ForComment = utfEncodedComment.length !== comment.length,
    dosTime,
    dosDate,
    extraFields = "",
    unicodePathExtraField = "",
    unicodeCommentExtraField = "",
    dir = file.dir,
    date = file.date;


    var dataInfo = {
        crc32 : 0,
        compressedSize : 0,
        uncompressedSize : 0
    };

    // if the content is streamed, the sizes/crc32 are only available AFTER
    // the end of the stream.
    if (!streamedContent || streamingEnded) {
        dataInfo.crc32 = streamInfo['crc32'];
        dataInfo.compressedSize = streamInfo['compressedSize'];
        dataInfo.uncompressedSize = streamInfo['uncompressedSize'];
    }

    var bitflag = 0;
    if (streamedContent) {
        // Bit 3: the sizes/crc32 are set to zero in the local header.
        // The correct values are put in the data descriptor immediately
        // following the compressed data.
        bitflag |= 0x0008;
    }
    if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {
        // Bit 11: Language encoding flag (EFS).
        bitflag |= 0x0800;
    }


    var extFileAttr = 0;
    var versionMadeBy = 0;
    if (dir) {
        // dos or unix, we set the dos dir flag
        extFileAttr |= 0x00010;
    }
    if(platform === "UNIX") {
        versionMadeBy = 0x031E; // UNIX, version 3.0
        extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);
    } else { // DOS or other, fallback to DOS
        versionMadeBy = 0x0014; // DOS, version 2.0
        extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);
    }

    // date
    // @see http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html
    // @see http://www.delorie.com/djgpp/doc/rbinter/it/65/16.html
    // @see http://www.delorie.com/djgpp/doc/rbinter/it/66/16.html

    dosTime = date.getUTCHours();
    dosTime = dosTime << 6;
    dosTime = dosTime | date.getUTCMinutes();
    dosTime = dosTime << 5;
    dosTime = dosTime | date.getUTCSeconds() / 2;

    dosDate = date.getUTCFullYear() - 1980;
    dosDate = dosDate << 4;
    dosDate = dosDate | (date.getUTCMonth() + 1);
    dosDate = dosDate << 5;
    dosDate = dosDate | date.getUTCDate();

    if (useUTF8ForFileName) {
        // set the unicode path extra field. unzip needs at least one extra
        // field to correctly handle unicode path, so using the path is as good
        // as any other information. This could improve the situation with
        // other archive managers too.
        // This field is usually used without the utf8 flag, with a non
        // unicode path in the header (winrar, winzip). This helps (a bit)
        // with the messy Windows' default compressed folders feature but
        // breaks on p7zip which doesn't seek the unicode path extra field.
        // So for now, UTF-8 everywhere !
        unicodePathExtraField =
            // Version
            decToHex(1, 1) +
            // NameCRC32
            decToHex(crc32(encodedFileName), 4) +
            // UnicodeName
            utfEncodedFileName;

        extraFields +=
            // Info-ZIP Unicode Path Extra Field
            "\x75\x70" +
            // size
            decToHex(unicodePathExtraField.length, 2) +
            // content
            unicodePathExtraField;
    }

    if(useUTF8ForComment) {

        unicodeCommentExtraField =
            // Version
            decToHex(1, 1) +
            // CommentCRC32
            decToHex(crc32(encodedComment), 4) +
            // UnicodeName
            utfEncodedComment;

        extraFields +=
            // Info-ZIP Unicode Path Extra Field
            "\x75\x63" +
            // size
            decToHex(unicodeCommentExtraField.length, 2) +
            // content
            unicodeCommentExtraField;
    }

    var header = "";

    // version needed to extract
    header += "\x0A\x00";
    // general purpose bit flag
    header += decToHex(bitflag, 2);
    // compression method
    header += compression.magic;
    // last mod file time
    header += decToHex(dosTime, 2);
    // last mod file date
    header += decToHex(dosDate, 2);
    // crc-32
    header += decToHex(dataInfo.crc32, 4);
    // compressed size
    header += decToHex(dataInfo.compressedSize, 4);
    // uncompressed size
    header += decToHex(dataInfo.uncompressedSize, 4);
    // file name length
    header += decToHex(encodedFileName.length, 2);
    // extra field length
    header += decToHex(extraFields.length, 2);


    var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;

    var dirRecord = signature.CENTRAL_FILE_HEADER +
        // version made by (00: DOS)
        decToHex(versionMadeBy, 2) +
        // file header (common to file and central directory)
        header +
        // file comment length
        decToHex(encodedComment.length, 2) +
        // disk number start
        "\x00\x00" +
        // internal file attributes TODO
        "\x00\x00" +
        // external file attributes
        decToHex(extFileAttr, 4) +
        // relative offset of local header
        decToHex(offset, 4) +
        // file name
        encodedFileName +
        // extra field
        extraFields +
        // file comment
        encodedComment;

    return {
        fileRecord: fileRecord,
        dirRecord: dirRecord
    };
};

/**
 * Generate the EOCD record.
 * @param {Number} entriesCount the number of entries in the zip file.
 * @param {Number} centralDirLength the length (in bytes) of the central dir.
 * @param {Number} localDirLength the length (in bytes) of the local dir.
 * @param {String} comment the zip file comment as a binary string.
 * @param {Function} encodeFileName the function to encode the comment.
 * @return {String} the EOCD record.
 */
var generateCentralDirectoryEnd = function (entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {
    var dirEnd = "";
    var encodedComment = utils.transformTo("string", encodeFileName(comment));

    // end of central dir signature
    dirEnd = signature.CENTRAL_DIRECTORY_END +
        // number of this disk
        "\x00\x00" +
        // number of the disk with the start of the central directory
        "\x00\x00" +
        // total number of entries in the central directory on this disk
        decToHex(entriesCount, 2) +
        // total number of entries in the central directory
        decToHex(entriesCount, 2) +
        // size of the central directory   4 bytes
        decToHex(centralDirLength, 4) +
        // offset of start of central directory with respect to the starting disk number
        decToHex(localDirLength, 4) +
        // .ZIP file comment length
        decToHex(encodedComment.length, 2) +
        // .ZIP file comment
        encodedComment;

    return dirEnd;
};

/**
 * Generate data descriptors for a file entry.
 * @param {Object} streamInfo the hash generated by a worker, containing information
 * on the file entry.
 * @return {String} the data descriptors.
 */
var generateDataDescriptors = function (streamInfo) {
    var descriptor = "";
    descriptor = signature.DATA_DESCRIPTOR +
        // crc-32                          4 bytes
        decToHex(streamInfo['crc32'], 4) +
        // compressed size                 4 bytes
        decToHex(streamInfo['compressedSize'], 4) +
        // uncompressed size               4 bytes
        decToHex(streamInfo['uncompressedSize'], 4);

    return descriptor;
};


/**
 * A worker to concatenate other workers to create a zip file.
 * @param {Boolean} streamFiles `true` to stream the content of the files,
 * `false` to accumulate it.
 * @param {String} comment the comment to use.
 * @param {String} platform the platform to use, "UNIX" or "DOS".
 * @param {Function} encodeFileName the function to encode file names and comments.
 */
function ZipFileWorker(streamFiles, comment, platform, encodeFileName) {
    GenericWorker.call(this, "ZipFileWorker");
    // The number of bytes written so far. This doesn't count accumulated chunks.
    this.bytesWritten = 0;
    // The comment of the zip file
    this.zipComment = comment;
    // The platform "generating" the zip file.
    this.zipPlatform = platform;
    // the function to encode file names and comments.
    this.encodeFileName = encodeFileName;
    // Should we stream the content of the files ?
    this.streamFiles = streamFiles;
    // If `streamFiles` is false, we will need to accumulate the content of the
    // files to calculate sizes / crc32 (and write them *before* the content).
    // This boolean indicates if we are accumulating chunks (it will change a lot
    // during the lifetime of this worker).
    this.accumulate = false;
    // The buffer receiving chunks when accumulating content.
    this.contentBuffer = [];
    // The list of generated directory records.
    this.dirRecords = [];
    // The offset (in bytes) from the beginning of the zip file for the current source.
    this.currentSourceOffset = 0;
    // The total number of entries in this zip file.
    this.entriesCount = 0;
    // the name of the file currently being added, null when handling the end of the zip file.
    // Used for the emitted metadata.
    this.currentFile = null;



    this._sources = [];
}
utils.inherits(ZipFileWorker, GenericWorker);

/**
 * @see GenericWorker.push
 */
ZipFileWorker.prototype.push = function (chunk) {

    var currentFilePercent = chunk.meta.percent || 0;
    var entriesCount = this.entriesCount;
    var remainingFiles = this._sources.length;

    if(this.accumulate) {
        this.contentBuffer.push(chunk);
    } else {
        this.bytesWritten += chunk.data.length;

        GenericWorker.prototype.push.call(this, {
            data : chunk.data,
            meta : {
                currentFile : this.currentFile,
                percent : entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100
            }
        });
    }
};

/**
 * The worker started a new source (an other worker).
 * @param {Object} streamInfo the streamInfo object from the new source.
 */
ZipFileWorker.prototype.openedSource = function (streamInfo) {
    this.currentSourceOffset = this.bytesWritten;
    this.currentFile = streamInfo['file'].name;

    var streamedContent = this.streamFiles && !streamInfo['file'].dir;

    // don't stream folders (because they don't have any content)
    if(streamedContent) {
        var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        this.push({
            data : record.fileRecord,
            meta : {percent:0}
        });
    } else {
        // we need to wait for the whole file before pushing anything
        this.accumulate = true;
    }
};

/**
 * The worker finished a source (an other worker).
 * @param {Object} streamInfo the streamInfo object from the finished source.
 */
ZipFileWorker.prototype.closedSource = function (streamInfo) {
    this.accumulate = false;
    var streamedContent = this.streamFiles && !streamInfo['file'].dir;
    var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);

    this.dirRecords.push(record.dirRecord);
    if(streamedContent) {
        // after the streamed file, we put data descriptors
        this.push({
            data : generateDataDescriptors(streamInfo),
            meta : {percent:100}
        });
    } else {
        // the content wasn't streamed, we need to push everything now
        // first the file record, then the content
        this.push({
            data : record.fileRecord,
            meta : {percent:0}
        });
        while(this.contentBuffer.length) {
            this.push(this.contentBuffer.shift());
        }
    }
    this.currentFile = null;
};

/**
 * @see GenericWorker.flush
 */
ZipFileWorker.prototype.flush = function () {

    var localDirLength = this.bytesWritten;
    for(var i = 0; i < this.dirRecords.length; i++) {
        this.push({
            data : this.dirRecords[i],
            meta : {percent:100}
        });
    }
    var centralDirLength = this.bytesWritten - localDirLength;

    var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);

    this.push({
        data : dirEnd,
        meta : {percent:100}
    });
};

/**
 * Prepare the next source to be read.
 */
ZipFileWorker.prototype.prepareNextSource = function () {
    this.previous = this._sources.shift();
    this.openedSource(this.previous.streamInfo);
    if (this.isPaused) {
        this.previous.pause();
    } else {
        this.previous.resume();
    }
};

/**
 * @see GenericWorker.registerPrevious
 */
ZipFileWorker.prototype.registerPrevious = function (previous) {
    this._sources.push(previous);
    var self = this;

    previous.on('data', function (chunk) {
        self.processChunk(chunk);
    });
    previous.on('end', function () {
        self.closedSource(self.previous.streamInfo);
        if(self._sources.length) {
            self.prepareNextSource();
        } else {
            self.end();
        }
    });
    previous.on('error', function (e) {
        self.error(e);
    });
    return this;
};

/**
 * @see GenericWorker.resume
 */
ZipFileWorker.prototype.resume = function () {
    if(!GenericWorker.prototype.resume.call(this)) {
        return false;
    }

    if (!this.previous && this._sources.length) {
        this.prepareNextSource();
        return true;
    }
    if (!this.previous && !this._sources.length && !this.generatedError) {
        this.end();
        return true;
    }
};

/**
 * @see GenericWorker.error
 */
ZipFileWorker.prototype.error = function (e) {
    var sources = this._sources;
    if(!GenericWorker.prototype.error.call(this, e)) {
        return false;
    }
    for(var i = 0; i < sources.length; i++) {
        try {
            sources[i].error(e);
        } catch(e) {
            // the `error` exploded, nothing to do
        }
    }
    return true;
};

/**
 * @see GenericWorker.lock
 */
ZipFileWorker.prototype.lock = function () {
    GenericWorker.prototype.lock.call(this);
    var sources = this._sources;
    for(var i = 0; i < sources.length; i++) {
        sources[i].lock();
    }
};

module.exports = ZipFileWorker;

},{"../crc32":15,"../signature":34,"../stream/GenericWorker":39,"../utf8":42,"../utils":43}],20:[function(require,module,exports){
'use strict';

var compressions = require('../compressions');
var ZipFileWorker = require('./ZipFileWorker');

/**
 * Find the compression to use.
 * @param {String} fileCompression the compression defined at the file level, if any.
 * @param {String} zipCompression the compression defined at the load() level.
 * @return {Object} the compression object to use.
 */
var getCompression = function (fileCompression, zipCompression) {

    var compressionName = fileCompression || zipCompression;
    var compression = compressions[compressionName];
    if (!compression) {
        throw new Error(compressionName + " is not a valid compression method !");
    }
    return compression;
};

/**
 * Create a worker to generate a zip file.
 * @param {JSZip} zip the JSZip instance at the right root level.
 * @param {Object} options to generate the zip file.
 * @param {String} comment the comment to use.
 */
exports.generateWorker = function (zip, options, comment) {

    var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);
    var entriesCount = 0;
    try {

        zip.forEach(function (relativePath, file) {
            entriesCount++;
            var compression = getCompression(file.options.compression, options.compression);
            var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};
            var dir = file.dir, date = file.date;

            file._compressWorker(compression, compressionOptions)
            .withStreamInfo("file", {
                name : relativePath,
                dir : dir,
                date : date,
                comment : file.comment || "",
                unixPermissions : file.unixPermissions,
                dosPermissions : file.dosPermissions
            })
            .pipe(zipFileWorker);
        });
        zipFileWorker.entriesCount = entriesCount;
    } catch (e) {
        zipFileWorker.error(e);
    }

    return zipFileWorker;
};

},{"../compressions":14,"./ZipFileWorker":19}],21:[function(require,module,exports){
'use strict';

/**
 * Representation a of zip file in js
 * @constructor
 */
function JSZip() {
    // if this constructor isused without`new`, itadds `new` beforeitself:
    if(!(this instanceof JSZip)) {
        return new JSZip();
    }

    if(arguments.length) {
        throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
    }

    // object containing the files :
    // {
    //   "folder/" : {...},
    //   "folder/data.txt" : {...}
    // }
    this.files = {};

    this.comment = null;

    // Where we are in the hierarchy
    this.root = "";
    this.clone = function() {
        var newObj = new JSZip();
        for (var i in this) {
            if (typeof this[i] !== "function") {
                newObj[i] = this[i];
            }
        }
        return newObj;
    };
}
JSZip.prototype = require('./object');
JSZip.prototype.loadAsync = require('./load');
JSZip.support = require('./support');
JSZip.defaults = require('./defaults');

// TODO find a better way to handle this version,
// a require('package.json').version doesn't work with webpack, see #327
JSZip.version = "3.5.0";

JSZip.loadAsync = function (content, options) {
    return new JSZip().loadAsync(content, options);
};

JSZip.external = require("./external");
module.exports = JSZip;

},{"./defaults":16,"./external":17,"./load":22,"./object":26,"./support":41}],22:[function(require,module,exports){
'use strict';
var utils = require('./utils');
var external = require("./external");
var utf8 = require('./utf8');
var utils = require('./utils');
var ZipEntries = require('./zipEntries');
var Crc32Probe = require('./stream/Crc32Probe');
var nodejsUtils = require("./nodejsUtils");

/**
 * Check the CRC32 of an entry.
 * @param {ZipEntry} zipEntry the zip entry to check.
 * @return {Promise} the result.
 */
function checkEntryCRC32(zipEntry) {
    return new external.Promise(function (resolve, reject) {
        var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());
        worker.on("error", function (e) {
            reject(e);
        })
        .on("end", function () {
            if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {
                reject(new Error("Corrupted zip : CRC32 mismatch"));
            } else {
                resolve();
            }
        })
        .resume();
    });
}

module.exports = function(data, options) {
    var zip = this;
    options = utils.extend(options || {}, {
        base64: false,
        checkCRC32: false,
        optimizedBinaryString: false,
        createFolders: false,
        decodeFileName: utf8.utf8decode
    });

    if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
        return external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
    }

    return utils.prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64)
    .then(function(data) {
        var zipEntries = new ZipEntries(options);
        zipEntries.load(data);
        return zipEntries;
    }).then(function checkCRC32(zipEntries) {
        var promises = [external.Promise.resolve(zipEntries)];
        var files = zipEntries.files;
        if (options.checkCRC32) {
            for (var i = 0; i < files.length; i++) {
                promises.push(checkEntryCRC32(files[i]));
            }
        }
        return external.Promise.all(promises);
    }).then(function addFiles(results) {
        var zipEntries = results.shift();
        var files = zipEntries.files;
        for (var i = 0; i < files.length; i++) {
            var input = files[i];
            zip.file(input.fileNameStr, input.decompressed, {
                binary: true,
                optimizedBinaryString: true,
                date: input.date,
                dir: input.dir,
                comment : input.fileCommentStr.length ? input.fileCommentStr : null,
                unixPermissions : input.unixPermissions,
                dosPermissions : input.dosPermissions,
                createFolders: options.createFolders
            });
        }
        if (zipEntries.zipComment.length) {
            zip.comment = zipEntries.zipComment;
        }

        return zip;
    });
};

},{"./external":17,"./nodejsUtils":23,"./stream/Crc32Probe":36,"./utf8":42,"./utils":43,"./zipEntries":44}],23:[function(require,module,exports){
(function (Buffer){
'use strict';

module.exports = {
    /**
     * True if this is running in Nodejs, will be undefined in a browser.
     * In a browser, browserify won't include this file and the whole module
     * will be resolved an empty object.
     */
    isNode : typeof Buffer !== "undefined",
    /**
     * Create a new nodejs Buffer from an existing content.
     * @param {Object} data the data to pass to the constructor.
     * @param {String} encoding the encoding to use.
     * @return {Buffer} a new Buffer.
     */
    newBufferFrom: function(data, encoding) {
        if (Buffer.from && Buffer.from !== Uint8Array.from) {
            return Buffer.from(data, encoding);
        } else {
            if (typeof data === "number") {
                // Safeguard for old Node.js versions. On newer versions,
                // Buffer.from(number) / Buffer(number, encoding) already throw.
                throw new Error("The \"data\" argument must not be a number");
            }
            return new Buffer(data, encoding);
        }
    },
    /**
     * Create a new nodejs Buffer with the specified size.
     * @param {Integer} size the size of the buffer.
     * @return {Buffer} a new Buffer.
     */
    allocBuffer: function (size) {
        if (Buffer.alloc) {
            return Buffer.alloc(size);
        } else {
            var buf = new Buffer(size);
            buf.fill(0);
            return buf;
        }
    },
    /**
     * Find out if an object is a Buffer.
     * @param {Object} b the object to test.
     * @return {Boolean} true if the object is a Buffer, false otherwise.
     */
    isBuffer : function(b){
        return Buffer.isBuffer(b);
    },

    isStream : function (obj) {
        return obj &&
            typeof obj.on === "function" &&
            typeof obj.pause === "function" &&
            typeof obj.resume === "function";
    }
};

}).call(this,require("buffer").Buffer)

},{"buffer":3}],24:[function(require,module,exports){
"use strict";

var utils = require('../utils');
var GenericWorker = require('../stream/GenericWorker');

/**
 * A worker that use a nodejs stream as source.
 * @constructor
 * @param {String} filename the name of the file entry for this stream.
 * @param {Readable} stream the nodejs stream.
 */
function NodejsStreamInputAdapter(filename, stream) {
    GenericWorker.call(this, "Nodejs stream input adapter for " + filename);
    this._upstreamEnded = false;
    this._bindStream(stream);
}

utils.inherits(NodejsStreamInputAdapter, GenericWorker);

/**
 * Prepare the stream and bind the callbacks on it.
 * Do this ASAP on node 0.10 ! A lazy binding doesn't always work.
 * @param {Stream} stream the nodejs stream to use.
 */
NodejsStreamInputAdapter.prototype._bindStream = function (stream) {
    var self = this;
    this._stream = stream;
    stream.pause();
    stream
    .on("data", function (chunk) {
        self.push({
            data: chunk,
            meta : {
                percent : 0
            }
        });
    })
    .on("error", function (e) {
        if(self.isPaused) {
            this.generatedError = e;
        } else {
            self.error(e);
        }
    })
    .on("end", function () {
        if(self.isPaused) {
            self._upstreamEnded = true;
        } else {
            self.end();
        }
    });
};
NodejsStreamInputAdapter.prototype.pause = function () {
    if(!GenericWorker.prototype.pause.call(this)) {
        return false;
    }
    this._stream.pause();
    return true;
};
NodejsStreamInputAdapter.prototype.resume = function () {
    if(!GenericWorker.prototype.resume.call(this)) {
        return false;
    }

    if(this._upstreamEnded) {
        this.end();
    } else {
        this._stream.resume();
    }

    return true;
};

module.exports = NodejsStreamInputAdapter;

},{"../stream/GenericWorker":39,"../utils":43}],25:[function(require,module,exports){
'use strict';

var Readable = require('readable-stream').Readable;

var utils = require('../utils');
utils.inherits(NodejsStreamOutputAdapter, Readable);

/**
* A nodejs stream using a worker as source.
* @see the SourceWrapper in http://nodejs.org/api/stream.html
* @constructor
* @param {StreamHelper} helper the helper wrapping the worker
* @param {Object} options the nodejs stream options
* @param {Function} updateCb the update callback.
*/
function NodejsStreamOutputAdapter(helper, options, updateCb) {
    Readable.call(this, options);
    this._helper = helper;

    var self = this;
    helper.on("data", function (data, meta) {
        if (!self.push(data)) {
            self._helper.pause();
        }
        if(updateCb) {
            updateCb(meta);
        }
    })
    .on("error", function(e) {
        self.emit('error', e);
    })
    .on("end", function () {
        self.push(null);
    });
}


NodejsStreamOutputAdapter.prototype._read = function() {
    this._helper.resume();
};

module.exports = NodejsStreamOutputAdapter;

},{"../utils":43,"readable-stream":27}],26:[function(require,module,exports){
'use strict';
var utf8 = require('./utf8');
var utils = require('./utils');
var GenericWorker = require('./stream/GenericWorker');
var StreamHelper = require('./stream/StreamHelper');
var defaults = require('./defaults');
var CompressedObject = require('./compressedObject');
var ZipObject = require('./zipObject');
var generate = require("./generate");
var nodejsUtils = require("./nodejsUtils");
var NodejsStreamInputAdapter = require("./nodejs/NodejsStreamInputAdapter");


/**
 * Add a file in the current folder.
 * @private
 * @param {string} name the name of the file
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data of the file
 * @param {Object} originalOptions the options of the file
 * @return {Object} the new file.
 */
var fileAdd = function(name, data, originalOptions) {
    // be sure sub folders exist
    var dataType = utils.getTypeOf(data),
        parent;


    /*
     * Correct options.
     */

    var o = utils.extend(originalOptions || {}, defaults);
    o.date = o.date || new Date();
    if (o.compression !== null) {
        o.compression = o.compression.toUpperCase();
    }

    if (typeof o.unixPermissions === "string") {
        o.unixPermissions = parseInt(o.unixPermissions, 8);
    }

    // UNX_IFDIR  0040000 see zipinfo.c
    if (o.unixPermissions && (o.unixPermissions & 0x4000)) {
        o.dir = true;
    }
    // Bit 4    Directory
    if (o.dosPermissions && (o.dosPermissions & 0x0010)) {
        o.dir = true;
    }

    if (o.dir) {
        name = forceTrailingSlash(name);
    }
    if (o.createFolders && (parent = parentFolder(name))) {
        folderAdd.call(this, parent, true);
    }

    var isUnicodeString = dataType === "string" && o.binary === false && o.base64 === false;
    if (!originalOptions || typeof originalOptions.binary === "undefined") {
        o.binary = !isUnicodeString;
    }


    var isCompressedEmpty = (data instanceof CompressedObject) && data.uncompressedSize === 0;

    if (isCompressedEmpty || o.dir || !data || data.length === 0) {
        o.base64 = false;
        o.binary = true;
        data = "";
        o.compression = "STORE";
        dataType = "string";
    }

    /*
     * Convert content to fit.
     */

    var zipObjectContent = null;
    if (data instanceof CompressedObject || data instanceof GenericWorker) {
        zipObjectContent = data;
    } else if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
        zipObjectContent = new NodejsStreamInputAdapter(name, data);
    } else {
        zipObjectContent = utils.prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);
    }

    var object = new ZipObject(name, zipObjectContent, o);
    this.files[name] = object;
    /*
    TODO: we can't throw an exception because we have async promises
    (we can have a promise of a Date() for example) but returning a
    promise is useless because file(name, data) returns the JSZip
    object for chaining. Should we break that to allow the user
    to catch the error ?

    return external.Promise.resolve(zipObjectContent)
    .then(function () {
        return object;
    });
    */
};

/**
 * Find the parent folder of the path.
 * @private
 * @param {string} path the path to use
 * @return {string} the parent folder, or ""
 */
var parentFolder = function (path) {
    if (path.slice(-1) === '/') {
        path = path.substring(0, path.length - 1);
    }
    var lastSlash = path.lastIndexOf('/');
    return (lastSlash > 0) ? path.substring(0, lastSlash) : "";
};

/**
 * Returns the path with a slash at the end.
 * @private
 * @param {String} path the path to check.
 * @return {String} the path with a trailing slash.
 */
var forceTrailingSlash = function(path) {
    // Check the name ends with a /
    if (path.slice(-1) !== "/") {
        path += "/"; // IE doesn't like substr(-1)
    }
    return path;
};

/**
 * Add a (sub) folder in the current folder.
 * @private
 * @param {string} name the folder's name
 * @param {boolean=} [createFolders] If true, automatically create sub
 *  folders. Defaults to false.
 * @return {Object} the new folder.
 */
var folderAdd = function(name, createFolders) {
    createFolders = (typeof createFolders !== 'undefined') ? createFolders : defaults.createFolders;

    name = forceTrailingSlash(name);

    // Does this folder already exist?
    if (!this.files[name]) {
        fileAdd.call(this, name, null, {
            dir: true,
            createFolders: createFolders
        });
    }
    return this.files[name];
};

/**
* Cross-window, cross-Node-context regular expression detection
* @param  {Object}  object Anything
* @return {Boolean}        true if the object is a regular expression,
* false otherwise
*/
function isRegExp(object) {
    return Object.prototype.toString.call(object) === "[object RegExp]";
}

// return the actual prototype of JSZip
var out = {
    /**
     * @see loadAsync
     */
    load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
    },


    /**
     * Call a callback function for each entry at this folder level.
     * @param {Function} cb the callback function:
     * function (relativePath, file) {...}
     * It takes 2 arguments : the relative path and the file.
     */
    forEach: function(cb) {
        var filename, relativePath, file;
        for (filename in this.files) {
            if (!this.files.hasOwnProperty(filename)) {
                continue;
            }
            file = this.files[filename];
            relativePath = filename.slice(this.root.length, filename.length);
            if (relativePath && filename.slice(0, this.root.length) === this.root) { // the file is in the current root
                cb(relativePath, file); // TODO reverse the parameters ? need to be clean AND consistent with the filter search fn...
            }
        }
    },

    /**
     * Filter nested files/folders with the specified function.
     * @param {Function} search the predicate to use :
     * function (relativePath, file) {...}
     * It takes 2 arguments : the relative path and the file.
     * @return {Array} An array of matching elements.
     */
    filter: function(search) {
        var result = [];
        this.forEach(function (relativePath, entry) {
            if (search(relativePath, entry)) { // the file matches the function
                result.push(entry);
            }

        });
        return result;
    },

    /**
     * Add a file to the zip file, or search a file.
     * @param   {string|RegExp} name The name of the file to add (if data is defined),
     * the name of the file to find (if no data) or a regex to match files.
     * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded
     * @param   {Object} o     File options
     * @return  {JSZip|Object|Array} this JSZip object (when adding a file),
     * a file (when searching by string) or an array of files (when searching by regex).
     */
    file: function(name, data, o) {
        if (arguments.length === 1) {
            if (isRegExp(name)) {
                var regexp = name;
                return this.filter(function(relativePath, file) {
                    return !file.dir && regexp.test(relativePath);
                });
            }
            else { // text
                var obj = this.files[this.root + name];
                if (obj && !obj.dir) {
                    return obj;
                } else {
                    return null;
                }
            }
        }
        else { // more than one argument : we have data !
            name = this.root + name;
            fileAdd.call(this, name, data, o);
        }
        return this;
    },

    /**
     * Add a directory to the zip file, or search.
     * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.
     * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.
     */
    folder: function(arg) {
        if (!arg) {
            return this;
        }

        if (isRegExp(arg)) {
            return this.filter(function(relativePath, file) {
                return file.dir && arg.test(relativePath);
            });
        }

        // else, name is a new folder
        var name = this.root + arg;
        var newFolder = folderAdd.call(this, name);

        // Allow chaining by returning a new object with this folder as the root
        var ret = this.clone();
        ret.root = newFolder.name;
        return ret;
    },

    /**
     * Delete a file, or a directory and all sub-files, from the zip
     * @param {string} name the name of the file to delete
     * @return {JSZip} this JSZip object
     */
    remove: function(name) {
        name = this.root + name;
        var file = this.files[name];
        if (!file) {
            // Look for any folders
            if (name.slice(-1) !== "/") {
                name += "/";
            }
            file = this.files[name];
        }

        if (file && !file.dir) {
            // file
            delete this.files[name];
        } else {
            // maybe a folder, delete recursively
            var kids = this.filter(function(relativePath, file) {
                return file.name.slice(0, name.length) === name;
            });
            for (var i = 0; i < kids.length; i++) {
                delete this.files[kids[i].name];
            }
        }

        return this;
    },

    /**
     * Generate the complete zip file
     * @param {Object} options the options to generate the zip file :
     * - compression, "STORE" by default.
     * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
     * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the zip file
     */
    generate: function(options) {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
    },

    /**
     * Generate the complete zip file as an internal stream.
     * @param {Object} options the options to generate the zip file :
     * - compression, "STORE" by default.
     * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
     * @return {StreamHelper} the streamed zip file.
     */
    generateInternalStream: function(options) {
      var worker, opts = {};
      try {
          opts = utils.extend(options || {}, {
              streamFiles: false,
              compression: "STORE",
              compressionOptions : null,
              type: "",
              platform: "DOS",
              comment: null,
              mimeType: 'application/zip',
              encodeFileName: utf8.utf8encode
          });

          opts.type = opts.type.toLowerCase();
          opts.compression = opts.compression.toUpperCase();

          // "binarystring" is preferred but the internals use "string".
          if(opts.type === "binarystring") {
            opts.type = "string";
          }

          if (!opts.type) {
            throw new Error("No output type specified.");
          }

          utils.checkSupport(opts.type);

          // accept nodejs `process.platform`
          if(
              opts.platform === 'darwin' ||
              opts.platform === 'freebsd' ||
              opts.platform === 'linux' ||
              opts.platform === 'sunos'
          ) {
              opts.platform = "UNIX";
          }
          if (opts.platform === 'win32') {
              opts.platform = "DOS";
          }

          var comment = opts.comment || this.comment || "";
          worker = generate.generateWorker(this, opts, comment);
      } catch (e) {
        worker = new GenericWorker("error");
        worker.error(e);
      }
      return new StreamHelper(worker, opts.type || "string", opts.mimeType);
    },
    /**
     * Generate the complete zip file asynchronously.
     * @see generateInternalStream
     */
    generateAsync: function(options, onUpdate) {
        return this.generateInternalStream(options).accumulate(onUpdate);
    },
    /**
     * Generate the complete zip file asynchronously.
     * @see generateInternalStream
     */
    generateNodeStream: function(options, onUpdate) {
        options = options || {};
        if (!options.type) {
            options.type = "nodebuffer";
        }
        return this.generateInternalStream(options).toNodejsStream(onUpdate);
    }
};
module.exports = out;

},{"./compressedObject":13,"./defaults":16,"./generate":20,"./nodejs/NodejsStreamInputAdapter":24,"./nodejsUtils":23,"./stream/GenericWorker":39,"./stream/StreamHelper":40,"./utf8":42,"./utils":43,"./zipObject":46}],27:[function(require,module,exports){
/*
 * This file is used by module bundlers (browserify/webpack/etc) when
 * including a stream implementation. We use "readable-stream" to get a
 * consistent behavior between nodejs versions but bundlers often have a shim
 * for "stream". Using this shim greatly improve the compatibility and greatly
 * reduce the final size of the bundle (only one stream implementation, not
 * two).
 */
module.exports = require("stream");

},{"stream":81}],28:[function(require,module,exports){
'use strict';
var DataReader = require('./DataReader');
var utils = require('../utils');

function ArrayReader(data) {
    DataReader.call(this, data);
	for(var i = 0; i < this.data.length; i++) {
		data[i] = data[i] & 0xFF;
	}
}
utils.inherits(ArrayReader, DataReader);
/**
 * @see DataReader.byteAt
 */
ArrayReader.prototype.byteAt = function(i) {
    return this.data[this.zero + i];
};
/**
 * @see DataReader.lastIndexOfSignature
 */
ArrayReader.prototype.lastIndexOfSignature = function(sig) {
    var sig0 = sig.charCodeAt(0),
        sig1 = sig.charCodeAt(1),
        sig2 = sig.charCodeAt(2),
        sig3 = sig.charCodeAt(3);
    for (var i = this.length - 4; i >= 0; --i) {
        if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {
            return i - this.zero;
        }
    }

    return -1;
};
/**
 * @see DataReader.readAndCheckSignature
 */
ArrayReader.prototype.readAndCheckSignature = function (sig) {
    var sig0 = sig.charCodeAt(0),
        sig1 = sig.charCodeAt(1),
        sig2 = sig.charCodeAt(2),
        sig3 = sig.charCodeAt(3),
        data = this.readData(4);
    return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];
};
/**
 * @see DataReader.readData
 */
ArrayReader.prototype.readData = function(size) {
    this.checkOffset(size);
    if(size === 0) {
        return [];
    }
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = ArrayReader;

},{"../utils":43,"./DataReader":29}],29:[function(require,module,exports){
'use strict';
var utils = require('../utils');

function DataReader(data) {
    this.data = data; // type : see implementation
    this.length = data.length;
    this.index = 0;
    this.zero = 0;
}
DataReader.prototype = {
    /**
     * Check that the offset will not go too far.
     * @param {string} offset the additional offset to check.
     * @throws {Error} an Error if the offset is out of bounds.
     */
    checkOffset: function(offset) {
        this.checkIndex(this.index + offset);
    },
    /**
     * Check that the specified index will not be too far.
     * @param {string} newIndex the index to check.
     * @throws {Error} an Error if the index is out of bounds.
     */
    checkIndex: function(newIndex) {
        if (this.length < this.zero + newIndex || newIndex < 0) {
            throw new Error("End of data reached (data length = " + this.length + ", asked index = " + (newIndex) + "). Corrupted zip ?");
        }
    },
    /**
     * Change the index.
     * @param {number} newIndex The new index.
     * @throws {Error} if the new index is out of the data.
     */
    setIndex: function(newIndex) {
        this.checkIndex(newIndex);
        this.index = newIndex;
    },
    /**
     * Skip the next n bytes.
     * @param {number} n the number of bytes to skip.
     * @throws {Error} if the new index is out of the data.
     */
    skip: function(n) {
        this.setIndex(this.index + n);
    },
    /**
     * Get the byte at the specified index.
     * @param {number} i the index to use.
     * @return {number} a byte.
     */
    byteAt: function(i) {
        // see implementations
    },
    /**
     * Get the next number with a given byte size.
     * @param {number} size the number of bytes to read.
     * @return {number} the corresponding number.
     */
    readInt: function(size) {
        var result = 0,
            i;
        this.checkOffset(size);
        for (i = this.index + size - 1; i >= this.index; i--) {
            result = (result << 8) + this.byteAt(i);
        }
        this.index += size;
        return result;
    },
    /**
     * Get the next string with a given byte size.
     * @param {number} size the number of bytes to read.
     * @return {string} the corresponding string.
     */
    readString: function(size) {
        return utils.transformTo("string", this.readData(size));
    },
    /**
     * Get raw data without conversion, <size> bytes.
     * @param {number} size the number of bytes to read.
     * @return {Object} the raw data, implementation specific.
     */
    readData: function(size) {
        // see implementations
    },
    /**
     * Find the last occurrence of a zip signature (4 bytes).
     * @param {string} sig the signature to find.
     * @return {number} the index of the last occurrence, -1 if not found.
     */
    lastIndexOfSignature: function(sig) {
        // see implementations
    },
    /**
     * Read the signature (4 bytes) at the current position and compare it with sig.
     * @param {string} sig the expected signature
     * @return {boolean} true if the signature matches, false otherwise.
     */
    readAndCheckSignature: function(sig) {
        // see implementations
    },
    /**
     * Get the next date.
     * @return {Date} the date.
     */
    readDate: function() {
        var dostime = this.readInt(4);
        return new Date(Date.UTC(
        ((dostime >> 25) & 0x7f) + 1980, // year
        ((dostime >> 21) & 0x0f) - 1, // month
        (dostime >> 16) & 0x1f, // day
        (dostime >> 11) & 0x1f, // hour
        (dostime >> 5) & 0x3f, // minute
        (dostime & 0x1f) << 1)); // second
    }
};
module.exports = DataReader;

},{"../utils":43}],30:[function(require,module,exports){
'use strict';
var Uint8ArrayReader = require('./Uint8ArrayReader');
var utils = require('../utils');

function NodeBufferReader(data) {
    Uint8ArrayReader.call(this, data);
}
utils.inherits(NodeBufferReader, Uint8ArrayReader);

/**
 * @see DataReader.readData
 */
NodeBufferReader.prototype.readData = function(size) {
    this.checkOffset(size);
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = NodeBufferReader;

},{"../utils":43,"./Uint8ArrayReader":32}],31:[function(require,module,exports){
'use strict';
var DataReader = require('./DataReader');
var utils = require('../utils');

function StringReader(data) {
    DataReader.call(this, data);
}
utils.inherits(StringReader, DataReader);
/**
 * @see DataReader.byteAt
 */
StringReader.prototype.byteAt = function(i) {
    return this.data.charCodeAt(this.zero + i);
};
/**
 * @see DataReader.lastIndexOfSignature
 */
StringReader.prototype.lastIndexOfSignature = function(sig) {
    return this.data.lastIndexOf(sig) - this.zero;
};
/**
 * @see DataReader.readAndCheckSignature
 */
StringReader.prototype.readAndCheckSignature = function (sig) {
    var data = this.readData(4);
    return sig === data;
};
/**
 * @see DataReader.readData
 */
StringReader.prototype.readData = function(size) {
    this.checkOffset(size);
    // this will work because the constructor applied the "& 0xff" mask.
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = StringReader;

},{"../utils":43,"./DataReader":29}],32:[function(require,module,exports){
'use strict';
var ArrayReader = require('./ArrayReader');
var utils = require('../utils');

function Uint8ArrayReader(data) {
    ArrayReader.call(this, data);
}
utils.inherits(Uint8ArrayReader, ArrayReader);
/**
 * @see DataReader.readData
 */
Uint8ArrayReader.prototype.readData = function(size) {
    this.checkOffset(size);
    if(size === 0) {
        // in IE10, when using subarray(idx, idx), we get the array [0x00] instead of [].
        return new Uint8Array(0);
    }
    var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
};
module.exports = Uint8ArrayReader;

},{"../utils":43,"./ArrayReader":28}],33:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var support = require('../support');
var ArrayReader = require('./ArrayReader');
var StringReader = require('./StringReader');
var NodeBufferReader = require('./NodeBufferReader');
var Uint8ArrayReader = require('./Uint8ArrayReader');

/**
 * Create a reader adapted to the data.
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data to read.
 * @return {DataReader} the data reader.
 */
module.exports = function (data) {
    var type = utils.getTypeOf(data);
    utils.checkSupport(type);
    if (type === "string" && !support.uint8array) {
        return new StringReader(data);
    }
    if (type === "nodebuffer") {
        return new NodeBufferReader(data);
    }
    if (support.uint8array) {
        return new Uint8ArrayReader(utils.transformTo("uint8array", data));
    }
    return new ArrayReader(utils.transformTo("array", data));
};

},{"../support":41,"../utils":43,"./ArrayReader":28,"./NodeBufferReader":30,"./StringReader":31,"./Uint8ArrayReader":32}],34:[function(require,module,exports){
'use strict';
exports.LOCAL_FILE_HEADER = "PK\x03\x04";
exports.CENTRAL_FILE_HEADER = "PK\x01\x02";
exports.CENTRAL_DIRECTORY_END = "PK\x05\x06";
exports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x06\x07";
exports.ZIP64_CENTRAL_DIRECTORY_END = "PK\x06\x06";
exports.DATA_DESCRIPTOR = "PK\x07\x08";

},{}],35:[function(require,module,exports){
'use strict';

var GenericWorker = require('./GenericWorker');
var utils = require('../utils');

/**
 * A worker which convert chunks to a specified type.
 * @constructor
 * @param {String} destType the destination type.
 */
function ConvertWorker(destType) {
    GenericWorker.call(this, "ConvertWorker to " + destType);
    this.destType = destType;
}
utils.inherits(ConvertWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
ConvertWorker.prototype.processChunk = function (chunk) {
    this.push({
        data : utils.transformTo(this.destType, chunk.data),
        meta : chunk.meta
    });
};
module.exports = ConvertWorker;

},{"../utils":43,"./GenericWorker":39}],36:[function(require,module,exports){
'use strict';

var GenericWorker = require('./GenericWorker');
var crc32 = require('../crc32');
var utils = require('../utils');

/**
 * A worker which calculate the crc32 of the data flowing through.
 * @constructor
 */
function Crc32Probe() {
    GenericWorker.call(this, "Crc32Probe");
    this.withStreamInfo("crc32", 0);
}
utils.inherits(Crc32Probe, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
Crc32Probe.prototype.processChunk = function (chunk) {
    this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0);
    this.push(chunk);
};
module.exports = Crc32Probe;

},{"../crc32":15,"../utils":43,"./GenericWorker":39}],37:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var GenericWorker = require('./GenericWorker');

/**
 * A worker which calculate the total length of the data flowing through.
 * @constructor
 * @param {String} propName the name used to expose the length
 */
function DataLengthProbe(propName) {
    GenericWorker.call(this, "DataLengthProbe for " + propName);
    this.propName = propName;
    this.withStreamInfo(propName, 0);
}
utils.inherits(DataLengthProbe, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
DataLengthProbe.prototype.processChunk = function (chunk) {
    if(chunk) {
        var length = this.streamInfo[this.propName] || 0;
        this.streamInfo[this.propName] = length + chunk.data.length;
    }
    GenericWorker.prototype.processChunk.call(this, chunk);
};
module.exports = DataLengthProbe;


},{"../utils":43,"./GenericWorker":39}],38:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var GenericWorker = require('./GenericWorker');

// the size of the generated chunks
// TODO expose this as a public variable
var DEFAULT_BLOCK_SIZE = 16 * 1024;

/**
 * A worker that reads a content and emits chunks.
 * @constructor
 * @param {Promise} dataP the promise of the data to split
 */
function DataWorker(dataP) {
    GenericWorker.call(this, "DataWorker");
    var self = this;
    this.dataIsReady = false;
    this.index = 0;
    this.max = 0;
    this.data = null;
    this.type = "";

    this._tickScheduled = false;

    dataP.then(function (data) {
        self.dataIsReady = true;
        self.data = data;
        self.max = data && data.length || 0;
        self.type = utils.getTypeOf(data);
        if(!self.isPaused) {
            self._tickAndRepeat();
        }
    }, function (e) {
        self.error(e);
    });
}

utils.inherits(DataWorker, GenericWorker);

/**
 * @see GenericWorker.cleanUp
 */
DataWorker.prototype.cleanUp = function () {
    GenericWorker.prototype.cleanUp.call(this);
    this.data = null;
};

/**
 * @see GenericWorker.resume
 */
DataWorker.prototype.resume = function () {
    if(!GenericWorker.prototype.resume.call(this)) {
        return false;
    }

    if (!this._tickScheduled && this.dataIsReady) {
        this._tickScheduled = true;
        utils.delay(this._tickAndRepeat, [], this);
    }
    return true;
};

/**
 * Trigger a tick a schedule an other call to this function.
 */
DataWorker.prototype._tickAndRepeat = function() {
    this._tickScheduled = false;
    if(this.isPaused || this.isFinished) {
        return;
    }
    this._tick();
    if(!this.isFinished) {
        utils.delay(this._tickAndRepeat, [], this);
        this._tickScheduled = true;
    }
};

/**
 * Read and push a chunk.
 */
DataWorker.prototype._tick = function() {

    if(this.isPaused || this.isFinished) {
        return false;
    }

    var size = DEFAULT_BLOCK_SIZE;
    var data = null, nextIndex = Math.min(this.max, this.index + size);
    if (this.index >= this.max) {
        // EOF
        return this.end();
    } else {
        switch(this.type) {
            case "string":
                data = this.data.substring(this.index, nextIndex);
            break;
            case "uint8array":
                data = this.data.subarray(this.index, nextIndex);
            break;
            case "array":
            case "nodebuffer":
                data = this.data.slice(this.index, nextIndex);
            break;
        }
        this.index = nextIndex;
        return this.push({
            data : data,
            meta : {
                percent : this.max ? this.index / this.max * 100 : 0
            }
        });
    }
};

module.exports = DataWorker;

},{"../utils":43,"./GenericWorker":39}],39:[function(require,module,exports){
'use strict';

/**
 * A worker that does nothing but passing chunks to the next one. This is like
 * a nodejs stream but with some differences. On the good side :
 * - it works on IE 6-9 without any issue / polyfill
 * - it weights less than the full dependencies bundled with browserify
 * - it forwards errors (no need to declare an error handler EVERYWHERE)
 *
 * A chunk is an object with 2 attributes : `meta` and `data`. The former is an
 * object containing anything (`percent` for example), see each worker for more
 * details. The latter is the real data (String, Uint8Array, etc).
 *
 * @constructor
 * @param {String} name the name of the stream (mainly used for debugging purposes)
 */
function GenericWorker(name) {
    // the name of the worker
    this.name = name || "default";
    // an object containing metadata about the workers chain
    this.streamInfo = {};
    // an error which happened when the worker was paused
    this.generatedError = null;
    // an object containing metadata to be merged by this worker into the general metadata
    this.extraStreamInfo = {};
    // true if the stream is paused (and should not do anything), false otherwise
    this.isPaused = true;
    // true if the stream is finished (and should not do anything), false otherwise
    this.isFinished = false;
    // true if the stream is locked to prevent further structure updates (pipe), false otherwise
    this.isLocked = false;
    // the event listeners
    this._listeners = {
        'data':[],
        'end':[],
        'error':[]
    };
    // the previous worker, if any
    this.previous = null;
}

GenericWorker.prototype = {
    /**
     * Push a chunk to the next workers.
     * @param {Object} chunk the chunk to push
     */
    push : function (chunk) {
        this.emit("data", chunk);
    },
    /**
     * End the stream.
     * @return {Boolean} true if this call ended the worker, false otherwise.
     */
    end : function () {
        if (this.isFinished) {
            return false;
        }

        this.flush();
        try {
            this.emit("end");
            this.cleanUp();
            this.isFinished = true;
        } catch (e) {
            this.emit("error", e);
        }
        return true;
    },
    /**
     * End the stream with an error.
     * @param {Error} e the error which caused the premature end.
     * @return {Boolean} true if this call ended the worker with an error, false otherwise.
     */
    error : function (e) {
        if (this.isFinished) {
            return false;
        }

        if(this.isPaused) {
            this.generatedError = e;
        } else {
            this.isFinished = true;

            this.emit("error", e);

            // in the workers chain exploded in the middle of the chain,
            // the error event will go downward but we also need to notify
            // workers upward that there has been an error.
            if(this.previous) {
                this.previous.error(e);
            }

            this.cleanUp();
        }
        return true;
    },
    /**
     * Add a callback on an event.
     * @param {String} name the name of the event (data, end, error)
     * @param {Function} listener the function to call when the event is triggered
     * @return {GenericWorker} the current object for chainability
     */
    on : function (name, listener) {
        this._listeners[name].push(listener);
        return this;
    },
    /**
     * Clean any references when a worker is ending.
     */
    cleanUp : function () {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null;
        this._listeners = [];
    },
    /**
     * Trigger an event. This will call registered callback with the provided arg.
     * @param {String} name the name of the event (data, end, error)
     * @param {Object} arg the argument to call the callback with.
     */
    emit : function (name, arg) {
        if (this._listeners[name]) {
            for(var i = 0; i < this._listeners[name].length; i++) {
                this._listeners[name][i].call(this, arg);
            }
        }
    },
    /**
     * Chain a worker with an other.
     * @param {Worker} next the worker receiving events from the current one.
     * @return {worker} the next worker for chainability
     */
    pipe : function (next) {
        return next.registerPrevious(this);
    },
    /**
     * Same as `pipe` in the other direction.
     * Using an API with `pipe(next)` is very easy.
     * Implementing the API with the point of view of the next one registering
     * a source is easier, see the ZipFileWorker.
     * @param {Worker} previous the previous worker, sending events to this one
     * @return {Worker} the current worker for chainability
     */
    registerPrevious : function (previous) {
        if (this.isLocked) {
            throw new Error("The stream '" + this + "' has already been used.");
        }

        // sharing the streamInfo...
        this.streamInfo = previous.streamInfo;
        // ... and adding our own bits
        this.mergeStreamInfo();
        this.previous =  previous;
        var self = this;
        previous.on('data', function (chunk) {
            self.processChunk(chunk);
        });
        previous.on('end', function () {
            self.end();
        });
        previous.on('error', function (e) {
            self.error(e);
        });
        return this;
    },
    /**
     * Pause the stream so it doesn't send events anymore.
     * @return {Boolean} true if this call paused the worker, false otherwise.
     */
    pause : function () {
        if(this.isPaused || this.isFinished) {
            return false;
        }
        this.isPaused = true;

        if(this.previous) {
            this.previous.pause();
        }
        return true;
    },
    /**
     * Resume a paused stream.
     * @return {Boolean} true if this call resumed the worker, false otherwise.
     */
    resume : function () {
        if(!this.isPaused || this.isFinished) {
            return false;
        }
        this.isPaused = false;

        // if true, the worker tried to resume but failed
        var withError = false;
        if(this.generatedError) {
            this.error(this.generatedError);
            withError = true;
        }
        if(this.previous) {
            this.previous.resume();
        }

        return !withError;
    },
    /**
     * Flush any remaining bytes as the stream is ending.
     */
    flush : function () {},
    /**
     * Process a chunk. This is usually the method overridden.
     * @param {Object} chunk the chunk to process.
     */
    processChunk : function(chunk) {
        this.push(chunk);
    },
    /**
     * Add a key/value to be added in the workers chain streamInfo once activated.
     * @param {String} key the key to use
     * @param {Object} value the associated value
     * @return {Worker} the current worker for chainability
     */
    withStreamInfo : function (key, value) {
        this.extraStreamInfo[key] = value;
        this.mergeStreamInfo();
        return this;
    },
    /**
     * Merge this worker's streamInfo into the chain's streamInfo.
     */
    mergeStreamInfo : function () {
        for(var key in this.extraStreamInfo) {
            if (!this.extraStreamInfo.hasOwnProperty(key)) {
                continue;
            }
            this.streamInfo[key] = this.extraStreamInfo[key];
        }
    },

    /**
     * Lock the stream to prevent further updates on the workers chain.
     * After calling this method, all calls to pipe will fail.
     */
    lock: function () {
        if (this.isLocked) {
            throw new Error("The stream '" + this + "' has already been used.");
        }
        this.isLocked = true;
        if (this.previous) {
            this.previous.lock();
        }
    },

    /**
     *
     * Pretty print the workers chain.
     */
    toString : function () {
        var me = "Worker " + this.name;
        if (this.previous) {
            return this.previous + " -> " + me;
        } else {
            return me;
        }
    }
};

module.exports = GenericWorker;

},{}],40:[function(require,module,exports){
(function (Buffer){
'use strict';

var utils = require('../utils');
var ConvertWorker = require('./ConvertWorker');
var GenericWorker = require('./GenericWorker');
var base64 = require('../base64');
var support = require("../support");
var external = require("../external");

var NodejsStreamOutputAdapter = null;
if (support.nodestream) {
    try {
        NodejsStreamOutputAdapter = require('../nodejs/NodejsStreamOutputAdapter');
    } catch(e) {}
}

/**
 * Apply the final transformation of the data. If the user wants a Blob for
 * example, it's easier to work with an U8intArray and finally do the
 * ArrayBuffer/Blob conversion.
 * @param {String} type the name of the final type
 * @param {String|Uint8Array|Buffer} content the content to transform
 * @param {String} mimeType the mime type of the content, if applicable.
 * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the content in the right format.
 */
function transformZipOutput(type, content, mimeType) {
    switch(type) {
        case "blob" :
            return utils.newBlob(utils.transformTo("arraybuffer", content), mimeType);
        case "base64" :
            return base64.encode(content);
        default :
            return utils.transformTo(type, content);
    }
}

/**
 * Concatenate an array of data of the given type.
 * @param {String} type the type of the data in the given array.
 * @param {Array} dataArray the array containing the data chunks to concatenate
 * @return {String|Uint8Array|Buffer} the concatenated data
 * @throws Error if the asked type is unsupported
 */
function concat (type, dataArray) {
    var i, index = 0, res = null, totalLength = 0;
    for(i = 0; i < dataArray.length; i++) {
        totalLength += dataArray[i].length;
    }
    switch(type) {
        case "string":
            return dataArray.join("");
          case "array":
            return Array.prototype.concat.apply([], dataArray);
        case "uint8array":
            res = new Uint8Array(totalLength);
            for(i = 0; i < dataArray.length; i++) {
                res.set(dataArray[i], index);
                index += dataArray[i].length;
            }
            return res;
        case "nodebuffer":
            return Buffer.concat(dataArray);
        default:
            throw new Error("concat : unsupported type '"  + type + "'");
    }
}

/**
 * Listen a StreamHelper, accumulate its content and concatenate it into a
 * complete block.
 * @param {StreamHelper} helper the helper to use.
 * @param {Function} updateCallback a callback called on each update. Called
 * with one arg :
 * - the metadata linked to the update received.
 * @return Promise the promise for the accumulation.
 */
function accumulate(helper, updateCallback) {
    return new external.Promise(function (resolve, reject){
        var dataArray = [];
        var chunkType = helper._internalType,
            resultType = helper._outputType,
            mimeType = helper._mimeType;
        helper
        .on('data', function (data, meta) {
            dataArray.push(data);
            if(updateCallback) {
                updateCallback(meta);
            }
        })
        .on('error', function(err) {
            dataArray = [];
            reject(err);
        })
        .on('end', function (){
            try {
                var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);
                resolve(result);
            } catch (e) {
                reject(e);
            }
            dataArray = [];
        })
        .resume();
    });
}

/**
 * An helper to easily use workers outside of JSZip.
 * @constructor
 * @param {Worker} worker the worker to wrap
 * @param {String} outputType the type of data expected by the use
 * @param {String} mimeType the mime type of the content, if applicable.
 */
function StreamHelper(worker, outputType, mimeType) {
    var internalType = outputType;
    switch(outputType) {
        case "blob":
        case "arraybuffer":
            internalType = "uint8array";
        break;
        case "base64":
            internalType = "string";
        break;
    }

    try {
        // the type used internally
        this._internalType = internalType;
        // the type used to output results
        this._outputType = outputType;
        // the mime type
        this._mimeType = mimeType;
        utils.checkSupport(internalType);
        this._worker = worker.pipe(new ConvertWorker(internalType));
        // the last workers can be rewired without issues but we need to
        // prevent any updates on previous workers.
        worker.lock();
    } catch(e) {
        this._worker = new GenericWorker("error");
        this._worker.error(e);
    }
}

StreamHelper.prototype = {
    /**
     * Listen a StreamHelper, accumulate its content and concatenate it into a
     * complete block.
     * @param {Function} updateCb the update callback.
     * @return Promise the promise for the accumulation.
     */
    accumulate : function (updateCb) {
        return accumulate(this, updateCb);
    },
    /**
     * Add a listener on an event triggered on a stream.
     * @param {String} evt the name of the event
     * @param {Function} fn the listener
     * @return {StreamHelper} the current helper.
     */
    on : function (evt, fn) {
        var self = this;

        if(evt === "data") {
            this._worker.on(evt, function (chunk) {
                fn.call(self, chunk.data, chunk.meta);
            });
        } else {
            this._worker.on(evt, function () {
                utils.delay(fn, arguments, self);
            });
        }
        return this;
    },
    /**
     * Resume the flow of chunks.
     * @return {StreamHelper} the current helper.
     */
    resume : function () {
        utils.delay(this._worker.resume, [], this._worker);
        return this;
    },
    /**
     * Pause the flow of chunks.
     * @return {StreamHelper} the current helper.
     */
    pause : function () {
        this._worker.pause();
        return this;
    },
    /**
     * Return a nodejs stream for this helper.
     * @param {Function} updateCb the update callback.
     * @return {NodejsStreamOutputAdapter} the nodejs stream.
     */
    toNodejsStream : function (updateCb) {
        utils.checkSupport("nodestream");
        if (this._outputType !== "nodebuffer") {
            // an object stream containing blob/arraybuffer/uint8array/string
            // is strange and I don't know if it would be useful.
            // I you find this comment and have a good usecase, please open a
            // bug report !
            throw new Error(this._outputType + " is not supported by this method");
        }

        return new NodejsStreamOutputAdapter(this, {
            objectMode : this._outputType !== "nodebuffer"
        }, updateCb);
    }
};


module.exports = StreamHelper;

}).call(this,require("buffer").Buffer)

},{"../base64":12,"../external":17,"../nodejs/NodejsStreamOutputAdapter":25,"../support":41,"../utils":43,"./ConvertWorker":35,"./GenericWorker":39,"buffer":3}],41:[function(require,module,exports){
(function (Buffer){
'use strict';

exports.base64 = true;
exports.array = true;
exports.string = true;
exports.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
exports.nodebuffer = typeof Buffer !== "undefined";
// contains true if JSZip can read/generate Uint8Array, false otherwise.
exports.uint8array = typeof Uint8Array !== "undefined";

if (typeof ArrayBuffer === "undefined") {
    exports.blob = false;
}
else {
    var buffer = new ArrayBuffer(0);
    try {
        exports.blob = new Blob([buffer], {
            type: "application/zip"
        }).size === 0;
    }
    catch (e) {
        try {
            var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
            var builder = new Builder();
            builder.append(buffer);
            exports.blob = builder.getBlob('application/zip').size === 0;
        }
        catch (e) {
            exports.blob = false;
        }
    }
}

try {
    exports.nodestream = !!require('readable-stream').Readable;
} catch(e) {
    exports.nodestream = false;
}

}).call(this,require("buffer").Buffer)

},{"buffer":3,"readable-stream":27}],42:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var support = require('./support');
var nodejsUtils = require('./nodejsUtils');
var GenericWorker = require('./stream/GenericWorker');

/**
 * The following functions come from pako, from pako/lib/utils/strings
 * released under the MIT license, see pako https://github.com/nodeca/pako/
 */

// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new Array(256);
for (var i=0; i<256; i++) {
  _utf8len[i] = (i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1);
}
_utf8len[254]=_utf8len[254]=1; // Invalid sequence start

// convert string to array (typed, when possible)
var string2buf = function (str) {
    var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

    // count binary size
    for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {
            c2 = str.charCodeAt(m_pos+1);
            if ((c2 & 0xfc00) === 0xdc00) {
                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
                m_pos++;
            }
        }
        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
    }

    // allocate buffer
    if (support.uint8array) {
        buf = new Uint8Array(buf_len);
    } else {
        buf = new Array(buf_len);
    }

    // convert
    for (i=0, m_pos = 0; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {
            c2 = str.charCodeAt(m_pos+1);
            if ((c2 & 0xfc00) === 0xdc00) {
                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
                m_pos++;
            }
        }
        if (c < 0x80) {
            /* one byte */
            buf[i++] = c;
        } else if (c < 0x800) {
            /* two bytes */
            buf[i++] = 0xC0 | (c >>> 6);
            buf[i++] = 0x80 | (c & 0x3f);
        } else if (c < 0x10000) {
            /* three bytes */
            buf[i++] = 0xE0 | (c >>> 12);
            buf[i++] = 0x80 | (c >>> 6 & 0x3f);
            buf[i++] = 0x80 | (c & 0x3f);
        } else {
            /* four bytes */
            buf[i++] = 0xf0 | (c >>> 18);
            buf[i++] = 0x80 | (c >>> 12 & 0x3f);
            buf[i++] = 0x80 | (c >>> 6 & 0x3f);
            buf[i++] = 0x80 | (c & 0x3f);
        }
    }

    return buf;
};

// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
var utf8border = function(buf, max) {
    var pos;

    max = max || buf.length;
    if (max > buf.length) { max = buf.length; }

    // go back from last position, until start of sequence found
    pos = max-1;
    while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

    // Fuckup - very small and broken sequence,
    // return max, because we should return something anyway.
    if (pos < 0) { return max; }

    // If we came to start of buffer - that means vuffer is too small,
    // return max too.
    if (pos === 0) { return max; }

    return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};

// convert array to string
var buf2string = function (buf) {
    var str, i, out, c, c_len;
    var len = buf.length;

    // Reserve max possible length (2 words per char)
    // NB: by unknown reasons, Array is significantly faster for
    //     String.fromCharCode.apply than Uint16Array.
    var utf16buf = new Array(len*2);

    for (out=0, i=0; i<len;) {
        c = buf[i++];
        // quick process ascii
        if (c < 0x80) { utf16buf[out++] = c; continue; }

        c_len = _utf8len[c];
        // skip 5 & 6 byte codes
        if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len-1; continue; }

        // apply mask on first byte
        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
        // join the rest
        while (c_len > 1 && i < len) {
            c = (c << 6) | (buf[i++] & 0x3f);
            c_len--;
        }

        // terminated by end of string?
        if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

        if (c < 0x10000) {
            utf16buf[out++] = c;
        } else {
            c -= 0x10000;
            utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
            utf16buf[out++] = 0xdc00 | (c & 0x3ff);
        }
    }

    // shrinkBuf(utf16buf, out)
    if (utf16buf.length !== out) {
        if(utf16buf.subarray) {
            utf16buf = utf16buf.subarray(0, out);
        } else {
            utf16buf.length = out;
        }
    }

    // return String.fromCharCode.apply(null, utf16buf);
    return utils.applyFromCharCode(utf16buf);
};


// That's all for the pako functions.


/**
 * Transform a javascript string into an array (typed if possible) of bytes,
 * UTF-8 encoded.
 * @param {String} str the string to encode
 * @return {Array|Uint8Array|Buffer} the UTF-8 encoded string.
 */
exports.utf8encode = function utf8encode(str) {
    if (support.nodebuffer) {
        return nodejsUtils.newBufferFrom(str, "utf-8");
    }

    return string2buf(str);
};


/**
 * Transform a bytes array (or a representation) representing an UTF-8 encoded
 * string into a javascript string.
 * @param {Array|Uint8Array|Buffer} buf the data de decode
 * @return {String} the decoded string.
 */
exports.utf8decode = function utf8decode(buf) {
    if (support.nodebuffer) {
        return utils.transformTo("nodebuffer", buf).toString("utf-8");
    }

    buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);

    return buf2string(buf);
};

/**
 * A worker to decode utf8 encoded binary chunks into string chunks.
 * @constructor
 */
function Utf8DecodeWorker() {
    GenericWorker.call(this, "utf-8 decode");
    // the last bytes if a chunk didn't end with a complete codepoint.
    this.leftOver = null;
}
utils.inherits(Utf8DecodeWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
Utf8DecodeWorker.prototype.processChunk = function (chunk) {

    var data = utils.transformTo(support.uint8array ? "uint8array" : "array", chunk.data);

    // 1st step, re-use what's left of the previous chunk
    if (this.leftOver && this.leftOver.length) {
        if(support.uint8array) {
            var previousData = data;
            data = new Uint8Array(previousData.length + this.leftOver.length);
            data.set(this.leftOver, 0);
            data.set(previousData, this.leftOver.length);
        } else {
            data = this.leftOver.concat(data);
        }
        this.leftOver = null;
    }

    var nextBoundary = utf8border(data);
    var usableData = data;
    if (nextBoundary !== data.length) {
        if (support.uint8array) {
            usableData = data.subarray(0, nextBoundary);
            this.leftOver = data.subarray(nextBoundary, data.length);
        } else {
            usableData = data.slice(0, nextBoundary);
            this.leftOver = data.slice(nextBoundary, data.length);
        }
    }

    this.push({
        data : exports.utf8decode(usableData),
        meta : chunk.meta
    });
};

/**
 * @see GenericWorker.flush
 */
Utf8DecodeWorker.prototype.flush = function () {
    if(this.leftOver && this.leftOver.length) {
        this.push({
            data : exports.utf8decode(this.leftOver),
            meta : {}
        });
        this.leftOver = null;
    }
};
exports.Utf8DecodeWorker = Utf8DecodeWorker;

/**
 * A worker to endcode string chunks into utf8 encoded binary chunks.
 * @constructor
 */
function Utf8EncodeWorker() {
    GenericWorker.call(this, "utf-8 encode");
}
utils.inherits(Utf8EncodeWorker, GenericWorker);

/**
 * @see GenericWorker.processChunk
 */
Utf8EncodeWorker.prototype.processChunk = function (chunk) {
    this.push({
        data : exports.utf8encode(chunk.data),
        meta : chunk.meta
    });
};
exports.Utf8EncodeWorker = Utf8EncodeWorker;

},{"./nodejsUtils":23,"./stream/GenericWorker":39,"./support":41,"./utils":43}],43:[function(require,module,exports){
'use strict';

var support = require('./support');
var base64 = require('./base64');
var nodejsUtils = require('./nodejsUtils');
var setImmediate = require('set-immediate-shim');
var external = require("./external");


/**
 * Convert a string that pass as a "binary string": it should represent a byte
 * array but may have > 255 char codes. Be sure to take only the first byte
 * and returns the byte array.
 * @param {String} str the string to transform.
 * @return {Array|Uint8Array} the string in a binary format.
 */
function string2binary(str) {
    var result = null;
    if (support.uint8array) {
      result = new Uint8Array(str.length);
    } else {
      result = new Array(str.length);
    }
    return stringToArrayLike(str, result);
}

/**
 * Create a new blob with the given content and the given type.
 * @param {String|ArrayBuffer} part the content to put in the blob. DO NOT use
 * an Uint8Array because the stock browser of android 4 won't accept it (it
 * will be silently converted to a string, "[object Uint8Array]").
 *
 * Use only ONE part to build the blob to avoid a memory leak in IE11 / Edge:
 * when a large amount of Array is used to create the Blob, the amount of
 * memory consumed is nearly 100 times the original data amount.
 *
 * @param {String} type the mime type of the blob.
 * @return {Blob} the created blob.
 */
exports.newBlob = function(part, type) {
    exports.checkSupport("blob");

    try {
        // Blob constructor
        return new Blob([part], {
            type: type
        });
    }
    catch (e) {

        try {
            // deprecated, browser only, old way
            var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
            var builder = new Builder();
            builder.append(part);
            return builder.getBlob(type);
        }
        catch (e) {

            // well, fuck ?!
            throw new Error("Bug : can't construct the Blob.");
        }
    }


};
/**
 * The identity function.
 * @param {Object} input the input.
 * @return {Object} the same input.
 */
function identity(input) {
    return input;
}

/**
 * Fill in an array with a string.
 * @param {String} str the string to use.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to fill in (will be mutated).
 * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated array.
 */
function stringToArrayLike(str, array) {
    for (var i = 0; i < str.length; ++i) {
        array[i] = str.charCodeAt(i) & 0xFF;
    }
    return array;
}

/**
 * An helper for the function arrayLikeToString.
 * This contains static information and functions that
 * can be optimized by the browser JIT compiler.
 */
var arrayToStringHelper = {
    /**
     * Transform an array of int into a string, chunk by chunk.
     * See the performances notes on arrayLikeToString.
     * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
     * @param {String} type the type of the array.
     * @param {Integer} chunk the chunk size.
     * @return {String} the resulting string.
     * @throws Error if the chunk is too big for the stack.
     */
    stringifyByChunk: function(array, type, chunk) {
        var result = [], k = 0, len = array.length;
        // shortcut
        if (len <= chunk) {
            return String.fromCharCode.apply(null, array);
        }
        while (k < len) {
            if (type === "array" || type === "nodebuffer") {
                result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));
            }
            else {
                result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));
            }
            k += chunk;
        }
        return result.join("");
    },
    /**
     * Call String.fromCharCode on every item in the array.
     * This is the naive implementation, which generate A LOT of intermediate string.
     * This should be used when everything else fail.
     * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
     * @return {String} the result.
     */
    stringifyByChar: function(array){
        var resultStr = "";
        for(var i = 0; i < array.length; i++) {
            resultStr += String.fromCharCode(array[i]);
        }
        return resultStr;
    },
    applyCanBeUsed : {
        /**
         * true if the browser accepts to use String.fromCharCode on Uint8Array
         */
        uint8array : (function () {
            try {
                return support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
            } catch (e) {
                return false;
            }
        })(),
        /**
         * true if the browser accepts to use String.fromCharCode on nodejs Buffer.
         */
        nodebuffer : (function () {
            try {
                return support.nodebuffer && String.fromCharCode.apply(null, nodejsUtils.allocBuffer(1)).length === 1;
            } catch (e) {
                return false;
            }
        })()
    }
};

/**
 * Transform an array-like object to a string.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
 * @return {String} the result.
 */
function arrayLikeToString(array) {
    // Performances notes :
    // --------------------
    // String.fromCharCode.apply(null, array) is the fastest, see
    // see http://jsperf.com/converting-a-uint8array-to-a-string/2
    // but the stack is limited (and we can get huge arrays !).
    //
    // result += String.fromCharCode(array[i]); generate too many strings !
    //
    // This code is inspired by http://jsperf.com/arraybuffer-to-string-apply-performance/2
    // TODO : we now have workers that split the work. Do we still need that ?
    var chunk = 65536,
        type = exports.getTypeOf(array),
        canUseApply = true;
    if (type === "uint8array") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;
    } else if (type === "nodebuffer") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;
    }

    if (canUseApply) {
        while (chunk > 1) {
            try {
                return arrayToStringHelper.stringifyByChunk(array, type, chunk);
            } catch (e) {
                chunk = Math.floor(chunk / 2);
            }
        }
    }

    // no apply or chunk error : slow and painful algorithm
    // default browser on android 4.*
    return arrayToStringHelper.stringifyByChar(array);
}

exports.applyFromCharCode = arrayLikeToString;


/**
 * Copy the data from an array-like to an other array-like.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayFrom the origin array.
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayTo the destination array which will be mutated.
 * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated destination array.
 */
function arrayLikeToArrayLike(arrayFrom, arrayTo) {
    for (var i = 0; i < arrayFrom.length; i++) {
        arrayTo[i] = arrayFrom[i];
    }
    return arrayTo;
}

// a matrix containing functions to transform everything into everything.
var transform = {};

// string to ?
transform["string"] = {
    "string": identity,
    "array": function(input) {
        return stringToArrayLike(input, new Array(input.length));
    },
    "arraybuffer": function(input) {
        return transform["string"]["uint8array"](input).buffer;
    },
    "uint8array": function(input) {
        return stringToArrayLike(input, new Uint8Array(input.length));
    },
    "nodebuffer": function(input) {
        return stringToArrayLike(input, nodejsUtils.allocBuffer(input.length));
    }
};

// array to ?
transform["array"] = {
    "string": arrayLikeToString,
    "array": identity,
    "arraybuffer": function(input) {
        return (new Uint8Array(input)).buffer;
    },
    "uint8array": function(input) {
        return new Uint8Array(input);
    },
    "nodebuffer": function(input) {
        return nodejsUtils.newBufferFrom(input);
    }
};

// arraybuffer to ?
transform["arraybuffer"] = {
    "string": function(input) {
        return arrayLikeToString(new Uint8Array(input));
    },
    "array": function(input) {
        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
    },
    "arraybuffer": identity,
    "uint8array": function(input) {
        return new Uint8Array(input);
    },
    "nodebuffer": function(input) {
        return nodejsUtils.newBufferFrom(new Uint8Array(input));
    }
};

// uint8array to ?
transform["uint8array"] = {
    "string": arrayLikeToString,
    "array": function(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
    },
    "arraybuffer": function(input) {
        return input.buffer;
    },
    "uint8array": identity,
    "nodebuffer": function(input) {
        return nodejsUtils.newBufferFrom(input);
    }
};

// nodebuffer to ?
transform["nodebuffer"] = {
    "string": arrayLikeToString,
    "array": function(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
    },
    "arraybuffer": function(input) {
        return transform["nodebuffer"]["uint8array"](input).buffer;
    },
    "uint8array": function(input) {
        return arrayLikeToArrayLike(input, new Uint8Array(input.length));
    },
    "nodebuffer": identity
};

/**
 * Transform an input into any type.
 * The supported output type are : string, array, uint8array, arraybuffer, nodebuffer.
 * If no output type is specified, the unmodified input will be returned.
 * @param {String} outputType the output type.
 * @param {String|Array|ArrayBuffer|Uint8Array|Buffer} input the input to convert.
 * @throws {Error} an Error if the browser doesn't support the requested output type.
 */
exports.transformTo = function(outputType, input) {
    if (!input) {
        // undefined, null, etc
        // an empty string won't harm.
        input = "";
    }
    if (!outputType) {
        return input;
    }
    exports.checkSupport(outputType);
    var inputType = exports.getTypeOf(input);
    var result = transform[inputType][outputType](input);
    return result;
};

/**
 * Return the type of the input.
 * The type will be in a format valid for JSZip.utils.transformTo : string, array, uint8array, arraybuffer.
 * @param {Object} input the input to identify.
 * @return {String} the (lowercase) type of the input.
 */
exports.getTypeOf = function(input) {
    if (typeof input === "string") {
        return "string";
    }
    if (Object.prototype.toString.call(input) === "[object Array]") {
        return "array";
    }
    if (support.nodebuffer && nodejsUtils.isBuffer(input)) {
        return "nodebuffer";
    }
    if (support.uint8array && input instanceof Uint8Array) {
        return "uint8array";
    }
    if (support.arraybuffer && input instanceof ArrayBuffer) {
        return "arraybuffer";
    }
};

/**
 * Throw an exception if the type is not supported.
 * @param {String} type the type to check.
 * @throws {Error} an Error if the browser doesn't support the requested type.
 */
exports.checkSupport = function(type) {
    var supported = support[type.toLowerCase()];
    if (!supported) {
        throw new Error(type + " is not supported by this platform");
    }
};

exports.MAX_VALUE_16BITS = 65535;
exports.MAX_VALUE_32BITS = -1; // well, "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF" is parsed as -1

/**
 * Prettify a string read as binary.
 * @param {string} str the string to prettify.
 * @return {string} a pretty string.
 */
exports.pretty = function(str) {
    var res = '',
        code, i;
    for (i = 0; i < (str || "").length; i++) {
        code = str.charCodeAt(i);
        res += '\\x' + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
    }
    return res;
};

/**
 * Defer the call of a function.
 * @param {Function} callback the function to call asynchronously.
 * @param {Array} args the arguments to give to the callback.
 */
exports.delay = function(callback, args, self) {
    setImmediate(function () {
        callback.apply(self || null, args || []);
    });
};

/**
 * Extends a prototype with an other, without calling a constructor with
 * side effects. Inspired by nodejs' `utils.inherits`
 * @param {Function} ctor the constructor to augment
 * @param {Function} superCtor the parent constructor to use
 */
exports.inherits = function (ctor, superCtor) {
    var Obj = function() {};
    Obj.prototype = superCtor.prototype;
    ctor.prototype = new Obj();
};

/**
 * Merge the objects passed as parameters into a new one.
 * @private
 * @param {...Object} var_args All objects to merge.
 * @return {Object} a new object with the data of the others.
 */
exports.extend = function() {
    var result = {}, i, attr;
    for (i = 0; i < arguments.length; i++) { // arguments is not enumerable in some browsers
        for (attr in arguments[i]) {
            if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === "undefined") {
                result[attr] = arguments[i][attr];
            }
        }
    }
    return result;
};

/**
 * Transform arbitrary content into a Promise.
 * @param {String} name a name for the content being processed.
 * @param {Object} inputData the content to process.
 * @param {Boolean} isBinary true if the content is not an unicode string
 * @param {Boolean} isOptimizedBinaryString true if the string content only has one byte per character.
 * @param {Boolean} isBase64 true if the string content is encoded with base64.
 * @return {Promise} a promise in a format usable by JSZip.
 */
exports.prepareContent = function(name, inputData, isBinary, isOptimizedBinaryString, isBase64) {

    // if inputData is already a promise, this flatten it.
    var promise = external.Promise.resolve(inputData).then(function(data) {
        
        
        var isBlob = support.blob && (data instanceof Blob || ['[object File]', '[object Blob]'].indexOf(Object.prototype.toString.call(data)) !== -1);

        if (isBlob && typeof FileReader !== "undefined") {
            return new external.Promise(function (resolve, reject) {
                var reader = new FileReader();

                reader.onload = function(e) {
                    resolve(e.target.result);
                };
                reader.onerror = function(e) {
                    reject(e.target.error);
                };
                reader.readAsArrayBuffer(data);
            });
        } else {
            return data;
        }
    });

    return promise.then(function(data) {
        var dataType = exports.getTypeOf(data);

        if (!dataType) {
            return external.Promise.reject(
                new Error("Can't read the data of '" + name + "'. Is it " +
                          "in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?")
            );
        }
        // special case : it's way easier to work with Uint8Array than with ArrayBuffer
        if (dataType === "arraybuffer") {
            data = exports.transformTo("uint8array", data);
        } else if (dataType === "string") {
            if (isBase64) {
                data = base64.decode(data);
            }
            else if (isBinary) {
                // optimizedBinaryString === true means that the file has already been filtered with a 0xFF mask
                if (isOptimizedBinaryString !== true) {
                    // this is a string, not in a base64 format.
                    // Be sure that this is a correct "binary string"
                    data = string2binary(data);
                }
            }
        }
        return data;
    });
};

},{"./base64":12,"./external":17,"./nodejsUtils":23,"./support":41,"set-immediate-shim":80}],44:[function(require,module,exports){
'use strict';
var readerFor = require('./reader/readerFor');
var utils = require('./utils');
var sig = require('./signature');
var ZipEntry = require('./zipEntry');
var utf8 = require('./utf8');
var support = require('./support');
//  class ZipEntries {{{
/**
 * All the entries in the zip file.
 * @constructor
 * @param {Object} loadOptions Options for loading the stream.
 */
function ZipEntries(loadOptions) {
    this.files = [];
    this.loadOptions = loadOptions;
}
ZipEntries.prototype = {
    /**
     * Check that the reader is on the specified signature.
     * @param {string} expectedSignature the expected signature.
     * @throws {Error} if it is an other signature.
     */
    checkSignature: function(expectedSignature) {
        if (!this.reader.readAndCheckSignature(expectedSignature)) {
            this.reader.index -= 4;
            var signature = this.reader.readString(4);
            throw new Error("Corrupted zip or bug: unexpected signature " + "(" + utils.pretty(signature) + ", expected " + utils.pretty(expectedSignature) + ")");
        }
    },
    /**
     * Check if the given signature is at the given index.
     * @param {number} askedIndex the index to check.
     * @param {string} expectedSignature the signature to expect.
     * @return {boolean} true if the signature is here, false otherwise.
     */
    isSignature: function(askedIndex, expectedSignature) {
        var currentIndex = this.reader.index;
        this.reader.setIndex(askedIndex);
        var signature = this.reader.readString(4);
        var result = signature === expectedSignature;
        this.reader.setIndex(currentIndex);
        return result;
    },
    /**
     * Read the end of the central directory.
     */
    readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2);
        this.diskWithCentralDirStart = this.reader.readInt(2);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
        this.centralDirRecords = this.reader.readInt(2);
        this.centralDirSize = this.reader.readInt(4);
        this.centralDirOffset = this.reader.readInt(4);

        this.zipCommentLength = this.reader.readInt(2);
        // warning : the encoding depends of the system locale
        // On a linux machine with LANG=en_US.utf8, this field is utf8 encoded.
        // On a windows machine, this field is encoded with the localized windows code page.
        var zipComment = this.reader.readData(this.zipCommentLength);
        var decodeParamType = support.uint8array ? "uint8array" : "array";
        // To get consistent behavior with the generation part, we will assume that
        // this is utf8 encoded unless specified otherwise.
        var decodeContent = utils.transformTo(decodeParamType, zipComment);
        this.zipComment = this.loadOptions.decodeFileName(decodeContent);
    },
    /**
     * Read the end of the Zip 64 central directory.
     * Not merged with the method readEndOfCentral :
     * The end of central can coexist with its Zip64 brother,
     * I don't want to read the wrong number of bytes !
     */
    readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8);
        this.reader.skip(4);
        // this.versionMadeBy = this.reader.readString(2);
        // this.versionNeeded = this.reader.readInt(2);
        this.diskNumber = this.reader.readInt(4);
        this.diskWithCentralDirStart = this.reader.readInt(4);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
        this.centralDirRecords = this.reader.readInt(8);
        this.centralDirSize = this.reader.readInt(8);
        this.centralDirOffset = this.reader.readInt(8);

        this.zip64ExtensibleData = {};
        var extraDataSize = this.zip64EndOfCentralSize - 44,
            index = 0,
            extraFieldId,
            extraFieldLength,
            extraFieldValue;
        while (index < extraDataSize) {
            extraFieldId = this.reader.readInt(2);
            extraFieldLength = this.reader.readInt(4);
            extraFieldValue = this.reader.readData(extraFieldLength);
            this.zip64ExtensibleData[extraFieldId] = {
                id: extraFieldId,
                length: extraFieldLength,
                value: extraFieldValue
            };
        }
    },
    /**
     * Read the end of the Zip 64 central directory locator.
     */
    readBlockZip64EndOfCentralLocator: function() {
        this.diskWithZip64CentralDirStart = this.reader.readInt(4);
        this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
        this.disksCount = this.reader.readInt(4);
        if (this.disksCount > 1) {
            throw new Error("Multi-volumes zip are not supported");
        }
    },
    /**
     * Read the local files, based on the offset read in the central part.
     */
    readLocalFiles: function() {
        var i, file;
        for (i = 0; i < this.files.length; i++) {
            file = this.files[i];
            this.reader.setIndex(file.localHeaderOffset);
            this.checkSignature(sig.LOCAL_FILE_HEADER);
            file.readLocalPart(this.reader);
            file.handleUTF8();
            file.processAttributes();
        }
    },
    /**
     * Read the central directory.
     */
    readCentralDir: function() {
        var file;

        this.reader.setIndex(this.centralDirOffset);
        while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {
            file = new ZipEntry({
                zip64: this.zip64
            }, this.loadOptions);
            file.readCentralPart(this.reader);
            this.files.push(file);
        }

        if (this.centralDirRecords !== this.files.length) {
            if (this.centralDirRecords !== 0 && this.files.length === 0) {
                // We expected some records but couldn't find ANY.
                // This is really suspicious, as if something went wrong.
                throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
            } else {
                // We found some records but not all.
                // Something is wrong but we got something for the user: no error here.
                // console.warn("expected", this.centralDirRecords, "records in central dir, got", this.files.length);
            }
        }
    },
    /**
     * Read the end of central directory.
     */
    readEndOfCentral: function() {
        var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
        if (offset < 0) {
            // Check if the content is a truncated zip or complete garbage.
            // A "LOCAL_FILE_HEADER" is not required at the beginning (auto
            // extractible zip for example) but it can give a good hint.
            // If an ajax request was used without responseType, we will also
            // get unreadable data.
            var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);

            if (isGarbage) {
                throw new Error("Can't find end of central directory : is this a zip file ? " +
                                "If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
            } else {
                throw new Error("Corrupted zip: can't find end of central directory");
            }

        }
        this.reader.setIndex(offset);
        var endOfCentralDirOffset = offset;
        this.checkSignature(sig.CENTRAL_DIRECTORY_END);
        this.readBlockEndOfCentral();


        /* extract from the zip spec :
            4)  If one of the fields in the end of central directory
                record is too small to hold required data, the field
                should be set to -1 (0xFFFF or 0xFFFFFFFF) and the
                ZIP64 format record should be created.
            5)  The end of central directory record and the
                Zip64 end of central directory locator record must
                reside on the same disk when splitting or spanning
                an archive.
         */
        if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
            this.zip64 = true;

            /*
            Warning : the zip64 extension is supported, but ONLY if the 64bits integer read from
            the zip file can fit into a 32bits integer. This cannot be solved : JavaScript represents
            all numbers as 64-bit double precision IEEE 754 floating point numbers.
            So, we have 53bits for integers and bitwise operations treat everything as 32bits.
            see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Bitwise_Operators
            and http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf section 8.5
            */

            // should look for a zip64 EOCD locator
            offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
            if (offset < 0) {
                throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
            }
            this.reader.setIndex(offset);
            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
            this.readBlockZip64EndOfCentralLocator();

            // now the zip64 EOCD record
            if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
                // console.warn("ZIP64 end of central directory not where expected.");
                this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
                if (this.relativeOffsetEndOfZip64CentralDir < 0) {
                    throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
                }
            }
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
            this.readBlockZip64EndOfCentral();
        }

        var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
        if (this.zip64) {
            expectedEndOfCentralDirOffset += 20; // end of central dir 64 locator
            expectedEndOfCentralDirOffset += 12 /* should not include the leading 12 bytes */ + this.zip64EndOfCentralSize;
        }

        var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;

        if (extraBytes > 0) {
            // console.warn(extraBytes, "extra bytes at beginning or within zipfile");
            if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {
                // The offsets seem wrong, but we have something at the specified offset.
                // So we keep it.
            } else {
                // the offset is wrong, update the "zero" of the reader
                // this happens if data has been prepended (crx files for example)
                this.reader.zero = extraBytes;
            }
        } else if (extraBytes < 0) {
            throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
        }
    },
    prepareReader: function(data) {
        this.reader = readerFor(data);
    },
    /**
     * Read a zip file and create ZipEntries.
     * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
     */
    load: function(data) {
        this.prepareReader(data);
        this.readEndOfCentral();
        this.readCentralDir();
        this.readLocalFiles();
    }
};
// }}} end of ZipEntries
module.exports = ZipEntries;

},{"./reader/readerFor":33,"./signature":34,"./support":41,"./utf8":42,"./utils":43,"./zipEntry":45}],45:[function(require,module,exports){
'use strict';
var readerFor = require('./reader/readerFor');
var utils = require('./utils');
var CompressedObject = require('./compressedObject');
var crc32fn = require('./crc32');
var utf8 = require('./utf8');
var compressions = require('./compressions');
var support = require('./support');

var MADE_BY_DOS = 0x00;
var MADE_BY_UNIX = 0x03;

/**
 * Find a compression registered in JSZip.
 * @param {string} compressionMethod the method magic to find.
 * @return {Object|null} the JSZip compression object, null if none found.
 */
var findCompression = function(compressionMethod) {
    for (var method in compressions) {
        if (!compressions.hasOwnProperty(method)) {
            continue;
        }
        if (compressions[method].magic === compressionMethod) {
            return compressions[method];
        }
    }
    return null;
};

// class ZipEntry {{{
/**
 * An entry in the zip file.
 * @constructor
 * @param {Object} options Options of the current file.
 * @param {Object} loadOptions Options for loading the stream.
 */
function ZipEntry(options, loadOptions) {
    this.options = options;
    this.loadOptions = loadOptions;
}
ZipEntry.prototype = {
    /**
     * say if the file is encrypted.
     * @return {boolean} true if the file is encrypted, false otherwise.
     */
    isEncrypted: function() {
        // bit 1 is set
        return (this.bitFlag & 0x0001) === 0x0001;
    },
    /**
     * say if the file has utf-8 filename/comment.
     * @return {boolean} true if the filename/comment is in utf-8, false otherwise.
     */
    useUTF8: function() {
        // bit 11 is set
        return (this.bitFlag & 0x0800) === 0x0800;
    },
    /**
     * Read the local part of a zip file and add the info in this object.
     * @param {DataReader} reader the reader to use.
     */
    readLocalPart: function(reader) {
        var compression, localExtraFieldsLength;

        // we already know everything from the central dir !
        // If the central dir data are false, we are doomed.
        // On the bright side, the local part is scary  : zip64, data descriptors, both, etc.
        // The less data we get here, the more reliable this should be.
        // Let's skip the whole header and dash to the data !
        reader.skip(22);
        // in some zip created on windows, the filename stored in the central dir contains \ instead of /.
        // Strangely, the filename here is OK.
        // I would love to treat these zip files as corrupted (see http://www.info-zip.org/FAQ.html#backslashes
        // or APPNOTE#4.4.17.1, "All slashes MUST be forward slashes '/'") but there are a lot of bad zip generators...
        // Search "unzip mismatching "local" filename continuing with "central" filename version" on
        // the internet.
        //
        // I think I see the logic here : the central directory is used to display
        // content and the local directory is used to extract the files. Mixing / and \
        // may be used to display \ to windows users and use / when extracting the files.
        // Unfortunately, this lead also to some issues : http://seclists.org/fulldisclosure/2009/Sep/394
        this.fileNameLength = reader.readInt(2);
        localExtraFieldsLength = reader.readInt(2); // can't be sure this will be the same as the central dir
        // the fileName is stored as binary data, the handleUTF8 method will take care of the encoding.
        this.fileName = reader.readData(this.fileNameLength);
        reader.skip(localExtraFieldsLength);

        if (this.compressedSize === -1 || this.uncompressedSize === -1) {
            throw new Error("Bug or corrupted zip : didn't get enough information from the central directory " + "(compressedSize === -1 || uncompressedSize === -1)");
        }

        compression = findCompression(this.compressionMethod);
        if (compression === null) { // no compression found
            throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + utils.transformTo("string", this.fileName) + ")");
        }
        this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));
    },

    /**
     * Read the central part of a zip file and add the info in this object.
     * @param {DataReader} reader the reader to use.
     */
    readCentralPart: function(reader) {
        this.versionMadeBy = reader.readInt(2);
        reader.skip(2);
        // this.versionNeeded = reader.readInt(2);
        this.bitFlag = reader.readInt(2);
        this.compressionMethod = reader.readString(2);
        this.date = reader.readDate();
        this.crc32 = reader.readInt(4);
        this.compressedSize = reader.readInt(4);
        this.uncompressedSize = reader.readInt(4);
        var fileNameLength = reader.readInt(2);
        this.extraFieldsLength = reader.readInt(2);
        this.fileCommentLength = reader.readInt(2);
        this.diskNumberStart = reader.readInt(2);
        this.internalFileAttributes = reader.readInt(2);
        this.externalFileAttributes = reader.readInt(4);
        this.localHeaderOffset = reader.readInt(4);

        if (this.isEncrypted()) {
            throw new Error("Encrypted zip are not supported");
        }

        // will be read in the local part, see the comments there
        reader.skip(fileNameLength);
        this.readExtraFields(reader);
        this.parseZIP64ExtraField(reader);
        this.fileComment = reader.readData(this.fileCommentLength);
    },

    /**
     * Parse the external file attributes and get the unix/dos permissions.
     */
    processAttributes: function () {
        this.unixPermissions = null;
        this.dosPermissions = null;
        var madeBy = this.versionMadeBy >> 8;

        // Check if we have the DOS directory flag set.
        // We look for it in the DOS and UNIX permissions
        // but some unknown platform could set it as a compatibility flag.
        this.dir = this.externalFileAttributes & 0x0010 ? true : false;

        if(madeBy === MADE_BY_DOS) {
            // first 6 bits (0 to 5)
            this.dosPermissions = this.externalFileAttributes & 0x3F;
        }

        if(madeBy === MADE_BY_UNIX) {
            this.unixPermissions = (this.externalFileAttributes >> 16) & 0xFFFF;
            // the octal permissions are in (this.unixPermissions & 0x01FF).toString(8);
        }

        // fail safe : if the name ends with a / it probably means a folder
        if (!this.dir && this.fileNameStr.slice(-1) === '/') {
            this.dir = true;
        }
    },

    /**
     * Parse the ZIP64 extra field and merge the info in the current ZipEntry.
     * @param {DataReader} reader the reader to use.
     */
    parseZIP64ExtraField: function(reader) {

        if (!this.extraFields[0x0001]) {
            return;
        }

        // should be something, preparing the extra reader
        var extraReader = readerFor(this.extraFields[0x0001].value);

        // I really hope that these 64bits integer can fit in 32 bits integer, because js
        // won't let us have more.
        if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {
            this.uncompressedSize = extraReader.readInt(8);
        }
        if (this.compressedSize === utils.MAX_VALUE_32BITS) {
            this.compressedSize = extraReader.readInt(8);
        }
        if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {
            this.localHeaderOffset = extraReader.readInt(8);
        }
        if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {
            this.diskNumberStart = extraReader.readInt(4);
        }
    },
    /**
     * Read the central part of a zip file and add the info in this object.
     * @param {DataReader} reader the reader to use.
     */
    readExtraFields: function(reader) {
        var end = reader.index + this.extraFieldsLength,
            extraFieldId,
            extraFieldLength,
            extraFieldValue;

        if (!this.extraFields) {
            this.extraFields = {};
        }

        while (reader.index + 4 < end) {
            extraFieldId = reader.readInt(2);
            extraFieldLength = reader.readInt(2);
            extraFieldValue = reader.readData(extraFieldLength);

            this.extraFields[extraFieldId] = {
                id: extraFieldId,
                length: extraFieldLength,
                value: extraFieldValue
            };
        }

        reader.setIndex(end);
    },
    /**
     * Apply an UTF8 transformation if needed.
     */
    handleUTF8: function() {
        var decodeParamType = support.uint8array ? "uint8array" : "array";
        if (this.useUTF8()) {
            this.fileNameStr = utf8.utf8decode(this.fileName);
            this.fileCommentStr = utf8.utf8decode(this.fileComment);
        } else {
            var upath = this.findExtraFieldUnicodePath();
            if (upath !== null) {
                this.fileNameStr = upath;
            } else {
                // ASCII text or unsupported code page
                var fileNameByteArray =  utils.transformTo(decodeParamType, this.fileName);
                this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
            }

            var ucomment = this.findExtraFieldUnicodeComment();
            if (ucomment !== null) {
                this.fileCommentStr = ucomment;
            } else {
                // ASCII text or unsupported code page
                var commentByteArray =  utils.transformTo(decodeParamType, this.fileComment);
                this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
            }
        }
    },

    /**
     * Find the unicode path declared in the extra field, if any.
     * @return {String} the unicode path, null otherwise.
     */
    findExtraFieldUnicodePath: function() {
        var upathField = this.extraFields[0x7075];
        if (upathField) {
            var extraReader = readerFor(upathField.value);

            // wrong version
            if (extraReader.readInt(1) !== 1) {
                return null;
            }

            // the crc of the filename changed, this field is out of date.
            if (crc32fn(this.fileName) !== extraReader.readInt(4)) {
                return null;
            }

            return utf8.utf8decode(extraReader.readData(upathField.length - 5));
        }
        return null;
    },

    /**
     * Find the unicode comment declared in the extra field, if any.
     * @return {String} the unicode comment, null otherwise.
     */
    findExtraFieldUnicodeComment: function() {
        var ucommentField = this.extraFields[0x6375];
        if (ucommentField) {
            var extraReader = readerFor(ucommentField.value);

            // wrong version
            if (extraReader.readInt(1) !== 1) {
                return null;
            }

            // the crc of the comment changed, this field is out of date.
            if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {
                return null;
            }

            return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));
        }
        return null;
    }
};
module.exports = ZipEntry;

},{"./compressedObject":13,"./compressions":14,"./crc32":15,"./reader/readerFor":33,"./support":41,"./utf8":42,"./utils":43}],46:[function(require,module,exports){
'use strict';

var StreamHelper = require('./stream/StreamHelper');
var DataWorker = require('./stream/DataWorker');
var utf8 = require('./utf8');
var CompressedObject = require('./compressedObject');
var GenericWorker = require('./stream/GenericWorker');

/**
 * A simple object representing a file in the zip file.
 * @constructor
 * @param {string} name the name of the file
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data
 * @param {Object} options the options of the file
 */
var ZipObject = function(name, data, options) {
    this.name = name;
    this.dir = options.dir;
    this.date = options.date;
    this.comment = options.comment;
    this.unixPermissions = options.unixPermissions;
    this.dosPermissions = options.dosPermissions;

    this._data = data;
    this._dataBinary = options.binary;
    // keep only the compression
    this.options = {
        compression : options.compression,
        compressionOptions : options.compressionOptions
    };
};

ZipObject.prototype = {
    /**
     * Create an internal stream for the content of this object.
     * @param {String} type the type of each chunk.
     * @return StreamHelper the stream.
     */
    internalStream: function (type) {
        var result = null, outputType = "string";
        try {
            if (!type) {
                throw new Error("No output type specified.");
            }
            outputType = type.toLowerCase();
            var askUnicodeString = outputType === "string" || outputType === "text";
            if (outputType === "binarystring" || outputType === "text") {
                outputType = "string";
            }
            result = this._decompressWorker();

            var isUnicodeString = !this._dataBinary;

            if (isUnicodeString && !askUnicodeString) {
                result = result.pipe(new utf8.Utf8EncodeWorker());
            }
            if (!isUnicodeString && askUnicodeString) {
                result = result.pipe(new utf8.Utf8DecodeWorker());
            }
        } catch (e) {
            result = new GenericWorker("error");
            result.error(e);
        }

        return new StreamHelper(result, outputType, "");
    },

    /**
     * Prepare the content in the asked type.
     * @param {String} type the type of the result.
     * @param {Function} onUpdate a function to call on each internal update.
     * @return Promise the promise of the result.
     */
    async: function (type, onUpdate) {
        return this.internalStream(type).accumulate(onUpdate);
    },

    /**
     * Prepare the content as a nodejs stream.
     * @param {String} type the type of each chunk.
     * @param {Function} onUpdate a function to call on each internal update.
     * @return Stream the stream.
     */
    nodeStream: function (type, onUpdate) {
        return this.internalStream(type || "nodebuffer").toNodejsStream(onUpdate);
    },

    /**
     * Return a worker for the compressed content.
     * @private
     * @param {Object} compression the compression object to use.
     * @param {Object} compressionOptions the options to use when compressing.
     * @return Worker the worker.
     */
    _compressWorker: function (compression, compressionOptions) {
        if (
            this._data instanceof CompressedObject &&
            this._data.compression.magic === compression.magic
        ) {
            return this._data.getCompressedWorker();
        } else {
            var result = this._decompressWorker();
            if(!this._dataBinary) {
                result = result.pipe(new utf8.Utf8EncodeWorker());
            }
            return CompressedObject.createWorkerFrom(result, compression, compressionOptions);
        }
    },
    /**
     * Return a worker for the decompressed content.
     * @private
     * @return Worker the worker.
     */
    _decompressWorker : function () {
        if (this._data instanceof CompressedObject) {
            return this._data.getContentWorker();
        } else if (this._data instanceof GenericWorker) {
            return this._data;
        } else {
            return new DataWorker(this._data);
        }
    }
};

var removedMethods = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"];
var removedFn = function () {
    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
};

for(var i = 0; i < removedMethods.length; i++) {
    ZipObject.prototype[removedMethods[i]] = removedFn;
}
module.exports = ZipObject;

},{"./compressedObject":13,"./stream/DataWorker":38,"./stream/GenericWorker":39,"./stream/StreamHelper":40,"./utf8":42}],47:[function(require,module,exports){
'use strict';
var immediate = require('immediate');

/* istanbul ignore next */
function INTERNAL() {}

var handlers = {};

var REJECTED = ['REJECTED'];
var FULFILLED = ['FULFILLED'];
var PENDING = ['PENDING'];

module.exports = Promise;

function Promise(resolver) {
  if (typeof resolver !== 'function') {
    throw new TypeError('resolver must be a function');
  }
  this.state = PENDING;
  this.queue = [];
  this.outcome = void 0;
  if (resolver !== INTERNAL) {
    safelyResolveThenable(this, resolver);
  }
}

Promise.prototype["finally"] = function (callback) {
  if (typeof callback !== 'function') {
    return this;
  }
  var p = this.constructor;
  return this.then(resolve, reject);

  function resolve(value) {
    function yes () {
      return value;
    }
    return p.resolve(callback()).then(yes);
  }
  function reject(reason) {
    function no () {
      throw reason;
    }
    return p.resolve(callback()).then(no);
  }
};
Promise.prototype["catch"] = function (onRejected) {
  return this.then(null, onRejected);
};
Promise.prototype.then = function (onFulfilled, onRejected) {
  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||
    typeof onRejected !== 'function' && this.state === REJECTED) {
    return this;
  }
  var promise = new this.constructor(INTERNAL);
  if (this.state !== PENDING) {
    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
    unwrap(promise, resolver, this.outcome);
  } else {
    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
  }

  return promise;
};
function QueueItem(promise, onFulfilled, onRejected) {
  this.promise = promise;
  if (typeof onFulfilled === 'function') {
    this.onFulfilled = onFulfilled;
    this.callFulfilled = this.otherCallFulfilled;
  }
  if (typeof onRejected === 'function') {
    this.onRejected = onRejected;
    this.callRejected = this.otherCallRejected;
  }
}
QueueItem.prototype.callFulfilled = function (value) {
  handlers.resolve(this.promise, value);
};
QueueItem.prototype.otherCallFulfilled = function (value) {
  unwrap(this.promise, this.onFulfilled, value);
};
QueueItem.prototype.callRejected = function (value) {
  handlers.reject(this.promise, value);
};
QueueItem.prototype.otherCallRejected = function (value) {
  unwrap(this.promise, this.onRejected, value);
};

function unwrap(promise, func, value) {
  immediate(function () {
    var returnValue;
    try {
      returnValue = func(value);
    } catch (e) {
      return handlers.reject(promise, e);
    }
    if (returnValue === promise) {
      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));
    } else {
      handlers.resolve(promise, returnValue);
    }
  });
}

handlers.resolve = function (self, value) {
  var result = tryCatch(getThen, value);
  if (result.status === 'error') {
    return handlers.reject(self, result.value);
  }
  var thenable = result.value;

  if (thenable) {
    safelyResolveThenable(self, thenable);
  } else {
    self.state = FULFILLED;
    self.outcome = value;
    var i = -1;
    var len = self.queue.length;
    while (++i < len) {
      self.queue[i].callFulfilled(value);
    }
  }
  return self;
};
handlers.reject = function (self, error) {
  self.state = REJECTED;
  self.outcome = error;
  var i = -1;
  var len = self.queue.length;
  while (++i < len) {
    self.queue[i].callRejected(error);
  }
  return self;
};

function getThen(obj) {
  // Make sure we only access the accessor once as required by the spec
  var then = obj && obj.then;
  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {
    return function appyThen() {
      then.apply(obj, arguments);
    };
  }
}

function safelyResolveThenable(self, thenable) {
  // Either fulfill, reject or reject with error
  var called = false;
  function onError(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.reject(self, value);
  }

  function onSuccess(value) {
    if (called) {
      return;
    }
    called = true;
    handlers.resolve(self, value);
  }

  function tryToUnwrap() {
    thenable(onSuccess, onError);
  }

  var result = tryCatch(tryToUnwrap);
  if (result.status === 'error') {
    onError(result.value);
  }
}

function tryCatch(func, value) {
  var out = {};
  try {
    out.value = func(value);
    out.status = 'success';
  } catch (e) {
    out.status = 'error';
    out.value = e;
  }
  return out;
}

Promise.resolve = resolve;
function resolve(value) {
  if (value instanceof this) {
    return value;
  }
  return handlers.resolve(new this(INTERNAL), value);
}

Promise.reject = reject;
function reject(reason) {
  var promise = new this(INTERNAL);
  return handlers.reject(promise, reason);
}

Promise.all = all;
function all(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var values = new Array(len);
  var resolved = 0;
  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    allResolver(iterable[i], i);
  }
  return promise;
  function allResolver(value, i) {
    self.resolve(value).then(resolveFromAll, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
    function resolveFromAll(outValue) {
      values[i] = outValue;
      if (++resolved === len && !called) {
        called = true;
        handlers.resolve(promise, values);
      }
    }
  }
}

Promise.race = race;
function race(iterable) {
  var self = this;
  if (Object.prototype.toString.call(iterable) !== '[object Array]') {
    return this.reject(new TypeError('must be an array'));
  }

  var len = iterable.length;
  var called = false;
  if (!len) {
    return this.resolve([]);
  }

  var i = -1;
  var promise = new this(INTERNAL);

  while (++i < len) {
    resolver(iterable[i]);
  }
  return promise;
  function resolver(value) {
    self.resolve(value).then(function (response) {
      if (!called) {
        called = true;
        handlers.resolve(promise, response);
      }
    }, function (error) {
      if (!called) {
        called = true;
        handlers.reject(promise, error);
      }
    });
  }
}

},{"immediate":8}],48:[function(require,module,exports){
// Top level file is just a mixin of submodules & constants
'use strict';

var assign    = require('./lib/utils/common').assign;

var deflate   = require('./lib/deflate');
var inflate   = require('./lib/inflate');
var constants = require('./lib/zlib/constants');

var pako = {};

assign(pako, deflate, inflate, constants);

module.exports = pako;

},{"./lib/deflate":49,"./lib/inflate":50,"./lib/utils/common":51,"./lib/zlib/constants":54}],49:[function(require,module,exports){
'use strict';


var zlib_deflate = require('./zlib/deflate');
var utils        = require('./utils/common');
var strings      = require('./utils/strings');
var msg          = require('./zlib/messages');
var ZStream      = require('./zlib/zstream');

var toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

var Z_NO_FLUSH      = 0;
var Z_FINISH        = 4;

var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_SYNC_FLUSH    = 2;

var Z_DEFAULT_COMPRESSION = -1;

var Z_DEFAULT_STRATEGY    = 0;

var Z_DEFLATED  = 8;

/* ===========================================================================*/


/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overridden.
 **/

/**
 * Deflate.result -> Uint8Array|Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
 * push a chunk with explicit flush (call [[Deflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/


/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate(options) {
  if (!(this instanceof Deflate)) return new Deflate(options);

  this.options = utils.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY,
    to: ''
  }, options || {});

  var opt = this.options;

  if (opt.raw && (opt.windowBits > 0)) {
    opt.windowBits = -opt.windowBits;
  }

  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
    opt.windowBits += 16;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;

  var status = zlib_deflate.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }

  if (opt.header) {
    zlib_deflate.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    var dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = zlib_deflate.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the compression context.
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * array format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var status, _mode;

  if (this.ended) { return false; }

  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */

    if (status !== Z_STREAM_END && status !== Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {
      if (this.options.to === 'string') {
        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
      } else {
        this.onData(utils.shrinkBuf(strm.output, strm.next_out));
      }
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);

  // Finalize on the last chunk.
  if (_mode === Z_FINISH) {
    status = zlib_deflate.deflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === Z_SYNC_FLUSH) {
    this.onEnd(Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): output data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * deflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate(input, options) {
  var deflator = new Deflate(options);

  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }

  return deflator.result;
}


/**
 * deflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return deflate(input, options);
}


/**
 * gzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate(input, options);
}


exports.Deflate = Deflate;
exports.deflate = deflate;
exports.deflateRaw = deflateRaw;
exports.gzip = gzip;

},{"./utils/common":51,"./utils/strings":52,"./zlib/deflate":56,"./zlib/messages":61,"./zlib/zstream":63}],50:[function(require,module,exports){
'use strict';


var zlib_inflate = require('./zlib/inflate');
var utils        = require('./utils/common');
var strings      = require('./utils/strings');
var c            = require('./zlib/constants');
var msg          = require('./zlib/messages');
var ZStream      = require('./zlib/zstream');
var GZheader     = require('./zlib/gzheader');

var toString = Object.prototype.toString;

/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overridden.
 **/

/**
 * Inflate.result -> Uint8Array|Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
 * push a chunk with explicit flush (call [[Inflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate(options) {
  if (!(this instanceof Inflate)) return new Inflate(options);

  this.options = utils.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ''
  }, options || {});

  var opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new ZStream();
  this.strm.avail_out = 0;

  var status  = zlib_inflate.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== c.Z_OK) {
    throw new Error(msg[status]);
  }

  this.header = new GZheader();

  zlib_inflate.inflateGetHeader(this.strm, this.header);

  // Setup dictionary
  if (opt.dictionary) {
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) { //In raw mode we need to set the dictionary early
      status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== c.Z_OK) {
        throw new Error(msg[status]);
      }
    }
  }
}

/**
 * Inflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the decompression context.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary = this.options.dictionary;
  var status, _mode;
  var next_out_utf8, tail, utf8str;

  // Flag to properly process Z_BUF_ERROR on testing inflate call
  // when we check that all output data was flushed.
  var allowBufError = false;

  if (this.ended) { return false; }
  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // Only binary strings can be decompressed on practice
    strm.input = strings.binstring2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */

    if (status === c.Z_NEED_DICT && dictionary) {
      status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
    }

    if (status === c.Z_BUF_ERROR && allowBufError === true) {
      status = c.Z_OK;
      allowBufError = false;
    }

    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {

        if (this.options.to === 'string') {

          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          tail = strm.next_out - next_out_utf8;
          utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }

          this.onData(utf8str);

        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    }

    // When no more input data, we should check that internal inflate buffers
    // are flushed. The only way to do it when avail_out = 0 - run one more
    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
    // Here we set flag to process this error properly.
    //
    // NOTE. Deflate does not return error in this case and does not needs such
    // logic.
    if (strm.avail_in === 0 && strm.avail_out === 0) {
      allowBufError = true;
    }

  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);

  if (status === c.Z_STREAM_END) {
    _mode = c.Z_FINISH;
  }

  // Finalize on the last chunk.
  if (_mode === c.Z_FINISH) {
    status = zlib_inflate.inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === c.Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === c.Z_SYNC_FLUSH) {
    this.onEnd(c.Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): output data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === c.Z_OK) {
    if (this.options.to === 'string') {
      // Glue & convert here, until we teach pako to send
      // utf8 aligned strings to onData
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
 *   , output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err)
 *   console.log(err);
 * }
 * ```
 **/
function inflate(input, options) {
  var inflator = new Inflate(options);

  inflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


exports.Inflate = Inflate;
exports.inflate = inflate;
exports.inflateRaw = inflateRaw;
exports.ungzip  = inflate;

},{"./utils/common":51,"./utils/strings":52,"./zlib/constants":54,"./zlib/gzheader":57,"./zlib/inflate":59,"./zlib/messages":61,"./zlib/zstream":63}],51:[function(require,module,exports){
'use strict';


var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
                (typeof Uint16Array !== 'undefined') &&
                (typeof Int32Array !== 'undefined');

function _has(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

exports.assign = function (obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    var source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// reduce buffer size, avoiding mem copy
exports.shrinkBuf = function (buf, size) {
  if (buf.length === size) { return buf; }
  if (buf.subarray) { return buf.subarray(0, size); }
  buf.length = size;
  return buf;
};


var fnTyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    }
    // Fallback to ordinary array
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    var i, l, len, pos, chunk, result;

    // calculate data length
    len = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }

    // join chunks
    result = new Uint8Array(len);
    pos = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }
};

var fnUntyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    return [].concat.apply([], chunks);
  }
};


// Enable/Disable typed arrays use, for testing
//
exports.setTyped = function (on) {
  if (on) {
    exports.Buf8  = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } else {
    exports.Buf8  = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.setTyped(TYPED_OK);

},{}],52:[function(require,module,exports){
// String encode/decode helpers
'use strict';


var utils = require('./common');


// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safari
//
var STR_APPLY_OK = true;
var STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }
try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new utils.Buf8(256);
for (var q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
exports.string2buf = function (str) {
  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new utils.Buf8(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper (used in 2 places)
function buf2binstring(buf, len) {
  // On Chrome, the arguments in a function call that are allowed is `65534`.
  // If the length of the buffer is smaller than that, we can use this optimization,
  // otherwise we will take a slower path.
  if (len < 65534) {
    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
    }
  }

  var result = '';
  for (var i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}


// Convert byte array to binary string
exports.buf2binstring = function (buf) {
  return buf2binstring(buf, buf.length);
};


// Convert binary string (typed, when possible)
exports.binstring2buf = function (str) {
  var buf = new utils.Buf8(str.length);
  for (var i = 0, len = buf.length; i < len; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
};


// convert array to string
exports.buf2string = function (buf, max) {
  var i, out, c, c_len;
  var len = max || buf.length;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  var utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
exports.utf8border = function (buf, max) {
  var pos;

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means buffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};

},{"./common":51}],53:[function(require,module,exports){
'use strict';

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function adler32(adler, buf, len, pos) {
  var s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
}


module.exports = adler32;

},{}],54:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};

},{}],55:[function(require,module,exports){
'use strict';

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here
function makeTable() {
  var c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();


function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;

  crc ^= -1;

  for (var i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
}


module.exports = crc32;

},{}],56:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils   = require('../utils/common');
var trees   = require('./trees');
var adler32 = require('./adler32');
var crc32   = require('./crc32');
var msg     = require('./messages');

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
var Z_NO_FLUSH      = 0;
var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
//var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
//var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
//var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;


/* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;
var Z_DEFAULT_COMPRESSION = -1;


var Z_FILTERED            = 1;
var Z_HUFFMAN_ONLY        = 2;
var Z_RLE                 = 3;
var Z_FIXED               = 4;
var Z_DEFAULT_STRATEGY    = 0;

/* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;


/* The deflate compression method */
var Z_DEFLATED  = 8;

/*============================================================================*/


var MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_MEM_LEVEL = 8;


var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
var LITERALS      = 256;
/* number of literal bytes 0..255 */
var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
var D_CODES       = 30;
/* number of distance codes */
var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */
var MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

var PRESET_DICT = 0x20;

var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;

var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
var BS_BLOCK_DONE     = 2; /* block flush performed */
var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}

function rank(f) {
  return ((f) << 1) - ((f) > 4 ? 9 : 0);
}

function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }


/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
function flush_pending(strm) {
  var s = strm.state;

  //_tr_flush_bits(s);
  var len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}


function flush_block_only(s, last) {
  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}


function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
function putShortMSB(s, b) {
//  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
}


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  utils.arraySet(buf, strm.input, strm.next_in, len, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
}


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;      /* max hash chain length */
  var scan = s.strstart; /* current string */
  var match;                       /* matched string */
  var len;                           /* length of current match */
  var best_len = s.prev_length;              /* best match length so far */
  var nice_match = s.nice_match;             /* stop if match long enough */
  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  var _win = s.window; // shortcut

  var wmask = s.w_mask;
  var prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  var strend = s.strstart + MAX_MATCH;
  var scan_end1  = _win[scan + best_len - 1];
  var scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = (m >= _w_size ? m - _w_size : 0);
      } while (--n);

      n = _w_size;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    var curr = s.strstart + s.lookahead;
//    var init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
function deflate_stored(s, flush) {
  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  var max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
//        s.block_start >= s.w_size)) {
//        throw  new Error("slide too late");
//      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
//    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    var max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/


    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
function deflate_fast(s, flush) {
  var hash_head;        /* head of the hash chain */
  var bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
function deflate_slow(s, flush) {
  var hash_head;          /* head of hash chain */
  var bflush;              /* set if current block must be flushed */

  var max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
}


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
function deflate_rle(s, flush) {
  var bflush;            /* set if current block must be flushed */
  var prev;              /* byte at distance one to match */
  var scan, strend;      /* scan goes up to strend for length of run */

  var _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
function deflate_huff(s, flush) {
  var bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

var configuration_table;

configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
function lm_init(s) {
  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new utils.Buf16(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;          /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;      /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


function deflateResetKeep(strm) {
  var s;

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH;
  trees._tr_init(s);
  return Z_OK;
}


function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
}


function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
  strm.state.gzhead = head;
  return Z_OK;
}


function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR;
  }
  var wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  var s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new utils.Buf8(s.w_size * 2);
  s.head = new utils.Buf16(s.hash_size);
  s.prev = new utils.Buf16(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;

  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;
  s.pending_buf = new utils.Buf8(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
  s.d_buf = 1 * s.lit_bufsize;

  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
}

function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}


function deflate(strm, flush) {
  var old_flush, s;
  var beg, val; // for gzip header write only

  if (!strm || !strm.state ||
    flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  s = strm.state;

  if (!strm.output ||
      (!strm.input && strm.avail_in !== 0) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm; /* just in case */
  old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) { // GZIP header
      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) { // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      }
      else {
        put_byte(s, (s.gzhead.text ? 1 : 0) +
                    (s.gzhead.hcrc ? 2 : 0) +
                    (!s.gzhead.extra ? 0 : 4) +
                    (!s.gzhead.name ? 0 : 8) +
                    (!s.gzhead.comment ? 0 : 16)
        );
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, (s.gzhead.time >> 8) & 0xff);
        put_byte(s, (s.gzhead.time >> 16) & 0xff);
        put_byte(s, (s.gzhead.time >> 24) & 0xff);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    else // DEFLATE header
    {
      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
      var level_flags = -1;

      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= (level_flags << 6);
      if (s.strstart !== 0) { header |= PRESET_DICT; }
      header += 31 - (header % 31);

      s.status = BUSY_STATE;
      putShortMSB(s, header);

      /* Save the adler32 of the preset dictionary: */
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      strm.adler = 1; // adler32(0L, Z_NULL, 0);
    }
  }

//#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */

      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    }
    else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    }
    else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    }
    else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    }
    else {
      s.status = BUSY_STATE;
    }
  }
//#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
        configuration_table[s.level].func(s, flush));

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      }
      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

        trees._tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH) { return Z_OK; }
  if (s.wrap <= 0) { return Z_STREAM_END; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}

function deflateEnd(strm) {
  var status;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  status = strm.state.status;
  if (status !== INIT_STATE &&
    status !== EXTRA_STATE &&
    status !== NAME_STATE &&
    status !== COMMENT_STATE &&
    status !== HCRC_STATE &&
    status !== BUSY_STATE &&
    status !== FINISH_STATE
  ) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var s;
  var str, n;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  s = strm.state;
  wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    tmpDict = new utils.Buf8(s.w_size);
    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
}


exports.deflateInit = deflateInit;
exports.deflateInit2 = deflateInit2;
exports.deflateReset = deflateReset;
exports.deflateResetKeep = deflateResetKeep;
exports.deflateSetHeader = deflateSetHeader;
exports.deflate = deflate;
exports.deflateEnd = deflateEnd;
exports.deflateSetDictionary = deflateSetDictionary;
exports.deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/

},{"../utils/common":51,"./adler32":53,"./crc32":55,"./messages":61,"./trees":62}],57:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

module.exports = GZheader;

},{}],58:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js
var BAD = 30;       /* got a data error -- remain here until reset */
var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
module.exports = function inflate_fast(strm, start) {
  var state;
  var _in;                    /* local strm.input */
  var last;                   /* have enough input while in < last */
  var _out;                   /* local strm.output */
  var beg;                    /* inflate()'s initial strm.output */
  var end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  var dmax;                   /* maximum distance from zlib header */
//#endif
  var wsize;                  /* window size or zero if not using window */
  var whave;                  /* valid bytes in the window */
  var wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  var s_window;               /* allocated sliding window, if wsize != 0 */
  var hold;                   /* local strm.hold */
  var bits;                   /* local strm.bits */
  var lcode;                  /* local strm.lencode */
  var dcode;                  /* local strm.distcode */
  var lmask;                  /* mask for first level of length codes */
  var dmask;                  /* mask for first level of distance codes */
  var here;                   /* retrieved table entry */
  var op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  var len;                    /* match length, unused bytes */
  var dist;                   /* match distance */
  var from;                   /* where to copy match from */
  var from_source;


  var input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};

},{}],59:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils         = require('../utils/common');
var adler32       = require('./adler32');
var crc32         = require('./crc32');
var inflate_fast  = require('./inffast');
var inflate_table = require('./inftrees');

var CODES = 0;
var LENS = 1;
var DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;

/* The deflate compression method */
var Z_DEFLATED  = 8;


/* STATES ====================================================================*/
/* ===========================================================================*/


var    HEAD = 1;       /* i: waiting for magic header */
var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
var    TIME = 3;       /* i: waiting for modification time (gzip) */
var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
var    NAME = 7;       /* i: waiting for end of file name (gzip) */
var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
var    HCRC = 9;       /* i: waiting for header crc (gzip) */
var    DICTID = 10;    /* i: waiting for dictionary check value */
var    DICT = 11;      /* waiting for inflateSetDictionary() call */
var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
var        STORED = 14;    /* i: waiting for stored size (length and complement) */
var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
var        LENLENS = 18;   /* i: waiting for code length code lengths */
var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
var            LEN = 21;       /* i: waiting for length/lit/eob code */
var            LENEXT = 22;    /* i: waiting for length extra bits */
var            DIST = 23;      /* i: waiting for distance code */
var            DISTEXT = 24;   /* i: waiting for distance extra bits */
var            MATCH = 25;     /* o: waiting for output space to copy string */
var            LIT = 26;       /* o: waiting for output space to write literal */
var    CHECK = 27;     /* i: waiting for 32-bit check value */
var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
var    DONE = 29;      /* finished check, done -- remain here until reset */
var    BAD = 30;       /* got a data error -- remain here until reset */
var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_WBITS = MAX_WBITS;


function zswap32(q) {
  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
}


function InflateState() {
  this.mode = 0;             /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
  this.work = new utils.Buf16(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}

function inflateResetKeep(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
}

function inflateReset(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

}

function inflateReset2(strm, windowBits) {
  var wrap;
  var state;

  /* get the state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}

function inflateInit2(strm, windowBits) {
  var ret;
  var state;

  if (!strm) { return Z_STREAM_ERROR; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null/*Z_NULL*/;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
}

function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
var virgin = true;

var lenfix, distfix; // We have no pointers in JS, so keep tables separate

function fixedtables(state) {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    var sym;

    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);

    /* literal/length table */
    sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new utils.Buf8(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      utils.arraySet(state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
}

function inflate(strm, flush) {
  var state;
  var input, output;          // input/output buffers
  var next;                   /* next input INDEX */
  var put;                    /* next output INDEX */
  var have, left;             /* available input and output */
  var hold;                   /* bit buffer */
  var bits;                   /* bits in bit buffer */
  var _in, _out;              /* save starting available input and output */
  var copy;                   /* number of stored or match bytes to copy */
  var from;                   /* where to copy match bytes from */
  var from_source;
  var here = 0;               /* current decoding table entry */
  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //var last;                   /* parent table entry */
  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  var len;                    /* length to copy for repeats, bits to drop */
  var ret;                    /* return code */
  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
  var opts;

  var n; // temporary var for NEED_BITS

  var order = /* permutation of code lengths */
    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];


  if (!strm || !strm.state || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        }
        //=== NEEDBITS(16);
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
          state.check = 0/*crc32(0L, Z_NULL, 0)*/;
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//

          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = FLAGS;
          break;
        }
        state.flags = 0;           /* expect zlib header */
        if (state.head) {
          state.head.done = false;
        }
        if (!(state.wrap & 1) ||   /* check if zlib header allowed */
          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD;
          break;
        }
        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        len = (hold & 0x0f)/*BITS(4)*/ + 8;
        if (state.wbits === 0) {
          state.wbits = len;
        }
        else if (len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD;
          break;
        }
        state.dmax = 1 << len;
        //Tracev((stderr, "inflate:   zlib header ok\n"));
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = hold & 0x200 ? DICTID : TYPE;
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        break;
      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.flags = hold;
        if ((state.flags & 0xff) !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD;
          break;
        }
        if (state.head) {
          state.head.text = ((hold >> 8) & 1);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = TIME;
        /* falls through */
      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.time = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          hbuf[2] = (hold >>> 16) & 0xff;
          hbuf[3] = (hold >>> 24) & 0xff;
          state.check = crc32(state.check, hbuf, 4, 0);
          //===
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = OS;
        /* falls through */
      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.xflags = (hold & 0xff);
          state.head.os = (hold >> 8);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = EXLEN;
        /* falls through */
      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length = hold;
          if (state.head) {
            state.head.extra_len = hold;
          }
          if (state.flags & 0x0200) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            state.check = crc32(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        else if (state.head) {
          state.head.extra = null/*Z_NULL*/;
        }
        state.mode = EXTRA;
        /* falls through */
      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;
          if (copy > have) { copy = have; }
          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;
              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Array(state.head.extra_len);
              }
              utils.arraySet(
                state.head.extra,
                input,
                next,
                // extra field is limited to 65536 bytes
                // - no need for additional size check
                copy,
                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                len
              );
              //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }
            if (state.flags & 0x0200) {
              state.check = crc32(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            state.length -= copy;
          }
          if (state.length) { break inf_leave; }
        }
        state.length = 0;
        state.mode = NAME;
        /* falls through */
      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.name_max*/)) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.name = null;
        }
        state.length = 0;
        state.mode = COMMENT;
        /* falls through */
      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.comm_max*/)) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);
          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.comment = null;
        }
        state.mode = HCRC;
        /* falls through */
      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        if (state.head) {
          state.head.hcrc = ((state.flags >> 9) & 1);
          state.head.done = true;
        }
        strm.adler = state.check = 0;
        state.mode = TYPE;
        break;
      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        strm.adler = state.check = zswap32(hold);
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = DICT;
        /* falls through */
      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          return Z_NEED_DICT;
        }
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = TYPE;
        /* falls through */
      case TYPE:
        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7;
          //---//
          state.mode = CHECK;
          break;
        }
        //=== NEEDBITS(3); */
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.last = (hold & 0x01)/*BITS(1)*/;
        //--- DROPBITS(1) ---//
        hold >>>= 1;
        bits -= 1;
        //---//

        switch ((hold & 0x03)/*BITS(2)*/) {
          case 0:                             /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED;
            break;
          case 1:                             /* fixed block */
            fixedtables(state);
            //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = LEN_;             /* decode codes */
            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
              break inf_leave;
            }
            break;
          case 2:                             /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE;
            break;
          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD;
        }
        //--- DROPBITS(2) ---//
        hold >>>= 2;
        bits -= 2;
        //---//
        break;
      case STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD;
          break;
        }
        state.length = hold & 0xffff;
        //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = COPY_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case COPY_:
        state.mode = COPY;
        /* falls through */
      case COPY:
        copy = state.length;
        if (copy) {
          if (copy > have) { copy = have; }
          if (copy > left) { copy = left; }
          if (copy === 0) { break inf_leave; }
          //--- zmemcpy(put, next, copy); ---
          utils.arraySet(output, input, next, copy, put);
          //---//
          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        }
        //Tracev((stderr, "inflate:       stored end\n"));
        state.mode = TYPE;
        break;
      case TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
//#ifndef PKZIP_BUG_WORKAROUND
        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));
        state.have = 0;
        state.mode = LENLENS;
        /* falls through */
      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
          //--- DROPBITS(3) ---//
          hold >>>= 3;
          bits -= 3;
          //---//
        }
        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        }
        // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table
        state.lencode = state.lendyn;
        state.lenbits = 7;

        opts = { bits: state.lenbits };
        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;

        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, "inflate:       code lengths ok\n"));
        state.have = 0;
        state.mode = CODELENS;
        /* falls through */
      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.lens[state.have++] = here_val;
          }
          else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }
              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03);//BITS(2);
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
            }
            else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 3 + (hold & 0x07);//BITS(3);
              //--- DROPBITS(3) ---//
              hold >>>= 3;
              bits -= 3;
              //---//
            }
            else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 11 + (hold & 0x7f);//BITS(7);
              //--- DROPBITS(7) ---//
              hold >>>= 7;
              bits -= 7;
              //---//
            }
            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }

        /* handle error breaks in while */
        if (state.mode === BAD) { break; }

        /* check for end-of-block code (better have one) */
        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD;
          break;
        }

        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */
        state.lenbits = 9;

        opts = { bits: state.lenbits };
        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.lenbits = opts.bits;
        // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD;
          break;
        }

        state.distbits = 6;
        //state.distcode.copy(state.codes);
        // Switch to use dynamic table
        state.distcode = state.distdyn;
        opts = { bits: state.distbits };
        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.distbits = opts.bits;
        // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, 'inflate:       codes ok\n'));
        state.mode = LEN_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case LEN_:
        state.mode = LEN;
        /* falls through */
      case LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          inflate_fast(strm, _out);
          //--- LOAD() ---
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          //---

          if (state.mode === TYPE) {
            state.back = -1;
          }
          break;
        }
        state.back = 0;
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.lencode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        state.length = here_val;
        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT;
          break;
        }
        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE;
          break;
        }
        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break;
        }
        state.extra = here_op & 15;
        state.mode = LENEXT;
        /* falls through */
      case LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //Tracevv((stderr, "inflate:         length %u\n", state.length));
        state.was = state.length;
        state.mode = DIST;
        /* falls through */
      case DIST:
        for (;;) {
          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.distcode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD;
          break;
        }
        state.offset = here_val;
        state.extra = (here_op) & 15;
        state.mode = DISTEXT;
        /* falls through */
      case DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
//#ifdef INFLATE_STRICT
        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
        state.mode = MATCH;
        /* falls through */
      case MATCH:
        if (left === 0) { break inf_leave; }
        copy = _out - left;
        if (state.offset > copy) {         /* copy from window */
          copy = state.offset - copy;
          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            }
// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
          }
          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          }
          else {
            from = state.wnext - copy;
          }
          if (copy > state.length) { copy = state.length; }
          from_source = state.window;
        }
        else {                              /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }
        if (copy > left) { copy = left; }
        left -= copy;
        state.length -= copy;
        do {
          output[put++] = from_source[from++];
        } while (--copy);
        if (state.length === 0) { state.mode = LEN; }
        break;
      case LIT:
        if (left === 0) { break inf_leave; }
        output[put++] = state.length;
        left--;
        state.mode = LEN;
        break;
      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            // Use '|' instead of '+' to make sure that result is signed
            hold |= input[next++] << bits;
            bits += 8;
          }
          //===//
          _out -= left;
          strm.total_out += _out;
          state.total += _out;
          if (_out) {
            strm.adler = state.check =
                /*UPDATE(state.check, put - _out, _out);*/
                (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

          }
          _out = left;
          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
          if ((state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }
        state.mode = LENGTH;
        /* falls through */
      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }
        state.mode = DONE;
        /* falls through */
      case DONE:
        ret = Z_STREAM_END;
        break inf_leave;
      case BAD:
        ret = Z_DATA_ERROR;
        break inf_leave;
      case MEM:
        return Z_MEM_ERROR;
      case SYNC:
        /* falls through */
      default:
        return Z_STREAM_ERROR;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}

function inflateEnd(strm) {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
    return Z_STREAM_ERROR;
  }

  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
}

function inflateGetHeader(strm, head) {
  var state;

  /* check state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK;
}

function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var state;
  var dictid;
  var ret;

  /* check state */
  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK;
}

exports.inflateReset = inflateReset;
exports.inflateReset2 = inflateReset2;
exports.inflateResetKeep = inflateResetKeep;
exports.inflateInit = inflateInit;
exports.inflateInit2 = inflateInit2;
exports.inflate = inflate;
exports.inflateEnd = inflateEnd;
exports.inflateGetHeader = inflateGetHeader;
exports.inflateSetDictionary = inflateSetDictionary;
exports.inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/

},{"../utils/common":51,"./adler32":53,"./crc32":55,"./inffast":58,"./inftrees":60}],60:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = require('../utils/common');

var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

var CODES = 0;
var LENS = 1;
var DISTS = 2;

var lbase = [ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
];

var lext = [ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
];

var dbase = [ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
];

var dext = [ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
];

module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
{
  var bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  var len = 0;               /* a code's length in bits */
  var sym = 0;               /* index of code symbols */
  var min = 0, max = 0;          /* minimum and maximum code lengths */
  var root = 0;              /* number of index bits for root table */
  var curr = 0;              /* number of index bits for current table */
  var drop = 0;              /* code bits to drop for sub-table */
  var left = 0;                   /* number of prefix codes available */
  var used = 0;              /* code entries in table used */
  var huff = 0;              /* Huffman code */
  var incr;              /* for incrementing code, index */
  var fill;              /* index for replicating entries */
  var low;               /* low bits for current root entry */
  var mask;              /* mask for low root bits */
  var next;             /* next available space in table */
  var base = null;     /* base value table to use */
  var base_index = 0;
//  var shoextra;    /* extra bits table to use */
  var end;                    /* use base and extra for symbol > end */
  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  var extra = null;
  var extra_index = 0;

  var here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES) {
    base = extra = work;    /* dummy value--not used */
    end = 19;

  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS && used > ENOUGH_LENS) ||
    (type === DISTS && used > ENOUGH_DISTS)) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS && used > ENOUGH_LENS) ||
        (type === DISTS && used > ENOUGH_DISTS)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};

},{"../utils/common":51}],61:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};

},{}],62:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

/* eslint-disable space-unary-ops */

var utils = require('../utils/common');

/* Public constants ==========================================================*/
/* ===========================================================================*/


//var Z_FILTERED          = 1;
//var Z_HUFFMAN_ONLY      = 2;
//var Z_RLE               = 3;
var Z_FIXED               = 4;
//var Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
var Z_BINARY              = 0;
var Z_TEXT                = 1;
//var Z_ASCII             = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;

/*============================================================================*/


function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES    = 2;
/* The three kinds of block type */

var MIN_MATCH    = 3;
var MAX_MATCH    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */

var LITERALS      = 256;
/* number of literal bytes 0..255 */

var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

var D_CODES       = 30;
/* number of distance codes */

var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */

var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */

var MAX_BITS      = 15;
/* All codes must not exceed MAX_BITS bits */

var Buf_size      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

var MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

var END_BLOCK   = 256;
/* end of block literal code */

var REP_3_6     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

var REPZ_3_10   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

var REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
var extra_lbits =   /* extra bits for each length code */
  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];

var extra_dbits =   /* extra bits for each distance code */
  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];

var extra_blbits =  /* extra bits for each bit length code */
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];

var bl_order =
  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
var static_ltree  = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

var static_dtree  = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

var _dist_code    = new Array(DIST_CODE_LEN);
zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

var _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);
zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

var base_length   = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

var base_dist     = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree && static_tree.length;
}


var static_l_desc;
var static_d_desc;
var static_bl_desc;


function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
}



function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
function put_short(s, w) {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) & 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
}


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
function send_bits(s, value, length) {
  if (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    s.bi_valid += length;
  }
}


function send_code(s, c, tree) {
  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
}


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
function bi_reverse(code, len) {
  var res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
}


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
function gen_bitlen(s, desc)
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  var tree            = desc.dyn_tree;
  var max_code        = desc.max_code;
  var stree           = desc.stat_desc.static_tree;
  var has_stree       = desc.stat_desc.has_stree;
  var extra           = desc.stat_desc.extra_bits;
  var base            = desc.stat_desc.extra_base;
  var max_length      = desc.stat_desc.max_length;
  var h;              /* heap index */
  var n, m;           /* iterate over the tree elements */
  var bits;           /* bit length */
  var xbits;          /* extra bits */
  var f;              /* frequency */
  var overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Trace((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
        tree[m * 2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
}


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
function gen_codes(tree, max_code, bl_count)
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
  var code = 0;              /* running code value */
  var bits;                  /* bit index */
  var n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n <= max_code; n++) {
    var len = tree[n * 2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
}


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
function tr_static_init() {
  var n;        /* iterates over tree elements */
  var bits;     /* bit counter */
  var length;   /* length value */
  var code;     /* code value */
  var dist;     /* distance index */
  var bl_count = new Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < (1 << extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < (1 << extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1]/*.Len*/ = 5;
    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);

  //static_init_done = true;
}


/* ===========================================================================
 * Initialize a new block.
 */
function init_block(s) {
  var n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
function bi_windup(s)
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
}

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
function copy_block(s, buf, len, header)
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s);        /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
//  while (len--) {
//    put_byte(s, *buf++);
//  }
  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
function smaller(tree, n, m, depth) {
  var _n2 = n * 2;
  var _m2 = m * 2;
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
}

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
function pqdownheap(s, tree, k)
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  var v = s.heap[k];
  var j = k << 1;  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len &&
      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
}


// inlined manually
// var SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
function compress_block(s, ltree, dtree)
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  var dist;           /* distance of matched string */
  var lc;             /* match length or unmatched char (if dist == 0) */
  var lx = 0;         /* running index in l_buf */
  var code;           /* the code to send */
  var extra;          /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");

    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
}


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
function build_tree(s, desc)
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  var tree     = desc.dyn_tree;
  var stree    = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems    = desc.stat_desc.elems;
  var n, m;          /* iterate over heap elements */
  var max_code = -1; /* largest code with non zero frequency */
  var node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n * 2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
}


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
function scan_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
function send_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);

    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);

    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
function build_bl_tree(s) {
  var max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
}


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
function send_all_trees(s, lcodes, dcodes, blcodes)
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  var rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1,   5);
  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
function detect_data_type(s) {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  var black_mask = 0xf3ffc07f;
  var n;

  /* Check for non-textual ("black-listed") bytes. */
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("white-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
}


var static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
function _tr_init(s)
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
}


/* ===========================================================================
 * Send a stored block
 */
function _tr_stored_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
  copy_block(s, buf, stored_len, true); /* with header */
}


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
function _tr_align(s) {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
function _tr_flush_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  var max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
    static_lenb = (s.static_len + 3 + 7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
function _tr_tally(s, dist, lc)
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //var out_length, in_length, dcode;

  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility

//#ifdef TRUNCATE_BLOCK
//  /* Try to guess if it is profitable to stop the current block here */
//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
//    /* Compute an upper bound for the compressed length */
//    out_length = s.last_lit*8;
//    in_length = s.strstart - s.block_start;
//
//    for (dcode = 0; dcode < D_CODES; dcode++) {
//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
//    }
//    out_length >>>= 3;
//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
//    //       s->last_lit, in_length, out_length,
//    //       100L - out_length*100L/in_length));
//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
//      return true;
//    }
//  }
//#endif

  return (s.last_lit === s.lit_bufsize - 1);
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
}

exports._tr_init  = _tr_init;
exports._tr_stored_block = _tr_stored_block;
exports._tr_flush_block  = _tr_flush_block;
exports._tr_tally = _tr_tally;
exports._tr_align = _tr_align;

},{"../utils/common":51}],63:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

module.exports = ZStream;

},{}],64:[function(require,module,exports){
(function (process){
'use strict';

if (typeof process === 'undefined' ||
    !process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


}).call(this,require('_process'))

},{"_process":65}],65:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],66:[function(require,module,exports){
module.exports = require('./lib/_stream_duplex.js');

},{"./lib/_stream_duplex.js":67}],67:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};
},{"./_stream_readable":69,"./_stream_writable":71,"core-util-is":4,"inherits":9,"process-nextick-args":64}],68:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":70,"core-util-is":4,"inherits":9}],69:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./_stream_duplex":67,"./internal/streams/BufferList":72,"./internal/streams/destroy":73,"./internal/streams/stream":74,"_process":65,"core-util-is":4,"events":6,"inherits":9,"isarray":11,"process-nextick-args":64,"safe-buffer":79,"string_decoder/":82,"util":2}],70:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":67,"core-util-is":4,"inherits":9}],71:[function(require,module,exports){
(function (process,global,setImmediate){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)

},{"./_stream_duplex":67,"./internal/streams/destroy":73,"./internal/streams/stream":74,"_process":65,"core-util-is":4,"inherits":9,"process-nextick-args":64,"safe-buffer":79,"timers":83,"util-deprecate":84}],72:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
var util = require('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}
},{"safe-buffer":79,"util":2}],73:[function(require,module,exports){
'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":64}],74:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":6}],75:[function(require,module,exports){
module.exports = require('./readable').PassThrough

},{"./readable":76}],76:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":67,"./lib/_stream_passthrough.js":68,"./lib/_stream_readable.js":69,"./lib/_stream_transform.js":70,"./lib/_stream_writable.js":71}],77:[function(require,module,exports){
module.exports = require('./readable').Transform

},{"./readable":76}],78:[function(require,module,exports){
module.exports = require('./lib/_stream_writable.js');

},{"./lib/_stream_writable.js":71}],79:[function(require,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":3}],80:[function(require,module,exports){
(function (setImmediate){
'use strict';
module.exports = typeof setImmediate === 'function' ? setImmediate :
	function setImmediate() {
		var args = [].slice.apply(arguments);
		args.splice(1, 0, 0);
		setTimeout.apply(null, args);
	};

}).call(this,require("timers").setImmediate)

},{"timers":83}],81:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":6,"inherits":9,"readable-stream/duplex.js":66,"readable-stream/passthrough.js":75,"readable-stream/readable.js":76,"readable-stream/transform.js":77,"readable-stream/writable.js":78}],82:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":79}],83:[function(require,module,exports){
(function (setImmediate,clearImmediate){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this,require("timers").setImmediate,require("timers").clearImmediate)

},{"process/browser.js":65,"timers":83}],84:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],85:[function(require,module,exports){
"use strict";

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HandleZip = void 0;

var jszip_1 = __importDefault(require("jszip"));

var method_1 = require("./common/method");

var HandleZip =
/** @class */
function () {
  function HandleZip(file) {
    // Support nodejs fs to read files
    // if(file instanceof File){
    this.uploadFile = file; // }
  }

  HandleZip.prototype.unzipFile = function (successFunc, errorFunc) {
    // var new_zip:JSZip = new JSZip();
    jszip_1["default"].loadAsync(this.uploadFile) // 1) read the Blob
    .then(function (zip) {
      var fileList = {},
          lastIndex = Object.keys(zip.files).length,
          index = 0;
      zip.forEach(function (relativePath, zipEntry) {
        var fileName = zipEntry.name;
        var fileNameArr = fileName.split(".");
        var suffix = fileNameArr[fileNameArr.length - 1].toLowerCase();
        var fileType = "string";

        if (suffix in {
          "png": 1,
          "jpeg": 1,
          "jpg": 1,
          "gif": 1,
          "bmp": 1,
          "tif": 1,
          "webp": 1
        }) {
          fileType = "base64";
        } else if (suffix == "emf") {
          fileType = "arraybuffer";
        }

        zipEntry.async(fileType).then(function (data) {
          if (fileType == "base64") {
            data = "data:image/" + suffix + ";base64," + data;
          }

          fileList[zipEntry.name] = data; // console.log(lastIndex, index);

          if (lastIndex == index + 1) {
            successFunc(fileList);
          }

          index++;
        });
      });
    }, function (e) {
      errorFunc(e);
    });
  };

  HandleZip.prototype.unzipFileByUrl = function (url, successFunc, errorFunc) {
    var new_zip = new jszip_1["default"]();
    method_1.getBinaryContent(url, function (err, data) {
      if (err) {
        throw err; // or handle err
      }

      jszip_1["default"].loadAsync(data).then(function (zip) {
        var fileList = {},
            lastIndex = Object.keys(zip.files).length,
            index = 0;
        zip.forEach(function (relativePath, zipEntry) {
          var fileName = zipEntry.name;
          var fileNameArr = fileName.split(".");
          var suffix = fileNameArr[fileNameArr.length - 1].toLowerCase();
          var fileType = "string";

          if (suffix in {
            "png": 1,
            "jpeg": 1,
            "jpg": 1,
            "gif": 1,
            "bmp": 1,
            "tif": 1,
            "webp": 1
          }) {
            fileType = "base64";
          } else if (suffix == "emf") {
            fileType = "arraybuffer";
          }

          zipEntry.async(fileType).then(function (data) {
            if (fileType == "base64") {
              data = "data:image/" + suffix + ";base64," + data;
            }

            fileList[zipEntry.name] = data; // console.log(lastIndex, index);

            if (lastIndex == index + 1) {
              successFunc(fileList);
            }

            index++;
          });
        });
      }, function (e) {
        errorFunc(e);
      });
    });
  };

  HandleZip.prototype.newZipFile = function () {
    var zip = new jszip_1["default"]();
    this.workBook = zip;
  }; //title:"nested/hello.txt", content:"Hello Worldasdfasfasdfasfasfasfasfasdfas"


  HandleZip.prototype.addToZipFile = function (title, content) {
    if (this.workBook == null) {
      var zip = new jszip_1["default"]();
      this.workBook = zip;
    }

    this.workBook.file(title, content);
  };

  return HandleZip;
}();

exports.HandleZip = HandleZip;

},{"./common/method":94,"jszip":21}],86:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LuckyImageBase = exports.LuckysheetCalcChain = exports.LuckySheetConfigMerge = exports.LuckySheetborderInfoCellValueStyle = exports.LuckySheetborderInfoCellValue = exports.LuckySheetborderInfoCellForImp = exports.LuckyConfig = exports.LuckyInlineString = exports.LuckySheetCellFormat = exports.LuckySheetCelldataValue = exports.LuckySheetCelldataBase = exports.LuckyFileInfo = exports.LuckySheetBase = exports.LuckyFileBase = void 0;

var LuckyFileBase =
/** @class */
function () {
  function LuckyFileBase() {}

  return LuckyFileBase;
}();

exports.LuckyFileBase = LuckyFileBase;

var LuckySheetBase =
/** @class */
function () {
  function LuckySheetBase() {}

  return LuckySheetBase;
}();

exports.LuckySheetBase = LuckySheetBase;

var LuckyFileInfo =
/** @class */
function () {
  function LuckyFileInfo() {}

  return LuckyFileInfo;
}();

exports.LuckyFileInfo = LuckyFileInfo;

var LuckySheetCelldataBase =
/** @class */
function () {
  function LuckySheetCelldataBase() {}

  return LuckySheetCelldataBase;
}();

exports.LuckySheetCelldataBase = LuckySheetCelldataBase;

var LuckySheetCelldataValue =
/** @class */
function () {
  function LuckySheetCelldataValue() {}

  return LuckySheetCelldataValue;
}();

exports.LuckySheetCelldataValue = LuckySheetCelldataValue;

var LuckySheetCellFormat =
/** @class */
function () {
  function LuckySheetCellFormat() {}

  return LuckySheetCellFormat;
}();

exports.LuckySheetCellFormat = LuckySheetCellFormat;

var LuckyInlineString =
/** @class */
function () {
  function LuckyInlineString() {}

  return LuckyInlineString;
}();

exports.LuckyInlineString = LuckyInlineString;

var LuckyConfig =
/** @class */
function () {
  function LuckyConfig() {}

  return LuckyConfig;
}();

exports.LuckyConfig = LuckyConfig;

var LuckySheetborderInfoCellForImp =
/** @class */
function () {
  function LuckySheetborderInfoCellForImp() {}

  return LuckySheetborderInfoCellForImp;
}();

exports.LuckySheetborderInfoCellForImp = LuckySheetborderInfoCellForImp;

var LuckySheetborderInfoCellValue =
/** @class */
function () {
  function LuckySheetborderInfoCellValue() {}

  return LuckySheetborderInfoCellValue;
}();

exports.LuckySheetborderInfoCellValue = LuckySheetborderInfoCellValue;

var LuckySheetborderInfoCellValueStyle =
/** @class */
function () {
  function LuckySheetborderInfoCellValueStyle() {}

  return LuckySheetborderInfoCellValueStyle;
}();

exports.LuckySheetborderInfoCellValueStyle = LuckySheetborderInfoCellValueStyle;

var LuckySheetConfigMerge =
/** @class */
function () {
  function LuckySheetConfigMerge() {}

  return LuckySheetConfigMerge;
}();

exports.LuckySheetConfigMerge = LuckySheetConfigMerge;

var LuckysheetCalcChain =
/** @class */
function () {
  function LuckysheetCalcChain() {}

  return LuckysheetCalcChain;
}();

exports.LuckysheetCalcChain = LuckysheetCalcChain;

var LuckyImageBase =
/** @class */
function () {
  function LuckyImageBase() {}

  return LuckyImageBase;
}();

exports.LuckyImageBase = LuckyImageBase;

},{}],87:[function(require,module,exports){
"use strict";

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LuckySheetCelldata = void 0;

var ReadXml_1 = require("./ReadXml");

var method_1 = require("../common/method");

var constant_1 = require("../common/constant");

var LuckyBase_1 = require("./LuckyBase");

var LuckySheetCelldata =
/** @class */
function (_super) {
  __extends(LuckySheetCelldata, _super);

  function LuckySheetCelldata(cell, styles, sharedStrings, mergeCells, sheetFile, ReadXml) {
    var _this = //Private
    _super.call(this) || this;

    _this.cell = cell;
    _this.sheetFile = sheetFile;
    _this.styles = styles;
    _this.sharedStrings = sharedStrings;
    _this.readXml = ReadXml;
    _this.mergeCells = mergeCells;
    var attrList = cell.attributeList;
    var r = attrList.r,
        s = attrList.s,
        t = attrList.t;
    var range = method_1.getcellrange(r);
    _this.r = range.row[0];
    _this.c = range.column[0];
    _this.v = _this.generateValue(s, t);
    return _this;
  }
  /**
  * @param s Style index ,start 1
  * @param t Cell type, Optional value is ST_CellType, it's found at constat.ts
  */


  LuckySheetCelldata.prototype.generateValue = function (s, t) {
    var _this = this;

    var v = this.cell.getInnerElements("v");
    var f = this.cell.getInnerElements("f");

    if (v == null) {
      v = this.cell.getInnerElements("t");
    }

    var cellXfs = this.styles["cellXfs"];
    var cellStyleXfs = this.styles["cellStyleXfs"];
    var cellStyles = this.styles["cellStyles"];
    var fonts = this.styles["fonts"];
    var fills = this.styles["fills"];
    var borders = this.styles["borders"];
    var numfmts = this.styles["numfmts"];
    var clrScheme = this.styles["clrScheme"];
    var sharedStrings = this.sharedStrings;
    var cellValue = new LuckyBase_1.LuckySheetCelldataValue();

    if (f != null) {
      var formula = f[0],
          attrList = formula.attributeList;
      var t_1 = attrList.t,
          ref = attrList.ref,
          si = attrList.si;
      var formulaValue = f[0].value;

      if (t_1 == "shared") {
        this._fomulaRef = ref;
        this._formulaType = t_1;
        this._formulaSi = si;
      } // console.log(ref, t, si);


      if (ref != null || formulaValue != null && formulaValue.length > 0) {
        formulaValue = method_1.escapeCharacter(formulaValue);
        cellValue.f = "=" + formulaValue;
      }
    }

    var familyFont = null;
    var quotePrefix;

    if (s != null) {
      var sNum = parseInt(s);
      var cellXf = cellXfs[sNum];
      var xfId = cellXf.attributeList.xfId;
      var numFmtId = void 0,
          fontId = void 0,
          fillId = void 0,
          borderId = void 0;
      var horizontal = void 0,
          vertical = void 0,
          wrapText = void 0,
          textRotation = void 0,
          shrinkToFit = void 0,
          indent = void 0,
          applyProtection = void 0;

      if (xfId != null) {
        var cellStyleXf = cellStyleXfs[parseInt(xfId)];
        var attrList = cellStyleXf.attributeList;
        var applyNumberFormat_1 = attrList.applyNumberFormat;
        var applyFont_1 = attrList.applyFont;
        var applyFill_1 = attrList.applyFill;
        var applyBorder_1 = attrList.applyBorder;
        var applyAlignment_1 = attrList.applyAlignment; // let applyProtection = attrList.applyProtection;

        applyProtection = attrList.applyProtection;
        quotePrefix = attrList.quotePrefix;

        if (applyNumberFormat_1 != "0" && attrList.numFmtId != null) {
          // if(attrList.numFmtId!="0"){
          numFmtId = attrList.numFmtId; // }
        }

        if (applyFont_1 != "0" && attrList.fontId != null) {
          fontId = attrList.fontId;
        }

        if (applyFill_1 != "0" && attrList.fillId != null) {
          fillId = attrList.fillId;
        }

        if (applyBorder_1 != "0" && attrList.borderId != null) {
          borderId = attrList.borderId;
        }

        if (applyAlignment_1 != null && applyAlignment_1 != "0") {
          var alignment = cellStyleXf.getInnerElements("alignment");

          if (alignment != null) {
            var attrList_1 = alignment[0].attributeList;

            if (attrList_1.horizontal != null) {
              horizontal = attrList_1.horizontal;
            }

            if (attrList_1.vertical != null) {
              vertical = attrList_1.vertical;
            }

            if (attrList_1.wrapText != null) {
              wrapText = attrList_1.wrapText;
            }

            if (attrList_1.textRotation != null) {
              textRotation = attrList_1.textRotation;
            }

            if (attrList_1.shrinkToFit != null) {
              shrinkToFit = attrList_1.shrinkToFit;
            }

            if (attrList_1.indent != null) {
              indent = attrList_1.indent;
            }
          }
        }
      }

      var applyNumberFormat = cellXf.attributeList.applyNumberFormat;
      var applyFont = cellXf.attributeList.applyFont;
      var applyFill = cellXf.attributeList.applyFill;
      var applyBorder = cellXf.attributeList.applyBorder;
      var applyAlignment = cellXf.attributeList.applyAlignment;

      if (cellXf.attributeList.applyProtection != null) {
        applyProtection = cellXf.attributeList.applyProtection;
      }

      if (cellXf.attributeList.quotePrefix != null) {
        quotePrefix = cellXf.attributeList.quotePrefix;
      }

      if (applyNumberFormat != "0" && cellXf.attributeList.numFmtId != null) {
        numFmtId = cellXf.attributeList.numFmtId;
      }

      if (applyFont != "0") {
        fontId = cellXf.attributeList.fontId;
      }

      if (applyFill != "0") {
        fillId = cellXf.attributeList.fillId;
      }

      if (applyBorder != "0") {
        borderId = cellXf.attributeList.borderId;
      }

      if (applyAlignment != "0") {
        var alignment = cellXf.getInnerElements("alignment");

        if (alignment != null && alignment.length > 0) {
          var attrList = alignment[0].attributeList;

          if (attrList.horizontal != null) {
            horizontal = attrList.horizontal;
          }

          if (attrList.vertical != null) {
            vertical = attrList.vertical;
          }

          if (attrList.wrapText != null) {
            wrapText = attrList.wrapText;
          }

          if (attrList.textRotation != null) {
            textRotation = attrList.textRotation;
          }

          if (attrList.shrinkToFit != null) {
            shrinkToFit = attrList.shrinkToFit;
          }

          if (attrList.indent != null) {
            indent = attrList.indent;
          }
        }
      }

      if (numFmtId != undefined) {
        var numf = numfmts[parseInt(numFmtId)];
        var cellFormat = new LuckyBase_1.LuckySheetCellFormat();
        cellFormat.fa = method_1.escapeCharacter(numf); // console.log(numf, numFmtId, this.v);

        cellFormat.t = t || 'd';
        cellValue.ct = cellFormat;
      }

      if (fillId != undefined) {
        var fillIdNum = parseInt(fillId);
        var fill = fills[fillIdNum]; // console.log(cellValue.v);

        var bg = this.getBackgroundByFill(fill, clrScheme);

        if (bg != null) {
          cellValue.bg = bg;
        }
      }

      if (fontId != undefined) {
        var fontIdNum = parseInt(fontId);
        var font = fonts[fontIdNum];

        if (font != null) {
          var sz = font.getInnerElements("sz"); //font size

          var colors = font.getInnerElements("color"); //font color

          var family = font.getInnerElements("name"); //font family

          var familyOverrides = font.getInnerElements("family"); //font family will be overrided by name

          var charset = font.getInnerElements("charset"); //font charset

          var bolds = font.getInnerElements("b"); //font bold

          var italics = font.getInnerElements("i"); //font italic

          var strikes = font.getInnerElements("strike"); //font italic

          var underlines = font.getInnerElements("u"); //font italic

          if (sz != null && sz.length > 0) {
            var fs = sz[0].attributeList.val;

            if (fs != null) {
              cellValue.fs = parseInt(fs);
            }
          }

          if (colors != null && colors.length > 0) {
            var color = colors[0];
            var fc = ReadXml_1.getColor(color, this.styles, "t");

            if (fc != null) {
              cellValue.fc = fc;
            }
          }

          if (familyOverrides != null && familyOverrides.length > 0) {
            var val = familyOverrides[0].attributeList.val;

            if (val != null) {
              familyFont = constant_1.fontFamilys[val];
            }
          }

          if (family != null && family.length > 0) {
            var val = family[0].attributeList.val;

            if (val != null) {
              cellValue.ff = val;
            }
          }

          if (bolds != null && bolds.length > 0) {
            var bold = bolds[0].attributeList.val;

            if (bold == "0") {
              cellValue.bl = 0;
            } else {
              cellValue.bl = 1;
            }
          }

          if (italics != null && italics.length > 0) {
            var italic = italics[0].attributeList.val;

            if (italic == "0") {
              cellValue.it = 0;
            } else {
              cellValue.it = 1;
            }
          }

          if (strikes != null && strikes.length > 0) {
            var strike = strikes[0].attributeList.val;

            if (strike == "0") {
              cellValue.cl = 0;
            } else {
              cellValue.cl = 1;
            }
          }

          if (underlines != null && underlines.length > 0) {
            var underline = underlines[0].attributeList.val;

            if (underline == "single") {
              cellValue.un = 1;
            } else if (underline == "double") {
              cellValue.un = 2;
            } else if (underline == "singleAccounting") {
              cellValue.un = 3;
            } else if (underline == "doubleAccounting") {
              cellValue.un = 4;
            } else {
              cellValue.un = 0;
            }
          }
        }
      } // vt: number | undefined//Vertical alignment, 0 middle, 1 up, 2 down, alignment
      // ht: number | undefined//Horizontal alignment,0 center, 1 left, 2 right, alignment
      // tr: number | undefined //Text rotation,0: 01: 45 2: -453 Vertical text4: 90 5: -90, alignment
      // tb: number | undefined //Text wrap,0 truncation, 1 overflow, 2 word wrap, alignment


      if (horizontal != undefined) {
        //Horizontal alignment
        if (horizontal == "center") {
          cellValue.ht = 0;
        } else if (horizontal == "centerContinuous") {
          cellValue.ht = 0; //luckysheet unsupport
        } else if (horizontal == "left") {
          cellValue.ht = 1;
        } else if (horizontal == "right") {
          cellValue.ht = 2;
        } else if (horizontal == "distributed") {
          cellValue.ht = 0; //luckysheet unsupport
        } else if (horizontal == "fill") {
          cellValue.ht = 1; //luckysheet unsupport
        } else if (horizontal == "general") {
          cellValue.ht = 1; //luckysheet unsupport
        } else if (horizontal == "justify") {
          cellValue.ht = 0; //luckysheet unsupport
        } else {
          cellValue.ht = 1;
        }
      }

      if (vertical != undefined) {
        //Vertical alignment
        if (vertical == "bottom") {
          cellValue.vt = 2;
        } else if (vertical == "center") {
          cellValue.vt = 0;
        } else if (vertical == "distributed") {
          cellValue.vt = 0; //luckysheet unsupport
        } else if (vertical == "justify") {
          cellValue.vt = 0; //luckysheet unsupport
        } else if (vertical == "top") {
          cellValue.vt = 1;
        } else {
          cellValue.vt = 1;
        }
      } else {
        //sometimes bottom style is lost after setting it in excel
        //when vertical is undefined set it to 2.
        cellValue.vt = 2;
      }

      if (wrapText != undefined) {
        if (wrapText == "1") {
          cellValue.tb = 2;
        } else {
          cellValue.tb = 1;
        }
      } else {
        cellValue.tb = 1;
      }

      if (textRotation != undefined) {
        // tr: number | undefined //Text rotation,0: 01: 45 2: -453 Vertical text4: 90 5: -90, alignment
        if (textRotation == "255") {
          cellValue.tr = 3;
        } // else if(textRotation=="45"){
        //     cellValue.tr = 1;
        // }
        // else if(textRotation=="90"){
        //     cellValue.tr = 4;
        // }
        // else if(textRotation=="135"){
        //     cellValue.tr = 2;
        // }
        // else if(textRotation=="180"){
        //     cellValue.tr = 5;
        // }
        else {
            cellValue.tr = 0;
            cellValue.rt = parseInt(textRotation);
          }
      }

      if (shrinkToFit != undefined) {//luckysheet unsupport
      }

      if (indent != undefined) {//luckysheet unsupport
      }

      if (borderId != undefined) {
        var borderIdNum = parseInt(borderId);
        var border = borders[borderIdNum]; // this._borderId = borderIdNum;

        var borderObject = new LuckyBase_1.LuckySheetborderInfoCellForImp();
        borderObject.rangeType = "cell"; // borderObject.cells = [];

        var borderCellValue = new LuckyBase_1.LuckySheetborderInfoCellValue();
        borderCellValue.row_index = this.r;
        borderCellValue.col_index = this.c;
        var lefts = border.getInnerElements("left");
        var rights = border.getInnerElements("right");
        var tops = border.getInnerElements("top");
        var bottoms = border.getInnerElements("bottom");
        var diagonals = border.getInnerElements("diagonal");
        var starts = border.getInnerElements("start");
        var ends = border.getInnerElements("end");
        var left = this.getBorderInfo(lefts);
        var right = this.getBorderInfo(rights);
        var top_1 = this.getBorderInfo(tops);
        var bottom = this.getBorderInfo(bottoms);
        var diagonal = this.getBorderInfo(diagonals);
        var start = this.getBorderInfo(starts);
        var end = this.getBorderInfo(ends);
        var isAdd = false;

        if (start != null && start.color != null) {
          borderCellValue.l = start;
          isAdd = true;
        }

        if (end != null && end.color != null) {
          borderCellValue.r = end;
          isAdd = true;
        }

        if (left != null && left.color != null) {
          borderCellValue.l = left;
          isAdd = true;
        }

        if (right != null && right.color != null) {
          borderCellValue.r = right;
          isAdd = true;
        }

        if (top_1 != null && top_1.color != null) {
          borderCellValue.t = top_1;
          isAdd = true;
        }

        if (bottom != null && bottom.color != null) {
          borderCellValue.b = bottom;
          isAdd = true;
        }

        if (isAdd) {
          borderObject.value = borderCellValue; // this.config._borderInfo[borderId] = borderObject;

          this._borderObject = borderObject;
        }
      }
    } else {
      cellValue.tb = 1;
    }

    if (v != null) {
      var value = v[0].value;

      if (/&#\d+;/.test(value)) {
        value = this.htmlDecode(value);
      }

      if (t == constant_1.ST_CellType["SharedString"]) {
        var siIndex = parseInt(v[0].value);
        var sharedSI = sharedStrings[siIndex];
        var rFlag = sharedSI.getInnerElements("r");

        if (rFlag == null) {
          var tFlag = sharedSI.getInnerElements("t");

          if (tFlag != null) {
            var text_1 = "";
            tFlag.forEach(function (t) {
              text_1 += t.value;
            });
            text_1 = method_1.escapeCharacter(text_1); //isContainMultiType(text) &&

            if (familyFont == "Roman" && text_1.length > 0) {
              var textArray = text_1.split("");
              var preWordType = null,
                  wordText = "",
                  preWholef = null;
              var wholef = "Times New Roman";

              if (cellValue.ff != null) {
                wholef = cellValue.ff;
              }

              var cellFormat = cellValue.ct;

              if (cellFormat == null) {
                cellFormat = new LuckyBase_1.LuckySheetCellFormat();
              }

              if (cellFormat.s == null) {
                cellFormat.s = [];
              }

              for (var i = 0; i < textArray.length; i++) {
                var w = textArray[i];
                var type = null,
                    ff = wholef;

                if (method_1.isChinese(w)) {
                  type = "c";
                  ff = "";
                } else if (method_1.isJapanese(w)) {
                  type = "j";
                  ff = "Yu Gothic";
                } else if (method_1.isKoera(w)) {
                  type = "k";
                  ff = "Malgun Gothic";
                } else {
                  type = "e";
                }

                if (type != preWordType && preWordType != null || i == textArray.length - 1) {
                  var InlineString = new LuckyBase_1.LuckyInlineString();
                  InlineString.ff = preWholef;

                  if (cellValue.fc != null) {
                    InlineString.fc = cellValue.fc;
                  }

                  if (cellValue.fs != null) {
                    InlineString.fs = cellValue.fs;
                  }

                  if (cellValue.cl != null) {
                    InlineString.cl = cellValue.cl;
                  }

                  if (cellValue.un != null) {
                    InlineString.un = cellValue.un;
                  }

                  if (cellValue.bl != null) {
                    InlineString.bl = cellValue.bl;
                  }

                  if (cellValue.it != null) {
                    InlineString.it = cellValue.it;
                  }

                  if (i == textArray.length - 1) {
                    if (type == preWordType) {
                      InlineString.ff = ff;
                      InlineString.v = wordText + w;
                    } else {
                      InlineString.ff = preWholef;
                      InlineString.v = wordText;
                      cellFormat.s.push(InlineString);
                      var InlineStringLast = new LuckyBase_1.LuckyInlineString();
                      InlineStringLast.ff = ff;
                      InlineStringLast.v = w;

                      if (cellValue.fc != null) {
                        InlineStringLast.fc = cellValue.fc;
                      }

                      if (cellValue.fs != null) {
                        InlineStringLast.fs = cellValue.fs;
                      }

                      if (cellValue.cl != null) {
                        InlineStringLast.cl = cellValue.cl;
                      }

                      if (cellValue.un != null) {
                        InlineStringLast.un = cellValue.un;
                      }

                      if (cellValue.bl != null) {
                        InlineStringLast.bl = cellValue.bl;
                      }

                      if (cellValue.it != null) {
                        InlineStringLast.it = cellValue.it;
                      }

                      cellFormat.s.push(InlineStringLast);
                      break;
                    }
                  } else {
                    InlineString.v = wordText;
                  }

                  cellFormat.s.push(InlineString);
                  wordText = w;
                } else {
                  wordText += w;
                }

                preWordType = type;
                preWholef = ff;
              }

              cellFormat.t = "inlineStr"; // cellFormat.s = [InlineString];

              cellValue.ct = cellFormat; // console.log(cellValue);
            } else {
              text_1 = this.replaceSpecialWrap(text_1);

              if (text_1.indexOf("\r\n") > -1 || text_1.indexOf("\n") > -1) {
                var InlineString = new LuckyBase_1.LuckyInlineString();
                InlineString.v = text_1;
                var cellFormat = cellValue.ct;

                if (cellFormat == null) {
                  cellFormat = new LuckyBase_1.LuckySheetCellFormat();
                }

                if (cellValue.ff != null) {
                  InlineString.ff = cellValue.ff;
                }

                if (cellValue.fc != null) {
                  InlineString.fc = cellValue.fc;
                }

                if (cellValue.fs != null) {
                  InlineString.fs = cellValue.fs;
                }

                if (cellValue.cl != null) {
                  InlineString.cl = cellValue.cl;
                }

                if (cellValue.un != null) {
                  InlineString.un = cellValue.un;
                }

                if (cellValue.bl != null) {
                  InlineString.bl = cellValue.bl;
                }

                if (cellValue.it != null) {
                  InlineString.it = cellValue.it;
                }

                cellFormat.t = "inlineStr";
                cellFormat.s = [InlineString];
                cellValue.ct = cellFormat;
              } else {
                cellValue.v = text_1;
                quotePrefix = "1";
              }
            }
          }
        } else {
          var styles_1 = [];
          rFlag.forEach(function (r) {
            var tFlag = r.getInnerElements("t");
            var rPr = r.getInnerElements("rPr");
            var InlineString = new LuckyBase_1.LuckyInlineString();

            if (tFlag != null && tFlag.length > 0) {
              var text = tFlag[0].value;
              text = _this.replaceSpecialWrap(text);
              text = method_1.escapeCharacter(text);
              InlineString.v = text;
            }

            if (rPr != null && rPr.length > 0) {
              var frpr = rPr[0];
              var sz = ReadXml_1.getlineStringAttr(frpr, "sz"),
                  rFont = ReadXml_1.getlineStringAttr(frpr, "rFont"),
                  family = ReadXml_1.getlineStringAttr(frpr, "family"),
                  charset = ReadXml_1.getlineStringAttr(frpr, "charset"),
                  scheme = ReadXml_1.getlineStringAttr(frpr, "scheme"),
                  b = ReadXml_1.getlineStringAttr(frpr, "b"),
                  i = ReadXml_1.getlineStringAttr(frpr, "i"),
                  u = ReadXml_1.getlineStringAttr(frpr, "u"),
                  strike = ReadXml_1.getlineStringAttr(frpr, "strike"),
                  vertAlign = ReadXml_1.getlineStringAttr(frpr, "vertAlign"),
                  color = void 0;
              var cEle = frpr.getInnerElements("color");

              if (cEle != null && cEle.length > 0) {
                color = ReadXml_1.getColor(cEle[0], _this.styles, "t");
              }

              var ff = void 0; // if(family!=null){
              //     ff = fontFamilys[family];
              // }

              if (rFont != null) {
                ff = rFont;
              }

              if (ff != null) {
                InlineString.ff = ff;
              } else if (cellValue.ff != null) {
                InlineString.ff = cellValue.ff;
              }

              if (color != null) {
                InlineString.fc = color;
              } else if (cellValue.fc != null) {
                InlineString.fc = cellValue.fc;
              }

              if (sz != null) {
                InlineString.fs = parseInt(sz);
              } else if (cellValue.fs != null) {
                InlineString.fs = cellValue.fs;
              }

              if (strike != null) {
                InlineString.cl = parseInt(strike);
              } else if (cellValue.cl != null) {
                InlineString.cl = cellValue.cl;
              }

              if (u != null) {
                InlineString.un = parseInt(u);
              } else if (cellValue.un != null) {
                InlineString.un = cellValue.un;
              }

              if (b != null) {
                InlineString.bl = parseInt(b);
              } else if (cellValue.bl != null) {
                InlineString.bl = cellValue.bl;
              }

              if (i != null) {
                InlineString.it = parseInt(i);
              } else if (cellValue.it != null) {
                InlineString.it = cellValue.it;
              }

              if (vertAlign != null) {
                InlineString.va = parseInt(vertAlign);
              } // ff:string | undefined //font family
              // fc:string | undefined//font color
              // fs:number | undefined//font size
              // cl:number | undefined//strike
              // un:number | undefined//underline
              // bl:number | undefined//blod
              // it:number | undefined//italic
              // v:string | undefined

            } else {
              if (InlineString.ff == null && cellValue.ff != null) {
                InlineString.ff = cellValue.ff;
              }

              if (InlineString.fc == null && cellValue.fc != null) {
                InlineString.fc = cellValue.fc;
              }

              if (InlineString.fs == null && cellValue.fs != null) {
                InlineString.fs = cellValue.fs;
              }

              if (InlineString.cl == null && cellValue.cl != null) {
                InlineString.cl = cellValue.cl;
              }

              if (InlineString.un == null && cellValue.un != null) {
                InlineString.un = cellValue.un;
              }

              if (InlineString.bl == null && cellValue.bl != null) {
                InlineString.bl = cellValue.bl;
              }

              if (InlineString.it == null && cellValue.it != null) {
                InlineString.it = cellValue.it;
              }
            }

            styles_1.push(InlineString);
          });
          var cellFormat = cellValue.ct;

          if (cellFormat == null) {
            cellFormat = new LuckyBase_1.LuckySheetCellFormat();
          }

          cellFormat.t = "inlineStr";
          cellFormat.s = styles_1;
          cellValue.ct = cellFormat;
        }
      } // to be confirmed
      else if (t == constant_1.ST_CellType["InlineString"] && v != null) {
          cellValue.v = "'" + value;
        } else {
          value = method_1.escapeCharacter(value);
          cellValue.v = value;
        }
    }

    if (quotePrefix != null) {
      cellValue.qp = parseInt(quotePrefix);
    }

    return cellValue;
  };

  LuckySheetCelldata.prototype.replaceSpecialWrap = function (text) {
    text = text.replace(/_x000D_/g, "").replace(/&#13;&#10;/g, "\r\n").replace(/&#13;/g, "\r").replace(/&#10;/g, "\n");
    return text;
  };

  LuckySheetCelldata.prototype.getBackgroundByFill = function (fill, clrScheme) {
    var patternFills = fill.getInnerElements("patternFill");

    if (patternFills != null) {
      var patternFill = patternFills[0];
      var fgColors = patternFill.getInnerElements("fgColor");
      var bgColors = patternFill.getInnerElements("bgColor");
      var fg = void 0,
          bg = void 0;

      if (fgColors != null) {
        var fgColor = fgColors[0];
        fg = ReadXml_1.getColor(fgColor, this.styles);
      }

      if (bgColors != null) {
        var bgColor = bgColors[0];
        bg = ReadXml_1.getColor(bgColor, this.styles);
      } // console.log(fgColors,bgColors,clrScheme);


      if (fg != null) {
        return fg;
      } else if (bg != null) {
        return bg;
      }
    } else {
      var gradientfills = fill.getInnerElements("gradientFill");

      if (gradientfills != null) {
        //graient color fill handler
        return null;
      }
    }
  };

  LuckySheetCelldata.prototype.getBorderInfo = function (borders) {
    if (borders == null) {
      return null;
    }

    var border = borders[0],
        attrList = border.attributeList;
    var clrScheme = this.styles["clrScheme"];
    var style = attrList.style;

    if (style == null || style == "none") {
      return null;
    }

    var colors = border.getInnerElements("color");
    var colorRet = "#000000";

    if (colors != null) {
      var color = colors[0];
      colorRet = ReadXml_1.getColor(color, this.styles, "b");

      if (colorRet == null) {
        colorRet = "#000000";
      }
    }

    var ret = new LuckyBase_1.LuckySheetborderInfoCellValueStyle();
    ret.style = constant_1.borderTypes[style];
    ret.color = colorRet;
    return ret;
  };

  LuckySheetCelldata.prototype.htmlDecode = function (str) {
    return str.replace(/&#(x)?([^&]{1,5});/g, function ($, $1, $2) {
      return String.fromCharCode(parseInt($2, $1 ? 16 : 10));
    });
  };

  ;
  return LuckySheetCelldata;
}(LuckyBase_1.LuckySheetCelldataBase);

exports.LuckySheetCelldata = LuckySheetCelldata;

},{"../common/constant":92,"../common/method":94,"./LuckyBase":86,"./ReadXml":91}],88:[function(require,module,exports){
"use strict";

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LuckyFile = void 0;

var LuckySheet_1 = require("./LuckySheet");

var constant_1 = require("../common/constant");

var ReadXml_1 = require("./ReadXml");

var method_1 = require("../common/method");

var LuckyBase_1 = require("./LuckyBase");

var LuckyImage_1 = require("./LuckyImage");

var LuckyFile =
/** @class */
function (_super) {
  __extends(LuckyFile, _super);

  function LuckyFile(files, fileName) {
    var _this = _super.call(this) || this;

    _this.columnWidthSet = [];
    _this.rowHeightSet = [];
    _this.files = files;
    _this.fileName = fileName;
    _this.readXml = new ReadXml_1.ReadXml(files);

    _this.getSheetNameList();

    _this.sharedStrings = _this.readXml.getElementsByTagName("sst/si", constant_1.sharedStringsFile);
    _this.calcChain = _this.readXml.getElementsByTagName("calcChain/c", constant_1.calcChainFile);
    _this.styles = {};
    _this.styles["cellXfs"] = _this.readXml.getElementsByTagName("cellXfs/xf", constant_1.stylesFile);
    _this.styles["cellStyleXfs"] = _this.readXml.getElementsByTagName("cellStyleXfs/xf", constant_1.stylesFile);
    _this.styles["cellStyles"] = _this.readXml.getElementsByTagName("cellStyles/cellStyle", constant_1.stylesFile);
    _this.styles["fonts"] = _this.readXml.getElementsByTagName("fonts/font", constant_1.stylesFile);
    _this.styles["fills"] = _this.readXml.getElementsByTagName("fills/fill", constant_1.stylesFile);
    _this.styles["borders"] = _this.readXml.getElementsByTagName("borders/border", constant_1.stylesFile);
    _this.styles["clrScheme"] = _this.readXml.getElementsByTagName("a:clrScheme/a:dk1|a:lt1|a:dk2|a:lt2|a:accent1|a:accent2|a:accent3|a:accent4|a:accent5|a:accent6|a:hlink|a:folHlink", constant_1.theme1File);
    _this.styles["indexedColors"] = _this.readXml.getElementsByTagName("colors/indexedColors/rgbColor", constant_1.stylesFile);
    _this.styles["mruColors"] = _this.readXml.getElementsByTagName("colors/mruColors/color", constant_1.stylesFile);
    _this.imageList = new LuckyImage_1.ImageList(files);

    var numfmts = _this.readXml.getElementsByTagName("numFmt/numFmt", constant_1.stylesFile);

    var numFmtDefaultC = JSON.parse(JSON.stringify(constant_1.numFmtDefault));

    for (var i = 0; i < numfmts.length; i++) {
      var attrList = numfmts[i].attributeList;
      var numfmtid = method_1.getXmlAttibute(attrList, "numFmtId", "49");
      var formatcode = method_1.getXmlAttibute(attrList, "formatCode", "@"); // console.log(numfmtid, formatcode);

      if (!(numfmtid in constant_1.numFmtDefault)) {
        numFmtDefaultC[numfmtid] = constant_1.numFmtDefaultMap[formatcode] || formatcode;
      }
    } // console.log(JSON.stringify(numFmtDefaultC), numfmts);


    _this.styles["numfmts"] = numFmtDefaultC;
    return _this;
  }
  /**
  * @return All sheet name of workbook
  */


  LuckyFile.prototype.getSheetNameList = function () {
    var workbookRelList = this.readXml.getElementsByTagName("Relationships/Relationship", constant_1.workbookRels);

    if (workbookRelList == null) {
      return;
    }

    var regex = new RegExp("worksheets/[^/]*?.xml");
    var sheetNames = {};

    for (var i = 0; i < workbookRelList.length; i++) {
      var rel = workbookRelList[i],
          attrList = rel.attributeList;
      var id = attrList["Id"],
          target = attrList["Target"];

      if (regex.test(target)) {
        if (target.indexOf('/xl') === 0) {
          sheetNames[id] = target.substr(1);
        } else {
          sheetNames[id] = "xl/" + target;
        }
      }
    }

    this.sheetNameList = sheetNames;
  };
  /**
  * @param sheetName WorkSheet'name
  * @return sheet file name and path in zip
  */


  LuckyFile.prototype.getSheetFileBysheetId = function (sheetId) {
    // for(let i=0;i<this.sheetNameList.length;i++){
    //     let sheetFileName = this.sheetNameList[i];
    //     if(sheetFileName.indexOf("sheet"+sheetId)>-1){
    //         return sheetFileName;
    //     }
    // }
    return this.sheetNameList[sheetId];
  };
  /**
  * @return workBook information
  */


  LuckyFile.prototype.getWorkBookInfo = function () {
    var Company = this.readXml.getElementsByTagName("Company", constant_1.appFile);
    var AppVersion = this.readXml.getElementsByTagName("AppVersion", constant_1.appFile);
    var creator = this.readXml.getElementsByTagName("dc:creator", constant_1.coreFile);
    var lastModifiedBy = this.readXml.getElementsByTagName("cp:lastModifiedBy", constant_1.coreFile);
    var created = this.readXml.getElementsByTagName("dcterms:created", constant_1.coreFile);
    var modified = this.readXml.getElementsByTagName("dcterms:modified", constant_1.coreFile);
    this.info = new LuckyBase_1.LuckyFileInfo();
    this.info.name = this.fileName;
    this.info.creator = creator.length > 0 ? creator[0].value : "";
    this.info.lastmodifiedby = lastModifiedBy.length > 0 ? lastModifiedBy[0].value : "";
    this.info.createdTime = created.length > 0 ? created[0].value : "";
    this.info.modifiedTime = modified.length > 0 ? modified[0].value : "";
    this.info.company = Company.length > 0 ? Company[0].value : "";
    this.info.appversion = AppVersion.length > 0 ? AppVersion[0].value : "";
  };
  /**
  * @return All sheet , include whole information
  */


  LuckyFile.prototype.getSheetsFull = function (isInitialCell) {
    if (isInitialCell === void 0) {
      isInitialCell = true;
    }

    var sheets = this.readXml.getElementsByTagName("sheets/sheet", constant_1.workBookFile);
    var sheetList = {};

    for (var key in sheets) {
      var sheet = sheets[key];
      sheetList[sheet.attributeList.name] = sheet.attributeList["sheetId"];
    }

    this.sheets = [];
    var order = 0;

    for (var key in sheets) {
      var sheet = sheets[key];
      var sheetName = sheet.attributeList.name;
      var sheetId = sheet.attributeList["sheetId"];
      var rid = sheet.attributeList["r:id"];
      var sheetFile = this.getSheetFileBysheetId(rid);
      var hide = sheet.attributeList.state === "hidden" ? 1 : 0;
      var drawing = this.readXml.getElementsByTagName("worksheet/drawing", sheetFile),
          drawingFile = void 0,
          drawingRelsFile = void 0;

      if (drawing != null && drawing.length > 0) {
        var attrList = drawing[0].attributeList;
        var rid_1 = method_1.getXmlAttibute(attrList, "r:id", null);

        if (rid_1 != null) {
          drawingFile = this.getDrawingFile(rid_1, sheetFile);
          drawingRelsFile = this.getDrawingRelsFile(drawingFile);
        }
      }

      if (sheetFile != null) {
        var sheet_1 = new LuckySheet_1.LuckySheet(sheetName, sheetId, order, isInitialCell, {
          sheetFile: sheetFile,
          readXml: this.readXml,
          sheetList: sheetList,
          styles: this.styles,
          sharedStrings: this.sharedStrings,
          calcChain: this.calcChain,
          imageList: this.imageList,
          drawingFile: drawingFile,
          drawingRelsFile: drawingRelsFile,
          hide: hide
        });
        this.columnWidthSet = [];
        this.rowHeightSet = [];
        this.imagePositionCaculation(sheet_1);
        this.sheets.push(sheet_1);
        order++;
      }
    }
  };

  LuckyFile.prototype.extendArray = function (index, sets, def, hidden, lens) {
    if (index < sets.length) {
      return;
    }

    var startIndex = sets.length,
        endIndex = index;
    var allGap = 0;

    if (startIndex > 0) {
      allGap = sets[startIndex - 1];
    } // else{
    //     sets.push(0);
    // }


    for (var i = startIndex; i <= endIndex; i++) {
      var gap = def,
          istring = i.toString();

      if (istring in hidden) {
        gap = 0;
      } else if (istring in lens) {
        gap = lens[istring];
      }

      allGap += Math.round(gap + 1);
      sets.push(allGap);
    }
  };

  LuckyFile.prototype.imagePositionCaculation = function (sheet) {
    var images = sheet.images,
        defaultColWidth = sheet.defaultColWidth,
        defaultRowHeight = sheet.defaultRowHeight;
    var colhidden = {};

    if (sheet.config.colhidden) {
      colhidden = sheet.config.colhidden;
    }

    var columnlen = {};

    if (sheet.config.columnlen) {
      columnlen = sheet.config.columnlen;
    }

    var rowhidden = {};

    if (sheet.config.rowhidden) {
      rowhidden = sheet.config.rowhidden;
    }

    var rowlen = {};

    if (sheet.config.rowlen) {
      rowlen = sheet.config.rowlen;
    }

    for (var key in images) {
      var imageObject = images[key]; //Image, luckyImage

      var fromCol = imageObject.fromCol;
      var fromColOff = imageObject.fromColOff;
      var fromRow = imageObject.fromRow;
      var fromRowOff = imageObject.fromRowOff;
      var toCol = imageObject.toCol;
      var toColOff = imageObject.toColOff;
      var toRow = imageObject.toRow;
      var toRowOff = imageObject.toRowOff;
      var x_n = 0,
          y_n = 0;
      var cx_n = 0,
          cy_n = 0;

      if (fromCol >= this.columnWidthSet.length) {
        this.extendArray(fromCol, this.columnWidthSet, defaultColWidth, colhidden, columnlen);
      }

      if (fromCol == 0) {
        x_n = 0;
      } else {
        x_n = this.columnWidthSet[fromCol - 1];
      }

      x_n = x_n + fromColOff;

      if (fromRow >= this.rowHeightSet.length) {
        this.extendArray(fromRow, this.rowHeightSet, defaultRowHeight, rowhidden, rowlen);
      }

      if (fromRow == 0) {
        y_n = 0;
      } else {
        y_n = this.rowHeightSet[fromRow - 1];
      }

      y_n = y_n + fromRowOff;

      if (toCol >= this.columnWidthSet.length) {
        this.extendArray(toCol, this.columnWidthSet, defaultColWidth, colhidden, columnlen);
      }

      if (toCol == 0) {
        cx_n = 0;
      } else {
        cx_n = this.columnWidthSet[toCol - 1];
      }

      cx_n = cx_n + toColOff - x_n;

      if (toRow >= this.rowHeightSet.length) {
        this.extendArray(toRow, this.rowHeightSet, defaultRowHeight, rowhidden, rowlen);
      }

      if (toRow == 0) {
        cy_n = 0;
      } else {
        cy_n = this.rowHeightSet[toRow - 1];
      }

      cy_n = cy_n + toRowOff - y_n;
      console.log(defaultColWidth, colhidden, columnlen);
      console.log(fromCol, this.columnWidthSet[fromCol], fromColOff);
      console.log(toCol, this.columnWidthSet[toCol], toColOff, JSON.stringify(this.columnWidthSet));
      imageObject.originWidth = cx_n;
      imageObject.originHeight = cy_n;
      imageObject.crop.height = cy_n;
      imageObject.crop.width = cx_n;
      imageObject["default"].height = cy_n;
      imageObject["default"].left = x_n;
      imageObject["default"].top = y_n;
      imageObject["default"].width = cx_n;
    } //console.log(this.columnWidthSet, this.rowHeightSet);

  };
  /**
  * @return drawing file string
  */


  LuckyFile.prototype.getDrawingFile = function (rid, sheetFile) {
    var sheetRelsPath = "xl/worksheets/_rels/";
    var sheetFileArr = sheetFile.split("/");
    var sheetRelsName = sheetFileArr[sheetFileArr.length - 1];
    var sheetRelsFile = sheetRelsPath + sheetRelsName + ".rels";
    var drawing = this.readXml.getElementsByTagName("Relationships/Relationship", sheetRelsFile);

    if (drawing.length > 0) {
      for (var i = 0; i < drawing.length; i++) {
        var relationship = drawing[i];
        var attrList = relationship.attributeList;
        var relationshipId = method_1.getXmlAttibute(attrList, "Id", null);

        if (relationshipId == rid) {
          var target = method_1.getXmlAttibute(attrList, "Target", null);

          if (target != null) {
            return target.replace(/\.\.\//g, "");
          }
        }
      }
    }

    return null;
  };

  LuckyFile.prototype.getDrawingRelsFile = function (drawingFile) {
    var drawingRelsPath = "xl/drawings/_rels/";
    var drawingFileArr = drawingFile.split("/");
    var drawingRelsName = drawingFileArr[drawingFileArr.length - 1];
    var drawingRelsFile = drawingRelsPath + drawingRelsName + ".rels";
    return drawingRelsFile;
  };
  /**
  * @return All sheet base information widthout cell and config
  */


  LuckyFile.prototype.getSheetsWithoutCell = function () {
    this.getSheetsFull(false);
  };
  /**
  * @return LuckySheet file json
  */


  LuckyFile.prototype.Parse = function () {
    // let xml = this.readXml;
    // for(let key in this.sheetNameList){
    //     let sheetName=this.sheetNameList[key];
    //     let sheetColumns = xml.getElementsByTagName("row/c/f", sheetName);
    //     console.log(sheetColumns);
    // }
    // return "";
    this.getWorkBookInfo();
    this.getSheetsFull(); // for(let i=0;i<this.sheets.length;i++){
    //     let sheet = this.sheets[i];
    //     let _borderInfo = sheet.config._borderInfo;
    //     if(_borderInfo==null){
    //         continue;
    //     }
    //     let _borderInfoKeys = Object.keys(_borderInfo);
    //     _borderInfoKeys.sort();
    //     for(let a=0;a<_borderInfoKeys.length;a++){
    //         let key = parseInt(_borderInfoKeys[a]);
    //         let b = _borderInfo[key];
    //         if(b.cells.length==0){
    //             continue;
    //         }
    //         if(sheet.config.borderInfo==null){
    //             sheet.config.borderInfo = [];
    //         }
    //         sheet.config.borderInfo.push(b);
    //     }
    // }

    return this.toJsonString(this);
  };

  LuckyFile.prototype.toJsonString = function (file) {
    var LuckyOutPutFile = new LuckyBase_1.LuckyFileBase();
    LuckyOutPutFile.info = file.info;
    LuckyOutPutFile.sheets = [];
    file.sheets.forEach(function (sheet) {
      var sheetout = new LuckyBase_1.LuckySheetBase(); //let attrName = ["name","color","config","index","status","order","row","column","luckysheet_select_save","scrollLeft","scrollTop","zoomRatio","showGridLines","defaultColWidth","defaultRowHeight","celldata","chart","isPivotTable","pivotTable","luckysheet_conditionformat_save","freezen","calcChain"];

      if (sheet.name != null) {
        sheetout.name = sheet.name;
      }

      if (sheet.color != null) {
        sheetout.color = sheet.color;
      }

      if (sheet.config != null) {
        sheetout.config = sheet.config; // if(sheetout.config._borderInfo!=null){
        //     delete sheetout.config._borderInfo;
        // }
      }

      if (sheet.index != null) {
        sheetout.index = sheet.index;
      }

      if (sheet.status != null) {
        sheetout.status = sheet.status;
      }

      if (sheet.order != null) {
        sheetout.order = sheet.order;
      }

      if (sheet.row != null) {
        sheetout.row = sheet.row;
      }

      if (sheet.column != null) {
        sheetout.column = sheet.column;
      }

      if (sheet.luckysheet_select_save != null) {
        sheetout.luckysheet_select_save = sheet.luckysheet_select_save;
      }

      if (sheet.scrollLeft != null) {
        sheetout.scrollLeft = sheet.scrollLeft;
      }

      if (sheet.scrollTop != null) {
        sheetout.scrollTop = sheet.scrollTop;
      }

      if (sheet.zoomRatio != null) {
        sheetout.zoomRatio = sheet.zoomRatio;
      }

      if (sheet.showGridLines != null) {
        sheetout.showGridLines = sheet.showGridLines;
      }

      if (sheet.defaultColWidth != null) {
        sheetout.defaultColWidth = sheet.defaultColWidth;
      }

      if (sheet.defaultRowHeight != null) {
        sheetout.defaultRowHeight = sheet.defaultRowHeight;
      }

      if (sheet.lastContentData != null) {
        sheetout.lastContentData = sheet.lastContentData;
      }

      if (sheet.celldata != null) {
        // sheetout.celldata = sheet.celldata;
        sheetout.celldata = [];
        sheet.celldata.forEach(function (cell) {
          var cellout = new LuckyBase_1.LuckySheetCelldataBase();
          cellout.r = cell.r;
          cellout.c = cell.c;
          cellout.v = cell.v;
          sheetout.celldata.push(cellout);
        });
      }

      if (sheet.chart != null) {
        sheetout.chart = sheet.chart;
      }

      if (sheet.isPivotTable != null) {
        sheetout.isPivotTable = sheet.isPivotTable;
      }

      if (sheet.pivotTable != null) {
        sheetout.pivotTable = sheet.pivotTable;
      }

      if (sheet.luckysheet_conditionformat_save != null) {
        sheetout.luckysheet_conditionformat_save = sheet.luckysheet_conditionformat_save;
      }

      if (sheet.freezen != null) {
        sheetout.freezen = sheet.freezen;
      }

      if (sheet.calcChain != null) {
        sheetout.calcChain = sheet.calcChain;
      }

      if (sheet.images != null) {
        sheetout.images = sheet.images;
      }

      if (sheet.dataVerification != null) {
        sheetout.dataVerification = sheet.dataVerification;
      }

      if (sheet.hyperlink != null) {
        sheetout.hyperlink = sheet.hyperlink;
      }

      if (sheet.hide != null) {
        sheetout.hide = sheet.hide;
      }

      LuckyOutPutFile.sheets.push(sheetout);
    });
    return JSON.stringify(LuckyOutPutFile);
  };

  return LuckyFile;
}(LuckyBase_1.LuckyFileBase);

exports.LuckyFile = LuckyFile;

},{"../common/constant":92,"../common/method":94,"./LuckyBase":86,"./LuckyImage":89,"./LuckySheet":90,"./ReadXml":91}],89:[function(require,module,exports){
"use strict";

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ImageList = void 0;

var LuckyBase_1 = require("./LuckyBase");

var emf_1 = require("../common/emf");

var ImageList =
/** @class */
function () {
  function ImageList(files) {
    if (files == null) {
      return;
    }

    this.images = {};

    for (var fileKey in files) {
      // let reg = new RegExp("xl/media/image1.png", "g");
      if (fileKey.indexOf("xl/media/") > -1) {
        var fileNameArr = fileKey.split(".");
        var suffix = fileNameArr[fileNameArr.length - 1].toLowerCase();

        if (suffix in {
          "png": 1,
          "jpeg": 1,
          "jpg": 1,
          "gif": 1,
          "bmp": 1,
          "tif": 1,
          "webp": 1,
          "emf": 1
        }) {
          if (suffix == "emf") {
            var pNum = 0; // number of the page, that you want to render

            var scale = 1; // the scale of the document

            var wrt = new emf_1.ToContext2D(pNum, scale);
            var inp, out, stt;
            emf_1.FromEMF.K = [];
            inp = emf_1.FromEMF.C;
            out = emf_1.FromEMF.K;
            stt = 4;

            for (var p in inp) {
              out[inp[p]] = p.slice(stt);
            }

            emf_1.FromEMF.Parse(files[fileKey], wrt);
            this.images[fileKey] = wrt.canvas.toDataURL("image/png");
          } else {
            this.images[fileKey] = files[fileKey];
          }
        }
      }
    }
  }

  ImageList.prototype.getImageByName = function (pathName) {
    if (pathName in this.images) {
      var base64 = this.images[pathName];
      return new Image(pathName, base64);
    }

    return null;
  };

  return ImageList;
}();

exports.ImageList = ImageList;

var Image =
/** @class */
function (_super) {
  __extends(Image, _super);

  function Image(pathName, base64) {
    var _this = _super.call(this) || this;

    _this.src = base64;
    return _this;
  }

  Image.prototype.setDefault = function () {};

  return Image;
}(LuckyBase_1.LuckyImageBase);

},{"../common/emf":93,"./LuckyBase":86}],90:[function(require,module,exports){
"use strict";

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LuckySheet = void 0;

var LuckyCell_1 = require("./LuckyCell");

var method_1 = require("../common/method");

var constant_1 = require("../common/constant");

var ReadXml_1 = require("./ReadXml");

var LuckyBase_1 = require("./LuckyBase");

var dayjs_1 = __importDefault(require("dayjs"));

var LuckySheet =
/** @class */
function (_super) {
  __extends(LuckySheet, _super); // private lastContentData: {r: 0, c: 0};


  function LuckySheet(sheetName, sheetId, sheetOrder, isInitialCell, allFileOption) {
    if (isInitialCell === void 0) {
      isInitialCell = false;
    }

    var _this = //Private
    _super.call(this) || this;

    _this.isInitialCell = isInitialCell;
    _this.readXml = allFileOption.readXml;
    _this.sheetFile = allFileOption.sheetFile;
    _this.styles = allFileOption.styles;
    _this.sharedStrings = allFileOption.sharedStrings;
    _this.calcChainEles = allFileOption.calcChain;
    _this.sheetList = allFileOption.sheetList;
    _this.imageList = allFileOption.imageList;
    _this.hide = allFileOption.hide; //Output

    _this.name = sheetName;
    _this.index = sheetId;
    _this.order = sheetOrder.toString();
    _this.config = new LuckyBase_1.LuckyConfig();
    _this.celldata = [];
    _this.mergeCells = _this.readXml.getElementsByTagName("mergeCells/mergeCell", _this.sheetFile);
    var clrScheme = _this.styles["clrScheme"];

    var sheetView = _this.readXml.getElementsByTagName("sheetViews/sheetView", _this.sheetFile);

    var showGridLines = "1",
        tabSelected = "0",
        zoomScale = "100",
        activeCell = "A1";

    if (sheetView.length > 0) {
      var attrList = sheetView[0].attributeList;
      showGridLines = method_1.getXmlAttibute(attrList, "showGridLines", "1");
      tabSelected = method_1.getXmlAttibute(attrList, "tabSelected", "0");
      zoomScale = method_1.getXmlAttibute(attrList, "zoomScale", "100"); // let colorId = getXmlAttibute(attrList, "colorId", "0");

      var selections = sheetView[0].getInnerElements("selection");

      if (selections != null && selections.length > 0) {
        activeCell = method_1.getXmlAttibute(selections[0].attributeList, "activeCell", "A1");
        var range = method_1.getcellrange(activeCell, _this.sheetList, sheetId);
        _this.luckysheet_select_save = [];

        _this.luckysheet_select_save.push(range);
      }
    }

    _this.showGridLines = showGridLines;
    _this.status = tabSelected;
    _this.zoomRatio = parseInt(zoomScale) / 100;

    var tabColors = _this.readXml.getElementsByTagName("sheetPr/tabColor", _this.sheetFile);

    if (tabColors != null && tabColors.length > 0) {
      var tabColor = tabColors[0],
          attrList = tabColor.attributeList; // if(attrList.rgb!=null){

      var tc = ReadXml_1.getColor(tabColor, _this.styles, "b");
      _this.color = tc; // }
    }

    var sheetFormatPr = _this.readXml.getElementsByTagName("sheetFormatPr", _this.sheetFile);

    var defaultColWidth, defaultRowHeight;

    if (sheetFormatPr.length > 0) {
      var attrList = sheetFormatPr[0].attributeList;
      defaultColWidth = method_1.getXmlAttibute(attrList, "defaultColWidth", "9.21");
      defaultRowHeight = method_1.getXmlAttibute(attrList, "defaultRowHeight", "19");
    }

    _this.defaultColWidth = method_1.getColumnWidthPixel(parseFloat(defaultColWidth));
    _this.defaultRowHeight = method_1.getRowHeightPixel(parseFloat(defaultRowHeight));

    _this.generateConfigColumnLenAndHidden();

    var cellOtherInfo = _this.generateConfigRowLenAndHiddenAddCell();

    if (_this.calcChain == null) {
      _this.calcChain = [];
    }

    var formulaListExist = {};

    for (var c = 0; c < _this.calcChainEles.length; c++) {
      var calcChainEle = _this.calcChainEles[c],
          attrList = calcChainEle.attributeList;

      if (attrList.i != sheetId) {
        continue;
      }

      var r = attrList.r,
          i = attrList.i,
          l = attrList.l,
          s = attrList.s,
          a = attrList.a,
          t = attrList.t;
      var range = method_1.getcellrange(r);
      var chain = new LuckyBase_1.LuckysheetCalcChain();
      chain.r = range.row[0];
      chain.c = range.column[0];
      chain.index = _this.index;

      _this.calcChain.push(chain);

      formulaListExist["r" + r + "c" + c] = null;
    }

    if (_this.formulaRefList != null) {
      for (var key in _this.formulaRefList) {
        var funclist = _this.formulaRefList[key];
        var mainFunc = funclist["mainRef"],
            mainCellValue = mainFunc.cellValue;
        var formulaTxt = mainFunc.fv;
        var mainR = mainCellValue.r,
            mainC = mainCellValue.c; // let refRange = getcellrange(ref);

        for (var name_1 in funclist) {
          if (name_1 == "mainRef") {
            continue;
          }

          var funcValue = funclist[name_1],
              cellValue = funcValue.cellValue;

          if (cellValue == null) {
            continue;
          }

          var r = cellValue.r,
              c = cellValue.c;
          var func = formulaTxt;
          var offsetRow = r - mainR,
              offsetCol = c - mainC;

          if (offsetRow > 0) {
            func = "=" + method_1.fromulaRef.functionCopy(func, "down", offsetRow);
          } else if (offsetRow < 0) {
            func = "=" + method_1.fromulaRef.functionCopy(func, "up", Math.abs(offsetRow));
          }

          if (offsetCol > 0) {
            func = "=" + method_1.fromulaRef.functionCopy(func, "right", offsetCol);
          } else if (offsetCol < 0) {
            func = "=" + method_1.fromulaRef.functionCopy(func, "left", Math.abs(offsetCol));
          } // console.log(offsetRow, offsetCol, func);


          cellValue.v.f = func; //

          var chain = new LuckyBase_1.LuckysheetCalcChain();
          chain.r = cellValue.r;
          chain.c = cellValue.c;
          chain.index = _this.index;

          _this.calcChain.push(chain);
        }
      }
    } //There may be formulas that do not appear in calcChain


    for (var key in cellOtherInfo.formulaList) {
      if (!(key in formulaListExist)) {
        var formulaListItem = cellOtherInfo.formulaList[key];
        var chain = new LuckyBase_1.LuckysheetCalcChain();
        chain.r = formulaListItem.r;
        chain.c = formulaListItem.c;
        chain.index = _this.index;

        _this.calcChain.push(chain);
      }
    } // dataVerification config


    _this.dataVerification = _this.generateConfigDataValidations(); // hyperlink config

    _this.hyperlink = _this.generateConfigHyperlinks(); // sheet hide

    _this.hide = _this.hide;

    if (_this.mergeCells != null) {
      for (var i = 0; i < _this.mergeCells.length; i++) {
        var merge = _this.mergeCells[i],
            attrList = merge.attributeList;
        var ref = attrList.ref;

        if (ref == null) {
          continue;
        }

        var range = method_1.getcellrange(ref, _this.sheetList, sheetId);
        var mergeValue = new LuckyBase_1.LuckySheetConfigMerge();
        mergeValue.r = range.row[0];
        mergeValue.c = range.column[0];
        mergeValue.rs = range.row[1] - range.row[0] + 1;
        mergeValue.cs = range.column[1] - range.column[0] + 1;

        if (_this.config.merge == null) {
          _this.config.merge = {};
        }

        _this.config.merge[range.row[0] + "_" + range.column[0]] = mergeValue;
      }
    }

    var drawingFile = allFileOption.drawingFile,
        drawingRelsFile = allFileOption.drawingRelsFile;

    if (drawingFile != null && drawingRelsFile != null) {
      var twoCellAnchors = _this.readXml.getElementsByTagName("xdr:twoCellAnchor", drawingFile);

      if (twoCellAnchors != null && twoCellAnchors.length > 0) {
        for (var i = 0; i < twoCellAnchors.length; i++) {
          var twoCellAnchor = twoCellAnchors[i];
          var editAs = method_1.getXmlAttibute(twoCellAnchor.attributeList, "editAs", "twoCell");
          var xdrFroms = twoCellAnchor.getInnerElements("xdr:from"),
              xdrTos = twoCellAnchor.getInnerElements("xdr:to");
          var xdr_blipfills = twoCellAnchor.getInnerElements("a:blip");

          if (xdrFroms != null && xdr_blipfills != null && xdrFroms.length > 0 && xdr_blipfills.length > 0) {
            var xdrFrom = xdrFroms[0],
                xdrTo = xdrTos[0],
                xdr_blipfill = xdr_blipfills[0];
            var rembed = method_1.getXmlAttibute(xdr_blipfill.attributeList, "r:embed", null);

            var imageObject = _this.getBase64ByRid(rembed, drawingRelsFile); // let aoff = xdr_xfrm.getInnerElements("a:off"), aext = xdr_xfrm.getInnerElements("a:ext");
            // if(aoff!=null && aext!=null && aoff.length>0 && aext.length>0){
            //     let aoffAttribute = aoff[0].attributeList, aextAttribute = aext[0].attributeList;
            //     let x = getXmlAttibute(aoffAttribute, "x", null);
            //     let y = getXmlAttibute(aoffAttribute, "y", null);
            //     let cx = getXmlAttibute(aextAttribute, "cx", null);
            //     let cy = getXmlAttibute(aextAttribute, "cy", null);
            //     if(x!=null && y!=null && cx!=null && cy!=null && imageObject !=null){
            // let x_n = getPxByEMUs(parseInt(x), "c"),y_n = getPxByEMUs(parseInt(y));
            // let cx_n = getPxByEMUs(parseInt(cx), "c"),cy_n = getPxByEMUs(parseInt(cy));


            var x_n = 0,
                y_n = 0;
            var cx_n = 0,
                cy_n = 0;
            imageObject.fromCol = _this.getXdrValue(xdrFrom.getInnerElements("xdr:col"));
            imageObject.fromColOff = method_1.getPxByEMUs(_this.getXdrValue(xdrFrom.getInnerElements("xdr:colOff")));
            imageObject.fromRow = _this.getXdrValue(xdrFrom.getInnerElements("xdr:row"));
            imageObject.fromRowOff = method_1.getPxByEMUs(_this.getXdrValue(xdrFrom.getInnerElements("xdr:rowOff")));
            imageObject.toCol = _this.getXdrValue(xdrTo.getInnerElements("xdr:col"));
            imageObject.toColOff = method_1.getPxByEMUs(_this.getXdrValue(xdrTo.getInnerElements("xdr:colOff")));
            imageObject.toRow = _this.getXdrValue(xdrTo.getInnerElements("xdr:row"));
            imageObject.toRowOff = method_1.getPxByEMUs(_this.getXdrValue(xdrTo.getInnerElements("xdr:rowOff")));
            imageObject.originWidth = cx_n;
            imageObject.originHeight = cy_n;

            if (editAs == "absolute") {
              imageObject.type = "3";
            } else if (editAs == "oneCell") {
              imageObject.type = "2";
            } else {
              imageObject.type = "1";
            }

            imageObject.isFixedPos = false;
            imageObject.fixedLeft = 0;
            imageObject.fixedTop = 0;
            var imageBorder = {
              color: "#000",
              radius: 0,
              style: "solid",
              width: 0
            };
            imageObject.border = imageBorder;
            var imageCrop = {
              height: cy_n,
              offsetLeft: 0,
              offsetTop: 0,
              width: cx_n
            };
            imageObject.crop = imageCrop;
            var imageDefault = {
              height: cy_n,
              left: x_n,
              top: y_n,
              width: cx_n
            };
            imageObject["default"] = imageDefault;

            if (_this.images == null) {
              _this.images = {};
            }

            _this.images[method_1.generateRandomIndex("image")] = imageObject; //     }
            // }
          }
        }
      }
    }

    return _this;
  }

  LuckySheet.prototype.getXdrValue = function (ele) {
    if (ele == null || ele.length == 0) {
      return null;
    }

    return parseInt(ele[0].value);
  };

  LuckySheet.prototype.getBase64ByRid = function (rid, drawingRelsFile) {
    var Relationships = this.readXml.getElementsByTagName("Relationships/Relationship", drawingRelsFile);

    if (Relationships != null && Relationships.length > 0) {
      for (var i = 0; i < Relationships.length; i++) {
        var Relationship = Relationships[i];
        var attrList = Relationship.attributeList;
        var Id = method_1.getXmlAttibute(attrList, "Id", null);
        var src = method_1.getXmlAttibute(attrList, "Target", null);

        if (Id == rid) {
          src = src.replace(/\.\.\//g, "");
          src = "xl/" + src;
          var imgage = this.imageList.getImageByName(src);
          return imgage;
        }
      }
    }

    return null;
  };
  /**
  * @desc This will convert cols/col to luckysheet config of column'width
  */


  LuckySheet.prototype.generateConfigColumnLenAndHidden = function () {
    var cols = this.readXml.getElementsByTagName("cols/col", this.sheetFile);

    for (var i = 0; i < cols.length; i++) {
      var col = cols[i],
          attrList = col.attributeList;
      var min = method_1.getXmlAttibute(attrList, "min", null);
      var max = method_1.getXmlAttibute(attrList, "max", null);
      var width = method_1.getXmlAttibute(attrList, "width", null);
      var hidden = method_1.getXmlAttibute(attrList, "hidden", null);
      var customWidth = method_1.getXmlAttibute(attrList, "customWidth", null);

      if (min == null || max == null) {
        continue;
      }

      var minNum = parseInt(min) - 1,
          maxNum = parseInt(max) - 1,
          widthNum = parseFloat(width);

      for (var m = minNum; m <= maxNum; m++) {
        if (width != null) {
          if (this.config.columnlen == null) {
            this.config.columnlen = {};
          }

          this.config.columnlen[m] = method_1.getColumnWidthPixel(widthNum);
        }

        if (hidden == "1") {
          if (this.config.colhidden == null) {
            this.config.colhidden = {};
          }

          this.config.colhidden[m] = 0;

          if (this.config.columnlen) {
            delete this.config.columnlen[m];
          }
        }

        if (customWidth != null) {
          if (this.config.customWidth == null) {
            this.config.customWidth = {};
          }

          this.config.customWidth[m] = 1;
        }
      }
    }
  };
  /**
  * @desc This will convert cols/col to luckysheet config of column'width
  */


  LuckySheet.prototype.generateConfigRowLenAndHiddenAddCell = function () {
    var rows = this.readXml.getElementsByTagName("sheetData/row", this.sheetFile);
    var cellOtherInfo = {};
    var formulaList = {};
    cellOtherInfo.formulaList = formulaList;

    for (var i = 0; i < rows.length; i++) {
      var row = rows[i],
          attrList = row.attributeList;
      var rowNo = method_1.getXmlAttibute(attrList, "r", null);
      var height = method_1.getXmlAttibute(attrList, "ht", null);
      var hidden = method_1.getXmlAttibute(attrList, "hidden", null);
      var customHeight = method_1.getXmlAttibute(attrList, "customHeight", null);

      if (rowNo == null) {
        continue;
      }

      var rowNoNum = parseInt(rowNo) - 1;

      if (height != null) {
        var heightNum = parseFloat(height);

        if (this.config.rowlen == null) {
          this.config.rowlen = {};
        }

        this.config.rowlen[rowNoNum] = method_1.getRowHeightPixel(heightNum);
      }

      if (hidden == "1") {
        if (this.config.rowhidden == null) {
          this.config.rowhidden = {};
        }

        this.config.rowhidden[rowNoNum] = 0;

        if (this.config.rowlen) {
          delete this.config.rowlen[rowNoNum];
        }
      }

      if (customHeight != null) {
        if (this.config.customHeight == null) {
          this.config.customHeight = {};
        }

        this.config.customHeight[rowNoNum] = 1;
      }

      if (this.isInitialCell) {
        var cells = row.getInnerElements("c");

        for (var key in cells) {
          var cell = cells[key];
          var cellValue = new LuckyCell_1.LuckySheetCelldata(cell, this.styles, this.sharedStrings, this.mergeCells, this.sheetFile, this.readXml);

          if (cellValue._borderObject != null) {
            if (this.config.borderInfo == null) {
              this.config.borderInfo = [];
            }

            this.config.borderInfo.push(cellValue._borderObject);
            delete cellValue._borderObject;
          } // let borderId = cellValue._borderId;
          // if(borderId!=null){
          //     let borders = this.styles["borders"] as Element[];
          //     if(this.config._borderInfo==null){
          //         this.config._borderInfo = {};
          //     }
          //     if( borderId in this.config._borderInfo){
          //         this.config._borderInfo[borderId].cells.push(cellValue.r + "_" + cellValue.c);
          //     }
          //     else{
          //         let border = borders[borderId];
          //         let borderObject = new LuckySheetborderInfoCellForImp();
          //         borderObject.rangeType = "cellGroup";
          //         borderObject.cells = [];
          //         let borderCellValue = new LuckySheetborderInfoCellValue();
          //         let lefts = border.getInnerElements("left");
          //         let rights = border.getInnerElements("right");
          //         let tops = border.getInnerElements("top");
          //         let bottoms = border.getInnerElements("bottom");
          //         let diagonals = border.getInnerElements("diagonal");
          //         let left = this.getBorderInfo(lefts);
          //         let right = this.getBorderInfo(rights);
          //         let top = this.getBorderInfo(tops);
          //         let bottom = this.getBorderInfo(bottoms);
          //         let diagonal = this.getBorderInfo(diagonals);
          //         let isAdd = false;
          //         if(left!=null && left.color!=null){
          //             borderCellValue.l = left;
          //             isAdd = true;
          //         }
          //         if(right!=null && right.color!=null){
          //             borderCellValue.r = right;
          //             isAdd = true;
          //         }
          //         if(top!=null && top.color!=null){
          //             borderCellValue.t = top;
          //             isAdd = true;
          //         }
          //         if(bottom!=null && bottom.color!=null){
          //             borderCellValue.b = bottom;
          //             isAdd = true;
          //         }
          //         if(isAdd){
          //             borderObject.value = borderCellValue;
          //             this.config._borderInfo[borderId] = borderObject;
          //         }
          //     }
          // }


          if (cellValue._formulaType == "shared") {
            if (this.formulaRefList == null) {
              this.formulaRefList = {};
            }

            if (this.formulaRefList[cellValue._formulaSi] == null) {
              this.formulaRefList[cellValue._formulaSi] = {};
            }

            var fv = void 0;

            if (cellValue.v != null) {
              fv = cellValue.v.f;
            }

            var refValue = {
              t: cellValue._formulaType,
              ref: cellValue._fomulaRef,
              si: cellValue._formulaSi,
              fv: fv,
              cellValue: cellValue
            };

            if (cellValue._fomulaRef != null) {
              this.formulaRefList[cellValue._formulaSi]["mainRef"] = refValue;
            } else {
              this.formulaRefList[cellValue._formulaSi][cellValue.r + "_" + cellValue.c] = refValue;
            } // console.log(refValue, this.formulaRefList);

          } //There may be formulas that do not appear in calcChain


          if (cellValue.v != null && cellValue.v.f != null) {
            var formulaCell = {
              r: cellValue.r,
              c: cellValue.c
            };
            cellOtherInfo.formulaList["r" + cellValue.r + "c" + cellValue.c] = formulaCell;
          } // let maxcolumn = cellValue.c;
          // if (cellValue.v != null && (cellValue.v as IluckySheetCelldataValue).v != null) {
          //     if (this.lastContentData != null){
          //       let lastContentCol = this.lastContentData.c > cellValue.c ? this.lastContentData.c : cellValue.c;
          //       this.lastContentData = {r : cellValue.r, c: lastContentCol, maxcolumn: maxcolumn};
          //     }else{
          //       this.lastContentData = {r : cellValue.r, c: cellValue.c, maxcolumn: maxcolumn};
          //     }
          //   }
          //let maxcolumn = cellValue.c;
          //let lastContentCol = cellValue.c;


          if (this.lastContentData == null) {
            this.lastContentData = {
              r: cellValue.r,
              c: cellValue.c,
              maxcolumn: cellValue.c
            };
          } else {
            if (cellValue.v != null && cellValue.v.v != null) {
              var lastContentCol = this.lastContentData.c > cellValue.c ? this.lastContentData.c : cellValue.c;
              this.lastContentData.c = lastContentCol;
              this.lastContentData.r = cellValue.r;
            }

            var maxcolumn = this.lastContentData.maxcolumn > cellValue.c ? this.lastContentData.maxcolumn : cellValue.c;
            this.lastContentData.maxcolumn = maxcolumn;
          }

          this.celldata.push(cellValue);
        }
      }
    }

    return cellOtherInfo;
  };
  /**
   * luckysheet config of dataValidations
   *
   * @returns {IluckysheetDataVerification} - dataValidations config
   */


  LuckySheet.prototype.generateConfigDataValidations = function () {
    var rows = this.readXml.getElementsByTagName("dataValidations/dataValidation", this.sheetFile);
    var extLst = this.readXml.getElementsByTagName("extLst/ext/x14:dataValidations/x14:dataValidation", this.sheetFile) || [];
    rows = rows.concat(extLst);
    var dataVerification = {};

    for (var i = 0; i < rows.length; i++) {
      var row = rows[i];
      var attrList = row.attributeList;
      var formulaValue = row.value;
      var type = method_1.getXmlAttibute(attrList, "type", null);

      if (!type) {
        continue;
      }

      var operator = "",
          sqref = "",
          sqrefIndexArr = [],
          valueArr = [];

      var _prohibitInput = method_1.getXmlAttibute(attrList, "allowBlank", null) !== "1" ? false : true; // x14 processing


      var formulaReg = new RegExp(/<x14:formula1>|<xm:sqref>/g);

      if (formulaReg.test(formulaValue) && (extLst === null || extLst === void 0 ? void 0 : extLst.length) >= 0) {
        operator = method_1.getXmlAttibute(attrList, "operator", null);
        var peelOffData = method_1.getPeelOffX14(formulaValue);
        sqref = peelOffData === null || peelOffData === void 0 ? void 0 : peelOffData.sqref;
        sqrefIndexArr = method_1.getMultiSequenceToNum(sqref);
        valueArr = method_1.getMultiFormulaValue(peelOffData === null || peelOffData === void 0 ? void 0 : peelOffData.formula);
      } else {
        operator = method_1.getXmlAttibute(attrList, "operator", null);
        sqref = method_1.getXmlAttibute(attrList, "sqref", null);
        sqrefIndexArr = method_1.getMultiSequenceToNum(sqref);
        valueArr = method_1.getMultiFormulaValue(formulaValue);
      }

      var _type = constant_1.DATA_VERIFICATION_MAP[type];
      var _type2 = null;

      var _value1 = (valueArr === null || valueArr === void 0 ? void 0 : valueArr.length) >= 1 ? valueArr[0] : "";

      var _value2 = (valueArr === null || valueArr === void 0 ? void 0 : valueArr.length) === 2 ? valueArr[1] : "";

      var _hint = method_1.getXmlAttibute(attrList, "prompt", null);

      var _hintShow = _hint ? true : false;

      var matchType = constant_1.COMMON_TYPE2.includes(_type) ? "common" : _type; // _type2 = operator
      //   ? DATA_VERIFICATION_TYPE2_MAP[matchType][operator]
      //   : "bw";

      if (constant_1.DATA_VERIFICATION_TYPE2_MAP[matchType] != undefined) {
        _type2 = operator ? constant_1.DATA_VERIFICATION_TYPE2_MAP[matchType][operator] : "bw"; // mobile phone number processing
      } else {
        _type2 = "bw";
      } // mobile phone number processing


      if (_type === "text_content" && ((_value1 === null || _value1 === void 0 ? void 0 : _value1.includes("LEN")) || (_value1 === null || _value1 === void 0 ? void 0 : _value1.includes("len"))) && (_value1 === null || _value1 === void 0 ? void 0 : _value1.includes("=11"))) {
        _type = "validity";
        _type2 = "phone";
      } // date processing


      if (_type === "date") {
        var D1900 = new Date(1899, 11, 30, 0, 0, 0);
        _value1 = dayjs_1["default"](D1900).clone().add(Number(_value1), "day").format("YYYY-MM-DD");
        _value2 = dayjs_1["default"](D1900).clone().add(Number(_value2), "day").format("YYYY-MM-DD");
      } // checkbox and dropdown processing


      if (_type === "checkbox" || _type === "dropdown") {
        _type2 = null;
      } // dynamically add dataVerifications


      for (var _i = 0, sqrefIndexArr_1 = sqrefIndexArr; _i < sqrefIndexArr_1.length; _i++) {
        var ref = sqrefIndexArr_1[_i];
        dataVerification[ref] = {
          type: _type,
          type2: _type2,
          value1: _value1,
          value2: _value2,
          checked: false,
          remote: false,
          prohibitInput: _prohibitInput,
          hintShow: _hintShow,
          hintText: _hint
        };
      }
    }

    return dataVerification;
  };
  /**
   * luckysheet config of hyperlink
   *
   * @returns {IluckysheetHyperlink} - hyperlink config
   */


  LuckySheet.prototype.generateConfigHyperlinks = function () {
    var _a;

    var rows = this.readXml.getElementsByTagName("hyperlinks/hyperlink", this.sheetFile);
    var hyperlink = {};

    var _loop_1 = function _loop_1(i) {
      var row = rows[i];
      var attrList = row.attributeList;

      var ref = method_1.getXmlAttibute(attrList, "ref", null),
          refArr = method_1.getMultiSequenceToNum(ref),
          _display = method_1.getXmlAttibute(attrList, "display", null),
          _address = method_1.getXmlAttibute(attrList, "location", null),
          _tooltip = method_1.getXmlAttibute(attrList, "tooltip", null);

      var _type = _address ? "internal" : "external"; // external hyperlink


      if (!_address) {
        var rid_1 = attrList["r:id"];
        var sheetFile = this_1.sheetFile;
        var relationshipList = this_1.readXml.getElementsByTagName("Relationships/Relationship", "xl/worksheets/_rels/" + sheetFile.replace(constant_1.worksheetFilePath, "") + ".rels");
        var findRid = relationshipList === null || relationshipList === void 0 ? void 0 : relationshipList.find(function (e) {
          return e.attributeList["Id"] === rid_1;
        });

        if (findRid) {
          _address = findRid.attributeList["Target"];
          _type = (_a = findRid.attributeList["TargetMode"]) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase();
        }
      } // match R1C1


      var addressReg = new RegExp(/^.*!R([\d$])+C([\d$])*$/g);

      if (addressReg.test(_address)) {
        _address = method_1.getTransR1C1ToSequence(_address);
      } // dynamically add hyperlinks


      for (var _i = 0, refArr_1 = refArr; _i < refArr_1.length; _i++) {
        var ref_1 = refArr_1[_i];
        hyperlink[ref_1] = {
          linkAddress: _address,
          linkTooltip: _tooltip || "",
          linkType: _type,
          display: _display || ""
        };
      }
    };

    var this_1 = this;

    for (var i = 0; i < rows.length; i++) {
      _loop_1(i);
    }

    return hyperlink;
  };

  return LuckySheet;
}(LuckyBase_1.LuckySheetBase);

exports.LuckySheet = LuckySheet;

},{"../common/constant":92,"../common/method":94,"./LuckyBase":86,"./LuckyCell":87,"./ReadXml":91,"dayjs":5}],91:[function(require,module,exports){
"use strict";

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  return function (d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getlineStringAttr = exports.getColor = exports.Element = exports.ReadXml = void 0;

var constant_1 = require("../common/constant");

var method_1 = require("../common/method");

var xmloperation =
/** @class */
function () {
  function xmloperation() {}
  /**
  * @param tag Search xml tag name , div,title etc.
  * @param file Xml string
  * @return Xml element string
  */


  xmloperation.prototype.getElementsByOneTag = function (tag, file) {
    //<a:[^/>: ]+?>.*?</a:[^/>: ]+?>
    var readTagReg;

    if (tag.indexOf("|") > -1) {
      var tags = tag.split("|"),
          tagsRegTxt = "";

      for (var i = 0; i < tags.length; i++) {
        var t = tags[i];
        tagsRegTxt += "|<" + t + " [^>]+?[^/]>[\\s\\S]*?</" + t + ">|<" + t + " [^>]+?/>|<" + t + ">[\\s\\S]*?</" + t + ">|<" + t + "/>";
      }

      tagsRegTxt = tagsRegTxt.substr(1, tagsRegTxt.length);
      readTagReg = new RegExp(tagsRegTxt, "g");
    } else {
      readTagReg = new RegExp("<" + tag + " [^>]+?[^/]>[\\s\\S]*?</" + tag + ">|<" + tag + " [^>]+?/>|<" + tag + ">[\\s\\S]*?</" + tag + ">|<" + tag + "/>", "g");
    }

    var ret = file.match(readTagReg);

    if (ret == null) {
      return [];
    } else {
      return ret;
    }
  };

  return xmloperation;
}();

var ReadXml =
/** @class */
function (_super) {
  __extends(ReadXml, _super);

  function ReadXml(files) {
    var _this = _super.call(this) || this;

    _this.originFile = files;
    return _this;
  }
  /**
  * @param path Search xml tag group , div,title etc.
  * @param fileName One of uploadfileList, uploadfileList is file group, {key:value}
  * @return Xml element calss
  */


  ReadXml.prototype.getElementsByTagName = function (path, fileName) {
    var file = this.getFileByName(fileName);
    var pathArr = path.split("/"),
        ret;

    for (var key in pathArr) {
      var path_1 = pathArr[key];

      if (ret == undefined) {
        ret = this.getElementsByOneTag(path_1, file);
      } else {
        if (ret instanceof Array) {
          var items = [];

          for (var key_1 in ret) {
            var item = ret[key_1];
            items = items.concat(this.getElementsByOneTag(path_1, item));
          }

          ret = items;
        } else {
          ret = this.getElementsByOneTag(path_1, ret);
        }
      }
    }

    var elements = [];

    for (var i = 0; i < ret.length; i++) {
      var ele = new Element(ret[i]);
      elements.push(ele);
    }

    return elements;
  };
  /**
  * @param name One of uploadfileList's name, search for file by this parameter
  * @retrun Select a file from uploadfileList
  */


  ReadXml.prototype.getFileByName = function (name) {
    for (var fileKey in this.originFile) {
      if (fileKey.indexOf(name) > -1) {
        return this.originFile[fileKey];
      }
    }

    return "";
  };

  return ReadXml;
}(xmloperation);

exports.ReadXml = ReadXml;

var Element =
/** @class */
function (_super) {
  __extends(Element, _super);

  function Element(str) {
    var _this = _super.call(this) || this;

    _this.elementString = str;

    _this.setValue();

    var readAttrReg = new RegExp('[a-zA-Z0-9_:]*?=".*?"', "g");

    var attrList = _this.container.match(readAttrReg);

    _this.attributeList = {};

    if (attrList != null) {
      for (var key in attrList) {
        var attrFull = attrList[key]; // let al= attrFull.split("=");

        if (attrFull.length == 0) {
          continue;
        }

        var attrKey = attrFull.substr(0, attrFull.indexOf('='));
        var attrValue = attrFull.substr(attrFull.indexOf('=') + 1);

        if (attrKey == null || attrValue == null || attrKey.length == 0 || attrValue.length == 0) {
          continue;
        }

        _this.attributeList[attrKey] = attrValue.substr(1, attrValue.length - 2);
      }
    }

    return _this;
  }
  /**
  * @param name Get attribute by key in element
  * @return Single attribute
  */


  Element.prototype.get = function (name) {
    return this.attributeList[name];
  };
  /**
  * @param tag Get elements by tag in elementString
  * @return Element group
  */


  Element.prototype.getInnerElements = function (tag) {
    var ret = this.getElementsByOneTag(tag, this.elementString);
    var elements = [];

    for (var i = 0; i < ret.length; i++) {
      var ele = new Element(ret[i]);
      elements.push(ele);
    }

    if (elements.length == 0) {
      return null;
    }

    return elements;
  };
  /**
  * @desc get xml dom value and container, <container>value</container>
  */


  Element.prototype.setValue = function () {
    var str = this.elementString;

    if (str.substr(str.length - 2, 2) == "/>") {
      this.value = "";
      this.container = str;
    } else {
      var firstTag = this.getFirstTag();
      var firstTagReg = new RegExp("(<" + firstTag + " [^>]+?[^/]>)([\\s\\S]*?)</" + firstTag + ">|(<" + firstTag + ">)([\\s\\S]*?)</" + firstTag + ">", "g");
      var result = firstTagReg.exec(str);

      if (result != null) {
        if (result[1] != null) {
          this.container = result[1];
          this.value = result[2];
        } else {
          this.container = result[3];
          this.value = result[4];
        }
      }
    }
  };
  /**
  * @desc get xml dom first tag, <a><b></b></a>, get a
  */


  Element.prototype.getFirstTag = function () {
    var str = this.elementString;
    var firstTag = str.substr(0, str.indexOf(' '));

    if (firstTag == "" || firstTag.indexOf(">") > -1) {
      firstTag = str.substr(0, str.indexOf('>'));
    }

    firstTag = firstTag.substr(1, firstTag.length);
    return firstTag;
  };

  return Element;
}(xmloperation);

exports.Element = Element;

function combineIndexedColor(indexedColorsInner, indexedColors) {
  var ret = {};

  if (indexedColorsInner == null || indexedColorsInner.length == 0) {
    return indexedColors;
  }

  for (var key in indexedColors) {
    var value = indexedColors[key],
        kn = parseInt(key);
    var inner = indexedColorsInner[kn];

    if (inner == null) {
      ret[key] = value;
    } else {
      var rgb = inner.attributeList.rgb;
      ret[key] = rgb;
    }
  }

  return ret;
} //clrScheme:Element[]


function getColor(color, styles, type) {
  if (type === void 0) {
    type = "g";
  }

  var attrList = color.attributeList;
  var clrScheme = styles["clrScheme"];
  var indexedColorsInner = styles["indexedColors"];
  var mruColorsInner = styles["mruColors"];
  var indexedColorsList = combineIndexedColor(indexedColorsInner, constant_1.indexedColors);
  var indexed = attrList.indexed,
      rgb = attrList.rgb,
      theme = attrList.theme,
      tint = attrList.tint;
  var bg;

  if (indexed != null) {
    var indexedNum = parseInt(indexed);
    bg = indexedColorsList[indexedNum];

    if (bg != null) {
      bg = bg.substring(bg.length - 6, bg.length);
      bg = "#" + bg;
    }
  } else if (rgb != null) {
    rgb = rgb.substring(rgb.length - 6, rgb.length);
    bg = "#" + rgb;
  } else if (theme != null) {
    var themeNum = parseInt(theme);

    if (themeNum == 0) {
      themeNum = 1;
    } else if (themeNum == 1) {
      themeNum = 0;
    } else if (themeNum == 2) {
      themeNum = 3;
    } else if (themeNum == 3) {
      themeNum = 2;
    }

    var clrSchemeElement = clrScheme[themeNum];

    if (clrSchemeElement != null) {
      var clrs = clrSchemeElement.getInnerElements("a:sysClr|a:srgbClr");

      if (clrs != null) {
        var clr = clrs[0];
        var clrAttrList = clr.attributeList; // console.log(clr.container, );

        if (clr.container.indexOf("sysClr") > -1) {
          // if(type=="g" && clrAttrList.val=="windowText"){
          //     bg = null;
          // }
          // else if((type=="t" || type=="b") && clrAttrList.val=="window"){
          //     bg = null;
          // }                    
          // else 
          if (clrAttrList.lastClr != null) {
            bg = "#" + clrAttrList.lastClr;
          } else if (clrAttrList.val != null) {
            bg = "#" + clrAttrList.val;
          }
        } else if (clr.container.indexOf("srgbClr") > -1) {
          // console.log(clrAttrList.val);
          bg = "#" + clrAttrList.val;
        }
      }
    }
  }

  if (tint != null) {
    var tintNum = parseFloat(tint);

    if (bg != null) {
      bg = method_1.LightenDarkenColor(bg, tintNum);
    }
  }

  return bg;
}

exports.getColor = getColor;
/**
 * @dom xml attribute object
 * @attr attribute name
 * @d if attribute is null, return default value
 * @return attribute value
*/

function getlineStringAttr(frpr, attr) {
  var attrEle = frpr.getInnerElements(attr),
      value;

  if (attrEle != null && attrEle.length > 0) {
    if (attr == "b" || attr == "i" || attr == "strike") {
      value = "1";
    } else if (attr == "u") {
      var v = attrEle[0].attributeList.val;

      if (v == "double") {
        value = "2";
      } else if (v == "singleAccounting") {
        value = "3";
      } else if (v == "doubleAccounting") {
        value = "4";
      } else {
        value = "1";
      }
    } else if (attr == "vertAlign") {
      var v = attrEle[0].attributeList.val;

      if (v == "subscript") {
        value = "1";
      } else if (v == "superscript") {
        value = "2";
      }
    } else {
      value = attrEle[0].attributeList.val;
    }
  }

  return value;
}

exports.getlineStringAttr = getlineStringAttr;

},{"../common/constant":92,"../common/method":94}],92:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DATA_VERIFICATION_TYPE2_MAP = exports.COMMON_TYPE2 = exports.DATA_VERIFICATION_MAP = exports.fontFamilys = exports.numFmtDefaultMap = exports.borderTypes = exports.OEM_CHARSET = exports.indexedColors = exports.numFmtDefault = exports.BuiltInCellStyles = exports.ST_CellType = exports.workbookRels = exports.theme1File = exports.worksheetFilePath = exports.sharedStringsFile = exports.stylesFile = exports.calcChainFile = exports.workBookFile = exports.contentTypesFile = exports.appFile = exports.coreFile = exports.columeHeader_word_index = exports.columeHeader_word = void 0;
exports.columeHeader_word = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];
exports.columeHeader_word_index = {
  'A': 0,
  'B': 1,
  'C': 2,
  'D': 3,
  'E': 4,
  'F': 5,
  'G': 6,
  'H': 7,
  'I': 8,
  'J': 9,
  'K': 10,
  'L': 11,
  'M': 12,
  'N': 13,
  'O': 14,
  'P': 15,
  'Q': 16,
  'R': 17,
  'S': 18,
  'T': 19,
  'U': 20,
  'V': 21,
  'W': 22,
  'X': 23,
  'Y': 24,
  'Z': 25
};
exports.coreFile = "docProps/core.xml";
exports.appFile = "docProps/app.xml";
exports.contentTypesFile = "[Content_Types].xml";
exports.workBookFile = "xl/workbook.xml";
exports.calcChainFile = "xl/calcChain.xml";
exports.stylesFile = "xl/styles.xml";
exports.sharedStringsFile = "xl/sharedStrings.xml";
exports.worksheetFilePath = "xl/worksheets/";
exports.theme1File = "xl/theme/theme1.xml";
exports.workbookRels = "xl/_rels/workbook.xml.rels"; //Excel Built-In cell type

exports.ST_CellType = {
  "Boolean": "b",
  "Date": "d",
  "Error": "e",
  "InlineString": "inlineStr",
  "Number": "n",
  "SharedString": "s",
  "String": "str"
}; //Excel Built-In cell style

exports.BuiltInCellStyles = {
  "0": "Normal"
};
exports.numFmtDefault = {
  "0": 'General',
  "1": '0',
  "2": '0.00',
  "3": '#,##0',
  "4": '#,##0.00',
  "9": '0%',
  "10": '0.00%',
  "11": '0.00E+00',
  "12": '# ?/?',
  "13": '# ??/??',
  "14": 'm/d/yy',
  "15": 'd-mmm-yy',
  "16": 'd-mmm',
  "17": 'mmm-yy',
  "18": 'h:mm AM/PM',
  "19": 'h:mm:ss AM/PM',
  "20": 'h:mm',
  "21": 'h:mm:ss',
  "22": 'm/d/yy h:mm',
  "37": '#,##0 ;(#,##0)',
  "38": '#,##0 ;[Red](#,##0)',
  "39": '#,##0.00;(#,##0.00)',
  "40": '#,##0.00;[Red](#,##0.00)',
  "45": 'mm:ss',
  "46": '[h]:mm:ss',
  "47": 'mmss.0',
  "48": '##0.0E+0',
  "49": '@'
};
exports.indexedColors = {
  "0": '00000000',
  "1": '00FFFFFF',
  "2": '00FF0000',
  "3": '0000FF00',
  "4": '000000FF',
  "5": '00FFFF00',
  "6": '00FF00FF',
  "7": '0000FFFF',
  "8": '00000000',
  "9": '00FFFFFF',
  "10": '00FF0000',
  "11": '0000FF00',
  "12": '000000FF',
  "13": '00FFFF00',
  "14": '00FF00FF',
  "15": '0000FFFF',
  "16": '00800000',
  "17": '00008000',
  "18": '00000080',
  "19": '00808000',
  "20": '00800080',
  "21": '00008080',
  "22": '00C0C0C0',
  "23": '00808080',
  "24": '009999FF',
  "25": '00993366',
  "26": '00FFFFCC',
  "27": '00CCFFFF',
  "28": '00660066',
  "29": '00FF8080',
  "30": '000066CC',
  "31": '00CCCCFF',
  "32": '00000080',
  "33": '00FF00FF',
  "34": '00FFFF00',
  "35": '0000FFFF',
  "36": '00800080',
  "37": '00800000',
  "38": '00008080',
  "39": '000000FF',
  "40": '0000CCFF',
  "41": '00CCFFFF',
  "42": '00CCFFCC',
  "43": '00FFFF99',
  "44": '0099CCFF',
  "45": '00FF99CC',
  "46": '00CC99FF',
  "47": '00FFCC99',
  "48": '003366FF',
  "49": '0033CCCC',
  "50": '0099CC00',
  "51": '00FFCC00',
  "52": '00FF9900',
  "53": '00FF6600',
  "54": '00666699',
  "55": '00969696',
  "56": '00003366',
  "57": '00339966',
  "58": '00003300',
  "59": '00333300',
  "60": '00993300',
  "61": '00993366',
  "62": '00333399',
  "63": '00333333',
  "64": null,
  "65": null
};
exports.OEM_CHARSET = {
  "0": "ANSI_CHARSET",
  "1": "DEFAULT_CHARSET",
  "2": "SYMBOL_CHARSET",
  "77": "MAC_CHARSET",
  "128": "SHIFTJIS_CHARSET",
  "129": "HANGUL_CHARSET",
  "130": "JOHAB_CHARSET",
  "134": "GB2312_CHARSET",
  "136": "CHINESEBIG5_CHARSET",
  "161": "GREEK_CHARSET",
  "162": "TURKISH_CHARSET",
  "163": "VIETNAMESE_CHARSET",
  "177": "HEBREW_CHARSET",
  "178": "ARABIC_CHARSET",
  "186": "BALTIC_CHARSET",
  "204": "RUSSIAN_CHARSET",
  "222": "THAI_CHARSET",
  "238": "EASTEUROPE_CHARSET",
  "255": "OEM_CHARSET"
};
exports.borderTypes = {
  "none": 0,
  "thin": 1,
  "hair": 2,
  "dotted": 3,
  "dashed": 4,
  "dashDot": 5,
  "dashDotDot": 6,
  "double": 7,
  "medium": 8,
  "mediumDashed": 9,
  "mediumDashDot": 10,
  "mediumDashDotDot": 11,
  "slantDashDot": 12,
  "thick": 13
};
exports.numFmtDefaultMap = {
  "yyyy/m/d;@": "yyyy/MM/dd",
  "yyyy&quot;&quot;m&quot;&quot;d&quot;&quot;;@": "yyyy&quot;&quot;MM&quot;&quot;dd&quot;&quot;",
  "[$-409]yyyy/m/d\\ h:mm\\ AM/PM;@": "yyyy/MM/dd hh:mm AM/PM"
};
exports.fontFamilys = {
  "0": "defualt",
  "1": "Roman",
  "2": "Swiss",
  "3": "Modern",
  "4": "Script",
  "5": "Decorative"
};
exports.DATA_VERIFICATION_MAP = {
  list: "dropdown",
  whole: "number_integer",
  decimal: "number_decimal",
  custom: "text_content",
  textLength: "text_length",
  date: "date",
  "unknown1": "number",
  "unknown2": "checkbox",
  "unknown3": "validity"
};
exports.COMMON_TYPE2 = ["number", "number_integer", "number_decimal", "text_length"];
exports.DATA_VERIFICATION_TYPE2_MAP = {
  common: {
    between: "bw",
    notBetween: "nb",
    equal: "eq",
    notEqualTo: "ne",
    moreThanThe: "gt",
    lessThan: "lt",
    greaterOrEqualTo: "gte",
    lessThanOrEqualTo: "lte"
  },
  text_content: {
    include: "include",
    exclude: "exclude",
    equal: "equal"
  },
  date: {
    between: "bw",
    notBetween: "nb",
    equal: "eq",
    notEqualTo: "ne",
    earlierThan: "bf",
    noEarlierThan: "nbf",
    laterThan: "af",
    noLaterThan: "naf"
  },
  validity: {
    card: "card",
    phone: "phone"
  }
};

},{}],93:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ToContext2D = exports.FromEMF = exports.UDOC = void 0;
exports.UDOC = {};
exports.UDOC.G = {
  concat: function concat(p, r) {
    for (var i = 0; i < r.cmds.length; i++) {
      p.cmds.push(r.cmds[i]);
    }

    for (var i = 0; i < r.crds.length; i++) {
      p.crds.push(r.crds[i]);
    }
  },
  getBB: function getBB(ps) {
    var x0 = 1e99,
        y0 = 1e99,
        x1 = -x0,
        y1 = -y0;

    for (var i = 0; i < ps.length; i += 2) {
      var x = ps[i],
          y = ps[i + 1];
      if (x < x0) x0 = x;else if (x > x1) x1 = x;
      if (y < y0) y0 = y;else if (y > y1) y1 = y;
    }

    return [x0, y0, x1, y1];
  },
  rectToPath: function rectToPath(r) {
    return {
      cmds: ["M", "L", "L", "L", "Z"],
      crds: [r[0], r[1], r[2], r[1], r[2], r[3], r[0], r[3]]
    };
  },
  // a inside b
  insideBox: function insideBox(a, b) {
    return b[0] <= a[0] && b[1] <= a[1] && a[2] <= b[2] && a[3] <= b[3];
  },
  isBox: function isBox(p, bb) {
    var sameCrd8 = function sameCrd8(pcrd, crds) {
      for (var o = 0; o < 8; o += 2) {
        var eq = true;

        for (var j = 0; j < 8; j++) {
          if (Math.abs(crds[j] - pcrd[j + o & 7]) >= 2) {
            eq = false;
            break;
          }
        }

        if (eq) return true;
      }

      return false;
    };

    if (p.cmds.length > 10) return false;
    var cmds = p.cmds.join(""),
        crds = p.crds;
    var sameRect = false;

    if (cmds == "MLLLZ" && crds.length == 8 || cmds == "MLLLLZ" && crds.length == 10) {
      if (crds.length == 10) crds = crds.slice(0, 8);
      var x0 = bb[0],
          y0 = bb[1],
          x1 = bb[2],
          y1 = bb[3];
      if (!sameRect) sameRect = sameCrd8(crds, [x0, y0, x1, y0, x1, y1, x0, y1]);
      if (!sameRect) sameRect = sameCrd8(crds, [x0, y1, x1, y1, x1, y0, x0, y0]);
    }

    return sameRect;
  },
  boxArea: function boxArea(a) {
    var w = a[2] - a[0],
        h = a[3] - a[1];
    return w * h;
  },
  newPath: function newPath(gst) {
    gst.pth = {
      cmds: [],
      crds: []
    };
  },
  moveTo: function moveTo(gst, x, y) {
    var p = exports.UDOC.M.multPoint(gst.ctm, [x, y]); //if(gst.cpos[0]==p[0] && gst.cpos[1]==p[1]) return;

    gst.pth.cmds.push("M");
    gst.pth.crds.push(p[0], p[1]);
    gst.cpos = p;
  },
  lineTo: function lineTo(gst, x, y) {
    var p = exports.UDOC.M.multPoint(gst.ctm, [x, y]);
    if (gst.cpos[0] == p[0] && gst.cpos[1] == p[1]) return;
    gst.pth.cmds.push("L");
    gst.pth.crds.push(p[0], p[1]);
    gst.cpos = p;
  },
  curveTo: function curveTo(gst, x1, y1, x2, y2, x3, y3) {
    var p;
    p = exports.UDOC.M.multPoint(gst.ctm, [x1, y1]);
    x1 = p[0];
    y1 = p[1];
    p = exports.UDOC.M.multPoint(gst.ctm, [x2, y2]);
    x2 = p[0];
    y2 = p[1];
    p = exports.UDOC.M.multPoint(gst.ctm, [x3, y3]);
    x3 = p[0];
    y3 = p[1];
    gst.cpos = p;
    gst.pth.cmds.push("C");
    gst.pth.crds.push(x1, y1, x2, y2, x3, y3);
  },
  closePath: function closePath(gst) {
    gst.pth.cmds.push("Z");
  },
  arc: function arc(gst, x, y, r, a0, a1, neg) {
    // circle from a0 counter-clock-wise to a1
    if (neg) while (a1 > a0) {
      a1 -= 2 * Math.PI;
    } else while (a1 < a0) {
      a1 += 2 * Math.PI;
    }
    var th = (a1 - a0) / 4;
    var x0 = Math.cos(th / 2),
        y0 = -Math.sin(th / 2);
    var x1 = (4 - x0) / 3,
        y1 = y0 == 0 ? y0 : (1 - x0) * (3 - x0) / (3 * y0);
    var x2 = x1,
        y2 = -y1;
    var x3 = x0,
        y3 = -y0;
    var p0 = [x0, y0],
        p1 = [x1, y1],
        p2 = [x2, y2],
        p3 = [x3, y3];
    var pth = {
      cmds: [gst.pth.cmds.length == 0 ? "M" : "L", "C", "C", "C", "C"],
      crds: [x0, y0, x1, y1, x2, y2, x3, y3]
    };
    var rot = [1, 0, 0, 1, 0, 0];
    exports.UDOC.M.rotate(rot, -th);

    for (var i = 0; i < 3; i++) {
      p1 = exports.UDOC.M.multPoint(rot, p1);
      p2 = exports.UDOC.M.multPoint(rot, p2);
      p3 = exports.UDOC.M.multPoint(rot, p3);
      pth.crds.push(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
    }

    var sc = [r, 0, 0, r, x, y];
    exports.UDOC.M.rotate(rot, -a0 + th / 2);
    exports.UDOC.M.concat(rot, sc);
    exports.UDOC.M.multArray(rot, pth.crds);
    exports.UDOC.M.multArray(gst.ctm, pth.crds);
    exports.UDOC.G.concat(gst.pth, pth);
    var y = pth.crds.pop();
    x = pth.crds.pop();
    gst.cpos = [x, y];
  },
  toPoly: function toPoly(p) {
    if (p.cmds[0] != "M" || p.cmds[p.cmds.length - 1] != "Z") return null;

    for (var i = 1; i < p.cmds.length - 1; i++) {
      if (p.cmds[i] != "L") return null;
    }

    var out = [],
        cl = p.crds.length;
    if (p.crds[0] == p.crds[cl - 2] && p.crds[1] == p.crds[cl - 1]) cl -= 2;

    for (var i = 0; i < cl; i += 2) {
      out.push([p.crds[i], p.crds[i + 1]]);
    }

    if (exports.UDOC.G.polyArea(p.crds) < 0) out.reverse();
    return out;
  },
  fromPoly: function fromPoly(p) {
    var o = {
      cmds: [],
      crds: []
    };

    for (var i = 0; i < p.length; i++) {
      o.crds.push(p[i][0], p[i][1]);
      o.cmds.push(i == 0 ? "M" : "L");
    }

    o.cmds.push("Z");
    return o;
  },
  polyArea: function polyArea(p) {
    if (p.length < 6) return 0;
    var l = p.length - 2;
    var sum = (p[0] - p[l]) * (p[l + 1] + p[1]);

    for (var i = 0; i < l; i += 2) {
      sum += (p[i + 2] - p[i]) * (p[i + 1] + p[i + 3]);
    }

    return -sum * 0.5;
  },
  polyClip: function polyClip(p0, p1) {
    var cp1, cp2, s, e;

    var inside = function inside(p) {
      return (cp2[0] - cp1[0]) * (p[1] - cp1[1]) > (cp2[1] - cp1[1]) * (p[0] - cp1[0]);
    };

    var isc = function isc() {
      var dc = [cp1[0] - cp2[0], cp1[1] - cp2[1]],
          dp = [s[0] - e[0], s[1] - e[1]],
          n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0],
          n2 = s[0] * e[1] - s[1] * e[0],
          n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0]);
      return [(n1 * dp[0] - n2 * dc[0]) * n3, (n1 * dp[1] - n2 * dc[1]) * n3];
    };

    var out = p0;
    cp1 = p1[p1.length - 1];

    for (var j in p1) {
      var cp2 = p1[j];
      var inp = out;
      out = [];
      s = inp[inp.length - 1]; //last on the input list

      for (var i in inp) {
        var e = inp[i];

        if (inside(e)) {
          if (!inside(s)) {
            out.push(isc());
          }

          out.push(e);
        } else if (inside(s)) {
          out.push(isc());
        }

        s = e;
      }

      cp1 = cp2;
    }

    return out;
  }
};
exports.UDOC.M = {
  getScale: function getScale(m) {
    return Math.sqrt(Math.abs(m[0] * m[3] - m[1] * m[2]));
  },
  translate: function translate(m, x, y) {
    exports.UDOC.M.concat(m, [1, 0, 0, 1, x, y]);
  },
  rotate: function rotate(m, a) {
    exports.UDOC.M.concat(m, [Math.cos(a), -Math.sin(a), Math.sin(a), Math.cos(a), 0, 0]);
  },
  scale: function scale(m, x, y) {
    exports.UDOC.M.concat(m, [x, 0, 0, y, 0, 0]);
  },
  concat: function concat(m, w) {
    var a = m[0],
        b = m[1],
        c = m[2],
        d = m[3],
        tx = m[4],
        ty = m[5];
    m[0] = a * w[0] + b * w[2];
    m[1] = a * w[1] + b * w[3];
    m[2] = c * w[0] + d * w[2];
    m[3] = c * w[1] + d * w[3];
    m[4] = tx * w[0] + ty * w[2] + w[4];
    m[5] = tx * w[1] + ty * w[3] + w[5];
  },
  invert: function invert(m) {
    var a = m[0],
        b = m[1],
        c = m[2],
        d = m[3],
        tx = m[4],
        ty = m[5],
        adbc = a * d - b * c;
    m[0] = d / adbc;
    m[1] = -b / adbc;
    m[2] = -c / adbc;
    m[3] = a / adbc;
    m[4] = (c * ty - d * tx) / adbc;
    m[5] = (b * tx - a * ty) / adbc;
  },
  multPoint: function multPoint(m, p) {
    var x = p[0],
        y = p[1];
    return [x * m[0] + y * m[2] + m[4], x * m[1] + y * m[3] + m[5]];
  },
  multArray: function multArray(m, a) {
    for (var i = 0; i < a.length; i += 2) {
      var x = a[i],
          y = a[i + 1];
      a[i] = x * m[0] + y * m[2] + m[4];
      a[i + 1] = x * m[1] + y * m[3] + m[5];
    }
  }
};
exports.UDOC.C = {
  srgbGamma: function srgbGamma(x) {
    return x < 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1.0 / 2.4) - 0.055;
  },
  cmykToRgb: function cmykToRgb(clr) {
    var c = clr[0],
        m = clr[1],
        y = clr[2],
        k = clr[3]; // return [1-Math.min(1,c+k), 1-Math.min(1, m+k), 1-Math.min(1,y+k)];

    var r = 255 + c * (-4.387332384609988 * c + 54.48615194189176 * m + 18.82290502165302 * y + 212.25662451639585 * k + -285.2331026137004) + m * (1.7149763477362134 * m - 5.6096736904047315 * y + -17.873870861415444 * k - 5.497006427196366) + y * (-2.5217340131683033 * y - 21.248923337353073 * k + 17.5119270841813) + k * (-21.86122147463605 * k - 189.48180835922747);
    var g = 255 + c * (8.841041422036149 * c + 60.118027045597366 * m + 6.871425592049007 * y + 31.159100130055922 * k + -79.2970844816548) + m * (-15.310361306967817 * m + 17.575251261109482 * y + 131.35250912493976 * k - 190.9453302588951) + y * (4.444339102852739 * y + 9.8632861493405 * k - 24.86741582555878) + k * (-20.737325471181034 * k - 187.80453709719578);
    var b = 255 + c * (0.8842522430003296 * c + 8.078677503112928 * m + 30.89978309703729 * y - 0.23883238689178934 * k + -14.183576799673286) + m * (10.49593273432072 * m + 63.02378494754052 * y + 50.606957656360734 * k - 112.23884253719248) + y * (0.03296041114873217 * y + 115.60384449646641 * k + -193.58209356861505) + k * (-22.33816807309886 * k - 180.12613974708367);
    return [Math.max(0, Math.min(1, r / 255)), Math.max(0, Math.min(1, g / 255)), Math.max(0, Math.min(1, b / 255))]; //var iK = 1-c[3];  
    //return [(1-c[0])*iK, (1-c[1])*iK, (1-c[2])*iK];  
  },
  labToRgb: function labToRgb(lab) {
    var k = 903.3,
        e = 0.008856,
        L = lab[0],
        a = lab[1],
        b = lab[2];
    var fy = (L + 16) / 116,
        fy3 = fy * fy * fy;
    var fz = fy - b / 200,
        fz3 = fz * fz * fz;
    var fx = a / 500 + fy,
        fx3 = fx * fx * fx;
    var zr = fz3 > e ? fz3 : (116 * fz - 16) / k;
    var yr = fy3 > e ? fy3 : (116 * fy - 16) / k;
    var xr = fx3 > e ? fx3 : (116 * fx - 16) / k;
    var X = xr * 96.72,
        Y = yr * 100,
        Z = zr * 81.427,
        xyz = [X / 100, Y / 100, Z / 100];
    var x2s = [3.1338561, -1.6168667, -0.4906146, -0.9787684, 1.9161415, 0.0334540, 0.0719453, -0.2289914, 1.4052427];
    var rgb = [x2s[0] * xyz[0] + x2s[1] * xyz[1] + x2s[2] * xyz[2], x2s[3] * xyz[0] + x2s[4] * xyz[1] + x2s[5] * xyz[2], x2s[6] * xyz[0] + x2s[7] * xyz[1] + x2s[8] * xyz[2]];

    for (var i = 0; i < 3; i++) {
      rgb[i] = Math.max(0, Math.min(1, exports.UDOC.C.srgbGamma(rgb[i])));
    }

    return rgb;
  }
};

exports.UDOC.getState = function (crds) {
  return {
    font: exports.UDOC.getFont(),
    dd: {
      flat: 1
    },
    space: "/DeviceGray",
    // fill
    ca: 1,
    colr: [0, 0, 0],
    sspace: "/DeviceGray",
    // stroke
    CA: 1,
    COLR: [0, 0, 0],
    bmode: "/Normal",
    SA: false,
    OPM: 0,
    AIS: false,
    OP: false,
    op: false,
    SMask: "/None",
    lwidth: 1,
    lcap: 0,
    ljoin: 0,
    mlimit: 10,
    SM: 0.1,
    doff: 0,
    dash: [],
    ctm: [1, 0, 0, 1, 0, 0],
    cpos: [0, 0],
    pth: {
      cmds: [],
      crds: []
    },
    cpth: crds ? exports.UDOC.G.rectToPath(crds) : null // clipping path

  };
};

exports.UDOC.getFont = function () {
  return {
    Tc: 0,
    Tw: 0,
    Th: 100,
    Tl: 0,
    Tf: "Helvetica-Bold",
    Tfs: 1,
    Tmode: 0,
    Trise: 0,
    Tk: 0,
    Tal: 0,
    Tun: 0,
    Tm: [1, 0, 0, 1, 0, 0],
    Tlm: [1, 0, 0, 1, 0, 0],
    Trm: [1, 0, 0, 1, 0, 0]
  };
};

exports.FromEMF = function () {};

exports.FromEMF.Parse = function (buff, genv) {
  buff = new Uint8Array(buff);
  var off = 0; //console.log(buff.slice(0,32));

  var prms = {
    fill: false,
    strk: false,
    bb: [0, 0, 1, 1],
    wbb: [0, 0, 1, 1],
    fnt: {
      nam: "Arial",
      hgh: 25,
      und: false,
      orn: 0
    },
    tclr: [0, 0, 0],
    talg: 0
  },
      gst,
      tab = [],
      sts = [];
  var rI = exports.FromEMF.B.readShort,
      rU = exports.FromEMF.B.readUshort,
      rI32 = exports.FromEMF.B.readInt,
      rU32 = exports.FromEMF.B.readUint,
      rF32 = exports.FromEMF.B.readFloat;
  var opn = 0;

  while (true) {
    var fnc = rU32(buff, off);
    off += 4;
    var fnm = exports.FromEMF.K[fnc];
    var siz = rU32(buff, off);
    off += 4; //if(gst && isNaN(gst.ctm[0])) throw "e";
    //console.log(fnc,fnm,siz);

    var loff = off; //if(opn++==253) break;

    var obj = null,
        oid = 0; //console.log(fnm, siz);

    if (false) {} else if (fnm == "EOF") {
      break;
    } else if (fnm == "HEADER") {
      prms.bb = exports.FromEMF._readBox(buff, loff);
      loff += 16; //console.log(fnm, prms.bb);

      genv.StartPage(prms.bb[0], prms.bb[1], prms.bb[2], prms.bb[3]);
      gst = exports.UDOC.getState(prms.bb);
    } else if (fnm == "SAVEDC") sts.push(JSON.stringify(gst), JSON.stringify(prms));else if (fnm == "RESTOREDC") {
      var dif = rI32(buff, loff);
      loff += 4;

      while (dif < -1) {
        sts.pop();
        sts.pop();
      }

      prms = JSON.parse(sts.pop());
      gst = JSON.parse(sts.pop());
    } else if (fnm == "SELECTCLIPPATH") {
      gst.cpth = JSON.parse(JSON.stringify(gst.pth));
    } else if (["SETMAPMODE", "SETPOLYFILLMODE", "SETBKMODE"
    /*,"SETVIEWPORTEXTEX"*/
    , "SETICMMODE", "SETROP2", "EXTSELECTCLIPRGN"].indexOf(fnm) != -1) {} //else if(fnm=="INTERSECTCLIPRECT") {  var r=prms.crct=FromEMF._readBox(buff, loff);  /*var y0=r[1],y1=r[3]; if(y0>y1){r[1]=y1; r[3]=y0;}*/ console.log(prms.crct);  }
    else if (fnm == "SETMITERLIMIT") gst.mlimit = rU32(buff, loff);else if (fnm == "SETTEXTCOLOR") prms.tclr = [buff[loff] / 255, buff[loff + 1] / 255, buff[loff + 2] / 255];else if (fnm == "SETTEXTALIGN") prms.talg = rU32(buff, loff);else if (fnm == "SETVIEWPORTEXTEX" || fnm == "SETVIEWPORTORGEX") {
        if (prms.vbb == null) prms.vbb = [];
        var coff = fnm == "SETVIEWPORTORGEX" ? 0 : 2;
        prms.vbb[coff] = rI32(buff, loff);
        loff += 4;
        prms.vbb[coff + 1] = rI32(buff, loff);
        loff += 4; //console.log(prms.vbb);

        if (fnm == "SETVIEWPORTEXTEX") exports.FromEMF._updateCtm(prms, gst);
      } else if (fnm == "SETWINDOWEXTEX" || fnm == "SETWINDOWORGEX") {
        var coff = fnm == "SETWINDOWORGEX" ? 0 : 2;
        prms.wbb[coff] = rI32(buff, loff);
        loff += 4;
        prms.wbb[coff + 1] = rI32(buff, loff);
        loff += 4;
        if (fnm == "SETWINDOWEXTEX") exports.FromEMF._updateCtm(prms, gst);
      } //else if(fnm=="SETMETARGN") {}
      else if (fnm == "COMMENT") {
          var ds = rU32(buff, loff);
          loff += 4;
        } else if (fnm == "SELECTOBJECT") {
          var ind = rU32(buff, loff);
          loff += 4; //console.log(ind.toString(16), tab, tab[ind]);

          if (ind == 0x80000000) {
            prms.fill = true;
            gst.colr = [1, 1, 1];
          } // white brush
          else if (ind == 0x80000005) {
              prms.fill = false;
            } // null brush
            else if (ind == 0x80000007) {
                prms.strk = true;
                prms.lwidth = 1;
                gst.COLR = [0, 0, 0];
              } // black pen
              else if (ind == 0x80000008) {
                  prms.strk = false;
                } // null  pen
                else if (ind == 0x8000000d) {} // system font
                  else if (ind == 0x8000000e) {} // device default font
                    else {
                        var co = tab[ind]; //console.log(ind, co);

                        if (co.t == "b") {
                          prms.fill = co.stl != 1;

                          if (co.stl == 0) {} else if (co.stl == 1) {} else throw co.stl + " e";

                          gst.colr = co.clr;
                        } else if (co.t == "p") {
                          prms.strk = co.stl != 5;
                          gst.lwidth = co.wid;
                          gst.COLR = co.clr;
                        } else if (co.t == "f") {
                          prms.fnt = co;
                          gst.font.Tf = co.nam;
                          gst.font.Tfs = Math.abs(co.hgh);
                          gst.font.Tun = co.und;
                        } else throw "e";
                      }
        } else if (fnm == "DELETEOBJECT") {
          var ind = rU32(buff, loff);
          loff += 4;
          if (tab[ind] != null) tab[ind] = null;else throw "e";
        } else if (fnm == "CREATEBRUSHINDIRECT") {
          oid = rU32(buff, loff);
          loff += 4;
          obj = {
            t: "b"
          };
          obj.stl = rU32(buff, loff);
          loff += 4;
          obj.clr = [buff[loff] / 255, buff[loff + 1] / 255, buff[loff + 2] / 255];
          loff += 4;
          obj.htc = rU32(buff, loff);
          loff += 4; //console.log(oid, obj);
        } else if (fnm == "CREATEPEN" || fnm == "EXTCREATEPEN") {
          oid = rU32(buff, loff);
          loff += 4;
          obj = {
            t: "p"
          };

          if (fnm == "EXTCREATEPEN") {
            loff += 16;
            obj.stl = rU32(buff, loff);
            loff += 4;
            obj.wid = rU32(buff, loff);
            loff += 4; //obj.stl = rU32(buff, loff);  

            loff += 4;
          } else {
            obj.stl = rU32(buff, loff);
            loff += 4;
            obj.wid = rU32(buff, loff);
            loff += 4;
            loff += 4;
          }

          obj.clr = [buff[loff] / 255, buff[loff + 1] / 255, buff[loff + 2] / 255];
          loff += 4;
        } else if (fnm == "EXTCREATEFONTINDIRECTW") {
          oid = rU32(buff, loff);
          loff += 4;
          obj = {
            t: "f",
            nam: ""
          };
          obj.hgh = rI32(buff, loff);
          loff += 4;
          loff += 4 * 2;
          obj.orn = rI32(buff, loff) / 10;
          loff += 4;
          var wgh = rU32(buff, loff);
          loff += 4; //console.log(fnm, obj.orn, wgh);
          //console.log(rU32(buff,loff), rU32(buff,loff+4), buff.slice(loff,loff+8));

          obj.und = buff[loff + 1];
          obj.stk = buff[loff + 2];
          loff += 4 * 2;

          while (rU(buff, loff) != 0) {
            obj.nam += String.fromCharCode(rU(buff, loff));
            loff += 2;
          }

          if (wgh > 500) obj.nam += "-Bold"; //console.log(wgh, obj.nam);
        } else if (fnm == "EXTTEXTOUTW") {
          //console.log(buff.slice(loff-8, loff-8+siz));
          loff += 16;
          var mod = rU32(buff, loff);
          loff += 4; //console.log(mod);

          var scx = rF32(buff, loff);
          loff += 4;
          var scy = rF32(buff, loff);
          loff += 4;
          var rfx = rI32(buff, loff);
          loff += 4;
          var rfy = rI32(buff, loff);
          loff += 4; //console.log(mod, scx, scy,rfx,rfy);

          gst.font.Tm = [1, 0, 0, -1, 0, 0];
          exports.UDOC.M.rotate(gst.font.Tm, prms.fnt.orn * Math.PI / 180);
          exports.UDOC.M.translate(gst.font.Tm, rfx, rfy);
          var alg = prms.talg; //console.log(alg.toString(2));

          if ((alg & 6) == 6) gst.font.Tal = 2;else if ((alg & 7) == 0) gst.font.Tal = 0;else throw alg + " e";

          if ((alg & 24) == 24) {} // baseline
          else if ((alg & 24) == 0) exports.UDOC.M.translate(gst.font.Tm, 0, gst.font.Tfs);else throw "e";

          var crs = rU32(buff, loff);
          loff += 4;
          var ofs = rU32(buff, loff);
          loff += 4;
          var ops = rU32(buff, loff);
          loff += 4; //if(ops!=0) throw "e";
          //console.log(ofs,ops,crs);

          loff += 16;
          var ofD = rU32(buff, loff);
          loff += 4; //console.log(ops, ofD, loff, ofs+off-8);

          ofs += off - 8; //console.log(crs, ops);

          var str = "";

          for (var i = 0; i < crs; i++) {
            var cc = rU(buff, ofs + i * 2);
            str += String.fromCharCode(cc);
          }

          ;
          var oclr = gst.colr;
          gst.colr = prms.tclr; //console.log(str, gst.colr, gst.font.Tm);
          //var otfs = gst.font.Tfs;  gst.font.Tfs *= 1/gst.ctm[0];

          genv.PutText(gst, str, str.length * gst.font.Tfs * 0.5);
          gst.colr = oclr; //gst.font.Tfs = otfs;
          //console.log(rfx, rfy, scx, ops, rcX, rcY, rcW, rcH, offDx, str);
        } else if (fnm == "BEGINPATH") {
          exports.UDOC.G.newPath(gst);
        } else if (fnm == "ENDPATH") {} else if (fnm == "CLOSEFIGURE") exports.UDOC.G.closePath(gst);else if (fnm == "MOVETOEX") {
          exports.UDOC.G.moveTo(gst, rI32(buff, loff), rI32(buff, loff + 4));
        } else if (fnm == "LINETO") {
          if (gst.pth.cmds.length == 0) {
            var im = gst.ctm.slice(0);
            exports.UDOC.M.invert(im);
            var p = exports.UDOC.M.multPoint(im, gst.cpos);
            exports.UDOC.G.moveTo(gst, p[0], p[1]);
          }

          exports.UDOC.G.lineTo(gst, rI32(buff, loff), rI32(buff, loff + 4));
        } else if (fnm == "POLYGON" || fnm == "POLYGON16" || fnm == "POLYLINE" || fnm == "POLYLINE16" || fnm == "POLYLINETO" || fnm == "POLYLINETO16") {
          loff += 16;
          var ndf = fnm.startsWith("POLYGON"),
              isTo = fnm.indexOf("TO") != -1;
          var cnt = rU32(buff, loff);
          loff += 4;
          if (!isTo) exports.UDOC.G.newPath(gst);
          loff = exports.FromEMF._drawPoly(buff, loff, cnt, gst, fnm.endsWith("16") ? 2 : 4, ndf, isTo);
          if (!isTo) exports.FromEMF._draw(genv, gst, prms, ndf); //console.log(prms, gst.lwidth);
          //console.log(JSON.parse(JSON.stringify(gst.pth)));
        } else if (fnm == "POLYPOLYGON16") {
          loff += 16;
          var ndf = fnm.startsWith("POLYPOLYGON"),
              isTo = fnm.indexOf("TO") != -1;
          var nop = rU32(buff, loff);
          loff += 4;
          loff += 4;
          var pi = loff;
          loff += nop * 4;
          if (!isTo) exports.UDOC.G.newPath(gst);

          for (var i = 0; i < nop; i++) {
            var ppp = rU(buff, pi + i * 4);
            loff = exports.FromEMF._drawPoly(buff, loff, ppp, gst, fnm.endsWith("16") ? 2 : 4, ndf, isTo);
          }

          if (!isTo) exports.FromEMF._draw(genv, gst, prms, ndf);
        } else if (fnm == "POLYBEZIER" || fnm == "POLYBEZIER16" || fnm == "POLYBEZIERTO" || fnm == "POLYBEZIERTO16") {
          loff += 16;
          var is16 = fnm.endsWith("16"),
              rC = is16 ? rI : rI32,
              nl = is16 ? 2 : 4;
          var cnt = rU32(buff, loff);
          loff += 4;

          if (fnm.indexOf("TO") == -1) {
            exports.UDOC.G.moveTo(gst, rC(buff, loff), rC(buff, loff + nl));
            loff += 2 * nl;
            cnt--;
          }

          while (cnt > 0) {
            exports.UDOC.G.curveTo(gst, rC(buff, loff), rC(buff, loff + nl), rC(buff, loff + 2 * nl), rC(buff, loff + 3 * nl), rC(buff, loff + 4 * nl), rC(buff, loff + 5 * nl));
            loff += 6 * nl;
            cnt -= 3;
          } //console.log(JSON.parse(JSON.stringify(gst.pth)));

        } else if (fnm == "RECTANGLE" || fnm == "ELLIPSE") {
          exports.UDOC.G.newPath(gst);

          var bx = exports.FromEMF._readBox(buff, loff);

          if (fnm == "RECTANGLE") {
            exports.UDOC.G.moveTo(gst, bx[0], bx[1]);
            exports.UDOC.G.lineTo(gst, bx[2], bx[1]);
            exports.UDOC.G.lineTo(gst, bx[2], bx[3]);
            exports.UDOC.G.lineTo(gst, bx[0], bx[3]);
          } else {
            var x = (bx[0] + bx[2]) / 2,
                y = (bx[1] + bx[3]) / 2;
            exports.UDOC.G.arc(gst, x, y, (bx[2] - bx[0]) / 2, 0, 2 * Math.PI, false);
          }

          exports.UDOC.G.closePath(gst);

          exports.FromEMF._draw(genv, gst, prms, true); //console.log(prms, gst.lwidth);

        } else if (fnm == "FILLPATH") genv.Fill(gst, false);else if (fnm == "STROKEPATH") genv.Stroke(gst);else if (fnm == "STROKEANDFILLPATH") {
          genv.Fill(gst, false);
          genv.Stroke(gst);
        } else if (fnm == "SETWORLDTRANSFORM" || fnm == "MODIFYWORLDTRANSFORM") {
          var mat = [];

          for (var i = 0; i < 6; i++) {
            mat.push(rF32(buff, loff + i * 4));
          }

          loff += 24; //console.log(fnm, gst.ctm.slice(0), mat);

          if (fnm == "SETWORLDTRANSFORM") gst.ctm = mat;else {
            var mod = rU32(buff, loff);
            loff += 4;

            if (mod == 2) {
              var om = gst.ctm;
              gst.ctm = mat;
              exports.UDOC.M.concat(gst.ctm, om);
            } else throw "e";
          }
        } else if (fnm == "SETSTRETCHBLTMODE") {
          var sm = rU32(buff, loff);
          loff += 4;
        } else if (fnm == "STRETCHDIBITS") {
          var bx = exports.FromEMF._readBox(buff, loff);

          loff += 16;
          var xD = rI32(buff, loff);
          loff += 4;
          var yD = rI32(buff, loff);
          loff += 4;
          var xS = rI32(buff, loff);
          loff += 4;
          var yS = rI32(buff, loff);
          loff += 4;
          var wS = rI32(buff, loff);
          loff += 4;
          var hS = rI32(buff, loff);
          loff += 4;
          var ofH = rU32(buff, loff) + off - 8;
          loff += 4;
          var szH = rU32(buff, loff);
          loff += 4;
          var ofB = rU32(buff, loff) + off - 8;
          loff += 4;
          var szB = rU32(buff, loff);
          loff += 4;
          var usg = rU32(buff, loff);
          loff += 4;
          if (usg != 0) throw "e";
          var bop = rU32(buff, loff);
          loff += 4;
          var wD = rI32(buff, loff);
          loff += 4;
          var hD = rI32(buff, loff);
          loff += 4; //console.log(bop, wD, hD);
          //console.log(ofH, szH, ofB, szB, ofH+40);
          //console.log(bx, xD,yD,wD,hD);
          //console.log(xS,yS,wS,hS);
          //console.log(ofH,szH,ofB,szB,usg,bop);

          var hl = rU32(buff, ofH);
          ofH += 4;
          var w = rU32(buff, ofH);
          ofH += 4;
          var h = rU32(buff, ofH);
          ofH += 4;
          if (w != wS || h != hS) throw "e";
          var ps = rU(buff, ofH);
          ofH += 2;
          var bc = rU(buff, ofH);
          ofH += 2;
          if (bc != 8 && bc != 24 && bc != 32) throw bc + " e";
          var cpr = rU32(buff, ofH);
          ofH += 4;
          if (cpr != 0) throw cpr + " e";
          var sz = rU32(buff, ofH);
          ofH += 4;
          var xpm = rU32(buff, ofH);
          ofH += 4;
          var ypm = rU32(buff, ofH);
          ofH += 4;
          var cu = rU32(buff, ofH);
          ofH += 4;
          var ci = rU32(buff, ofH);
          ofH += 4; //console.log(hl, w, h, ps, bc, cpr, sz, xpm, ypm, cu, ci);
          //console.log(hl,w,h,",",xS,yS,wS,hS,",",xD,yD,wD,hD,",",xpm,ypm);

          var rl = Math.floor((w * ps * bc + 31 & ~31) / 8);
          var img = new Uint8Array(w * h * 4);

          if (bc == 8) {
            for (var y = 0; y < h; y++) {
              for (var x = 0; x < w; x++) {
                var qi = y * w + x << 2,
                    ind = buff[ofB + (h - 1 - y) * rl + x] << 2;
                img[qi] = buff[ofH + ind + 2];
                img[qi + 1] = buff[ofH + ind + 1];
                img[qi + 2] = buff[ofH + ind + 0];
                img[qi + 3] = 255;
              }
            }
          }

          if (bc == 24) {
            for (var y = 0; y < h; y++) {
              for (var x = 0; x < w; x++) {
                var qi = y * w + x << 2,
                    ti = ofB + (h - 1 - y) * rl + x * 3;
                img[qi] = buff[ti + 2];
                img[qi + 1] = buff[ti + 1];
                img[qi + 2] = buff[ti + 0];
                img[qi + 3] = 255;
              }
            }
          }

          if (bc == 32) {
            for (var y = 0; y < h; y++) {
              for (var x = 0; x < w; x++) {
                var qi = y * w + x << 2,
                    ti = ofB + (h - 1 - y) * rl + x * 4;
                img[qi] = buff[ti + 2];
                img[qi + 1] = buff[ti + 1];
                img[qi + 2] = buff[ti + 0];
                img[qi + 3] = buff[ti + 3];
              }
            }
          }

          var ctm = gst.ctm.slice(0);
          gst.ctm = [1, 0, 0, 1, 0, 0];
          exports.UDOC.M.scale(gst.ctm, wD, -hD);
          exports.UDOC.M.translate(gst.ctm, xD, yD + hD);
          exports.UDOC.M.concat(gst.ctm, ctm);
          genv.PutImage(gst, img, w, h);
          gst.ctm = ctm;
        } else {
          console.log(fnm, siz);
        }

    if (obj != null) tab[oid] = obj;
    off += siz - 8;
  } //genv.Stroke(gst);


  genv.ShowPage();
  genv.Done();
};

exports.FromEMF._readBox = function (buff, off) {
  var b = [];

  for (var i = 0; i < 4; i++) {
    b[i] = exports.FromEMF.B.readInt(buff, off + i * 4);
  }

  return b;
};

exports.FromEMF._updateCtm = function (prms, gst) {
  var mat = [1, 0, 0, 1, 0, 0];
  var wbb = prms.wbb,
      bb = prms.bb,
      vbb = prms.vbb && prms.vbb.length == 4 ? prms.vbb : prms.bb; //var y0 = bb[1], y1 = bb[3];  bb[1]=Math.min(y0,y1);  bb[3]=Math.max(y0,y1);

  exports.UDOC.M.translate(mat, -wbb[0], -wbb[1]);
  exports.UDOC.M.scale(mat, 1 / wbb[2], 1 / wbb[3]);
  exports.UDOC.M.scale(mat, vbb[2], vbb[3]); //UDOC.M.scale(mat, vbb[2]/(bb[2]-bb[0]), vbb[3]/(bb[3]-bb[1]));
  //UDOC.M.scale(mat, bb[2]-bb[0],bb[3]-bb[1]);

  gst.ctm = mat;
};

exports.FromEMF._draw = function (genv, gst, prms, needFill) {
  if (prms.fill && needFill) genv.Fill(gst, false);
  if (prms.strk && gst.lwidth != 0) genv.Stroke(gst);
};

exports.FromEMF._drawPoly = function (buff, off, ppp, gst, nl, clos, justLine) {
  var rS = nl == 2 ? exports.FromEMF.B.readShort : exports.FromEMF.B.readInt;

  for (var j = 0; j < ppp; j++) {
    var px = rS(buff, off);
    off += nl;
    var py = rS(buff, off);
    off += nl;
    if (j == 0 && !justLine) exports.UDOC.G.moveTo(gst, px, py);else exports.UDOC.G.lineTo(gst, px, py);
  }

  if (clos) exports.UDOC.G.closePath(gst);
  return off;
};

exports.FromEMF.B = {
  uint8: new Uint8Array(4),
  readShort: function readShort(buff, p) {
    var u8 = exports.FromEMF.B.uint8;
    u8[0] = buff[p];
    u8[1] = buff[p + 1];
    return exports.FromEMF.B.int16[0];
  },
  readUshort: function readUshort(buff, p) {
    var u8 = exports.FromEMF.B.uint8;
    u8[0] = buff[p];
    u8[1] = buff[p + 1];
    return exports.FromEMF.B.uint16[0];
  },
  readInt: function readInt(buff, p) {
    var u8 = exports.FromEMF.B.uint8;
    u8[0] = buff[p];
    u8[1] = buff[p + 1];
    u8[2] = buff[p + 2];
    u8[3] = buff[p + 3];
    return exports.FromEMF.B.int32[0];
  },
  readUint: function readUint(buff, p) {
    var u8 = exports.FromEMF.B.uint8;
    u8[0] = buff[p];
    u8[1] = buff[p + 1];
    u8[2] = buff[p + 2];
    u8[3] = buff[p + 3];
    return exports.FromEMF.B.uint32[0];
  },
  readFloat: function readFloat(buff, p) {
    var u8 = exports.FromEMF.B.uint8;
    u8[0] = buff[p];
    u8[1] = buff[p + 1];
    u8[2] = buff[p + 2];
    u8[3] = buff[p + 3];
    return exports.FromEMF.B.flot32[0];
  },
  readASCII: function readASCII(buff, p, l) {
    var s = "";

    for (var i = 0; i < l; i++) {
      s += String.fromCharCode(buff[p + i]);
    }

    return s;
  }
};
exports.FromEMF.B.int16 = new Int16Array(exports.FromEMF.B.uint8.buffer);
exports.FromEMF.B.uint16 = new Uint16Array(exports.FromEMF.B.uint8.buffer);
exports.FromEMF.B.int32 = new Int32Array(exports.FromEMF.B.uint8.buffer);
exports.FromEMF.B.uint32 = new Uint32Array(exports.FromEMF.B.uint8.buffer);
exports.FromEMF.B.flot32 = new Float32Array(exports.FromEMF.B.uint8.buffer);
exports.FromEMF.C = {
  EMR_HEADER: 0x00000001,
  EMR_POLYBEZIER: 0x00000002,
  EMR_POLYGON: 0x00000003,
  EMR_POLYLINE: 0x00000004,
  EMR_POLYBEZIERTO: 0x00000005,
  EMR_POLYLINETO: 0x00000006,
  EMR_POLYPOLYLINE: 0x00000007,
  EMR_POLYPOLYGON: 0x00000008,
  EMR_SETWINDOWEXTEX: 0x00000009,
  EMR_SETWINDOWORGEX: 0x0000000A,
  EMR_SETVIEWPORTEXTEX: 0x0000000B,
  EMR_SETVIEWPORTORGEX: 0x0000000C,
  EMR_SETBRUSHORGEX: 0x0000000D,
  EMR_EOF: 0x0000000E,
  EMR_SETPIXELV: 0x0000000F,
  EMR_SETMAPPERFLAGS: 0x00000010,
  EMR_SETMAPMODE: 0x00000011,
  EMR_SETBKMODE: 0x00000012,
  EMR_SETPOLYFILLMODE: 0x00000013,
  EMR_SETROP2: 0x00000014,
  EMR_SETSTRETCHBLTMODE: 0x00000015,
  EMR_SETTEXTALIGN: 0x00000016,
  EMR_SETCOLORADJUSTMENT: 0x00000017,
  EMR_SETTEXTCOLOR: 0x00000018,
  EMR_SETBKCOLOR: 0x00000019,
  EMR_OFFSETCLIPRGN: 0x0000001A,
  EMR_MOVETOEX: 0x0000001B,
  EMR_SETMETARGN: 0x0000001C,
  EMR_EXCLUDECLIPRECT: 0x0000001D,
  EMR_INTERSECTCLIPRECT: 0x0000001E,
  EMR_SCALEVIEWPORTEXTEX: 0x0000001F,
  EMR_SCALEWINDOWEXTEX: 0x00000020,
  EMR_SAVEDC: 0x00000021,
  EMR_RESTOREDC: 0x00000022,
  EMR_SETWORLDTRANSFORM: 0x00000023,
  EMR_MODIFYWORLDTRANSFORM: 0x00000024,
  EMR_SELECTOBJECT: 0x00000025,
  EMR_CREATEPEN: 0x00000026,
  EMR_CREATEBRUSHINDIRECT: 0x00000027,
  EMR_DELETEOBJECT: 0x00000028,
  EMR_ANGLEARC: 0x00000029,
  EMR_ELLIPSE: 0x0000002A,
  EMR_RECTANGLE: 0x0000002B,
  EMR_ROUNDRECT: 0x0000002C,
  EMR_ARC: 0x0000002D,
  EMR_CHORD: 0x0000002E,
  EMR_PIE: 0x0000002F,
  EMR_SELECTPALETTE: 0x00000030,
  EMR_CREATEPALETTE: 0x00000031,
  EMR_SETPALETTEENTRIES: 0x00000032,
  EMR_RESIZEPALETTE: 0x00000033,
  EMR_REALIZEPALETTE: 0x00000034,
  EMR_EXTFLOODFILL: 0x00000035,
  EMR_LINETO: 0x00000036,
  EMR_ARCTO: 0x00000037,
  EMR_POLYDRAW: 0x00000038,
  EMR_SETARCDIRECTION: 0x00000039,
  EMR_SETMITERLIMIT: 0x0000003A,
  EMR_BEGINPATH: 0x0000003B,
  EMR_ENDPATH: 0x0000003C,
  EMR_CLOSEFIGURE: 0x0000003D,
  EMR_FILLPATH: 0x0000003E,
  EMR_STROKEANDFILLPATH: 0x0000003F,
  EMR_STROKEPATH: 0x00000040,
  EMR_FLATTENPATH: 0x00000041,
  EMR_WIDENPATH: 0x00000042,
  EMR_SELECTCLIPPATH: 0x00000043,
  EMR_ABORTPATH: 0x00000044,
  EMR_COMMENT: 0x00000046,
  EMR_FILLRGN: 0x00000047,
  EMR_FRAMERGN: 0x00000048,
  EMR_INVERTRGN: 0x00000049,
  EMR_PAINTRGN: 0x0000004A,
  EMR_EXTSELECTCLIPRGN: 0x0000004B,
  EMR_BITBLT: 0x0000004C,
  EMR_STRETCHBLT: 0x0000004D,
  EMR_MASKBLT: 0x0000004E,
  EMR_PLGBLT: 0x0000004F,
  EMR_SETDIBITSTODEVICE: 0x00000050,
  EMR_STRETCHDIBITS: 0x00000051,
  EMR_EXTCREATEFONTINDIRECTW: 0x00000052,
  EMR_EXTTEXTOUTA: 0x00000053,
  EMR_EXTTEXTOUTW: 0x00000054,
  EMR_POLYBEZIER16: 0x00000055,
  EMR_POLYGON16: 0x00000056,
  EMR_POLYLINE16: 0x00000057,
  EMR_POLYBEZIERTO16: 0x00000058,
  EMR_POLYLINETO16: 0x00000059,
  EMR_POLYPOLYLINE16: 0x0000005A,
  EMR_POLYPOLYGON16: 0x0000005B,
  EMR_POLYDRAW16: 0x0000005C,
  EMR_CREATEMONOBRUSH: 0x0000005D,
  EMR_CREATEDIBPATTERNBRUSHPT: 0x0000005E,
  EMR_EXTCREATEPEN: 0x0000005F,
  EMR_POLYTEXTOUTA: 0x00000060,
  EMR_POLYTEXTOUTW: 0x00000061,
  EMR_SETICMMODE: 0x00000062,
  EMR_CREATECOLORSPACE: 0x00000063,
  EMR_SETCOLORSPACE: 0x00000064,
  EMR_DELETECOLORSPACE: 0x00000065,
  EMR_GLSRECORD: 0x00000066,
  EMR_GLSBOUNDEDRECORD: 0x00000067,
  EMR_PIXELFORMAT: 0x00000068,
  EMR_DRAWESCAPE: 0x00000069,
  EMR_EXTESCAPE: 0x0000006A,
  EMR_SMALLTEXTOUT: 0x0000006C,
  EMR_FORCEUFIMAPPING: 0x0000006D,
  EMR_NAMEDESCAPE: 0x0000006E,
  EMR_COLORCORRECTPALETTE: 0x0000006F,
  EMR_SETICMPROFILEA: 0x00000070,
  EMR_SETICMPROFILEW: 0x00000071,
  EMR_ALPHABLEND: 0x00000072,
  EMR_SETLAYOUT: 0x00000073,
  EMR_TRANSPARENTBLT: 0x00000074,
  EMR_GRADIENTFILL: 0x00000076,
  EMR_SETLINKEDUFIS: 0x00000077,
  EMR_SETTEXTJUSTIFICATION: 0x00000078,
  EMR_COLORMATCHTOTARGETW: 0x00000079,
  EMR_CREATECOLORSPACEW: 0x0000007A
};
exports.FromEMF.K = []; // (function() {
//     var inp, out, stt;
//     inp = FromEMF.C;   out = FromEMF.K;   stt=4;
//     for(var p in inp) out[inp[p]] = p.slice(stt);
// }  )();

exports.ToContext2D = function (needPage, scale) {
  this.canvas = document.createElement("canvas");
  this.ctx = this.canvas.getContext("2d");
  this.bb = null;
  this.currPage = 0;
  this.needPage = needPage;
  this.scale = scale;
};

exports.ToContext2D.prototype.StartPage = function (x, y, w, h) {
  if (this.currPage != this.needPage) return;
  this.bb = [x, y, w, h];
  var scl = this.scale,
      dpr = window.devicePixelRatio;
  var cnv = this.canvas,
      ctx = this.ctx;
  cnv.width = Math.round(w * scl);
  cnv.height = Math.round(h * scl);
  ctx.translate(0, h * scl);
  ctx.scale(scl, -scl);
  cnv.setAttribute("style", "border:1px solid; width:" + cnv.width / dpr + "px; height:" + cnv.height / dpr + "px");
};

exports.ToContext2D.prototype.Fill = function (gst, evenOdd) {
  if (this.currPage != this.needPage) return;
  var ctx = this.ctx;
  ctx.beginPath();

  this._setStyle(gst, ctx);

  this._draw(gst.pth, ctx);

  ctx.fill();
};

exports.ToContext2D.prototype.Stroke = function (gst) {
  if (this.currPage != this.needPage) return;
  var ctx = this.ctx;
  ctx.beginPath();

  this._setStyle(gst, ctx);

  this._draw(gst.pth, ctx);

  ctx.stroke();
};

exports.ToContext2D.prototype.PutText = function (gst, str, stw) {
  if (this.currPage != this.needPage) return;

  var scl = this._scale(gst.ctm);

  var ctx = this.ctx;

  this._setStyle(gst, ctx);

  ctx.save();
  var m = [1, 0, 0, -1, 0, 0];

  this._concat(m, gst.font.Tm);

  this._concat(m, gst.ctm); //console.log(str, m, gst);  throw "e";


  ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
  ctx.fillText(str, 0, 0);
  ctx.restore();
};

exports.ToContext2D.prototype.PutImage = function (gst, buff, w, h, msk) {
  if (this.currPage != this.needPage) return;
  var ctx = this.ctx;

  if (buff.length == w * h * 4) {
    buff = buff.slice(0);
    if (msk && msk.length == w * h * 4) for (var i = 0; i < buff.length; i += 4) {
      buff[i + 3] = msk[i + 1];
    }
    var cnv = document.createElement("canvas"),
        cctx = cnv.getContext("2d");
    cnv.width = w;
    cnv.height = h;
    var imgd = cctx.createImageData(w, h);

    for (var i = 0; i < buff.length; i++) {
      imgd.data[i] = buff[i];
    }

    cctx.putImageData(imgd, 0, 0);
    ctx.save();
    var m = [1, 0, 0, 1, 0, 0];

    this._concat(m, [1 / w, 0, 0, -1 / h, 0, 1]);

    this._concat(m, gst.ctm);

    ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
    ctx.drawImage(cnv, 0, 0);
    ctx.restore();
  }
};

exports.ToContext2D.prototype.ShowPage = function () {
  this.currPage++;
};

exports.ToContext2D.prototype.Done = function () {};

function _flt(n) {
  return "" + parseFloat(n.toFixed(2));
}

exports.ToContext2D.prototype._setStyle = function (gst, ctx) {
  var scl = this._scale(gst.ctm);

  ctx.fillStyle = this._getFill(gst.colr, gst.ca, ctx);
  ctx.strokeStyle = this._getFill(gst.COLR, gst.CA, ctx);
  ctx.lineCap = ["butt", "round", "square"][gst.lcap];
  ctx.lineJoin = ["miter", "round", "bevel"][gst.ljoin];
  ctx.lineWidth = gst.lwidth * scl;
  var dsh = gst.dash.slice(0);

  for (var i = 0; i < dsh.length; i++) {
    dsh[i] = _flt(dsh[i] * scl);
  }

  ctx.setLineDash(dsh);
  ctx.miterLimit = gst.mlimit * scl;
  var fn = gst.font.Tf,
      ln = fn.toLowerCase();
  var p0 = ln.indexOf("bold") != -1 ? "bold " : "";
  var p1 = ln.indexOf("italic") != -1 || ln.indexOf("oblique") != -1 ? "italic " : "";
  ctx.font = p0 + p1 + gst.font.Tfs + "px \"" + fn + "\"";
};

exports.ToContext2D.prototype._getFill = function (colr, ca, ctx) {
  if (colr.typ == null) return this._colr(colr, ca);else {
    var grd = colr,
        crd = grd.crds,
        mat = grd.mat,
        scl = this._scale(mat),
        gf;

    if (grd.typ == "lin") {
      var p0 = this._multPoint(mat, crd.slice(0, 2)),
          p1 = this._multPoint(mat, crd.slice(2));

      gf = ctx.createLinearGradient(p0[0], p0[1], p1[0], p1[1]);
    } else if (grd.typ == "rad") {
      var p0 = this._multPoint(mat, crd.slice(0, 2)),
          p1 = this._multPoint(mat, crd.slice(3));

      gf = ctx.createRadialGradient(p0[0], p0[1], crd[2] * scl, p1[0], p1[1], crd[5] * scl);
    }

    for (var i = 0; i < grd.grad.length; i++) {
      gf.addColorStop(grd.grad[i][0], this._colr(grd.grad[i][1], ca));
    }

    return gf;
  }
};

exports.ToContext2D.prototype._colr = function (c, a) {
  return "rgba(" + Math.round(c[0] * 255) + "," + Math.round(c[1] * 255) + "," + Math.round(c[2] * 255) + "," + a + ")";
};

exports.ToContext2D.prototype._scale = function (m) {
  return Math.sqrt(Math.abs(m[0] * m[3] - m[1] * m[2]));
};

exports.ToContext2D.prototype._concat = function (m, w) {
  var a = m[0],
      b = m[1],
      c = m[2],
      d = m[3],
      tx = m[4],
      ty = m[5];
  m[0] = a * w[0] + b * w[2];
  m[1] = a * w[1] + b * w[3];
  m[2] = c * w[0] + d * w[2];
  m[3] = c * w[1] + d * w[3];
  m[4] = tx * w[0] + ty * w[2] + w[4];
  m[5] = tx * w[1] + ty * w[3] + w[5];
};

exports.ToContext2D.prototype._multPoint = function (m, p) {
  var x = p[0],
      y = p[1];
  return [x * m[0] + y * m[2] + m[4], x * m[1] + y * m[3] + m[5]];
}, exports.ToContext2D.prototype._draw = function (path, ctx) {
  var c = 0,
      crds = path.crds;

  for (var j = 0; j < path.cmds.length; j++) {
    var cmd = path.cmds[j];

    if (cmd == "M") {
      ctx.moveTo(crds[c], crds[c + 1]);
      c += 2;
    } else if (cmd == "L") {
      ctx.lineTo(crds[c], crds[c + 1]);
      c += 2;
    } else if (cmd == "C") {
      ctx.bezierCurveTo(crds[c], crds[c + 1], crds[c + 2], crds[c + 3], crds[c + 4], crds[c + 5]);
      c += 6;
    } else if (cmd == "Q") {
      ctx.quadraticCurveTo(crds[c], crds[c + 1], crds[c + 2], crds[c + 3]);
      c += 4;
    } else if (cmd == "Z") {
      ctx.closePath();
    }
  }
};

},{}],94:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMultiFormulaValue = exports.getPeelOffX14 = exports.getTransR1C1ToSequence = exports.getSingleSequenceToNum = exports.getSqrefRawArrFormat = exports.getRegionSequence = exports.getMultiSequenceToNum = exports.getBinaryContent = exports.isContainMultiType = exports.isKoera = exports.isJapanese = exports.isChinese = exports.fromulaRef = exports.escapeCharacter = exports.generateRandomIndex = exports.LightenDarkenColor = exports.getRowHeightPixel = exports.getColumnWidthPixel = exports.getXmlAttibute = exports.getPxByEMUs = exports.getptToPxRatioByDPI = exports.getcellrange = exports.getRangetxt = void 0;

var constant_1 = require("./constant");

function getRangetxt(range, sheettxt) {
  var row0 = range["row"][0],
      row1 = range["row"][1];
  var column0 = range["column"][0],
      column1 = range["column"][1];

  if (row0 == null && row1 == null) {
    return sheettxt + chatatABC(column0) + ":" + chatatABC(column1);
  } else if (column0 == null && column1 == null) {
    return sheettxt + (row0 + 1) + ":" + (row1 + 1);
  } else {
    if (column0 == column1 && row0 == row1) {
      return sheettxt + chatatABC(column0) + (row0 + 1);
    } else {
      return sheettxt + chatatABC(column0) + (row0 + 1) + ":" + chatatABC(column1) + (row1 + 1);
    }
  }
}

exports.getRangetxt = getRangetxt;

function getcellrange(txt, sheets, sheetId) {
  if (sheets === void 0) {
    sheets = {};
  }

  if (sheetId === void 0) {
    sheetId = "1";
  }

  var val = txt.split("!");
  var sheettxt = "",
      rangetxt = "",
      sheetIndex = -1;

  if (val.length > 1) {
    sheettxt = val[0];
    rangetxt = val[1];
    var si = sheets[sheettxt];

    if (si == null) {
      sheetIndex = parseInt(sheetId);
    } else {
      sheetIndex = parseInt(si);
    }
  } else {
    sheetIndex = parseInt(sheetId);
    rangetxt = val[0];
  }

  if (rangetxt.indexOf(":") == -1) {
    var row = parseInt(rangetxt.replace(/[^0-9]/g, "")) - 1;
    var col = ABCatNum(rangetxt.replace(/[^A-Za-z]/g, ""));

    if (!isNaN(row) && !isNaN(col)) {
      return {
        "row": [row, row],
        "column": [col, col],
        "sheetIndex": sheetIndex
      };
    } else {
      return null;
    }
  } else {
    var rangetxtArray = rangetxt.split(":");
    var row = [],
        col = [];
    row[0] = parseInt(rangetxtArray[0].replace(/[^0-9]/g, "")) - 1;
    row[1] = parseInt(rangetxtArray[1].replace(/[^0-9]/g, "")) - 1; // if (isNaN(row[0])) {
    //     row[0] = 0;
    // }
    // if (isNaN(row[1])) {
    //     row[1] = sheetdata.length - 1;
    // }

    if (row[0] > row[1]) {
      return null;
    }

    col[0] = ABCatNum(rangetxtArray[0].replace(/[^A-Za-z]/g, ""));
    col[1] = ABCatNum(rangetxtArray[1].replace(/[^A-Za-z]/g, "")); // if (isNaN(col[0])) {
    //     col[0] = 0;
    // }
    // if (isNaN(col[1])) {
    //     col[1] = sheetdata[0].length - 1;
    // }

    if (col[0] > col[1]) {
      return null;
    }

    return {
      "row": row,
      "column": col,
      "sheetIndex": sheetIndex
    };
  }
}

exports.getcellrange = getcellrange; //  

function ABCatNum(abc) {
  abc = abc.toUpperCase();
  var abc_len = abc.length;

  if (abc_len == 0) {
    return NaN;
  }

  var abc_array = abc.split("");
  var wordlen = constant_1.columeHeader_word.length;
  var ret = 0;

  for (var i = abc_len - 1; i >= 0; i--) {
    if (i == abc_len - 1) {
      ret += constant_1.columeHeader_word_index[abc_array[i]];
    } else {
      ret += Math.pow(wordlen, abc_len - i - 1) * (constant_1.columeHeader_word_index[abc_array[i]] + 1);
    }
  }

  return ret;
} //  


function chatatABC(index) {
  var wordlen = constant_1.columeHeader_word.length;

  if (index < wordlen) {
    return constant_1.columeHeader_word[index];
  } else {
    var last = 0,
        pre = 0,
        ret = "";
    var i = 1,
        n = 0;

    while (index >= wordlen / (wordlen - 1) * (Math.pow(wordlen, i++) - 1)) {
      n = i;
    }

    var index_ab = index - wordlen / (wordlen - 1) * (Math.pow(wordlen, n - 1) - 1); //970

    last = index_ab + 1;

    for (var x = n; x > 0; x--) {
      var last1 = last,
          x1 = x; //-702=268, 3

      if (x == 1) {
        last1 = last1 % wordlen;

        if (last1 == 0) {
          last1 = 26;
        }

        return ret + constant_1.columeHeader_word[last1 - 1];
      }

      last1 = Math.ceil(last1 / Math.pow(wordlen, x - 1)); //last1 = last1 % wordlen;

      ret += constant_1.columeHeader_word[last1 - 1];

      if (x > 1) {
        last = last - (last1 - 1) * wordlen;
      }
    }
  }
}
/**
 * @return ratio, default 0.75 1in = 2.54cm = 25.4mm = 72pt = 6pc,  pt = 1/72 In, px = 1/dpi In
*/


function getptToPxRatioByDPI() {
  return 72 / 96;
}

exports.getptToPxRatioByDPI = getptToPxRatioByDPI;
/**
 * @emus EMUs, Excel drawing unit
 * @return pixel
*/

function getPxByEMUs(emus) {
  if (emus == null) {
    return 0;
  }

  var inch = emus / 914400;
  var pt = inch * 72;
  var px = pt / getptToPxRatioByDPI();
  return px;
}

exports.getPxByEMUs = getPxByEMUs;
/**
 * @dom xml attribute object
 * @attr attribute name
 * @d if attribute is null, return default value
 * @return attribute value
*/

function getXmlAttibute(dom, attr, d) {
  var value = dom[attr];
  value = value == null ? d : value;
  return value;
}

exports.getXmlAttibute = getXmlAttibute;
/**
 * @columnWidth Excel column width
 * @return pixel column width
*/

function getColumnWidthPixel(columnWidth) {
  var pix = Math.round((columnWidth - 0.83) * 8 + 5);
  return pix;
}

exports.getColumnWidthPixel = getColumnWidthPixel;
/**
 * @rowHeight Excel row height
 * @return pixel row height
*/

function getRowHeightPixel(rowHeight) {
  var pix = Math.round(rowHeight / getptToPxRatioByDPI());
  return pix;
}

exports.getRowHeightPixel = getRowHeightPixel;

function LightenDarkenColor(sixColor, tint) {
  var hex = sixColor.substring(sixColor.length - 6, sixColor.length);
  var rgbArray = hexToRgbArray("#" + hex);
  var hslArray = rgbToHsl(rgbArray[0], rgbArray[1], rgbArray[2]);

  if (tint > 0) {
    hslArray[2] = hslArray[2] * (1.0 - tint) + tint;
  } else if (tint < 0) {
    hslArray[2] = hslArray[2] * (1.0 + tint);
  } else {
    return "#" + hex;
  }

  var newRgbArray = hslToRgb(hslArray[0], hslArray[1], hslArray[2]);
  return rgbToHex("RGB(" + newRgbArray.join(",") + ")");
}

exports.LightenDarkenColor = LightenDarkenColor;

function rgbToHex(rgb) {
  //
  var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/; // rgb

  if (/^(rgb|RGB)/.test(rgb)) {
    var aColor = rgb.replace(/(?:\(|\)|rgb|RGB)*/g, "").split(",");
    var strHex = "#";

    for (var i = 0; i < aColor.length; i++) {
      var hex = Number(aColor[i]).toString(16);

      if (hex.length < 2) {
        hex = '0' + hex;
      }

      strHex += hex;
    }

    if (strHex.length !== 7) {
      strHex = rgb;
    }

    return strHex;
  } else if (reg.test(rgb)) {
    var aNum = rgb.replace(/#/, "").split("");

    if (aNum.length === 6) {
      return rgb;
    } else if (aNum.length === 3) {
      var numHex = "#";

      for (var i = 0; i < aNum.length; i += 1) {
        numHex += aNum[i] + aNum[i];
      }

      return numHex;
    }
  }

  return rgb;
}

function hexToRgb(hex) {
  var sColor = hex.toLowerCase(); //

  var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/; // 16

  if (sColor && reg.test(sColor)) {
    if (sColor.length === 4) {
      var sColorNew = "#";

      for (var i = 1; i < 4; i += 1) {
        sColorNew += sColor.slice(i, i + 1).concat(sColor.slice(i, i + 1));
      }

      sColor = sColorNew;
    } //


    var sColorChange = [];

    for (var i = 1; i < 7; i += 2) {
      sColorChange.push(parseInt("0x" + sColor.slice(i, i + 2)));
    }

    return "RGB(" + sColorChange.join(",") + ")";
  }

  return sColor;
}

function hexToRgbArray(hex) {
  var sColor = hex.toLowerCase(); //

  var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/; // 16

  if (sColor && reg.test(sColor)) {
    if (sColor.length === 4) {
      var sColorNew = "#";

      for (var i = 1; i < 4; i += 1) {
        sColorNew += sColor.slice(i, i + 1).concat(sColor.slice(i, i + 1));
      }

      sColor = sColorNew;
    } //


    var sColorChange = [];

    for (var i = 1; i < 7; i += 2) {
      sColorChange.push(parseInt("0x" + sColor.slice(i, i + 2)));
    }

    return sColorChange;
  }

  return null;
}
/**
 * HSLRGB.
 *  http://en.wikipedia.org/wiki/HSL_color_space.
 * h, s,  l  [0, 1] 
 *  r, g,  b  [0, 255]
 *
 * @param   Number  h       
 * @param   Number  s       
 * @param   Number  l       
 * @return  Array           RGB
 */


function hslToRgb(h, s, l) {
  var r, g, b;

  if (s == 0) {
    r = g = b = l; // achromatic
  } else {
    var hue2rgb = function hue2rgb(p, q, t) {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p + (q - p) * 6 * t;
      if (t < 1 / 2) return q;
      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    };

    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }

  return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
}
/**
 * RGB  HSL.
 *  http://en.wikipedia.org/wiki/HSL_color_space.
 * r, g,  b  [0, 255] 
 *  h, s,  l  [0, 1] 
 *
 * @param   Number  r       
 * @param   Number  g       
 * @param   Number  b       
 * @return  Array           HSL
 */


function rgbToHsl(r, g, b) {
  r /= 255, g /= 255, b /= 255;
  var max = Math.max(r, g, b),
      min = Math.min(r, g, b);
  var h,
      s,
      l = (max + min) / 2;

  if (max == min) {
    h = s = 0; // achromatic
  } else {
    var d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;

      case g:
        h = (b - r) / d + 2;
        break;

      case b:
        h = (r - g) / d + 4;
        break;
    }

    h /= 6;
  }

  return [h, s, l];
}

function generateRandomIndex(prefix) {
  if (prefix == null) {
    prefix = "Sheet";
  }

  var userAgent = window.navigator.userAgent.replace(/[^a-zA-Z0-9]/g, "").split("");
  var mid = "";

  for (var i = 0; i < 5; i++) {
    mid += userAgent[Math.round(Math.random() * (userAgent.length - 1))];
  }

  var time = new Date().getTime();
  return prefix + "_" + mid + "_" + time;
}

exports.generateRandomIndex = generateRandomIndex;

function escapeCharacter(str) {
  if (str == null || str.length == 0) {
    return str;
  }

  return str.replace(/&amp;/g, "&").replace(/&quot;/g, '"').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&nbsp;/g, ' ').replace(/&apos;/g, "'").replace(/&iexcl;/g, "").replace(/&cent;/g, "").replace(/&pound;/g, "").replace(/&curren;/g, "").replace(/&yen;/g, "").replace(/&brvbar;/g, "").replace(/&sect;/g, "").replace(/&uml;/g, "").replace(/&copy;/g, "").replace(/&ordf;/g, "").replace(/&laquo;/g, "").replace(/&not;/g, "").replace(/&shy;/g, "").replace(/&reg;/g, "").replace(/&macr;/g, "").replace(/&deg;/g, "").replace(/&plusmn;/g, "").replace(/&sup2;/g, "").replace(/&sup3;/g, "").replace(/&acute;/g, "").replace(/&micro;/g, "").replace(/&para;/g, "").replace(/&middot;/g, "").replace(/&cedil;/g, "").replace(/&sup1;/g, "").replace(/&ordm;/g, "").replace(/&raquo;/g, "").replace(/&frac14;/g, "").replace(/&frac12;/g, "").replace(/&frac34;/g, "").replace(/&iquest;/g, "").replace(/&times;/g, "").replace(/&divide;/g, "").replace(/&Agrave;/g, "").replace(/&Aacute;/g, "").replace(/&Acirc;/g, "").replace(/&Atilde;/g, "").replace(/&Auml;/g, "").replace(/&Aring;/g, "").replace(/&AElig;/g, "").replace(/&Ccedil;/g, "").replace(/&Egrave;/g, "").replace(/&Eacute;/g, "").replace(/&Ecirc;/g, "").replace(/&Euml;/g, "").replace(/&Igrave;/g, "").replace(/&Iacute;/g, "").replace(/&Icirc;/g, "").replace(/&Iuml;/g, "").replace(/&ETH;/g, "").replace(/&Ntilde;/g, "").replace(/&Ograve;/g, "").replace(/&Oacute;/g, "").replace(/&Ocirc;/g, "").replace(/&Otilde;/g, "").replace(/&Ouml;/g, "").replace(/&Oslash;/g, "").replace(/&Ugrave;/g, "").replace(/&Uacute;/g, "").replace(/&Ucirc;/g, "").replace(/&Uuml;/g, "").replace(/&Yacute;/g, "").replace(/&THORN;/g, "").replace(/&szlig;/g, "").replace(/&agrave;/g, "").replace(/&aacute;/g, "").replace(/&acirc;/g, "").replace(/&atilde;/g, "").replace(/&auml;/g, "").replace(/&aring;/g, "").replace(/&aelig;/g, "").replace(/&ccedil;/g, "").replace(/&egrave;/g, "").replace(/&eacute;/g, "").replace(/&ecirc;/g, "").replace(/&euml;/g, "").replace(/&igrave;/g, "").replace(/&iacute;/g, "").replace(/&icirc;/g, "").replace(/&iuml;/g, "").replace(/&eth;/g, "").replace(/&ntilde;/g, "").replace(/&ograve;/g, "").replace(/&oacute;/g, "").replace(/&ocirc;/g, "").replace(/&otilde;/g, "").replace(/&ouml;/g, "").replace(/&oslash;/g, "").replace(/&ugrave;/g, "").replace(/&uacute;/g, "").replace(/&ucirc;/g, "").replace(/&uuml;/g, "").replace(/&yacute;/g, "").replace(/&thorn;/g, "").replace(/&yuml;/g, "");
}

exports.escapeCharacter = escapeCharacter;

var fromulaRef =
/** @class */
function () {
  function fromulaRef() {}

  fromulaRef.trim = function (str) {
    if (str == null) {
      str = "";
    }

    return str.replace(/(^\s*)|(\s*$)/g, "");
  };

  fromulaRef.functionCopy = function (txt, mode, step) {
    var _this = this;

    if (_this.operatorjson == null) {
      var arr = _this.operator.split("|"),
          op = {};

      for (var i_1 = 0; i_1 < arr.length; i_1++) {
        op[arr[i_1].toString()] = 1;
      }

      _this.operatorjson = op;
    }

    if (mode == null) {
      mode = "down";
    }

    if (step == null) {
      step = 1;
    }

    if (txt.substr(0, 1) == "=") {
      txt = txt.substr(1);
    }

    var funcstack = txt.split("");
    var i = 0,
        str = "",
        function_str = "",
        ispassby = true;
    var matchConfig = {
      "bracket": 0,
      "comma": 0,
      "squote": 0,
      "dquote": 0
    };

    while (i < funcstack.length) {
      var s = funcstack[i];

      if (s == "(" && matchConfig.dquote == 0) {
        matchConfig.bracket += 1;

        if (str.length > 0) {
          function_str += str + "(";
        } else {
          function_str += "(";
        }

        str = "";
      } else if (s == ")" && matchConfig.dquote == 0) {
        matchConfig.bracket -= 1;
        function_str += _this.functionCopy(str, mode, step) + ")";
        str = "";
      } else if (s == '"' && matchConfig.squote == 0) {
        if (matchConfig.dquote > 0) {
          function_str += str + '"';
          matchConfig.dquote -= 1;
          str = "";
        } else {
          matchConfig.dquote += 1;
          str += '"';
        }
      } else if (s == ',' && matchConfig.dquote == 0) {
        function_str += _this.functionCopy(str, mode, step) + ',';
        str = "";
      } else if (s == '&' && matchConfig.dquote == 0) {
        if (str.length > 0) {
          function_str += _this.functionCopy(str, mode, step) + "&";
          str = "";
        } else {
          function_str += "&";
        }
      } else if (s in _this.operatorjson && matchConfig.dquote == 0) {
        var s_next = "";

        if (i + 1 < funcstack.length) {
          s_next = funcstack[i + 1];
        }

        var p = i - 1,
            s_pre = null;

        if (p >= 0) {
          do {
            s_pre = funcstack[p--];
          } while (p >= 0 && s_pre == " ");
        }

        if (s + s_next in _this.operatorjson) {
          if (str.length > 0) {
            function_str += _this.functionCopy(str, mode, step) + s + s_next;
            str = "";
          } else {
            function_str += s + s_next;
          }

          i++;
        } else if (!/[^0-9]/.test(s_next) && s == "-" && (s_pre == "(" || s_pre == null || s_pre == "," || s_pre == " " || s_pre in _this.operatorjson)) {
          str += s;
        } else {
          if (str.length > 0) {
            function_str += _this.functionCopy(str, mode, step) + s;
            str = "";
          } else {
            function_str += s;
          }
        }
      } else {
        str += s;
      }

      if (i == funcstack.length - 1) {
        if (_this.iscelldata(_this.trim(str))) {
          if (mode == "down") {
            function_str += _this.downparam(_this.trim(str), step);
          } else if (mode == "up") {
            function_str += _this.upparam(_this.trim(str), step);
          } else if (mode == "left") {
            function_str += _this.leftparam(_this.trim(str), step);
          } else if (mode == "right") {
            function_str += _this.rightparam(_this.trim(str), step);
          }
        } else {
          function_str += _this.trim(str);
        }
      }

      i++;
    }

    return function_str;
  };

  fromulaRef.downparam = function (txt, step) {
    return this.updateparam("d", txt, step);
  };

  fromulaRef.upparam = function (txt, step) {
    return this.updateparam("u", txt, step);
  };

  fromulaRef.leftparam = function (txt, step) {
    return this.updateparam("l", txt, step);
  };

  fromulaRef.rightparam = function (txt, step) {
    return this.updateparam("r", txt, step);
  };

  fromulaRef.updateparam = function (orient, txt, step) {
    var _this = this;

    var val = txt.split("!"),
        rangetxt,
        prefix = "";

    if (val.length > 1) {
      rangetxt = val[1];
      prefix = val[0] + "!";
    } else {
      rangetxt = val[0];
    }

    if (rangetxt.indexOf(":") == -1) {
      var row = parseInt(rangetxt.replace(/[^0-9]/g, ""));
      var col = ABCatNum(rangetxt.replace(/[^A-Za-z]/g, ""));

      var freezonFuc = _this.isfreezonFuc(rangetxt);

      var $row = freezonFuc[0] ? "$" : "",
          $col = freezonFuc[1] ? "$" : "";

      if (orient == "u" && !freezonFuc[0]) {
        row -= step;
      } else if (orient == "r" && !freezonFuc[1]) {
        col += step;
      } else if (orient == "l" && !freezonFuc[1]) {
        col -= step;
      } else if (!freezonFuc[0]) {
        row += step;
      }

      if (row < 0 || col < 0) {
        return _this.error.r;
      }

      if (!isNaN(row) && !isNaN(col)) {
        return prefix + $col + chatatABC(col) + $row + row;
      } else if (!isNaN(row)) {
        return prefix + $row + row;
      } else if (!isNaN(col)) {
        return prefix + $col + chatatABC(col);
      } else {
        return txt;
      }
    } else {
      rangetxt = rangetxt.split(":");
      var row = [],
          col = [];
      row[0] = parseInt(rangetxt[0].replace(/[^0-9]/g, ""));
      row[1] = parseInt(rangetxt[1].replace(/[^0-9]/g, ""));

      if (row[0] > row[1]) {
        return txt;
      }

      col[0] = ABCatNum(rangetxt[0].replace(/[^A-Za-z]/g, ""));
      col[1] = ABCatNum(rangetxt[1].replace(/[^A-Za-z]/g, ""));

      if (col[0] > col[1]) {
        return txt;
      }

      var freezonFuc0 = _this.isfreezonFuc(rangetxt[0]);

      var freezonFuc1 = _this.isfreezonFuc(rangetxt[1]);

      var $row0 = freezonFuc0[0] ? "$" : "",
          $col0 = freezonFuc0[1] ? "$" : "";
      var $row1 = freezonFuc1[0] ? "$" : "",
          $col1 = freezonFuc1[1] ? "$" : "";

      if (orient == "u") {
        if (!freezonFuc0[0]) {
          row[0] -= step;
        }

        if (!freezonFuc1[0]) {
          row[1] -= step;
        }
      } else if (orient == "r") {
        if (!freezonFuc0[1]) {
          col[0] += step;
        }

        if (!freezonFuc1[1]) {
          col[1] += step;
        }
      } else if (orient == "l") {
        if (!freezonFuc0[1]) {
          col[0] -= step;
        }

        if (!freezonFuc1[1]) {
          col[1] -= step;
        }
      } else {
        if (!freezonFuc0[0]) {
          row[0] += step;
        }

        if (!freezonFuc1[0]) {
          row[1] += step;
        }
      }

      if (row[0] < 0 || col[0] < 0) {
        return _this.error.r;
      }

      if (isNaN(col[0]) && isNaN(col[1])) {
        return prefix + $row0 + row[0] + ":" + $row1 + row[1];
      } else if (isNaN(row[0]) && isNaN(row[1])) {
        return prefix + $col0 + chatatABC(col[0]) + ":" + $col1 + chatatABC(col[1]);
      } else {
        return prefix + $col0 + chatatABC(col[0]) + $row0 + row[0] + ":" + $col1 + chatatABC(col[1]) + $row1 + row[1];
      }
    }
  };

  fromulaRef.iscelldata = function (txt) {
    var val = txt.split("!"),
        rangetxt;

    if (val.length > 1) {
      rangetxt = val[1];
    } else {
      rangetxt = val[0];
    }

    var reg_cell = /^(([a-zA-Z]+)|([$][a-zA-Z]+))(([0-9]+)|([$][0-9]+))$/g; //+ A1:B3

    var reg_cellRange = /^(((([a-zA-Z]+)|([$][a-zA-Z]+))(([0-9]+)|([$][0-9]+)))|((([a-zA-Z]+)|([$][a-zA-Z]+))))$/g; //+ A1:B3A:A

    if (rangetxt.indexOf(":") == -1) {
      var row = parseInt(rangetxt.replace(/[^0-9]/g, "")) - 1;
      var col = ABCatNum(rangetxt.replace(/[^A-Za-z]/g, ""));

      if (!isNaN(row) && !isNaN(col) && rangetxt.toString().match(reg_cell)) {
        return true;
      } else if (!isNaN(row)) {
        return false;
      } else if (!isNaN(col)) {
        return false;
      } else {
        return false;
      }
    } else {
      reg_cellRange = /^(((([a-zA-Z]+)|([$][a-zA-Z]+))(([0-9]+)|([$][0-9]+)))|((([a-zA-Z]+)|([$][a-zA-Z]+)))|((([0-9]+)|([$][0-9]+s))))$/g;
      rangetxt = rangetxt.split(":");
      var row = [],
          col = [];
      row[0] = parseInt(rangetxt[0].replace(/[^0-9]/g, "")) - 1;
      row[1] = parseInt(rangetxt[1].replace(/[^0-9]/g, "")) - 1;

      if (row[0] > row[1]) {
        return false;
      }

      col[0] = ABCatNum(rangetxt[0].replace(/[^A-Za-z]/g, ""));
      col[1] = ABCatNum(rangetxt[1].replace(/[^A-Za-z]/g, ""));

      if (col[0] > col[1]) {
        return false;
      }

      if (rangetxt[0].toString().match(reg_cellRange) && rangetxt[1].toString().match(reg_cellRange)) {
        return true;
      } else {
        return false;
      }
    }
  };

  fromulaRef.isfreezonFuc = function (txt) {
    var row = txt.replace(/[^0-9]/g, "");
    var col = txt.replace(/[^A-Za-z]/g, "");
    var row$ = txt.substr(txt.indexOf(row) - 1, 1);
    var col$ = txt.substr(txt.indexOf(col) - 1, 1);
    var ret = [false, false];

    if (row$ == "$") {
      ret[0] = true;
    }

    if (col$ == "$") {
      ret[1] = true;
    }

    return ret;
  };

  fromulaRef.operator = '==|!=|<>|<=|>=|=|+|-|>|<|/|*|%|&|^';
  fromulaRef.error = {
    v: "#VALUE!",
    n: "#NAME?",
    na: "#N/A",
    r: "#REF!",
    d: "#DIV/0!",
    nm: "#NUM!",
    nl: "#NULL!",
    sp: "#SPILL!" //

  };
  fromulaRef.operatorjson = null;
  return fromulaRef;
}();

exports.fromulaRef = fromulaRef;

function isChinese(temp) {
  var re = /[^\u4e00-\u9fa5]/;
  var reg = /[\u3002|\uff1f|\uff01|\uff0c|\u3001|\uff1b|\uff1a|\u201c|\u201d|\u2018|\u2019|\uff08|\uff09|\u300a|\u300b|\u3008|\u3009|\u3010|\u3011|\u300e|\u300f|\u300c|\u300d|\ufe43|\ufe44|\u3014|\u3015|\u2026|\u2014|\uff5e|\ufe4f|\uffe5]/;
  if (reg.test(temp)) return true;
  if (re.test(temp)) return false;
  return true;
}

exports.isChinese = isChinese;

function isJapanese(temp) {
  var re = /[^\u0800-\u4e00]/;
  if (re.test(temp)) return false;
  return true;
}

exports.isJapanese = isJapanese;

function isKoera(chr) {
  if (chr > 0x3130 && chr < 0x318F || chr >= 0xAC00 && chr <= 0xD7A3) {
    return true;
  }

  return false;
}

exports.isKoera = isKoera;

function isContainMultiType(str) {
  var isUnicode = false;

  if (escape(str).indexOf("%u") > -1) {
    isUnicode = true;
  }

  var isNot = false;
  var reg = /[0-9a-z]/gi;

  if (reg.test(str)) {
    isNot = true;
  }

  var reEnSign = /[\x00-\xff]+/g;

  if (reEnSign.test(str)) {
    isNot = true;
  }

  if (isUnicode && isNot) {
    return true;
  }

  return false;
}

exports.isContainMultiType = isContainMultiType;

function getBinaryContent(path, options) {
  var promise, resolve, reject;
  var callback;

  if (!options) {
    options = {};
  } // taken from jQuery


  var createStandardXHR = function createStandardXHR() {
    try {
      return new window.XMLHttpRequest();
    } catch (e) {}
  };

  var createActiveXHR = function createActiveXHR() {
    try {
      return new window.ActiveXObject("Microsoft.XMLHTTP");
    } catch (e) {}
  }; // Create the request object


  var createXHR = typeof window !== "undefined" && window.ActiveXObject ?
  /* Microsoft failed to properly
  * implement the XMLHttpRequest in IE7 (can't request local files),
  * so we use the ActiveXObject when it is available
  * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
  * we need a fallback.
  */
  function () {
    return createStandardXHR() || createActiveXHR();
  } : // For all other browsers, use the standard XMLHttpRequest object
  createStandardXHR; // backward compatible callback

  if (typeof options === "function") {
    callback = options;
    options = {};
  } else if (typeof options.callback === 'function') {
    // callback inside options object
    callback = options.callback;
  }

  resolve = function resolve(data) {
    callback(null, data);
  };

  reject = function reject(err) {
    callback(err, null);
  };

  try {
    var xhr = createXHR();
    xhr.open('GET', path, true); // recent browsers

    if ("responseType" in xhr) {
      xhr.responseType = "arraybuffer";
    } // older browser


    if (xhr.overrideMimeType) {
      xhr.overrideMimeType("text/plain; charset=x-user-defined");
    }

    xhr.onreadystatechange = function (event) {
      // use `xhr` and not `this`... thanks IE
      if (xhr.readyState === 4) {
        if (xhr.status === 200 || xhr.status === 0) {
          try {
            resolve(function (xhr) {
              // for xhr.responseText, the 0xFF mask is applied by JSZip
              return xhr.response || xhr.responseText;
            }(xhr));
          } catch (err) {
            reject(new Error(err));
          }
        } else {
          reject(new Error("Ajax error for " + path + " : " + this.status + " " + this.statusText));
        }
      }
    };

    if (options.progress) {
      xhr.onprogress = function (e) {
        options.progress({
          path: path,
          originalEvent: e,
          percent: e.loaded / e.total * 100,
          loaded: e.loaded,
          total: e.total
        });
      };
    }

    xhr.send();
  } catch (e) {
    reject(new Error(e), null);
  } // returns a promise or undefined depending on whether a callback was
  // provided


  return promise;
}

exports.getBinaryContent = getBinaryContent;
/**
 * multi sequence conversion
 * example:
 *  1E14 -> 13_4
 *  2E14 J14 O14 T14 Y14 AD14 AI14 AN14 AS14 AX14 ->
 *     ['13_4', '13_9','13_14', '13_19', '13_24', '13_3', '13_8',  '13_13', '13_18', '13_23']
 *  3E46:E47 -> ['45_4',  '46_4']
 *
 * @param {string} sqref - before sequence
 * @returns {string[]}
 */

function getMultiSequenceToNum(sqref) {
  if (!sqref || (sqref === null || sqref === void 0 ? void 0 : sqref.length) <= 0) return [];
  sqref = sqref.toUpperCase();
  var sqrefRawArr = sqref.split(" ");
  var sqrefArr = sqrefRawArr.filter(function (e) {
    return e && e.trim();
  });
  var sqrefLastArr = getSqrefRawArrFormat(sqrefArr);
  var resArr = [];

  for (var i = 0; i < sqrefLastArr.length; i++) {
    var _res = getSingleSequenceToNum(sqrefLastArr[i]);

    if (_res) resArr.push(_res);
  }

  return resArr;
}

exports.getMultiSequenceToNum = getMultiSequenceToNum;
/**
 * get region sequence
 * example:
 *  1[A1:C2'] -> ['A1', 'A2', 'B1', 'B2', 'C1', 'C2']
 *
 * @param {string[]} arr - formats arr
 * @returns {string[]} - after arr
 */

function getRegionSequence(arr) {
  var _a, _b;

  var formatArr = [];
  var regEn = new RegExp(/[A-Z]+|[0-9]+/g);
  var startArr = (_a = arr[0]) === null || _a === void 0 ? void 0 : _a.match(regEn);
  var lastArr = (_b = arr[1]) === null || _b === void 0 ? void 0 : _b.match(regEn);
  var columnMax = Math.max.apply(Math, [ABCatNum(startArr[0]), ABCatNum(lastArr[0])]);
  var columnMin = Math.min.apply(Math, [ABCatNum(startArr[0]), ABCatNum(lastArr[0])]);
  var rowMax = Math.max.apply(Math, [parseInt(startArr[1]), parseInt(lastArr[1])]);
  var rowMin = Math.min.apply(Math, [parseInt(startArr[1]), parseInt(lastArr[1])]);

  for (var i = columnMin; i <= columnMax; i++) {
    for (var j = rowMin; j <= rowMax; j++) {
      formatArr.push("" + chatatABC(i) + j);
    }
  }

  return formatArr;
}

exports.getRegionSequence = getRegionSequence;
/**
 * unified processing of conversion formats
 * example:
 *  1['E38', 'A1:C2'] -> ['E38', 'A1', 'A2', 'B1', 'B2', 'C1', 'C2']
 *
 * @param {string[]} arr - formats arr
 * @returns {string[]} - after arr
 */

function getSqrefRawArrFormat(arr) {
  arr === null || arr === void 0 ? void 0 : arr.map(function (el) {
    if (el.includes(":")) {
      var tempArr = el.split(":");

      if ((tempArr === null || tempArr === void 0 ? void 0 : tempArr.length) === 2) {
        arr = arr.concat(getRegionSequence(tempArr));
        arr.splice(arr.indexOf(el), 1);
      }
    }
  });
  var resultArr = arr.filter(function (value, index, array) {
    return array.indexOf(value) === index;
  });
  return resultArr;
}

exports.getSqrefRawArrFormat = getSqrefRawArrFormat;
/**
 * single sequence to number
 * example:
 *  1A1 -> 0_0
 *  2ES14 -> 13_4
 *
 * @param {string} sqref - before sequence
 * @returns {string} - after sequence
 */

function getSingleSequenceToNum(sqref) {
  var sqrefArray = sqref.match(/[A-Z]+|[0-9]+/g);
  var sqrefLen = sqrefArray.length;
  var regEn = new RegExp("^[A-Z]+$");
  var ret = "";

  for (var i = sqrefLen - 1; i >= 0; i--) {
    var cur = sqrefArray[i];

    if (regEn.test(cur)) {
      ret += ABCatNum(cur) + "_";
    } else {
      ret += parseInt(cur) - 1 + "_";
    }
  }

  return ret.substring(0, ret.length - 1);
}

exports.getSingleSequenceToNum = getSingleSequenceToNum;
/**
 * R1C1 to Sequence
 * example: sheet2!R1C1 => sheet!A1
 *
 * @param {string} value - R1C1 value
 * @returns
 */

function getTransR1C1ToSequence(value) {
  if (!value && (value === null || value === void 0 ? void 0 : value.length) <= 0) return "";
  var len = value.length;
  var index = value.lastIndexOf("!");
  var valueArr = [value.slice(0, index), value.slice(index + 1, len)];
  var repStr = valueArr[1] || "";
  var indexR = repStr.indexOf("R");
  var indexC = repStr.indexOf("C");
  var row = Number(repStr.slice(indexR + 1, indexC));
  var column = chatatABC(Number(repStr.slice(indexC + 1, repStr === null || repStr === void 0 ? void 0 : repStr.length)) - 1);
  return valueArr[0] + "!" + column + row;
}

exports.getTransR1C1ToSequence = getTransR1C1ToSequence;
/**
 * strip x14 format data
 *
 * @param {string} value
 * @returns {Object} - { formula, sqref }
 */

function getPeelOffX14(value) {
  var _a;

  if (!value || (value === null || value === void 0 ? void 0 : value.length) <= 0) return {}; // formula

  var formulaReg = new RegExp("</x14:formula[^]>", "g");
  var lastIndex = (_a = value.match(formulaReg)) === null || _a === void 0 ? void 0 : _a.length;
  var lastValue = "</x14:formula" + lastIndex + ">";
  var lastValueEnd = value.indexOf(lastValue);
  var formulaValue = value.substring(0, lastValueEnd + lastValue.length);
  formulaValue = formulaValue.replace(/<xm:f>/g, "").replace(/<\/xm:f>/g, "").replace(/x14:/g, "").replace(/\/x14:/g, "");
  var formula = formulaValue; // sqref

  var xmSqrefLen = "<xm:sqref>".length;
  var sqrefStart = value.indexOf("<xm:sqref>");
  var sqrefEnd = value.indexOf("</xm:sqref>");
  var sqref = value.substring(sqrefStart + xmSqrefLen, sqrefEnd);
  return {
    formula: formula,
    sqref: sqref
  };
}

exports.getPeelOffX14 = getPeelOffX14;
/**
 * get the value in the formula
 *
 * @param {string} value - extracted value
 * @returns {string[]}
 */

function getMultiFormulaValue(value) {
  var _a, _b;

  if (!value || (value === null || value === void 0 ? void 0 : value.length) <= 0) return [];
  var lenReg = new RegExp("formula", "g");
  var len = (((_a = value.match(lenReg)) === null || _a === void 0 ? void 0 : _a.length) || 0) / 2;
  if (len === 0) return [];
  var retArr = [];

  for (var i = 1; i <= len; i++) {
    var startLen = (_b = "<formula" + i + ">") === null || _b === void 0 ? void 0 : _b.length;
    var start = value.indexOf("<formula" + i + ">");
    var end = value.indexOf("</formula" + i + ">");

    var _value = value.substring(start + startLen, end);

    retArr.push(escapeCharacter(_value.replace(/&quot;|^\"|\"$/g, "")));
  }

  return retArr;
}

exports.getMultiFormulaValue = getMultiFormulaValue;

},{"./constant":92}],95:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.exceler = void 0;

var LuckyFile_1 = require("./ToLuckySheet/LuckyFile"); // import {SecurityDoor,Car} from './content';


var HandleZip_1 = require("./HandleZip"); // //demo
// function demoHandler(){
//     let upload = document.getElementById("Luckyexcel-demo-file");
//     let selectADemo = document.getElementById("Luckyexcel-select-demo");
//     let downlodDemo = document.getElementById("Luckyexcel-downlod-file");
//     let mask = document.getElementById("lucky-mask-demo");
//     if(upload){
//         window.onload = () => {
//             upload.addEventListener("change", function(evt){
//                 var files:FileList = (evt.target as any).files;
//                 if(files==null || files.length==0){
//                     alert("No files wait for import");
//                     return;
//                 }
//                 let name = files[0].name;
//                 let suffixArr = name.split("."), suffix = suffixArr[suffixArr.length-1];
//                 if(suffix!="xlsx"){
//                     alert("Currently only supports the import of xlsx files");
//                     return;
//                 }
//                 LuckyExcel.transformExcelToLucky(files[0], function(exportJson:any, luckysheetfile:string){
//                     if(exportJson.sheets==null || exportJson.sheets.length==0){
//                         alert("Failed to read the content of the excel file, currently does not support xls files!");
//                         return;
//                     }
//                     console.log(exportJson, luckysheetfile);
//                     window.luckysheet.destroy();
//                     window.luckysheet.create({
//                         container: 'luckysheet', //luckysheet is the container id
//                         showinfobar:false,
//                         data:exportJson.sheets,
//                         title:exportJson.info.name,
//                         userInfo:exportJson.info.name.creator
//                     });
//                 });
//             });
//             selectADemo.addEventListener("change", function(evt){
//                 var obj:any = selectADemo;
//                 var index = obj.selectedIndex;
//                 var value = obj.options[index].value;
//                 var name = obj.options[index].innerHTML;
//                 if(value==""){
//                     return;
//                 }
//                 mask.style.display = "flex";
//                 LuckyExcel.transformExcelToLuckyByUrl(value, name, function(exportJson:any, luckysheetfile:string){
//                     if(exportJson.sheets==null || exportJson.sheets.length==0){
//                         alert("Failed to read the content of the excel file, currently does not support xls files!");
//                         return;
//                     }
//                     console.log(exportJson, luckysheetfile);
//                     mask.style.display = "none";
//                     window.luckysheet.destroy();
//                     window.luckysheet.create({
//                         container: 'luckysheet', //luckysheet is the container id
//                         showinfobar:false,
//                         data:exportJson.sheets,
//                         title:exportJson.info.name,
//                         userInfo:exportJson.info.name.creator
//                     });
//                 });
//             });
//             downlodDemo.addEventListener("click", function(evt){
//                 var obj:any = selectADemo;
//                 var index = obj.selectedIndex;
//                 var value = obj.options[index].value;
//                 if(value.length==0){
//                     alert("Please select a demo file");
//                     return;
//                 }
//                 var elemIF:any = document.getElementById("Lucky-download-frame");
//                 if(elemIF==null){
//                     elemIF = document.createElement("iframe");
//                     elemIF.style.display = "none";
//                     elemIF.id = "Lucky-download-frame";
//                     document.body.appendChild(elemIF);
//                 }
//                 elemIF.src = value;
//                 // elemIF.parentNode.removeChild(elemIF);
//             });
//         }
//     }
// }
// demoHandler();
// api


var exceler =
/** @class */
function () {
  function exceler() {}

  exceler.transformExcelToLucky = function (excelFile, callback, errorHandler) {
    var handleZip = new HandleZip_1.HandleZip(excelFile);
    handleZip.unzipFile(function (files) {
      var luckyFile = new LuckyFile_1.LuckyFile(files, excelFile.name);
      var luckysheetfile = luckyFile.Parse();
      var exportJson = JSON.parse(luckysheetfile);

      if (callback != undefined) {
        callback(exportJson, luckysheetfile);
      }
    }, function (err) {
      if (errorHandler) {
        errorHandler(err);
      } else {
        console.error(err);
      }
    });
  };

  exceler.transformExcelToLuckyByUrl = function (url, name, callBack, errorHandler) {
    var handleZip = new HandleZip_1.HandleZip();
    handleZip.unzipFileByUrl(url, function (files) {
      var luckyFile = new LuckyFile_1.LuckyFile(files, name);
      var luckysheetfile = luckyFile.Parse();
      var exportJson = JSON.parse(luckysheetfile);

      if (callBack != undefined) {
        callBack(exportJson, luckysheetfile);
      }
    }, function (err) {
      if (errorHandler) {
        errorHandler(err);
      } else {
        console.error(err);
      }
    });
  };

  exceler.transformLuckyToExcel = function (LuckyFile, callBack, errorHandler) {};

  return exceler;
}();

exports.exceler = exceler;

},{"./HandleZip":85,"./ToLuckySheet/LuckyFile":88}],96:[function(require,module,exports){
"use strict";

var main_1 = require("./main");

module.exports = main_1.exceler;

},{"./main":95}]},{},[96])(96)
});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY29yZS11dGlsLWlzL2xpYi91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2RheWpzL2RheWpzLm1pbi5qcyIsIm5vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwibm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaW1tZWRpYXRlL2xpYi9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvaXMtYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL2Jhc2U2NC5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvY29tcHJlc3NlZE9iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvY29tcHJlc3Npb25zLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9jcmMzMi5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvZGVmYXVsdHMuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL2V4dGVybmFsLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9mbGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvZ2VuZXJhdGUvWmlwRmlsZVdvcmtlci5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvZ2VuZXJhdGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9sb2FkLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9ub2RlanNVdGlscy5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvbm9kZWpzL05vZGVqc1N0cmVhbUlucHV0QWRhcHRlci5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvbm9kZWpzL05vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL29iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvcmVhZGFibGUtc3RyZWFtLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRlci9BcnJheVJlYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvcmVhZGVyL0RhdGFSZWFkZXIuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3JlYWRlci9Ob2RlQnVmZmVyUmVhZGVyLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9yZWFkZXIvU3RyaW5nUmVhZGVyLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9yZWFkZXIvVWludDhBcnJheVJlYWRlci5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvcmVhZGVyL3JlYWRlckZvci5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvc2lnbmF0dXJlLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zdHJlYW0vQ29udmVydFdvcmtlci5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvc3RyZWFtL0NyYzMyUHJvYmUuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3N0cmVhbS9EYXRhTGVuZ3RoUHJvYmUuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3N0cmVhbS9EYXRhV29ya2VyLmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi9zdHJlYW0vR2VuZXJpY1dvcmtlci5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvc3RyZWFtL1N0cmVhbUhlbHBlci5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvc3VwcG9ydC5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvdXRmOC5qcyIsIm5vZGVfbW9kdWxlcy9qc3ppcC9saWIvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3ppcEVudHJpZXMuanMiLCJub2RlX21vZHVsZXMvanN6aXAvbGliL3ppcEVudHJ5LmpzIiwibm9kZV9tb2R1bGVzL2pzemlwL2xpYi96aXBPYmplY3QuanMiLCJub2RlX21vZHVsZXMvbGllL2xpYi9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vaW5kZXguanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvZGVmbGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi9pbmZsYXRlLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3V0aWxzL2NvbW1vbi5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi91dGlscy9zdHJpbmdzLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvYWRsZXIzMi5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2NyYzMyLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvZGVmbGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2d6aGVhZGVyLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvaW5mZmFzdC5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmxhdGUuanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9pbmZ0cmVlcy5qcyIsIm5vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL21lc3NhZ2VzLmpzIiwibm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvdHJlZXMuanMiLCJub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi96c3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MtbmV4dGljay1hcmdzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vZHVwbGV4LWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95LmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0tYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9zYWZlLWJ1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zZXQtaW1tZWRpYXRlLXNoaW0vaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzIiwibm9kZV9tb2R1bGVzL3RpbWVycy1icm93c2VyaWZ5L21haW4uanMiLCJub2RlX21vZHVsZXMvdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qcyIsInNyYy9IYW5kbGVaaXAudHMiLCJzcmMvVG9MdWNreVNoZWV0L0x1Y2t5QmFzZS50cyIsInNyYy9Ub0x1Y2t5U2hlZXQvTHVja3lDZWxsLnRzIiwic3JjL1RvTHVja3lTaGVldC9MdWNreUZpbGUudHMiLCJzcmMvVG9MdWNreVNoZWV0L0x1Y2t5SW1hZ2UudHMiLCJzcmMvVG9MdWNreVNoZWV0L0x1Y2t5U2hlZXQudHMiLCJzcmMvVG9MdWNreVNoZWV0L1JlYWRYbWwudHMiLCJzcmMvY29tbW9uL2NvbnN0YW50LnRzIiwic3JjL2NvbW1vbi9lbWYudHMiLCJzcmMvY29tbW9uL21ldGhvZC50cyIsInNyYy9tYWluLnRzIiwic3JjL21haW4udW1kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEpBOzs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzd2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0dBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDcE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1ZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcGhEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdHNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hMQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMS9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDck5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzlxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdlNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ25FQSxJQUFBLE9BQUEsR0FBQSxlQUFBLENBQUEsT0FBQSxDQUFBLE9BQUEsQ0FBQSxDQUFBOztBQUVBLElBQUEsUUFBQSxHQUFBLE9BQUEsQ0FBQSxpQkFBQSxDQUFBOztBQUdBLElBQUEsU0FBQTtBQUFBO0FBQUEsWUFBQTtBQUlJLFdBQUEsU0FBQSxDQUFZLElBQVosRUFBc0I7QUFDbEI7QUFDQTtBQUNJLFNBQUssVUFBTCxHQUFrQixJ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Q0FBeUIsR0FBekIsRUFBOEIsVUFBUyxLQUFULEVBQThCO0FBQ3hELFVBQUksU0FBUyxHQUFHLElBQUksV0FBQSxDQUFBLFNBQUosQ0FBYyxLQUFkLEVBQXFCLElBQXJCLENBQWhCO0FBQ0EsVUFBSSxjQUFjLEdBQUcsU0FBUyxDQUFDLEtBQVYsRUFBckI7QUFDQSxVQUFJLFVBQVUsR0FBRyxJQUFJLENBQUMsS0FBTCxDQUFXLGNBQVgsQ0FBakI7O0FBQ0EsVUFBRyxRQUFRLElBQUksU0FBZixFQUF5QjtBQUNyQixRQUFBLFFBQVEsQ0FBQyxVQUFELEVBQWEsY0FBYixDQUFSO0FBQ0g7QUFDSixLQVBELEVBUUEsVUFBUyxHQUFULEVBQWtCO0FBQ2QsVUFBSSxZQUFKLEVBQWtCO0FBQ2QsUUFBQSxZQUFZLENBQUMsR0FBRCxDQUFaO0FBQ0QsT0FGSCxNQUVTO0FBQ0wsUUFBQSxPQUFPLENBQUMsS0FBUixDQUFjLEdBQWQ7QUFDRDtBQUNOLEtBZEQ7QUFlSCxHQXJCTTs7QUF1QkEsRUFBQSxPQUFBLENBQUEscUJBQUEsR0FBUCxVQUNJLFNBREosRUFFSSxRQUZKLEVBR0ksWUFISixFQUd1QyxDQUFJLENBSHBDOztBQUlYLFNBQUEsT0FBQTtBQUFDLENBbERELEVBQUE7O0FBQWEsT0FBQSxDQUFBLE9BQUEsR0FBQSxPQUFBOzs7OztBQzFHYixJQUFBLE1BQUEsR0FBQSxPQUFBLENBQUEsUUFBQSxDQUFBOztBQUVBLE1BQUEsQ0FBQSxPQUFBLEdBQVMsTUFBQSxDQUFBLE9BQVQiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsIiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xuZXhwb3J0cy5rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuKVxuXG4gICAgaWYgKHRoYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhhdFxuICAgIH1cblxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAoaXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cblxuZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xuICB9XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG4iLCIhZnVuY3Rpb24odCxlKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1lKCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShlKToodD1cInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsVGhpcz9nbG9iYWxUaGlzOnR8fHNlbGYpLmRheWpzPWUoKX0odGhpcywoZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjt2YXIgdD0xZTMsZT02ZTQsbj0zNmU1LHI9XCJtaWxsaXNlY29uZFwiLGk9XCJzZWNvbmRcIixzPVwibWludXRlXCIsdT1cImhvdXJcIixhPVwiZGF5XCIsbz1cIndlZWtcIixmPVwibW9udGhcIixoPVwicXVhcnRlclwiLGM9XCJ5ZWFyXCIsZD1cImRhdGVcIiwkPVwiSW52YWxpZCBEYXRlXCIsbD0vXihcXGR7NH0pWy0vXT8oXFxkezEsMn0pP1stL10/KFxcZHswLDJ9KVtUdFxcc10qKFxcZHsxLDJ9KT86PyhcXGR7MSwyfSk/Oj8oXFxkezEsMn0pP1suOl0/KFxcZCspPyQvLHk9L1xcWyhbXlxcXV0rKV18WXsxLDR9fE17MSw0fXxEezEsMn18ZHsxLDR9fEh7MSwyfXxoezEsMn18YXxBfG17MSwyfXxzezEsMn18WnsxLDJ9fFNTUy9nLE09e25hbWU6XCJlblwiLHdlZWtkYXlzOlwiU3VuZGF5X01vbmRheV9UdWVzZGF5X1dlZG5lc2RheV9UaHVyc2RheV9GcmlkYXlfU2F0dXJkYXlcIi5zcGxpdChcIl9cIiksbW9udGhzOlwiSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlclwiLnNwbGl0KFwiX1wiKX0sbT1mdW5jdGlvbih0LGUsbil7dmFyIHI9U3RyaW5nKHQpO3JldHVybiFyfHxyLmxlbmd0aD49ZT90OlwiXCIrQXJyYXkoZSsxLXIubGVuZ3RoKS5qb2luKG4pK3R9LGc9e3M6bSx6OmZ1bmN0aW9uKHQpe3ZhciBlPS10LnV0Y09mZnNldCgpLG49TWF0aC5hYnMoZSkscj1NYXRoLmZsb29yKG4vNjApLGk9biU2MDtyZXR1cm4oZTw9MD9cIitcIjpcIi1cIikrbShyLDIsXCIwXCIpK1wiOlwiK20oaSwyLFwiMFwiKX0sbTpmdW5jdGlvbiB0KGUsbil7aWYoZS5kYXRlKCk8bi5kYXRlKCkpcmV0dXJuLXQobixlKTt2YXIgcj0xMioobi55ZWFyKCktZS55ZWFyKCkpKyhuLm1vbnRoKCktZS5tb250aCgpKSxpPWUuY2xvbmUoKS5hZGQocixmKSxzPW4taTwwLHU9ZS5jbG9uZSgpLmFkZChyKyhzPy0xOjEpLGYpO3JldHVybisoLShyKyhuLWkpLyhzP2ktdTp1LWkpKXx8MCl9LGE6ZnVuY3Rpb24odCl7cmV0dXJuIHQ8MD9NYXRoLmNlaWwodCl8fDA6TWF0aC5mbG9vcih0KX0scDpmdW5jdGlvbih0KXtyZXR1cm57TTpmLHk6Yyx3Om8sZDphLEQ6ZCxoOnUsbTpzLHM6aSxtczpyLFE6aH1bdF18fFN0cmluZyh0fHxcIlwiKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL3MkLyxcIlwiKX0sdTpmdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dH19LEQ9XCJlblwiLHY9e307dltEXT1NO3ZhciBwPWZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2YgX30sUz1mdW5jdGlvbih0LGUsbil7dmFyIHI7aWYoIXQpcmV0dXJuIEQ7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpdlt0XSYmKHI9dCksZSYmKHZbdF09ZSxyPXQpO2Vsc2V7dmFyIGk9dC5uYW1lO3ZbaV09dCxyPWl9cmV0dXJuIW4mJnImJihEPXIpLHJ8fCFuJiZEfSx3PWZ1bmN0aW9uKHQsZSl7aWYocCh0KSlyZXR1cm4gdC5jbG9uZSgpO3ZhciBuPVwib2JqZWN0XCI9PXR5cGVvZiBlP2U6e307cmV0dXJuIG4uZGF0ZT10LG4uYXJncz1hcmd1bWVudHMsbmV3IF8obil9LE89ZztPLmw9UyxPLmk9cCxPLnc9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdyh0LHtsb2NhbGU6ZS4kTCx1dGM6ZS4kdSx4OmUuJHgsJG9mZnNldDplLiRvZmZzZXR9KX07dmFyIF89ZnVuY3Rpb24oKXtmdW5jdGlvbiBNKHQpe3RoaXMuJEw9Uyh0LmxvY2FsZSxudWxsLCEwKSx0aGlzLnBhcnNlKHQpfXZhciBtPU0ucHJvdG90eXBlO3JldHVybiBtLnBhcnNlPWZ1bmN0aW9uKHQpe3RoaXMuJGQ9ZnVuY3Rpb24odCl7dmFyIGU9dC5kYXRlLG49dC51dGM7aWYobnVsbD09PWUpcmV0dXJuIG5ldyBEYXRlKE5hTik7aWYoTy51KGUpKXJldHVybiBuZXcgRGF0ZTtpZihlIGluc3RhbmNlb2YgRGF0ZSlyZXR1cm4gbmV3IERhdGUoZSk7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUmJiEvWiQvaS50ZXN0KGUpKXt2YXIgcj1lLm1hdGNoKGwpO2lmKHIpe3ZhciBpPXJbMl0tMXx8MCxzPShyWzddfHxcIjBcIikuc3Vic3RyaW5nKDAsMyk7cmV0dXJuIG4/bmV3IERhdGUoRGF0ZS5VVEMoclsxXSxpLHJbM118fDEscls0XXx8MCxyWzVdfHwwLHJbNl18fDAscykpOm5ldyBEYXRlKHJbMV0saSxyWzNdfHwxLHJbNF18fDAscls1XXx8MCxyWzZdfHwwLHMpfX1yZXR1cm4gbmV3IERhdGUoZSl9KHQpLHRoaXMuJHg9dC54fHx7fSx0aGlzLmluaXQoKX0sbS5pbml0PWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy4kZDt0aGlzLiR5PXQuZ2V0RnVsbFllYXIoKSx0aGlzLiRNPXQuZ2V0TW9udGgoKSx0aGlzLiREPXQuZ2V0RGF0ZSgpLHRoaXMuJFc9dC5nZXREYXkoKSx0aGlzLiRIPXQuZ2V0SG91cnMoKSx0aGlzLiRtPXQuZ2V0TWludXRlcygpLHRoaXMuJHM9dC5nZXRTZWNvbmRzKCksdGhpcy4kbXM9dC5nZXRNaWxsaXNlY29uZHMoKX0sbS4kdXRpbHM9ZnVuY3Rpb24oKXtyZXR1cm4gT30sbS5pc1ZhbGlkPWZ1bmN0aW9uKCl7cmV0dXJuISh0aGlzLiRkLnRvU3RyaW5nKCk9PT0kKX0sbS5pc1NhbWU9ZnVuY3Rpb24odCxlKXt2YXIgbj13KHQpO3JldHVybiB0aGlzLnN0YXJ0T2YoZSk8PW4mJm48PXRoaXMuZW5kT2YoZSl9LG0uaXNBZnRlcj1mdW5jdGlvbih0LGUpe3JldHVybiB3KHQpPHRoaXMuc3RhcnRPZihlKX0sbS5pc0JlZm9yZT1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmVuZE9mKGUpPHcodCl9LG0uJGc9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBPLnUodCk/dGhpc1tlXTp0aGlzLnNldChuLHQpfSxtLnVuaXg9ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5mbG9vcih0aGlzLnZhbHVlT2YoKS8xZTMpfSxtLnZhbHVlT2Y9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kZC5nZXRUaW1lKCl9LG0uc3RhcnRPZj1mdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMscj0hIU8udShlKXx8ZSxoPU8ucCh0KSwkPWZ1bmN0aW9uKHQsZSl7dmFyIGk9Ty53KG4uJHU/RGF0ZS5VVEMobi4keSxlLHQpOm5ldyBEYXRlKG4uJHksZSx0KSxuKTtyZXR1cm4gcj9pOmkuZW5kT2YoYSl9LGw9ZnVuY3Rpb24odCxlKXtyZXR1cm4gTy53KG4udG9EYXRlKClbdF0uYXBwbHkobi50b0RhdGUoXCJzXCIpLChyP1swLDAsMCwwXTpbMjMsNTksNTksOTk5XSkuc2xpY2UoZSkpLG4pfSx5PXRoaXMuJFcsTT10aGlzLiRNLG09dGhpcy4kRCxnPVwic2V0XCIrKHRoaXMuJHU/XCJVVENcIjpcIlwiKTtzd2l0Y2goaCl7Y2FzZSBjOnJldHVybiByPyQoMSwwKTokKDMxLDExKTtjYXNlIGY6cmV0dXJuIHI/JCgxLE0pOiQoMCxNKzEpO2Nhc2Ugbzp2YXIgRD10aGlzLiRsb2NhbGUoKS53ZWVrU3RhcnR8fDAsdj0oeTxEP3krNzp5KS1EO3JldHVybiAkKHI/bS12Om0rKDYtdiksTSk7Y2FzZSBhOmNhc2UgZDpyZXR1cm4gbChnK1wiSG91cnNcIiwwKTtjYXNlIHU6cmV0dXJuIGwoZytcIk1pbnV0ZXNcIiwxKTtjYXNlIHM6cmV0dXJuIGwoZytcIlNlY29uZHNcIiwyKTtjYXNlIGk6cmV0dXJuIGwoZytcIk1pbGxpc2Vjb25kc1wiLDMpO2RlZmF1bHQ6cmV0dXJuIHRoaXMuY2xvbmUoKX19LG0uZW5kT2Y9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuc3RhcnRPZih0LCExKX0sbS4kc2V0PWZ1bmN0aW9uKHQsZSl7dmFyIG4sbz1PLnAodCksaD1cInNldFwiKyh0aGlzLiR1P1wiVVRDXCI6XCJcIiksJD0obj17fSxuW2FdPWgrXCJEYXRlXCIsbltkXT1oK1wiRGF0ZVwiLG5bZl09aCtcIk1vbnRoXCIsbltjXT1oK1wiRnVsbFllYXJcIixuW3VdPWgrXCJIb3Vyc1wiLG5bc109aCtcIk1pbnV0ZXNcIixuW2ldPWgrXCJTZWNvbmRzXCIsbltyXT1oK1wiTWlsbGlzZWNvbmRzXCIsbilbb10sbD1vPT09YT90aGlzLiREKyhlLXRoaXMuJFcpOmU7aWYobz09PWZ8fG89PT1jKXt2YXIgeT10aGlzLmNsb25lKCkuc2V0KGQsMSk7eS4kZFskXShsKSx5LmluaXQoKSx0aGlzLiRkPXkuc2V0KGQsTWF0aC5taW4odGhpcy4kRCx5LmRheXNJbk1vbnRoKCkpKS4kZH1lbHNlICQmJnRoaXMuJGRbJF0obCk7cmV0dXJuIHRoaXMuaW5pdCgpLHRoaXN9LG0uc2V0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuY2xvbmUoKS4kc2V0KHQsZSl9LG0uZ2V0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzW08ucCh0KV0oKX0sbS5hZGQ9ZnVuY3Rpb24ocixoKXt2YXIgZCwkPXRoaXM7cj1OdW1iZXIocik7dmFyIGw9Ty5wKGgpLHk9ZnVuY3Rpb24odCl7dmFyIGU9dygkKTtyZXR1cm4gTy53KGUuZGF0ZShlLmRhdGUoKStNYXRoLnJvdW5kKHQqcikpLCQpfTtpZihsPT09ZilyZXR1cm4gdGhpcy5zZXQoZix0aGlzLiRNK3IpO2lmKGw9PT1jKXJldHVybiB0aGlzLnNldChjLHRoaXMuJHkrcik7aWYobD09PWEpcmV0dXJuIHkoMSk7aWYobD09PW8pcmV0dXJuIHkoNyk7dmFyIE09KGQ9e30sZFtzXT1lLGRbdV09bixkW2ldPXQsZClbbF18fDEsbT10aGlzLiRkLmdldFRpbWUoKStyKk07cmV0dXJuIE8udyhtLHRoaXMpfSxtLnN1YnRyYWN0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuYWRkKC0xKnQsZSl9LG0uZm9ybWF0PWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMsbj10aGlzLiRsb2NhbGUoKTtpZighdGhpcy5pc1ZhbGlkKCkpcmV0dXJuIG4uaW52YWxpZERhdGV8fCQ7dmFyIHI9dHx8XCJZWVlZLU1NLUREVEhIOm1tOnNzWlwiLGk9Ty56KHRoaXMpLHM9dGhpcy4kSCx1PXRoaXMuJG0sYT10aGlzLiRNLG89bi53ZWVrZGF5cyxmPW4ubW9udGhzLGg9ZnVuY3Rpb24odCxuLGkscyl7cmV0dXJuIHQmJih0W25dfHx0KGUscikpfHxpW25dLnN1YnN0cigwLHMpfSxjPWZ1bmN0aW9uKHQpe3JldHVybiBPLnMocyUxMnx8MTIsdCxcIjBcIil9LGQ9bi5tZXJpZGllbXx8ZnVuY3Rpb24odCxlLG4pe3ZhciByPXQ8MTI/XCJBTVwiOlwiUE1cIjtyZXR1cm4gbj9yLnRvTG93ZXJDYXNlKCk6cn0sbD17WVk6U3RyaW5nKHRoaXMuJHkpLnNsaWNlKC0yKSxZWVlZOnRoaXMuJHksTTphKzEsTU06Ty5zKGErMSwyLFwiMFwiKSxNTU06aChuLm1vbnRoc1Nob3J0LGEsZiwzKSxNTU1NOmgoZixhKSxEOnRoaXMuJEQsREQ6Ty5zKHRoaXMuJEQsMixcIjBcIiksZDpTdHJpbmcodGhpcy4kVyksZGQ6aChuLndlZWtkYXlzTWluLHRoaXMuJFcsbywyKSxkZGQ6aChuLndlZWtkYXlzU2hvcnQsdGhpcy4kVyxvLDMpLGRkZGQ6b1t0aGlzLiRXXSxIOlN0cmluZyhzKSxISDpPLnMocywyLFwiMFwiKSxoOmMoMSksaGg6YygyKSxhOmQocyx1LCEwKSxBOmQocyx1LCExKSxtOlN0cmluZyh1KSxtbTpPLnModSwyLFwiMFwiKSxzOlN0cmluZyh0aGlzLiRzKSxzczpPLnModGhpcy4kcywyLFwiMFwiKSxTU1M6Ty5zKHRoaXMuJG1zLDMsXCIwXCIpLFo6aX07cmV0dXJuIHIucmVwbGFjZSh5LChmdW5jdGlvbih0LGUpe3JldHVybiBlfHxsW3RdfHxpLnJlcGxhY2UoXCI6XCIsXCJcIil9KSl9LG0udXRjT2Zmc2V0PWZ1bmN0aW9uKCl7cmV0dXJuIDE1Ki1NYXRoLnJvdW5kKHRoaXMuJGQuZ2V0VGltZXpvbmVPZmZzZXQoKS8xNSl9LG0uZGlmZj1mdW5jdGlvbihyLGQsJCl7dmFyIGwseT1PLnAoZCksTT13KHIpLG09KE0udXRjT2Zmc2V0KCktdGhpcy51dGNPZmZzZXQoKSkqZSxnPXRoaXMtTSxEPU8ubSh0aGlzLE0pO3JldHVybiBEPShsPXt9LGxbY109RC8xMixsW2ZdPUQsbFtoXT1ELzMsbFtvXT0oZy1tKS82MDQ4ZTUsbFthXT0oZy1tKS84NjRlNSxsW3VdPWcvbixsW3NdPWcvZSxsW2ldPWcvdCxsKVt5XXx8ZywkP0Q6Ty5hKEQpfSxtLmRheXNJbk1vbnRoPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZW5kT2YoZikuJER9LG0uJGxvY2FsZT1mdW5jdGlvbigpe3JldHVybiB2W3RoaXMuJExdfSxtLmxvY2FsZT1mdW5jdGlvbih0LGUpe2lmKCF0KXJldHVybiB0aGlzLiRMO3ZhciBuPXRoaXMuY2xvbmUoKSxyPVModCxlLCEwKTtyZXR1cm4gciYmKG4uJEw9ciksbn0sbS5jbG9uZT1mdW5jdGlvbigpe3JldHVybiBPLncodGhpcy4kZCx0aGlzKX0sbS50b0RhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IERhdGUodGhpcy52YWx1ZU9mKCkpfSxtLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmlzVmFsaWQoKT90aGlzLnRvSVNPU3RyaW5nKCk6bnVsbH0sbS50b0lTT1N0cmluZz1mdW5jdGlvbigpe3JldHVybiB0aGlzLiRkLnRvSVNPU3RyaW5nKCl9LG0udG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kZC50b1VUQ1N0cmluZygpfSxNfSgpLGI9Xy5wcm90b3R5cGU7cmV0dXJuIHcucHJvdG90eXBlPWIsW1tcIiRtc1wiLHJdLFtcIiRzXCIsaV0sW1wiJG1cIixzXSxbXCIkSFwiLHVdLFtcIiRXXCIsYV0sW1wiJE1cIixmXSxbXCIkeVwiLGNdLFtcIiREXCIsZF1dLmZvckVhY2goKGZ1bmN0aW9uKHQpe2JbdFsxXV09ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuJGcoZSx0WzBdLHRbMV0pfX0pKSx3LmV4dGVuZD1mdW5jdGlvbih0LGUpe3JldHVybiB0LiRpfHwodChlLF8sdyksdC4kaT0hMCksd30sdy5sb2NhbGU9Uyx3LmlzRGF5anM9cCx3LnVuaXg9ZnVuY3Rpb24odCl7cmV0dXJuIHcoMWUzKnQpfSx3LmVuPXZbRF0sdy5Mcz12LHcucD17fSx3fSkpOyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuICgnICsgZXIgKyAnKScpO1xuICAgICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodGhpcy5fZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgICBpZiAoaXNGdW5jdGlvbihldmxpc3RlbmVyKSlcbiAgICAgIHJldHVybiAxO1xuICAgIGVsc2UgaWYgKGV2bGlzdGVuZXIpXG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbiIsIi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCIndXNlIHN0cmljdCc7XG52YXIgTXV0YXRpb24gPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcblxudmFyIHNjaGVkdWxlRHJhaW47XG5cbntcbiAgaWYgKE11dGF0aW9uKSB7XG4gICAgdmFyIGNhbGxlZCA9IDA7XG4gICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uKG5leHRUaWNrKTtcbiAgICB2YXIgZWxlbWVudCA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50LCB7XG4gICAgICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG4gICAgfSk7XG4gICAgc2NoZWR1bGVEcmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGVsZW1lbnQuZGF0YSA9IChjYWxsZWQgPSArK2NhbGxlZCAlIDIpO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoIWdsb2JhbC5zZXRJbW1lZGlhdGUgJiYgdHlwZW9mIGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgY2hhbm5lbCA9IG5ldyBnbG9iYWwuTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IG5leHRUaWNrO1xuICAgIHNjaGVkdWxlRHJhaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuICAgIH07XG4gIH0gZWxzZSBpZiAoJ2RvY3VtZW50JyBpbiBnbG9iYWwgJiYgJ29ucmVhZHlzdGF0ZWNoYW5nZScgaW4gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpKSB7XG4gICAgc2NoZWR1bGVEcmFpbiA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgdmFyIHNjcmlwdEVsID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgc2NyaXB0RWwub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBuZXh0VGljaygpO1xuXG4gICAgICAgIHNjcmlwdEVsLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgIHNjcmlwdEVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0RWwpO1xuICAgICAgICBzY3JpcHRFbCA9IG51bGw7XG4gICAgICB9O1xuICAgICAgZ2xvYmFsLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChzY3JpcHRFbCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBzY2hlZHVsZURyYWluID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2V0VGltZW91dChuZXh0VGljaywgMCk7XG4gICAgfTtcbiAgfVxufVxuXG52YXIgZHJhaW5pbmc7XG52YXIgcXVldWUgPSBbXTtcbi8vbmFtZWQgbmV4dFRpY2sgZm9yIGxlc3MgY29uZnVzaW5nIHN0YWNrIHRyYWNlc1xuZnVuY3Rpb24gbmV4dFRpY2soKSB7XG4gIGRyYWluaW5nID0gdHJ1ZTtcbiAgdmFyIGksIG9sZFF1ZXVlO1xuICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICB3aGlsZSAobGVuKSB7XG4gICAgb2xkUXVldWUgPSBxdWV1ZTtcbiAgICBxdWV1ZSA9IFtdO1xuICAgIGkgPSAtMTtcbiAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICBvbGRRdWV1ZVtpXSgpO1xuICAgIH1cbiAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gIH1cbiAgZHJhaW5pbmcgPSBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbW1lZGlhdGU7XG5mdW5jdGlvbiBpbW1lZGlhdGUodGFzaykge1xuICBpZiAocXVldWUucHVzaCh0YXNrKSA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICBzY2hlZHVsZURyYWluKCk7XG4gIH1cbn1cbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgICB9XG4gIH1cbn1cbiIsIi8qIVxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlclxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxuLy8gVGhlIF9pc0J1ZmZlciBjaGVjayBpcyBmb3IgU2FmYXJpIDUtNyBzdXBwb3J0LCBiZWNhdXNlIGl0J3MgbWlzc2luZ1xuLy8gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiAoaXNCdWZmZXIob2JqKSB8fCBpc1Nsb3dCdWZmZXIob2JqKSB8fCAhIW9iai5faXNCdWZmZXIpXG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyIChvYmopIHtcbiAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cblxuLy8gRm9yIE5vZGUgdjAuMTAgc3VwcG9ydC4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseS5cbmZ1bmN0aW9uIGlzU2xvd0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqLnJlYWRGbG9hdExFID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgaXNCdWZmZXIob2JqLnNsaWNlKDAsIDApKVxufVxuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgc3VwcG9ydCA9IHJlcXVpcmUoJy4vc3VwcG9ydCcpO1xuLy8gcHJpdmF0ZSBwcm9wZXJ0eVxudmFyIF9rZXlTdHIgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCI7XG5cblxuLy8gcHVibGljIG1ldGhvZCBmb3IgZW5jb2RpbmdcbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24oaW5wdXQpIHtcbiAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgdmFyIGNocjEsIGNocjIsIGNocjMsIGVuYzEsIGVuYzIsIGVuYzMsIGVuYzQ7XG4gICAgdmFyIGkgPSAwLCBsZW4gPSBpbnB1dC5sZW5ndGgsIHJlbWFpbmluZ0J5dGVzID0gbGVuO1xuXG4gICAgdmFyIGlzQXJyYXkgPSB1dGlscy5nZXRUeXBlT2YoaW5wdXQpICE9PSBcInN0cmluZ1wiO1xuICAgIHdoaWxlIChpIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIHJlbWFpbmluZ0J5dGVzID0gbGVuIC0gaTtcblxuICAgICAgICBpZiAoIWlzQXJyYXkpIHtcbiAgICAgICAgICAgIGNocjEgPSBpbnB1dC5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgICAgICBjaHIyID0gaSA8IGxlbiA/IGlucHV0LmNoYXJDb2RlQXQoaSsrKSA6IDA7XG4gICAgICAgICAgICBjaHIzID0gaSA8IGxlbiA/IGlucHV0LmNoYXJDb2RlQXQoaSsrKSA6IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaHIxID0gaW5wdXRbaSsrXTtcbiAgICAgICAgICAgIGNocjIgPSBpIDwgbGVuID8gaW5wdXRbaSsrXSA6IDA7XG4gICAgICAgICAgICBjaHIzID0gaSA8IGxlbiA/IGlucHV0W2krK10gOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgZW5jMSA9IGNocjEgPj4gMjtcbiAgICAgICAgZW5jMiA9ICgoY2hyMSAmIDMpIDw8IDQpIHwgKGNocjIgPj4gNCk7XG4gICAgICAgIGVuYzMgPSByZW1haW5pbmdCeXRlcyA+IDEgPyAoKChjaHIyICYgMTUpIDw8IDIpIHwgKGNocjMgPj4gNikpIDogNjQ7XG4gICAgICAgIGVuYzQgPSByZW1haW5pbmdCeXRlcyA+IDIgPyAoY2hyMyAmIDYzKSA6IDY0O1xuXG4gICAgICAgIG91dHB1dC5wdXNoKF9rZXlTdHIuY2hhckF0KGVuYzEpICsgX2tleVN0ci5jaGFyQXQoZW5jMikgKyBfa2V5U3RyLmNoYXJBdChlbmMzKSArIF9rZXlTdHIuY2hhckF0KGVuYzQpKTtcblxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQuam9pbihcIlwiKTtcbn07XG5cbi8vIHB1YmxpYyBtZXRob2QgZm9yIGRlY29kaW5nXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgdmFyIGNocjEsIGNocjIsIGNocjM7XG4gICAgdmFyIGVuYzEsIGVuYzIsIGVuYzMsIGVuYzQ7XG4gICAgdmFyIGkgPSAwLCByZXN1bHRJbmRleCA9IDA7XG5cbiAgICB2YXIgZGF0YVVybFByZWZpeCA9IFwiZGF0YTpcIjtcblxuICAgIGlmIChpbnB1dC5zdWJzdHIoMCwgZGF0YVVybFByZWZpeC5sZW5ndGgpID09PSBkYXRhVXJsUHJlZml4KSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBjb21tb24gZXJyb3I6IHBlb3BsZSBnaXZlIGEgZGF0YSB1cmxcbiAgICAgICAgLy8gKGRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUi4uLikgd2l0aCBhIHtiYXNlNjQ6IHRydWV9IGFuZFxuICAgICAgICAvLyB3b25kZXJzIHdoeSB0aGluZ3MgZG9uJ3Qgd29yay5cbiAgICAgICAgLy8gV2UgY2FuIGRldGVjdCB0aGF0IHRoZSBzdHJpbmcgaW5wdXQgbG9va3MgbGlrZSBhIGRhdGEgdXJsIGJ1dCB3ZVxuICAgICAgICAvLyAqY2FuJ3QqIGJlIHN1cmUgaXQgaXMgb25lOiByZW1vdmluZyBldmVyeXRoaW5nIHVwIHRvIHRoZSBjb21tYSB3b3VsZFxuICAgICAgICAvLyBiZSB0b28gZGFuZ2Vyb3VzLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGJhc2U2NCBpbnB1dCwgaXQgbG9va3MgbGlrZSBhIGRhdGEgdXJsLlwiKTtcbiAgICB9XG5cbiAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoL1teQS1aYS16MC05XFwrXFwvXFw9XS9nLCBcIlwiKTtcblxuICAgIHZhciB0b3RhbExlbmd0aCA9IGlucHV0Lmxlbmd0aCAqIDMgLyA0O1xuICAgIGlmKGlucHV0LmNoYXJBdChpbnB1dC5sZW5ndGggLSAxKSA9PT0gX2tleVN0ci5jaGFyQXQoNjQpKSB7XG4gICAgICAgIHRvdGFsTGVuZ3RoLS07XG4gICAgfVxuICAgIGlmKGlucHV0LmNoYXJBdChpbnB1dC5sZW5ndGggLSAyKSA9PT0gX2tleVN0ci5jaGFyQXQoNjQpKSB7XG4gICAgICAgIHRvdGFsTGVuZ3RoLS07XG4gICAgfVxuICAgIGlmICh0b3RhbExlbmd0aCAlIDEgIT09IDApIHtcbiAgICAgICAgLy8gdG90YWxMZW5ndGggaXMgbm90IGFuIGludGVnZXIsIHRoZSBsZW5ndGggZG9lcyBub3QgbWF0Y2ggYSB2YWxpZFxuICAgICAgICAvLyBiYXNlNjQgY29udGVudC4gVGhhdCBjYW4gaGFwcGVuIGlmOlxuICAgICAgICAvLyAtIHRoZSBpbnB1dCBpcyBub3QgYSBiYXNlNjQgY29udGVudFxuICAgICAgICAvLyAtIHRoZSBpbnB1dCBpcyAqYWxtb3N0KiBhIGJhc2U2NCBjb250ZW50LCB3aXRoIGEgZXh0cmEgY2hhcnMgYXQgdGhlXG4gICAgICAgIC8vICAgYmVnaW5uaW5nIG9yIGF0IHRoZSBlbmRcbiAgICAgICAgLy8gLSB0aGUgaW5wdXQgdXNlcyBhIGJhc2U2NCB2YXJpYW50IChiYXNlNjR1cmwgZm9yIGV4YW1wbGUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYmFzZTY0IGlucHV0LCBiYWQgY29udGVudCBsZW5ndGguXCIpO1xuICAgIH1cbiAgICB2YXIgb3V0cHV0O1xuICAgIGlmIChzdXBwb3J0LnVpbnQ4YXJyYXkpIHtcbiAgICAgICAgb3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGh8MCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0ID0gbmV3IEFycmF5KHRvdGFsTGVuZ3RofDApO1xuICAgIH1cblxuICAgIHdoaWxlIChpIDwgaW5wdXQubGVuZ3RoKSB7XG5cbiAgICAgICAgZW5jMSA9IF9rZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG4gICAgICAgIGVuYzIgPSBfa2V5U3RyLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpO1xuICAgICAgICBlbmMzID0gX2tleVN0ci5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcbiAgICAgICAgZW5jNCA9IF9rZXlTdHIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG5cbiAgICAgICAgY2hyMSA9IChlbmMxIDw8IDIpIHwgKGVuYzIgPj4gNCk7XG4gICAgICAgIGNocjIgPSAoKGVuYzIgJiAxNSkgPDwgNCkgfCAoZW5jMyA+PiAyKTtcbiAgICAgICAgY2hyMyA9ICgoZW5jMyAmIDMpIDw8IDYpIHwgZW5jNDtcblxuICAgICAgICBvdXRwdXRbcmVzdWx0SW5kZXgrK10gPSBjaHIxO1xuXG4gICAgICAgIGlmIChlbmMzICE9PSA2NCkge1xuICAgICAgICAgICAgb3V0cHV0W3Jlc3VsdEluZGV4KytdID0gY2hyMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5jNCAhPT0gNjQpIHtcbiAgICAgICAgICAgIG91dHB1dFtyZXN1bHRJbmRleCsrXSA9IGNocjM7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXh0ZXJuYWwgPSByZXF1aXJlKFwiLi9leHRlcm5hbFwiKTtcbnZhciBEYXRhV29ya2VyID0gcmVxdWlyZSgnLi9zdHJlYW0vRGF0YVdvcmtlcicpO1xudmFyIERhdGFMZW5ndGhQcm9iZSA9IHJlcXVpcmUoJy4vc3RyZWFtL0RhdGFMZW5ndGhQcm9iZScpO1xudmFyIENyYzMyUHJvYmUgPSByZXF1aXJlKCcuL3N0cmVhbS9DcmMzMlByb2JlJyk7XG52YXIgRGF0YUxlbmd0aFByb2JlID0gcmVxdWlyZSgnLi9zdHJlYW0vRGF0YUxlbmd0aFByb2JlJyk7XG5cbi8qKlxuICogUmVwcmVzZW50IGEgY29tcHJlc3NlZCBvYmplY3QsIHdpdGggZXZlcnl0aGluZyBuZWVkZWQgdG8gZGVjb21wcmVzcyBpdC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtudW1iZXJ9IGNvbXByZXNzZWRTaXplIHRoZSBzaXplIG9mIHRoZSBkYXRhIGNvbXByZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gdW5jb21wcmVzc2VkU2l6ZSB0aGUgc2l6ZSBvZiB0aGUgZGF0YSBhZnRlciBkZWNvbXByZXNzaW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGNyYzMyIHRoZSBjcmMzMiBvZiB0aGUgZGVjb21wcmVzc2VkIGZpbGUuXG4gKiBAcGFyYW0ge29iamVjdH0gY29tcHJlc3Npb24gdGhlIHR5cGUgb2YgY29tcHJlc3Npb24sIHNlZSBsaWIvY29tcHJlc3Npb25zLmpzLlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGRhdGEgdGhlIGNvbXByZXNzZWQgZGF0YS5cbiAqL1xuZnVuY3Rpb24gQ29tcHJlc3NlZE9iamVjdChjb21wcmVzc2VkU2l6ZSwgdW5jb21wcmVzc2VkU2l6ZSwgY3JjMzIsIGNvbXByZXNzaW9uLCBkYXRhKSB7XG4gICAgdGhpcy5jb21wcmVzc2VkU2l6ZSA9IGNvbXByZXNzZWRTaXplO1xuICAgIHRoaXMudW5jb21wcmVzc2VkU2l6ZSA9IHVuY29tcHJlc3NlZFNpemU7XG4gICAgdGhpcy5jcmMzMiA9IGNyYzMyO1xuICAgIHRoaXMuY29tcHJlc3Npb24gPSBjb21wcmVzc2lvbjtcbiAgICB0aGlzLmNvbXByZXNzZWRDb250ZW50ID0gZGF0YTtcbn1cblxuQ29tcHJlc3NlZE9iamVjdC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgd29ya2VyIHRvIGdldCB0aGUgdW5jb21wcmVzc2VkIGNvbnRlbnQuXG4gICAgICogQHJldHVybiB7R2VuZXJpY1dvcmtlcn0gdGhlIHdvcmtlci5cbiAgICAgKi9cbiAgICBnZXRDb250ZW50V29ya2VyIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd29ya2VyID0gbmV3IERhdGFXb3JrZXIoZXh0ZXJuYWwuUHJvbWlzZS5yZXNvbHZlKHRoaXMuY29tcHJlc3NlZENvbnRlbnQpKVxuICAgICAgICAucGlwZSh0aGlzLmNvbXByZXNzaW9uLnVuY29tcHJlc3NXb3JrZXIoKSlcbiAgICAgICAgLnBpcGUobmV3IERhdGFMZW5ndGhQcm9iZShcImRhdGFfbGVuZ3RoXCIpKTtcblxuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHdvcmtlci5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZih0aGlzLnN0cmVhbUluZm9bJ2RhdGFfbGVuZ3RoJ10gIT09IHRoYXQudW5jb21wcmVzc2VkU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJ1ZyA6IHVuY29tcHJlc3NlZCBkYXRhIHNpemUgbWlzbWF0Y2hcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gd29ya2VyO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgd29ya2VyIHRvIGdldCB0aGUgY29tcHJlc3NlZCBjb250ZW50LlxuICAgICAqIEByZXR1cm4ge0dlbmVyaWNXb3JrZXJ9IHRoZSB3b3JrZXIuXG4gICAgICovXG4gICAgZ2V0Q29tcHJlc3NlZFdvcmtlciA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRhV29ya2VyKGV4dGVybmFsLlByb21pc2UucmVzb2x2ZSh0aGlzLmNvbXByZXNzZWRDb250ZW50KSlcbiAgICAgICAgLndpdGhTdHJlYW1JbmZvKFwiY29tcHJlc3NlZFNpemVcIiwgdGhpcy5jb21wcmVzc2VkU2l6ZSlcbiAgICAgICAgLndpdGhTdHJlYW1JbmZvKFwidW5jb21wcmVzc2VkU2l6ZVwiLCB0aGlzLnVuY29tcHJlc3NlZFNpemUpXG4gICAgICAgIC53aXRoU3RyZWFtSW5mbyhcImNyYzMyXCIsIHRoaXMuY3JjMzIpXG4gICAgICAgIC53aXRoU3RyZWFtSW5mbyhcImNvbXByZXNzaW9uXCIsIHRoaXMuY29tcHJlc3Npb24pXG4gICAgICAgIDtcbiAgICB9XG59O1xuXG4vKipcbiAqIENoYWluIHRoZSBnaXZlbiB3b3JrZXIgd2l0aCBvdGhlciB3b3JrZXJzIHRvIGNvbXByZXNzIHRoZSBjb250ZW50IHdpdGggdGhlXG4gKiBnaXZlbiBjb21wcmVzc2lvbi5cbiAqIEBwYXJhbSB7R2VuZXJpY1dvcmtlcn0gdW5jb21wcmVzc2VkV29ya2VyIHRoZSB3b3JrZXIgdG8gcGlwZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb21wcmVzc2lvbiB0aGUgY29tcHJlc3Npb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IGNvbXByZXNzaW9uT3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2Ugd2hlbiBjb21wcmVzc2luZy5cbiAqIEByZXR1cm4ge0dlbmVyaWNXb3JrZXJ9IHRoZSBuZXcgd29ya2VyIGNvbXByZXNzaW5nIHRoZSBjb250ZW50LlxuICovXG5Db21wcmVzc2VkT2JqZWN0LmNyZWF0ZVdvcmtlckZyb20gPSBmdW5jdGlvbiAodW5jb21wcmVzc2VkV29ya2VyLCBjb21wcmVzc2lvbiwgY29tcHJlc3Npb25PcHRpb25zKSB7XG4gICAgcmV0dXJuIHVuY29tcHJlc3NlZFdvcmtlclxuICAgIC5waXBlKG5ldyBDcmMzMlByb2JlKCkpXG4gICAgLnBpcGUobmV3IERhdGFMZW5ndGhQcm9iZShcInVuY29tcHJlc3NlZFNpemVcIikpXG4gICAgLnBpcGUoY29tcHJlc3Npb24uY29tcHJlc3NXb3JrZXIoY29tcHJlc3Npb25PcHRpb25zKSlcbiAgICAucGlwZShuZXcgRGF0YUxlbmd0aFByb2JlKFwiY29tcHJlc3NlZFNpemVcIikpXG4gICAgLndpdGhTdHJlYW1JbmZvKFwiY29tcHJlc3Npb25cIiwgY29tcHJlc3Npb24pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb21wcmVzc2VkT2JqZWN0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoXCIuL3N0cmVhbS9HZW5lcmljV29ya2VyXCIpO1xuXG5leHBvcnRzLlNUT1JFID0ge1xuICAgIG1hZ2ljOiBcIlxceDAwXFx4MDBcIixcbiAgICBjb21wcmVzc1dvcmtlciA6IGZ1bmN0aW9uIChjb21wcmVzc2lvbk9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHZW5lcmljV29ya2VyKFwiU1RPUkUgY29tcHJlc3Npb25cIik7XG4gICAgfSxcbiAgICB1bmNvbXByZXNzV29ya2VyIDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IEdlbmVyaWNXb3JrZXIoXCJTVE9SRSBkZWNvbXByZXNzaW9uXCIpO1xuICAgIH1cbn07XG5leHBvcnRzLkRFRkxBVEUgPSByZXF1aXJlKCcuL2ZsYXRlJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuLyoqXG4gKiBUaGUgZm9sbG93aW5nIGZ1bmN0aW9ucyBjb21lIGZyb20gcGFrbywgZnJvbSBwYWtvL2xpYi96bGliL2NyYzMyLmpzXG4gKiByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UsIHNlZSBwYWtvIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlY2EvcGFrby9cbiAqL1xuXG4vLyBVc2Ugb3JkaW5hcnkgYXJyYXksIHNpbmNlIHVudHlwZWQgbWFrZXMgbm8gYm9vc3QgaGVyZVxuZnVuY3Rpb24gbWFrZVRhYmxlKCkge1xuICAgIHZhciBjLCB0YWJsZSA9IFtdO1xuXG4gICAgZm9yKHZhciBuID0wOyBuIDwgMjU2OyBuKyspe1xuICAgICAgICBjID0gbjtcbiAgICAgICAgZm9yKHZhciBrID0wOyBrIDwgODsgaysrKXtcbiAgICAgICAgICAgIGMgPSAoKGMmMSkgPyAoMHhFREI4ODMyMCBeIChjID4+PiAxKSkgOiAoYyA+Pj4gMSkpO1xuICAgICAgICB9XG4gICAgICAgIHRhYmxlW25dID0gYztcbiAgICB9XG5cbiAgICByZXR1cm4gdGFibGU7XG59XG5cbi8vIENyZWF0ZSB0YWJsZSBvbiBsb2FkLiBKdXN0IDI1NSBzaWduZWQgbG9uZ3MuIE5vdCBhIHByb2JsZW0uXG52YXIgY3JjVGFibGUgPSBtYWtlVGFibGUoKTtcblxuXG5mdW5jdGlvbiBjcmMzMihjcmMsIGJ1ZiwgbGVuLCBwb3MpIHtcbiAgICB2YXIgdCA9IGNyY1RhYmxlLCBlbmQgPSBwb3MgKyBsZW47XG5cbiAgICBjcmMgPSBjcmMgXiAoLTEpO1xuXG4gICAgZm9yICh2YXIgaSA9IHBvczsgaSA8IGVuZDsgaSsrICkge1xuICAgICAgICBjcmMgPSAoY3JjID4+PiA4KSBeIHRbKGNyYyBeIGJ1ZltpXSkgJiAweEZGXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKGNyYyBeICgtMSkpOyAvLyA+Pj4gMDtcbn1cblxuLy8gVGhhdCdzIGFsbCBmb3IgdGhlIHBha28gZnVuY3Rpb25zLlxuXG4vKipcbiAqIENvbXB1dGUgdGhlIGNyYzMyIG9mIGEgc3RyaW5nLlxuICogVGhpcyBpcyBhbG1vc3QgdGhlIHNhbWUgYXMgdGhlIGZ1bmN0aW9uIGNyYzMyLCBidXQgZm9yIHN0cmluZ3MuIFVzaW5nIHRoZVxuICogc2FtZSBmdW5jdGlvbiBmb3IgdGhlIHR3byB1c2UgY2FzZXMgbGVhZHMgdG8gaG9ycmlibGUgcGVyZm9ybWFuY2VzLlxuICogQHBhcmFtIHtOdW1iZXJ9IGNyYyB0aGUgc3RhcnRpbmcgdmFsdWUgb2YgdGhlIGNyYy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgdGhlIHN0cmluZyB0byB1c2UuXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuIHRoZSBsZW5ndGggb2YgdGhlIHN0cmluZy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBwb3MgdGhlIHN0YXJ0aW5nIHBvc2l0aW9uIGZvciB0aGUgY3JjMzIgY29tcHV0YXRpb24uXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBjb21wdXRlZCBjcmMzMi5cbiAqL1xuZnVuY3Rpb24gY3JjMzJzdHIoY3JjLCBzdHIsIGxlbiwgcG9zKSB7XG4gICAgdmFyIHQgPSBjcmNUYWJsZSwgZW5kID0gcG9zICsgbGVuO1xuXG4gICAgY3JjID0gY3JjIF4gKC0xKTtcblxuICAgIGZvciAodmFyIGkgPSBwb3M7IGkgPCBlbmQ7IGkrKyApIHtcbiAgICAgICAgY3JjID0gKGNyYyA+Pj4gOCkgXiB0WyhjcmMgXiBzdHIuY2hhckNvZGVBdChpKSkgJiAweEZGXTtcbiAgICB9XG5cbiAgICByZXR1cm4gKGNyYyBeICgtMSkpOyAvLyA+Pj4gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmMzMndyYXBwZXIoaW5wdXQsIGNyYykge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwidW5kZWZpbmVkXCIgfHwgIWlucHV0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICB2YXIgaXNBcnJheSA9IHV0aWxzLmdldFR5cGVPZihpbnB1dCkgIT09IFwic3RyaW5nXCI7XG5cbiAgICBpZihpc0FycmF5KSB7XG4gICAgICAgIHJldHVybiBjcmMzMihjcmN8MCwgaW5wdXQsIGlucHV0Lmxlbmd0aCwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNyYzMyc3RyKGNyY3wwLCBpbnB1dCwgaW5wdXQubGVuZ3RoLCAwKTtcbiAgICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuZXhwb3J0cy5iYXNlNjQgPSBmYWxzZTtcbmV4cG9ydHMuYmluYXJ5ID0gZmFsc2U7XG5leHBvcnRzLmRpciA9IGZhbHNlO1xuZXhwb3J0cy5jcmVhdGVGb2xkZXJzID0gdHJ1ZTtcbmV4cG9ydHMuZGF0ZSA9IG51bGw7XG5leHBvcnRzLmNvbXByZXNzaW9uID0gbnVsbDtcbmV4cG9ydHMuY29tcHJlc3Npb25PcHRpb25zID0gbnVsbDtcbmV4cG9ydHMuY29tbWVudCA9IG51bGw7XG5leHBvcnRzLnVuaXhQZXJtaXNzaW9ucyA9IG51bGw7XG5leHBvcnRzLmRvc1Blcm1pc3Npb25zID0gbnVsbDtcbiIsIi8qIGdsb2JhbCBQcm9taXNlICovXG4ndXNlIHN0cmljdCc7XG5cbi8vIGxvYWQgdGhlIGdsb2JhbCBvYmplY3QgZmlyc3Q6XG4vLyAtIGl0IHNob3VsZCBiZSBiZXR0ZXIgaW50ZWdyYXRlZCBpbiB0aGUgc3lzdGVtICh1bmhhbmRsZWRSZWplY3Rpb24gaW4gbm9kZSlcbi8vIC0gdGhlIGVudmlyb25tZW50IG1heSBoYXZlIGEgY3VzdG9tIFByb21pc2UgaW1wbGVtZW50YXRpb24gKHNlZSB6b25lLmpzKVxudmFyIEVTNlByb21pc2UgPSBudWxsO1xuaWYgKHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgRVM2UHJvbWlzZSA9IFByb21pc2U7XG59IGVsc2Uge1xuICAgIEVTNlByb21pc2UgPSByZXF1aXJlKFwibGllXCIpO1xufVxuXG4vKipcbiAqIExldCB0aGUgdXNlciB1c2UvY2hhbmdlIHNvbWUgaW1wbGVtZW50YXRpb25zLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBQcm9taXNlOiBFUzZQcm9taXNlXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIFVTRV9UWVBFREFSUkFZID0gKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykgJiYgKHR5cGVvZiBVaW50MTZBcnJheSAhPT0gJ3VuZGVmaW5lZCcpICYmICh0eXBlb2YgVWludDMyQXJyYXkgIT09ICd1bmRlZmluZWQnKTtcblxudmFyIHBha28gPSByZXF1aXJlKFwicGFrb1wiKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKFwiLi9zdHJlYW0vR2VuZXJpY1dvcmtlclwiKTtcblxudmFyIEFSUkFZX1RZUEUgPSBVU0VfVFlQRURBUlJBWSA/IFwidWludDhhcnJheVwiIDogXCJhcnJheVwiO1xuXG5leHBvcnRzLm1hZ2ljID0gXCJcXHgwOFxceDAwXCI7XG5cbi8qKlxuICogQ3JlYXRlIGEgd29ya2VyIHRoYXQgdXNlcyBwYWtvIHRvIGluZmxhdGUvZGVmbGF0ZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IGFjdGlvbiB0aGUgbmFtZSBvZiB0aGUgcGFrbyBmdW5jdGlvbiB0byBjYWxsIDogZWl0aGVyIFwiRGVmbGF0ZVwiIG9yIFwiSW5mbGF0ZVwiLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdGhlIG9wdGlvbnMgdG8gdXNlIHdoZW4gKGRlKWNvbXByZXNzaW5nLlxuICovXG5mdW5jdGlvbiBGbGF0ZVdvcmtlcihhY3Rpb24sIG9wdGlvbnMpIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJGbGF0ZVdvcmtlci9cIiArIGFjdGlvbik7XG5cbiAgICB0aGlzLl9wYWtvID0gbnVsbDtcbiAgICB0aGlzLl9wYWtvQWN0aW9uID0gYWN0aW9uO1xuICAgIHRoaXMuX3Bha29PcHRpb25zID0gb3B0aW9ucztcbiAgICAvLyB0aGUgYG1ldGFgIG9iamVjdCBmcm9tIHRoZSBsYXN0IGNodW5rIHJlY2VpdmVkXG4gICAgLy8gdGhpcyBhbGxvdyB0aGlzIHdvcmtlciB0byBwYXNzIGFyb3VuZCBtZXRhZGF0YVxuICAgIHRoaXMubWV0YSA9IHt9O1xufVxuXG51dGlscy5pbmhlcml0cyhGbGF0ZVdvcmtlciwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnByb2Nlc3NDaHVua1xuICovXG5GbGF0ZVdvcmtlci5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgdGhpcy5tZXRhID0gY2h1bmsubWV0YTtcbiAgICBpZiAodGhpcy5fcGFrbyA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9jcmVhdGVQYWtvKCk7XG4gICAgfVxuICAgIHRoaXMuX3Bha28ucHVzaCh1dGlscy50cmFuc2Zvcm1UbyhBUlJBWV9UWVBFLCBjaHVuay5kYXRhKSwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIuZmx1c2hcbiAqL1xuRmxhdGVXb3JrZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIEdlbmVyaWNXb3JrZXIucHJvdG90eXBlLmZsdXNoLmNhbGwodGhpcyk7XG4gICAgaWYgKHRoaXMuX3Bha28gPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlUGFrbygpO1xuICAgIH1cbiAgICB0aGlzLl9wYWtvLnB1c2goW10sIHRydWUpO1xufTtcbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLmNsZWFuVXBcbiAqL1xuRmxhdGVXb3JrZXIucHJvdG90eXBlLmNsZWFuVXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgR2VuZXJpY1dvcmtlci5wcm90b3R5cGUuY2xlYW5VcC5jYWxsKHRoaXMpO1xuICAgIHRoaXMuX3Bha28gPSBudWxsO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgdGhlIF9wYWtvIG9iamVjdC5cbiAqIFRPRE86IGxhenktbG9hZGluZyB0aGlzIG9iamVjdCBpc24ndCB0aGUgYmVzdCBzb2x1dGlvbiBidXQgaXQncyB0aGVcbiAqIHF1aWNrZXN0LiBUaGUgYmVzdCBzb2x1dGlvbiBpcyB0byBsYXp5LWxvYWQgdGhlIHdvcmtlciBsaXN0LiBTZWUgYWxzbyB0aGVcbiAqIGlzc3VlICM0NDYuXG4gKi9cbkZsYXRlV29ya2VyLnByb3RvdHlwZS5fY3JlYXRlUGFrbyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9wYWtvID0gbmV3IHBha29bdGhpcy5fcGFrb0FjdGlvbl0oe1xuICAgICAgICByYXc6IHRydWUsXG4gICAgICAgIGxldmVsOiB0aGlzLl9wYWtvT3B0aW9ucy5sZXZlbCB8fCAtMSAvLyBkZWZhdWx0IGNvbXByZXNzaW9uXG4gICAgfSk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuX3Bha28ub25EYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBzZWxmLnB1c2goe1xuICAgICAgICAgICAgZGF0YSA6IGRhdGEsXG4gICAgICAgICAgICBtZXRhIDogc2VsZi5tZXRhXG4gICAgICAgIH0pO1xuICAgIH07XG59O1xuXG5leHBvcnRzLmNvbXByZXNzV29ya2VyID0gZnVuY3Rpb24gKGNvbXByZXNzaW9uT3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgRmxhdGVXb3JrZXIoXCJEZWZsYXRlXCIsIGNvbXByZXNzaW9uT3B0aW9ucyk7XG59O1xuZXhwb3J0cy51bmNvbXByZXNzV29ya2VyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXcgRmxhdGVXb3JrZXIoXCJJbmZsYXRlXCIsIHt9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4uL3N0cmVhbS9HZW5lcmljV29ya2VyJyk7XG52YXIgdXRmOCA9IHJlcXVpcmUoJy4uL3V0ZjgnKTtcbnZhciBjcmMzMiA9IHJlcXVpcmUoJy4uL2NyYzMyJyk7XG52YXIgc2lnbmF0dXJlID0gcmVxdWlyZSgnLi4vc2lnbmF0dXJlJyk7XG5cbi8qKlxuICogVHJhbnNmb3JtIGFuIGludGVnZXIgaW50byBhIHN0cmluZyBpbiBoZXhhZGVjaW1hbC5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gZGVjIHRoZSBudW1iZXIgdG8gY29udmVydC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBieXRlcyB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIGdlbmVyYXRlLlxuICogQHJldHVybnMge3N0cmluZ30gdGhlIHJlc3VsdC5cbiAqL1xudmFyIGRlY1RvSGV4ID0gZnVuY3Rpb24oZGVjLCBieXRlcykge1xuICAgIHZhciBoZXggPSBcIlwiLCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBieXRlczsgaSsrKSB7XG4gICAgICAgIGhleCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGRlYyAmIDB4ZmYpO1xuICAgICAgICBkZWMgPSBkZWMgPj4+IDg7XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIHRoZSBVTklYIHBhcnQgb2YgdGhlIGV4dGVybmFsIGZpbGUgYXR0cmlidXRlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSB1bml4UGVybWlzc2lvbnMgdGhlIHVuaXggcGVybWlzc2lvbnMgb3IgbnVsbC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNEaXIgdHJ1ZSBpZiB0aGUgZW50cnkgaXMgYSBkaXJlY3RvcnksIGZhbHNlIG90aGVyd2lzZS5cbiAqIEByZXR1cm4ge051bWJlcn0gYSAzMiBiaXQgaW50ZWdlci5cbiAqXG4gKiBhZGFwdGVkIGZyb20gaHR0cDovL3VuaXguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzE0NzA1L3RoZS16aXAtZm9ybWF0cy1leHRlcm5hbC1maWxlLWF0dHJpYnV0ZSA6XG4gKlxuICogVFRUVHNzdHJ3eHJ3eHJ3eDAwMDAwMDAwMDBBRFZTSFJcbiAqIF5eXl5fX19fX19fX19fX19fX19fX19fX19fX19fX19fIGZpbGUgdHlwZSwgc2VlIHppcGluZm8uYyAoVU5YXyopXG4gKiAgICAgXl5eX19fX19fX19fX19fX19fX19fX19fX19fXyBzZXR1aWQsIHNldGdpZCwgc3RpY2t5XG4gKiAgICAgICAgXl5eXl5eXl5eX19fX19fX19fX19fX19fXyBwZXJtaXNzaW9uc1xuICogICAgICAgICAgICAgICAgIF5eXl5eXl5eXl5fX19fX18gbm90IHVzZWQgP1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICBeXl5eXl4gRE9TIGF0dHJpYnV0ZSBiaXRzIDogQXJjaGl2ZSwgRGlyZWN0b3J5LCBWb2x1bWUgbGFiZWwsIFN5c3RlbSBmaWxlLCBIaWRkZW4sIFJlYWQgb25seVxuICovXG52YXIgZ2VuZXJhdGVVbml4RXh0ZXJuYWxGaWxlQXR0ciA9IGZ1bmN0aW9uICh1bml4UGVybWlzc2lvbnMsIGlzRGlyKSB7XG5cbiAgICB2YXIgcmVzdWx0ID0gdW5peFBlcm1pc3Npb25zO1xuICAgIGlmICghdW5peFBlcm1pc3Npb25zKSB7XG4gICAgICAgIC8vIEkgY2FuJ3QgdXNlIG9jdGFsIHZhbHVlcyBpbiBzdHJpY3QgbW9kZSwgaGVuY2UgdGhlIGhleGEuXG4gICAgICAgIC8vICAwNDA3NzUgPT4gMHg0MWZkXG4gICAgICAgIC8vIDAxMDA2NjQgPT4gMHg4MWI0XG4gICAgICAgIHJlc3VsdCA9IGlzRGlyID8gMHg0MWZkIDogMHg4MWI0O1xuICAgIH1cbiAgICByZXR1cm4gKHJlc3VsdCAmIDB4RkZGRikgPDwgMTY7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIHRoZSBET1MgcGFydCBvZiB0aGUgZXh0ZXJuYWwgZmlsZSBhdHRyaWJ1dGVzLlxuICogQHBhcmFtIHtPYmplY3R9IGRvc1Blcm1pc3Npb25zIHRoZSBkb3MgcGVybWlzc2lvbnMgb3IgbnVsbC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNEaXIgdHJ1ZSBpZiB0aGUgZW50cnkgaXMgYSBkaXJlY3RvcnksIGZhbHNlIG90aGVyd2lzZS5cbiAqIEByZXR1cm4ge051bWJlcn0gYSAzMiBiaXQgaW50ZWdlci5cbiAqXG4gKiBCaXQgMCAgICAgUmVhZC1Pbmx5XG4gKiBCaXQgMSAgICAgSGlkZGVuXG4gKiBCaXQgMiAgICAgU3lzdGVtXG4gKiBCaXQgMyAgICAgVm9sdW1lIExhYmVsXG4gKiBCaXQgNCAgICAgRGlyZWN0b3J5XG4gKiBCaXQgNSAgICAgQXJjaGl2ZVxuICovXG52YXIgZ2VuZXJhdGVEb3NFeHRlcm5hbEZpbGVBdHRyID0gZnVuY3Rpb24gKGRvc1Blcm1pc3Npb25zLCBpc0Rpcikge1xuXG4gICAgLy8gdGhlIGRpciBmbGFnIGlzIGFscmVhZHkgc2V0IGZvciBjb21wYXRpYmlsaXR5XG4gICAgcmV0dXJuIChkb3NQZXJtaXNzaW9ucyB8fCAwKSAgJiAweDNGO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgdmFyaW91cyBwYXJ0cyB1c2VkIGluIHRoZSBjb25zdHJ1Y3Rpb24gb2YgdGhlIGZpbmFsIHppcCBmaWxlLlxuICogQHBhcmFtIHtPYmplY3R9IHN0cmVhbUluZm8gdGhlIGhhc2ggd2l0aCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY29tcHJlc3NlZCBmaWxlLlxuICogQHBhcmFtIHtCb29sZWFufSBzdHJlYW1lZENvbnRlbnQgaXMgdGhlIGNvbnRlbnQgc3RyZWFtZWQgP1xuICogQHBhcmFtIHtCb29sZWFufSBzdHJlYW1pbmdFbmRlZCBpcyB0aGUgc3RyZWFtIGZpbmlzaGVkID9cbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgdGhlIGN1cnJlbnQgb2Zmc2V0IGZyb20gdGhlIHN0YXJ0IG9mIHRoZSB6aXAgZmlsZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwbGF0Zm9ybSBsZXQncyBwcmV0ZW5kIHdlIGFyZSB0aGlzIHBsYXRmb3JtIChjaGFuZ2UgcGxhdGZvcm0gZGVwZW5kZW50cyBmaWVsZHMpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlbmNvZGVGaWxlTmFtZSB0aGUgZnVuY3Rpb24gdG8gZW5jb2RlIHRoZSBmaWxlIG5hbWUgLyBjb21tZW50LlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgemlwIHBhcnRzLlxuICovXG52YXIgZ2VuZXJhdGVaaXBQYXJ0cyA9IGZ1bmN0aW9uKHN0cmVhbUluZm8sIHN0cmVhbWVkQ29udGVudCwgc3RyZWFtaW5nRW5kZWQsIG9mZnNldCwgcGxhdGZvcm0sIGVuY29kZUZpbGVOYW1lKSB7XG4gICAgdmFyIGZpbGUgPSBzdHJlYW1JbmZvWydmaWxlJ10sXG4gICAgY29tcHJlc3Npb24gPSBzdHJlYW1JbmZvWydjb21wcmVzc2lvbiddLFxuICAgIHVzZUN1c3RvbUVuY29kaW5nID0gZW5jb2RlRmlsZU5hbWUgIT09IHV0ZjgudXRmOGVuY29kZSxcbiAgICBlbmNvZGVkRmlsZU5hbWUgPSB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCBlbmNvZGVGaWxlTmFtZShmaWxlLm5hbWUpKSxcbiAgICB1dGZFbmNvZGVkRmlsZU5hbWUgPSB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCB1dGY4LnV0ZjhlbmNvZGUoZmlsZS5uYW1lKSksXG4gICAgY29tbWVudCA9IGZpbGUuY29tbWVudCxcbiAgICBlbmNvZGVkQ29tbWVudCA9IHV0aWxzLnRyYW5zZm9ybVRvKFwic3RyaW5nXCIsIGVuY29kZUZpbGVOYW1lKGNvbW1lbnQpKSxcbiAgICB1dGZFbmNvZGVkQ29tbWVudCA9IHV0aWxzLnRyYW5zZm9ybVRvKFwic3RyaW5nXCIsIHV0ZjgudXRmOGVuY29kZShjb21tZW50KSksXG4gICAgdXNlVVRGOEZvckZpbGVOYW1lID0gdXRmRW5jb2RlZEZpbGVOYW1lLmxlbmd0aCAhPT0gZmlsZS5uYW1lLmxlbmd0aCxcbiAgICB1c2VVVEY4Rm9yQ29tbWVudCA9IHV0ZkVuY29kZWRDb21tZW50Lmxlbmd0aCAhPT0gY29tbWVudC5sZW5ndGgsXG4gICAgZG9zVGltZSxcbiAgICBkb3NEYXRlLFxuICAgIGV4dHJhRmllbGRzID0gXCJcIixcbiAgICB1bmljb2RlUGF0aEV4dHJhRmllbGQgPSBcIlwiLFxuICAgIHVuaWNvZGVDb21tZW50RXh0cmFGaWVsZCA9IFwiXCIsXG4gICAgZGlyID0gZmlsZS5kaXIsXG4gICAgZGF0ZSA9IGZpbGUuZGF0ZTtcblxuXG4gICAgdmFyIGRhdGFJbmZvID0ge1xuICAgICAgICBjcmMzMiA6IDAsXG4gICAgICAgIGNvbXByZXNzZWRTaXplIDogMCxcbiAgICAgICAgdW5jb21wcmVzc2VkU2l6ZSA6IDBcbiAgICB9O1xuXG4gICAgLy8gaWYgdGhlIGNvbnRlbnQgaXMgc3RyZWFtZWQsIHRoZSBzaXplcy9jcmMzMiBhcmUgb25seSBhdmFpbGFibGUgQUZURVJcbiAgICAvLyB0aGUgZW5kIG9mIHRoZSBzdHJlYW0uXG4gICAgaWYgKCFzdHJlYW1lZENvbnRlbnQgfHwgc3RyZWFtaW5nRW5kZWQpIHtcbiAgICAgICAgZGF0YUluZm8uY3JjMzIgPSBzdHJlYW1JbmZvWydjcmMzMiddO1xuICAgICAgICBkYXRhSW5mby5jb21wcmVzc2VkU2l6ZSA9IHN0cmVhbUluZm9bJ2NvbXByZXNzZWRTaXplJ107XG4gICAgICAgIGRhdGFJbmZvLnVuY29tcHJlc3NlZFNpemUgPSBzdHJlYW1JbmZvWyd1bmNvbXByZXNzZWRTaXplJ107XG4gICAgfVxuXG4gICAgdmFyIGJpdGZsYWcgPSAwO1xuICAgIGlmIChzdHJlYW1lZENvbnRlbnQpIHtcbiAgICAgICAgLy8gQml0IDM6IHRoZSBzaXplcy9jcmMzMiBhcmUgc2V0IHRvIHplcm8gaW4gdGhlIGxvY2FsIGhlYWRlci5cbiAgICAgICAgLy8gVGhlIGNvcnJlY3QgdmFsdWVzIGFyZSBwdXQgaW4gdGhlIGRhdGEgZGVzY3JpcHRvciBpbW1lZGlhdGVseVxuICAgICAgICAvLyBmb2xsb3dpbmcgdGhlIGNvbXByZXNzZWQgZGF0YS5cbiAgICAgICAgYml0ZmxhZyB8PSAweDAwMDg7XG4gICAgfVxuICAgIGlmICghdXNlQ3VzdG9tRW5jb2RpbmcgJiYgKHVzZVVURjhGb3JGaWxlTmFtZSB8fCB1c2VVVEY4Rm9yQ29tbWVudCkpIHtcbiAgICAgICAgLy8gQml0IDExOiBMYW5ndWFnZSBlbmNvZGluZyBmbGFnIChFRlMpLlxuICAgICAgICBiaXRmbGFnIHw9IDB4MDgwMDtcbiAgICB9XG5cblxuICAgIHZhciBleHRGaWxlQXR0ciA9IDA7XG4gICAgdmFyIHZlcnNpb25NYWRlQnkgPSAwO1xuICAgIGlmIChkaXIpIHtcbiAgICAgICAgLy8gZG9zIG9yIHVuaXgsIHdlIHNldCB0aGUgZG9zIGRpciBmbGFnXG4gICAgICAgIGV4dEZpbGVBdHRyIHw9IDB4MDAwMTA7XG4gICAgfVxuICAgIGlmKHBsYXRmb3JtID09PSBcIlVOSVhcIikge1xuICAgICAgICB2ZXJzaW9uTWFkZUJ5ID0gMHgwMzFFOyAvLyBVTklYLCB2ZXJzaW9uIDMuMFxuICAgICAgICBleHRGaWxlQXR0ciB8PSBnZW5lcmF0ZVVuaXhFeHRlcm5hbEZpbGVBdHRyKGZpbGUudW5peFBlcm1pc3Npb25zLCBkaXIpO1xuICAgIH0gZWxzZSB7IC8vIERPUyBvciBvdGhlciwgZmFsbGJhY2sgdG8gRE9TXG4gICAgICAgIHZlcnNpb25NYWRlQnkgPSAweDAwMTQ7IC8vIERPUywgdmVyc2lvbiAyLjBcbiAgICAgICAgZXh0RmlsZUF0dHIgfD0gZ2VuZXJhdGVEb3NFeHRlcm5hbEZpbGVBdHRyKGZpbGUuZG9zUGVybWlzc2lvbnMsIGRpcik7XG4gICAgfVxuXG4gICAgLy8gZGF0ZVxuICAgIC8vIEBzZWUgaHR0cDovL3d3dy5kZWxvcmllLmNvbS9kamdwcC9kb2MvcmJpbnRlci9pdC81Mi8xMy5odG1sXG4gICAgLy8gQHNlZSBodHRwOi8vd3d3LmRlbG9yaWUuY29tL2RqZ3BwL2RvYy9yYmludGVyL2l0LzY1LzE2Lmh0bWxcbiAgICAvLyBAc2VlIGh0dHA6Ly93d3cuZGVsb3JpZS5jb20vZGpncHAvZG9jL3JiaW50ZXIvaXQvNjYvMTYuaHRtbFxuXG4gICAgZG9zVGltZSA9IGRhdGUuZ2V0VVRDSG91cnMoKTtcbiAgICBkb3NUaW1lID0gZG9zVGltZSA8PCA2O1xuICAgIGRvc1RpbWUgPSBkb3NUaW1lIHwgZGF0ZS5nZXRVVENNaW51dGVzKCk7XG4gICAgZG9zVGltZSA9IGRvc1RpbWUgPDwgNTtcbiAgICBkb3NUaW1lID0gZG9zVGltZSB8IGRhdGUuZ2V0VVRDU2Vjb25kcygpIC8gMjtcblxuICAgIGRvc0RhdGUgPSBkYXRlLmdldFVUQ0Z1bGxZZWFyKCkgLSAxOTgwO1xuICAgIGRvc0RhdGUgPSBkb3NEYXRlIDw8IDQ7XG4gICAgZG9zRGF0ZSA9IGRvc0RhdGUgfCAoZGF0ZS5nZXRVVENNb250aCgpICsgMSk7XG4gICAgZG9zRGF0ZSA9IGRvc0RhdGUgPDwgNTtcbiAgICBkb3NEYXRlID0gZG9zRGF0ZSB8IGRhdGUuZ2V0VVRDRGF0ZSgpO1xuXG4gICAgaWYgKHVzZVVURjhGb3JGaWxlTmFtZSkge1xuICAgICAgICAvLyBzZXQgdGhlIHVuaWNvZGUgcGF0aCBleHRyYSBmaWVsZC4gdW56aXAgbmVlZHMgYXQgbGVhc3Qgb25lIGV4dHJhXG4gICAgICAgIC8vIGZpZWxkIHRvIGNvcnJlY3RseSBoYW5kbGUgdW5pY29kZSBwYXRoLCBzbyB1c2luZyB0aGUgcGF0aCBpcyBhcyBnb29kXG4gICAgICAgIC8vIGFzIGFueSBvdGhlciBpbmZvcm1hdGlvbi4gVGhpcyBjb3VsZCBpbXByb3ZlIHRoZSBzaXR1YXRpb24gd2l0aFxuICAgICAgICAvLyBvdGhlciBhcmNoaXZlIG1hbmFnZXJzIHRvby5cbiAgICAgICAgLy8gVGhpcyBmaWVsZCBpcyB1c3VhbGx5IHVzZWQgd2l0aG91dCB0aGUgdXRmOCBmbGFnLCB3aXRoIGEgbm9uXG4gICAgICAgIC8vIHVuaWNvZGUgcGF0aCBpbiB0aGUgaGVhZGVyICh3aW5yYXIsIHdpbnppcCkuIFRoaXMgaGVscHMgKGEgYml0KVxuICAgICAgICAvLyB3aXRoIHRoZSBtZXNzeSBXaW5kb3dzJyBkZWZhdWx0IGNvbXByZXNzZWQgZm9sZGVycyBmZWF0dXJlIGJ1dFxuICAgICAgICAvLyBicmVha3Mgb24gcDd6aXAgd2hpY2ggZG9lc24ndCBzZWVrIHRoZSB1bmljb2RlIHBhdGggZXh0cmEgZmllbGQuXG4gICAgICAgIC8vIFNvIGZvciBub3csIFVURi04IGV2ZXJ5d2hlcmUgIVxuICAgICAgICB1bmljb2RlUGF0aEV4dHJhRmllbGQgPVxuICAgICAgICAgICAgLy8gVmVyc2lvblxuICAgICAgICAgICAgZGVjVG9IZXgoMSwgMSkgK1xuICAgICAgICAgICAgLy8gTmFtZUNSQzMyXG4gICAgICAgICAgICBkZWNUb0hleChjcmMzMihlbmNvZGVkRmlsZU5hbWUpLCA0KSArXG4gICAgICAgICAgICAvLyBVbmljb2RlTmFtZVxuICAgICAgICAgICAgdXRmRW5jb2RlZEZpbGVOYW1lO1xuXG4gICAgICAgIGV4dHJhRmllbGRzICs9XG4gICAgICAgICAgICAvLyBJbmZvLVpJUCBVbmljb2RlIFBhdGggRXh0cmEgRmllbGRcbiAgICAgICAgICAgIFwiXFx4NzVcXHg3MFwiICtcbiAgICAgICAgICAgIC8vIHNpemVcbiAgICAgICAgICAgIGRlY1RvSGV4KHVuaWNvZGVQYXRoRXh0cmFGaWVsZC5sZW5ndGgsIDIpICtcbiAgICAgICAgICAgIC8vIGNvbnRlbnRcbiAgICAgICAgICAgIHVuaWNvZGVQYXRoRXh0cmFGaWVsZDtcbiAgICB9XG5cbiAgICBpZih1c2VVVEY4Rm9yQ29tbWVudCkge1xuXG4gICAgICAgIHVuaWNvZGVDb21tZW50RXh0cmFGaWVsZCA9XG4gICAgICAgICAgICAvLyBWZXJzaW9uXG4gICAgICAgICAgICBkZWNUb0hleCgxLCAxKSArXG4gICAgICAgICAgICAvLyBDb21tZW50Q1JDMzJcbiAgICAgICAgICAgIGRlY1RvSGV4KGNyYzMyKGVuY29kZWRDb21tZW50KSwgNCkgK1xuICAgICAgICAgICAgLy8gVW5pY29kZU5hbWVcbiAgICAgICAgICAgIHV0ZkVuY29kZWRDb21tZW50O1xuXG4gICAgICAgIGV4dHJhRmllbGRzICs9XG4gICAgICAgICAgICAvLyBJbmZvLVpJUCBVbmljb2RlIFBhdGggRXh0cmEgRmllbGRcbiAgICAgICAgICAgIFwiXFx4NzVcXHg2M1wiICtcbiAgICAgICAgICAgIC8vIHNpemVcbiAgICAgICAgICAgIGRlY1RvSGV4KHVuaWNvZGVDb21tZW50RXh0cmFGaWVsZC5sZW5ndGgsIDIpICtcbiAgICAgICAgICAgIC8vIGNvbnRlbnRcbiAgICAgICAgICAgIHVuaWNvZGVDb21tZW50RXh0cmFGaWVsZDtcbiAgICB9XG5cbiAgICB2YXIgaGVhZGVyID0gXCJcIjtcblxuICAgIC8vIHZlcnNpb24gbmVlZGVkIHRvIGV4dHJhY3RcbiAgICBoZWFkZXIgKz0gXCJcXHgwQVxceDAwXCI7XG4gICAgLy8gZ2VuZXJhbCBwdXJwb3NlIGJpdCBmbGFnXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGJpdGZsYWcsIDIpO1xuICAgIC8vIGNvbXByZXNzaW9uIG1ldGhvZFxuICAgIGhlYWRlciArPSBjb21wcmVzc2lvbi5tYWdpYztcbiAgICAvLyBsYXN0IG1vZCBmaWxlIHRpbWVcbiAgICBoZWFkZXIgKz0gZGVjVG9IZXgoZG9zVGltZSwgMik7XG4gICAgLy8gbGFzdCBtb2QgZmlsZSBkYXRlXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGRvc0RhdGUsIDIpO1xuICAgIC8vIGNyYy0zMlxuICAgIGhlYWRlciArPSBkZWNUb0hleChkYXRhSW5mby5jcmMzMiwgNCk7XG4gICAgLy8gY29tcHJlc3NlZCBzaXplXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGRhdGFJbmZvLmNvbXByZXNzZWRTaXplLCA0KTtcbiAgICAvLyB1bmNvbXByZXNzZWQgc2l6ZVxuICAgIGhlYWRlciArPSBkZWNUb0hleChkYXRhSW5mby51bmNvbXByZXNzZWRTaXplLCA0KTtcbiAgICAvLyBmaWxlIG5hbWUgbGVuZ3RoXG4gICAgaGVhZGVyICs9IGRlY1RvSGV4KGVuY29kZWRGaWxlTmFtZS5sZW5ndGgsIDIpO1xuICAgIC8vIGV4dHJhIGZpZWxkIGxlbmd0aFxuICAgIGhlYWRlciArPSBkZWNUb0hleChleHRyYUZpZWxkcy5sZW5ndGgsIDIpO1xuXG5cbiAgICB2YXIgZmlsZVJlY29yZCA9IHNpZ25hdHVyZS5MT0NBTF9GSUxFX0hFQURFUiArIGhlYWRlciArIGVuY29kZWRGaWxlTmFtZSArIGV4dHJhRmllbGRzO1xuXG4gICAgdmFyIGRpclJlY29yZCA9IHNpZ25hdHVyZS5DRU5UUkFMX0ZJTEVfSEVBREVSICtcbiAgICAgICAgLy8gdmVyc2lvbiBtYWRlIGJ5ICgwMDogRE9TKVxuICAgICAgICBkZWNUb0hleCh2ZXJzaW9uTWFkZUJ5LCAyKSArXG4gICAgICAgIC8vIGZpbGUgaGVhZGVyIChjb21tb24gdG8gZmlsZSBhbmQgY2VudHJhbCBkaXJlY3RvcnkpXG4gICAgICAgIGhlYWRlciArXG4gICAgICAgIC8vIGZpbGUgY29tbWVudCBsZW5ndGhcbiAgICAgICAgZGVjVG9IZXgoZW5jb2RlZENvbW1lbnQubGVuZ3RoLCAyKSArXG4gICAgICAgIC8vIGRpc2sgbnVtYmVyIHN0YXJ0XG4gICAgICAgIFwiXFx4MDBcXHgwMFwiICtcbiAgICAgICAgLy8gaW50ZXJuYWwgZmlsZSBhdHRyaWJ1dGVzIFRPRE9cbiAgICAgICAgXCJcXHgwMFxceDAwXCIgK1xuICAgICAgICAvLyBleHRlcm5hbCBmaWxlIGF0dHJpYnV0ZXNcbiAgICAgICAgZGVjVG9IZXgoZXh0RmlsZUF0dHIsIDQpICtcbiAgICAgICAgLy8gcmVsYXRpdmUgb2Zmc2V0IG9mIGxvY2FsIGhlYWRlclxuICAgICAgICBkZWNUb0hleChvZmZzZXQsIDQpICtcbiAgICAgICAgLy8gZmlsZSBuYW1lXG4gICAgICAgIGVuY29kZWRGaWxlTmFtZSArXG4gICAgICAgIC8vIGV4dHJhIGZpZWxkXG4gICAgICAgIGV4dHJhRmllbGRzICtcbiAgICAgICAgLy8gZmlsZSBjb21tZW50XG4gICAgICAgIGVuY29kZWRDb21tZW50O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZmlsZVJlY29yZDogZmlsZVJlY29yZCxcbiAgICAgICAgZGlyUmVjb3JkOiBkaXJSZWNvcmRcbiAgICB9O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSB0aGUgRU9DRCByZWNvcmQuXG4gKiBAcGFyYW0ge051bWJlcn0gZW50cmllc0NvdW50IHRoZSBudW1iZXIgb2YgZW50cmllcyBpbiB0aGUgemlwIGZpbGUuXG4gKiBAcGFyYW0ge051bWJlcn0gY2VudHJhbERpckxlbmd0aCB0aGUgbGVuZ3RoIChpbiBieXRlcykgb2YgdGhlIGNlbnRyYWwgZGlyLlxuICogQHBhcmFtIHtOdW1iZXJ9IGxvY2FsRGlyTGVuZ3RoIHRoZSBsZW5ndGggKGluIGJ5dGVzKSBvZiB0aGUgbG9jYWwgZGlyLlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbW1lbnQgdGhlIHppcCBmaWxlIGNvbW1lbnQgYXMgYSBiaW5hcnkgc3RyaW5nLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZW5jb2RlRmlsZU5hbWUgdGhlIGZ1bmN0aW9uIHRvIGVuY29kZSB0aGUgY29tbWVudC5cbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIEVPQ0QgcmVjb3JkLlxuICovXG52YXIgZ2VuZXJhdGVDZW50cmFsRGlyZWN0b3J5RW5kID0gZnVuY3Rpb24gKGVudHJpZXNDb3VudCwgY2VudHJhbERpckxlbmd0aCwgbG9jYWxEaXJMZW5ndGgsIGNvbW1lbnQsIGVuY29kZUZpbGVOYW1lKSB7XG4gICAgdmFyIGRpckVuZCA9IFwiXCI7XG4gICAgdmFyIGVuY29kZWRDb21tZW50ID0gdXRpbHMudHJhbnNmb3JtVG8oXCJzdHJpbmdcIiwgZW5jb2RlRmlsZU5hbWUoY29tbWVudCkpO1xuXG4gICAgLy8gZW5kIG9mIGNlbnRyYWwgZGlyIHNpZ25hdHVyZVxuICAgIGRpckVuZCA9IHNpZ25hdHVyZS5DRU5UUkFMX0RJUkVDVE9SWV9FTkQgK1xuICAgICAgICAvLyBudW1iZXIgb2YgdGhpcyBkaXNrXG4gICAgICAgIFwiXFx4MDBcXHgwMFwiICtcbiAgICAgICAgLy8gbnVtYmVyIG9mIHRoZSBkaXNrIHdpdGggdGhlIHN0YXJ0IG9mIHRoZSBjZW50cmFsIGRpcmVjdG9yeVxuICAgICAgICBcIlxceDAwXFx4MDBcIiArXG4gICAgICAgIC8vIHRvdGFsIG51bWJlciBvZiBlbnRyaWVzIGluIHRoZSBjZW50cmFsIGRpcmVjdG9yeSBvbiB0aGlzIGRpc2tcbiAgICAgICAgZGVjVG9IZXgoZW50cmllc0NvdW50LCAyKSArXG4gICAgICAgIC8vIHRvdGFsIG51bWJlciBvZiBlbnRyaWVzIGluIHRoZSBjZW50cmFsIGRpcmVjdG9yeVxuICAgICAgICBkZWNUb0hleChlbnRyaWVzQ291bnQsIDIpICtcbiAgICAgICAgLy8gc2l6ZSBvZiB0aGUgY2VudHJhbCBkaXJlY3RvcnkgICA0IGJ5dGVzXG4gICAgICAgIGRlY1RvSGV4KGNlbnRyYWxEaXJMZW5ndGgsIDQpICtcbiAgICAgICAgLy8gb2Zmc2V0IG9mIHN0YXJ0IG9mIGNlbnRyYWwgZGlyZWN0b3J5IHdpdGggcmVzcGVjdCB0byB0aGUgc3RhcnRpbmcgZGlzayBudW1iZXJcbiAgICAgICAgZGVjVG9IZXgobG9jYWxEaXJMZW5ndGgsIDQpICtcbiAgICAgICAgLy8gLlpJUCBmaWxlIGNvbW1lbnQgbGVuZ3RoXG4gICAgICAgIGRlY1RvSGV4KGVuY29kZWRDb21tZW50Lmxlbmd0aCwgMikgK1xuICAgICAgICAvLyAuWklQIGZpbGUgY29tbWVudFxuICAgICAgICBlbmNvZGVkQ29tbWVudDtcblxuICAgIHJldHVybiBkaXJFbmQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIGRhdGEgZGVzY3JpcHRvcnMgZm9yIGEgZmlsZSBlbnRyeS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdHJlYW1JbmZvIHRoZSBoYXNoIGdlbmVyYXRlZCBieSBhIHdvcmtlciwgY29udGFpbmluZyBpbmZvcm1hdGlvblxuICogb24gdGhlIGZpbGUgZW50cnkuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBkYXRhIGRlc2NyaXB0b3JzLlxuICovXG52YXIgZ2VuZXJhdGVEYXRhRGVzY3JpcHRvcnMgPSBmdW5jdGlvbiAoc3RyZWFtSW5mbykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gXCJcIjtcbiAgICBkZXNjcmlwdG9yID0gc2lnbmF0dXJlLkRBVEFfREVTQ1JJUFRPUiArXG4gICAgICAgIC8vIGNyYy0zMiAgICAgICAgICAgICAgICAgICAgICAgICAgNCBieXRlc1xuICAgICAgICBkZWNUb0hleChzdHJlYW1JbmZvWydjcmMzMiddLCA0KSArXG4gICAgICAgIC8vIGNvbXByZXNzZWQgc2l6ZSAgICAgICAgICAgICAgICAgNCBieXRlc1xuICAgICAgICBkZWNUb0hleChzdHJlYW1JbmZvWydjb21wcmVzc2VkU2l6ZSddLCA0KSArXG4gICAgICAgIC8vIHVuY29tcHJlc3NlZCBzaXplICAgICAgICAgICAgICAgNCBieXRlc1xuICAgICAgICBkZWNUb0hleChzdHJlYW1JbmZvWyd1bmNvbXByZXNzZWRTaXplJ10sIDQpO1xuXG4gICAgcmV0dXJuIGRlc2NyaXB0b3I7XG59O1xuXG5cbi8qKlxuICogQSB3b3JrZXIgdG8gY29uY2F0ZW5hdGUgb3RoZXIgd29ya2VycyB0byBjcmVhdGUgYSB6aXAgZmlsZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc3RyZWFtRmlsZXMgYHRydWVgIHRvIHN0cmVhbSB0aGUgY29udGVudCBvZiB0aGUgZmlsZXMsXG4gKiBgZmFsc2VgIHRvIGFjY3VtdWxhdGUgaXQuXG4gKiBAcGFyYW0ge1N0cmluZ30gY29tbWVudCB0aGUgY29tbWVudCB0byB1c2UuXG4gKiBAcGFyYW0ge1N0cmluZ30gcGxhdGZvcm0gdGhlIHBsYXRmb3JtIHRvIHVzZSwgXCJVTklYXCIgb3IgXCJET1NcIi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVuY29kZUZpbGVOYW1lIHRoZSBmdW5jdGlvbiB0byBlbmNvZGUgZmlsZSBuYW1lcyBhbmQgY29tbWVudHMuXG4gKi9cbmZ1bmN0aW9uIFppcEZpbGVXb3JrZXIoc3RyZWFtRmlsZXMsIGNvbW1lbnQsIHBsYXRmb3JtLCBlbmNvZGVGaWxlTmFtZSkge1xuICAgIEdlbmVyaWNXb3JrZXIuY2FsbCh0aGlzLCBcIlppcEZpbGVXb3JrZXJcIik7XG4gICAgLy8gVGhlIG51bWJlciBvZiBieXRlcyB3cml0dGVuIHNvIGZhci4gVGhpcyBkb2Vzbid0IGNvdW50IGFjY3VtdWxhdGVkIGNodW5rcy5cbiAgICB0aGlzLmJ5dGVzV3JpdHRlbiA9IDA7XG4gICAgLy8gVGhlIGNvbW1lbnQgb2YgdGhlIHppcCBmaWxlXG4gICAgdGhpcy56aXBDb21tZW50ID0gY29tbWVudDtcbiAgICAvLyBUaGUgcGxhdGZvcm0gXCJnZW5lcmF0aW5nXCIgdGhlIHppcCBmaWxlLlxuICAgIHRoaXMuemlwUGxhdGZvcm0gPSBwbGF0Zm9ybTtcbiAgICAvLyB0aGUgZnVuY3Rpb24gdG8gZW5jb2RlIGZpbGUgbmFtZXMgYW5kIGNvbW1lbnRzLlxuICAgIHRoaXMuZW5jb2RlRmlsZU5hbWUgPSBlbmNvZGVGaWxlTmFtZTtcbiAgICAvLyBTaG91bGQgd2Ugc3RyZWFtIHRoZSBjb250ZW50IG9mIHRoZSBmaWxlcyA/XG4gICAgdGhpcy5zdHJlYW1GaWxlcyA9IHN0cmVhbUZpbGVzO1xuICAgIC8vIElmIGBzdHJlYW1GaWxlc2AgaXMgZmFsc2UsIHdlIHdpbGwgbmVlZCB0byBhY2N1bXVsYXRlIHRoZSBjb250ZW50IG9mIHRoZVxuICAgIC8vIGZpbGVzIHRvIGNhbGN1bGF0ZSBzaXplcyAvIGNyYzMyIChhbmQgd3JpdGUgdGhlbSAqYmVmb3JlKiB0aGUgY29udGVudCkuXG4gICAgLy8gVGhpcyBib29sZWFuIGluZGljYXRlcyBpZiB3ZSBhcmUgYWNjdW11bGF0aW5nIGNodW5rcyAoaXQgd2lsbCBjaGFuZ2UgYSBsb3RcbiAgICAvLyBkdXJpbmcgdGhlIGxpZmV0aW1lIG9mIHRoaXMgd29ya2VyKS5cbiAgICB0aGlzLmFjY3VtdWxhdGUgPSBmYWxzZTtcbiAgICAvLyBUaGUgYnVmZmVyIHJlY2VpdmluZyBjaHVua3Mgd2hlbiBhY2N1bXVsYXRpbmcgY29udGVudC5cbiAgICB0aGlzLmNvbnRlbnRCdWZmZXIgPSBbXTtcbiAgICAvLyBUaGUgbGlzdCBvZiBnZW5lcmF0ZWQgZGlyZWN0b3J5IHJlY29yZHMuXG4gICAgdGhpcy5kaXJSZWNvcmRzID0gW107XG4gICAgLy8gVGhlIG9mZnNldCAoaW4gYnl0ZXMpIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgemlwIGZpbGUgZm9yIHRoZSBjdXJyZW50IHNvdXJjZS5cbiAgICB0aGlzLmN1cnJlbnRTb3VyY2VPZmZzZXQgPSAwO1xuICAgIC8vIFRoZSB0b3RhbCBudW1iZXIgb2YgZW50cmllcyBpbiB0aGlzIHppcCBmaWxlLlxuICAgIHRoaXMuZW50cmllc0NvdW50ID0gMDtcbiAgICAvLyB0aGUgbmFtZSBvZiB0aGUgZmlsZSBjdXJyZW50bHkgYmVpbmcgYWRkZWQsIG51bGwgd2hlbiBoYW5kbGluZyB0aGUgZW5kIG9mIHRoZSB6aXAgZmlsZS5cbiAgICAvLyBVc2VkIGZvciB0aGUgZW1pdHRlZCBtZXRhZGF0YS5cbiAgICB0aGlzLmN1cnJlbnRGaWxlID0gbnVsbDtcblxuXG5cbiAgICB0aGlzLl9zb3VyY2VzID0gW107XG59XG51dGlscy5pbmhlcml0cyhaaXBGaWxlV29ya2VyLCBHZW5lcmljV29ya2VyKTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucHVzaFxuICovXG5aaXBGaWxlV29ya2VyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rKSB7XG5cbiAgICB2YXIgY3VycmVudEZpbGVQZXJjZW50ID0gY2h1bmsubWV0YS5wZXJjZW50IHx8IDA7XG4gICAgdmFyIGVudHJpZXNDb3VudCA9IHRoaXMuZW50cmllc0NvdW50O1xuICAgIHZhciByZW1haW5pbmdGaWxlcyA9IHRoaXMuX3NvdXJjZXMubGVuZ3RoO1xuXG4gICAgaWYodGhpcy5hY2N1bXVsYXRlKSB7XG4gICAgICAgIHRoaXMuY29udGVudEJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJ5dGVzV3JpdHRlbiArPSBjaHVuay5kYXRhLmxlbmd0aDtcblxuICAgICAgICBHZW5lcmljV29ya2VyLnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywge1xuICAgICAgICAgICAgZGF0YSA6IGNodW5rLmRhdGEsXG4gICAgICAgICAgICBtZXRhIDoge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRGaWxlIDogdGhpcy5jdXJyZW50RmlsZSxcbiAgICAgICAgICAgICAgICBwZXJjZW50IDogZW50cmllc0NvdW50ID8gKGN1cnJlbnRGaWxlUGVyY2VudCArIDEwMCAqIChlbnRyaWVzQ291bnQgLSByZW1haW5pbmdGaWxlcyAtIDEpKSAvIGVudHJpZXNDb3VudCA6IDEwMFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFRoZSB3b3JrZXIgc3RhcnRlZCBhIG5ldyBzb3VyY2UgKGFuIG90aGVyIHdvcmtlcikuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RyZWFtSW5mbyB0aGUgc3RyZWFtSW5mbyBvYmplY3QgZnJvbSB0aGUgbmV3IHNvdXJjZS5cbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUub3BlbmVkU291cmNlID0gZnVuY3Rpb24gKHN0cmVhbUluZm8pIHtcbiAgICB0aGlzLmN1cnJlbnRTb3VyY2VPZmZzZXQgPSB0aGlzLmJ5dGVzV3JpdHRlbjtcbiAgICB0aGlzLmN1cnJlbnRGaWxlID0gc3RyZWFtSW5mb1snZmlsZSddLm5hbWU7XG5cbiAgICB2YXIgc3RyZWFtZWRDb250ZW50ID0gdGhpcy5zdHJlYW1GaWxlcyAmJiAhc3RyZWFtSW5mb1snZmlsZSddLmRpcjtcblxuICAgIC8vIGRvbid0IHN0cmVhbSBmb2xkZXJzIChiZWNhdXNlIHRoZXkgZG9uJ3QgaGF2ZSBhbnkgY29udGVudClcbiAgICBpZihzdHJlYW1lZENvbnRlbnQpIHtcbiAgICAgICAgdmFyIHJlY29yZCA9IGdlbmVyYXRlWmlwUGFydHMoc3RyZWFtSW5mbywgc3RyZWFtZWRDb250ZW50LCBmYWxzZSwgdGhpcy5jdXJyZW50U291cmNlT2Zmc2V0LCB0aGlzLnppcFBsYXRmb3JtLCB0aGlzLmVuY29kZUZpbGVOYW1lKTtcbiAgICAgICAgdGhpcy5wdXNoKHtcbiAgICAgICAgICAgIGRhdGEgOiByZWNvcmQuZmlsZVJlY29yZCxcbiAgICAgICAgICAgIG1ldGEgOiB7cGVyY2VudDowfVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSB3aG9sZSBmaWxlIGJlZm9yZSBwdXNoaW5nIGFueXRoaW5nXG4gICAgICAgIHRoaXMuYWNjdW11bGF0ZSA9IHRydWU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBUaGUgd29ya2VyIGZpbmlzaGVkIGEgc291cmNlIChhbiBvdGhlciB3b3JrZXIpLlxuICogQHBhcmFtIHtPYmplY3R9IHN0cmVhbUluZm8gdGhlIHN0cmVhbUluZm8gb2JqZWN0IGZyb20gdGhlIGZpbmlzaGVkIHNvdXJjZS5cbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUuY2xvc2VkU291cmNlID0gZnVuY3Rpb24gKHN0cmVhbUluZm8pIHtcbiAgICB0aGlzLmFjY3VtdWxhdGUgPSBmYWxzZTtcbiAgICB2YXIgc3RyZWFtZWRDb250ZW50ID0gdGhpcy5zdHJlYW1GaWxlcyAmJiAhc3RyZWFtSW5mb1snZmlsZSddLmRpcjtcbiAgICB2YXIgcmVjb3JkID0gZ2VuZXJhdGVaaXBQYXJ0cyhzdHJlYW1JbmZvLCBzdHJlYW1lZENvbnRlbnQsIHRydWUsIHRoaXMuY3VycmVudFNvdXJjZU9mZnNldCwgdGhpcy56aXBQbGF0Zm9ybSwgdGhpcy5lbmNvZGVGaWxlTmFtZSk7XG5cbiAgICB0aGlzLmRpclJlY29yZHMucHVzaChyZWNvcmQuZGlyUmVjb3JkKTtcbiAgICBpZihzdHJlYW1lZENvbnRlbnQpIHtcbiAgICAgICAgLy8gYWZ0ZXIgdGhlIHN0cmVhbWVkIGZpbGUsIHdlIHB1dCBkYXRhIGRlc2NyaXB0b3JzXG4gICAgICAgIHRoaXMucHVzaCh7XG4gICAgICAgICAgICBkYXRhIDogZ2VuZXJhdGVEYXRhRGVzY3JpcHRvcnMoc3RyZWFtSW5mbyksXG4gICAgICAgICAgICBtZXRhIDoge3BlcmNlbnQ6MTAwfVxuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGUgY29udGVudCB3YXNuJ3Qgc3RyZWFtZWQsIHdlIG5lZWQgdG8gcHVzaCBldmVyeXRoaW5nIG5vd1xuICAgICAgICAvLyBmaXJzdCB0aGUgZmlsZSByZWNvcmQsIHRoZW4gdGhlIGNvbnRlbnRcbiAgICAgICAgdGhpcy5wdXNoKHtcbiAgICAgICAgICAgIGRhdGEgOiByZWNvcmQuZmlsZVJlY29yZCxcbiAgICAgICAgICAgIG1ldGEgOiB7cGVyY2VudDowfVxuICAgICAgICB9KTtcbiAgICAgICAgd2hpbGUodGhpcy5jb250ZW50QnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5wdXNoKHRoaXMuY29udGVudEJ1ZmZlci5zaGlmdCgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRGaWxlID0gbnVsbDtcbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLmZsdXNoXG4gKi9cblppcEZpbGVXb3JrZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGxvY2FsRGlyTGVuZ3RoID0gdGhpcy5ieXRlc1dyaXR0ZW47XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuZGlyUmVjb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnB1c2goe1xuICAgICAgICAgICAgZGF0YSA6IHRoaXMuZGlyUmVjb3Jkc1tpXSxcbiAgICAgICAgICAgIG1ldGEgOiB7cGVyY2VudDoxMDB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgY2VudHJhbERpckxlbmd0aCA9IHRoaXMuYnl0ZXNXcml0dGVuIC0gbG9jYWxEaXJMZW5ndGg7XG5cbiAgICB2YXIgZGlyRW5kID0gZ2VuZXJhdGVDZW50cmFsRGlyZWN0b3J5RW5kKHRoaXMuZGlyUmVjb3Jkcy5sZW5ndGgsIGNlbnRyYWxEaXJMZW5ndGgsIGxvY2FsRGlyTGVuZ3RoLCB0aGlzLnppcENvbW1lbnQsIHRoaXMuZW5jb2RlRmlsZU5hbWUpO1xuXG4gICAgdGhpcy5wdXNoKHtcbiAgICAgICAgZGF0YSA6IGRpckVuZCxcbiAgICAgICAgbWV0YSA6IHtwZXJjZW50OjEwMH1cbiAgICB9KTtcbn07XG5cbi8qKlxuICogUHJlcGFyZSB0aGUgbmV4dCBzb3VyY2UgdG8gYmUgcmVhZC5cbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUucHJlcGFyZU5leHRTb3VyY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5wcmV2aW91cyA9IHRoaXMuX3NvdXJjZXMuc2hpZnQoKTtcbiAgICB0aGlzLm9wZW5lZFNvdXJjZSh0aGlzLnByZXZpb3VzLnN0cmVhbUluZm8pO1xuICAgIGlmICh0aGlzLmlzUGF1c2VkKSB7XG4gICAgICAgIHRoaXMucHJldmlvdXMucGF1c2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByZXZpb3VzLnJlc3VtZSgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnJlZ2lzdGVyUHJldmlvdXNcbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUucmVnaXN0ZXJQcmV2aW91cyA9IGZ1bmN0aW9uIChwcmV2aW91cykge1xuICAgIHRoaXMuX3NvdXJjZXMucHVzaChwcmV2aW91cyk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgcHJldmlvdXMub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgc2VsZi5wcm9jZXNzQ2h1bmsoY2h1bmspO1xuICAgIH0pO1xuICAgIHByZXZpb3VzLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuY2xvc2VkU291cmNlKHNlbGYucHJldmlvdXMuc3RyZWFtSW5mbyk7XG4gICAgICAgIGlmKHNlbGYuX3NvdXJjZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzZWxmLnByZXBhcmVOZXh0U291cmNlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmVuZCgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcHJldmlvdXMub24oJ2Vycm9yJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgc2VsZi5lcnJvcihlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnJlc3VtZVxuICovXG5aaXBGaWxlV29ya2VyLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoIUdlbmVyaWNXb3JrZXIucHJvdG90eXBlLnJlc3VtZS5jYWxsKHRoaXMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMucHJldmlvdXMgJiYgdGhpcy5fc291cmNlcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5wcmVwYXJlTmV4dFNvdXJjZSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnByZXZpb3VzICYmICF0aGlzLl9zb3VyY2VzLmxlbmd0aCAmJiAhdGhpcy5nZW5lcmF0ZWRFcnJvcikge1xuICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5lcnJvclxuICovXG5aaXBGaWxlV29ya2VyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHNvdXJjZXMgPSB0aGlzLl9zb3VyY2VzO1xuICAgIGlmKCFHZW5lcmljV29ya2VyLnByb3RvdHlwZS5lcnJvci5jYWxsKHRoaXMsIGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNvdXJjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNvdXJjZXNbaV0uZXJyb3IoZSk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgLy8gdGhlIGBlcnJvcmAgZXhwbG9kZWQsIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLmxvY2tcbiAqL1xuWmlwRmlsZVdvcmtlci5wcm90b3R5cGUubG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgICBHZW5lcmljV29ya2VyLnByb3RvdHlwZS5sb2NrLmNhbGwodGhpcyk7XG4gICAgdmFyIHNvdXJjZXMgPSB0aGlzLl9zb3VyY2VzO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzb3VyY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNvdXJjZXNbaV0ubG9jaygpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gWmlwRmlsZVdvcmtlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNvbXByZXNzaW9ucyA9IHJlcXVpcmUoJy4uL2NvbXByZXNzaW9ucycpO1xudmFyIFppcEZpbGVXb3JrZXIgPSByZXF1aXJlKCcuL1ppcEZpbGVXb3JrZXInKTtcblxuLyoqXG4gKiBGaW5kIHRoZSBjb21wcmVzc2lvbiB0byB1c2UuXG4gKiBAcGFyYW0ge1N0cmluZ30gZmlsZUNvbXByZXNzaW9uIHRoZSBjb21wcmVzc2lvbiBkZWZpbmVkIGF0IHRoZSBmaWxlIGxldmVsLCBpZiBhbnkuXG4gKiBAcGFyYW0ge1N0cmluZ30gemlwQ29tcHJlc3Npb24gdGhlIGNvbXByZXNzaW9uIGRlZmluZWQgYXQgdGhlIGxvYWQoKSBsZXZlbC5cbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIGNvbXByZXNzaW9uIG9iamVjdCB0byB1c2UuXG4gKi9cbnZhciBnZXRDb21wcmVzc2lvbiA9IGZ1bmN0aW9uIChmaWxlQ29tcHJlc3Npb24sIHppcENvbXByZXNzaW9uKSB7XG5cbiAgICB2YXIgY29tcHJlc3Npb25OYW1lID0gZmlsZUNvbXByZXNzaW9uIHx8IHppcENvbXByZXNzaW9uO1xuICAgIHZhciBjb21wcmVzc2lvbiA9IGNvbXByZXNzaW9uc1tjb21wcmVzc2lvbk5hbWVdO1xuICAgIGlmICghY29tcHJlc3Npb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGNvbXByZXNzaW9uTmFtZSArIFwiIGlzIG5vdCBhIHZhbGlkIGNvbXByZXNzaW9uIG1ldGhvZCAhXCIpO1xuICAgIH1cbiAgICByZXR1cm4gY29tcHJlc3Npb247XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHdvcmtlciB0byBnZW5lcmF0ZSBhIHppcCBmaWxlLlxuICogQHBhcmFtIHtKU1ppcH0gemlwIHRoZSBKU1ppcCBpbnN0YW5jZSBhdCB0aGUgcmlnaHQgcm9vdCBsZXZlbC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRvIGdlbmVyYXRlIHRoZSB6aXAgZmlsZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBjb21tZW50IHRoZSBjb21tZW50IHRvIHVzZS5cbiAqL1xuZXhwb3J0cy5nZW5lcmF0ZVdvcmtlciA9IGZ1bmN0aW9uICh6aXAsIG9wdGlvbnMsIGNvbW1lbnQpIHtcblxuICAgIHZhciB6aXBGaWxlV29ya2VyID0gbmV3IFppcEZpbGVXb3JrZXIob3B0aW9ucy5zdHJlYW1GaWxlcywgY29tbWVudCwgb3B0aW9ucy5wbGF0Zm9ybSwgb3B0aW9ucy5lbmNvZGVGaWxlTmFtZSk7XG4gICAgdmFyIGVudHJpZXNDb3VudCA9IDA7XG4gICAgdHJ5IHtcblxuICAgICAgICB6aXAuZm9yRWFjaChmdW5jdGlvbiAocmVsYXRpdmVQYXRoLCBmaWxlKSB7XG4gICAgICAgICAgICBlbnRyaWVzQ291bnQrKztcbiAgICAgICAgICAgIHZhciBjb21wcmVzc2lvbiA9IGdldENvbXByZXNzaW9uKGZpbGUub3B0aW9ucy5jb21wcmVzc2lvbiwgb3B0aW9ucy5jb21wcmVzc2lvbik7XG4gICAgICAgICAgICB2YXIgY29tcHJlc3Npb25PcHRpb25zID0gZmlsZS5vcHRpb25zLmNvbXByZXNzaW9uT3B0aW9ucyB8fCBvcHRpb25zLmNvbXByZXNzaW9uT3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgIHZhciBkaXIgPSBmaWxlLmRpciwgZGF0ZSA9IGZpbGUuZGF0ZTtcblxuICAgICAgICAgICAgZmlsZS5fY29tcHJlc3NXb3JrZXIoY29tcHJlc3Npb24sIGNvbXByZXNzaW9uT3B0aW9ucylcbiAgICAgICAgICAgIC53aXRoU3RyZWFtSW5mbyhcImZpbGVcIiwge1xuICAgICAgICAgICAgICAgIG5hbWUgOiByZWxhdGl2ZVBhdGgsXG4gICAgICAgICAgICAgICAgZGlyIDogZGlyLFxuICAgICAgICAgICAgICAgIGRhdGUgOiBkYXRlLFxuICAgICAgICAgICAgICAgIGNvbW1lbnQgOiBmaWxlLmNvbW1lbnQgfHwgXCJcIixcbiAgICAgICAgICAgICAgICB1bml4UGVybWlzc2lvbnMgOiBmaWxlLnVuaXhQZXJtaXNzaW9ucyxcbiAgICAgICAgICAgICAgICBkb3NQZXJtaXNzaW9ucyA6IGZpbGUuZG9zUGVybWlzc2lvbnNcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAucGlwZSh6aXBGaWxlV29ya2VyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHppcEZpbGVXb3JrZXIuZW50cmllc0NvdW50ID0gZW50cmllc0NvdW50O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgemlwRmlsZVdvcmtlci5lcnJvcihlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gemlwRmlsZVdvcmtlcjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogUmVwcmVzZW50YXRpb24gYSBvZiB6aXAgZmlsZSBpbiBqc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEpTWmlwKCkge1xuICAgIC8vIGlmIHRoaXMgY29uc3RydWN0b3IgaXPCoHVzZWQgd2l0aG91dMKgYG5ld2AsIGl0wqBhZGRzIGBuZXdgIGJlZm9yZcKgaXRzZWxmOlxuICAgIGlmKCEodGhpcyBpbnN0YW5jZW9mIEpTWmlwKSkge1xuICAgICAgICByZXR1cm4gbmV3IEpTWmlwKCk7XG4gICAgfVxuXG4gICAgaWYoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgY29uc3RydWN0b3Igd2l0aCBwYXJhbWV0ZXJzIGhhcyBiZWVuIHJlbW92ZWQgaW4gSlNaaXAgMy4wLCBwbGVhc2UgY2hlY2sgdGhlIHVwZ3JhZGUgZ3VpZGUuXCIpO1xuICAgIH1cblxuICAgIC8vIG9iamVjdCBjb250YWluaW5nIHRoZSBmaWxlcyA6XG4gICAgLy8ge1xuICAgIC8vICAgXCJmb2xkZXIvXCIgOiB7Li4ufSxcbiAgICAvLyAgIFwiZm9sZGVyL2RhdGEudHh0XCIgOiB7Li4ufVxuICAgIC8vIH1cbiAgICB0aGlzLmZpbGVzID0ge307XG5cbiAgICB0aGlzLmNvbW1lbnQgPSBudWxsO1xuXG4gICAgLy8gV2hlcmUgd2UgYXJlIGluIHRoZSBoaWVyYXJjaHlcbiAgICB0aGlzLnJvb3QgPSBcIlwiO1xuICAgIHRoaXMuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5ld09iaiA9IG5ldyBKU1ppcCgpO1xuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpc1tpXSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgbmV3T2JqW2ldID0gdGhpc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3T2JqO1xuICAgIH07XG59XG5KU1ppcC5wcm90b3R5cGUgPSByZXF1aXJlKCcuL29iamVjdCcpO1xuSlNaaXAucHJvdG90eXBlLmxvYWRBc3luYyA9IHJlcXVpcmUoJy4vbG9hZCcpO1xuSlNaaXAuc3VwcG9ydCA9IHJlcXVpcmUoJy4vc3VwcG9ydCcpO1xuSlNaaXAuZGVmYXVsdHMgPSByZXF1aXJlKCcuL2RlZmF1bHRzJyk7XG5cbi8vIFRPRE8gZmluZCBhIGJldHRlciB3YXkgdG8gaGFuZGxlIHRoaXMgdmVyc2lvbixcbi8vIGEgcmVxdWlyZSgncGFja2FnZS5qc29uJykudmVyc2lvbiBkb2Vzbid0IHdvcmsgd2l0aCB3ZWJwYWNrLCBzZWUgIzMyN1xuSlNaaXAudmVyc2lvbiA9IFwiMy41LjBcIjtcblxuSlNaaXAubG9hZEFzeW5jID0gZnVuY3Rpb24gKGNvbnRlbnQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEpTWmlwKCkubG9hZEFzeW5jKGNvbnRlbnQsIG9wdGlvbnMpO1xufTtcblxuSlNaaXAuZXh0ZXJuYWwgPSByZXF1aXJlKFwiLi9leHRlcm5hbFwiKTtcbm1vZHVsZS5leHBvcnRzID0gSlNaaXA7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgZXh0ZXJuYWwgPSByZXF1aXJlKFwiLi9leHRlcm5hbFwiKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgnLi91dGY4Jyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgWmlwRW50cmllcyA9IHJlcXVpcmUoJy4vemlwRW50cmllcycpO1xudmFyIENyYzMyUHJvYmUgPSByZXF1aXJlKCcuL3N0cmVhbS9DcmMzMlByb2JlJyk7XG52YXIgbm9kZWpzVXRpbHMgPSByZXF1aXJlKFwiLi9ub2RlanNVdGlsc1wiKTtcblxuLyoqXG4gKiBDaGVjayB0aGUgQ1JDMzIgb2YgYW4gZW50cnkuXG4gKiBAcGFyYW0ge1ppcEVudHJ5fSB6aXBFbnRyeSB0aGUgemlwIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybiB7UHJvbWlzZX0gdGhlIHJlc3VsdC5cbiAqL1xuZnVuY3Rpb24gY2hlY2tFbnRyeUNSQzMyKHppcEVudHJ5KSB7XG4gICAgcmV0dXJuIG5ldyBleHRlcm5hbC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIHdvcmtlciA9IHppcEVudHJ5LmRlY29tcHJlc3NlZC5nZXRDb250ZW50V29ya2VyKCkucGlwZShuZXcgQ3JjMzJQcm9iZSgpKTtcbiAgICAgICAgd29ya2VyLm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKFwiZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh3b3JrZXIuc3RyZWFtSW5mby5jcmMzMiAhPT0gemlwRW50cnkuZGVjb21wcmVzc2VkLmNyYzMyKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXAgOiBDUkMzMiBtaXNtYXRjaFwiKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLnJlc3VtZSgpO1xuICAgIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRhdGEsIG9wdGlvbnMpIHtcbiAgICB2YXIgemlwID0gdGhpcztcbiAgICBvcHRpb25zID0gdXRpbHMuZXh0ZW5kKG9wdGlvbnMgfHwge30sIHtcbiAgICAgICAgYmFzZTY0OiBmYWxzZSxcbiAgICAgICAgY2hlY2tDUkMzMjogZmFsc2UsXG4gICAgICAgIG9wdGltaXplZEJpbmFyeVN0cmluZzogZmFsc2UsXG4gICAgICAgIGNyZWF0ZUZvbGRlcnM6IGZhbHNlLFxuICAgICAgICBkZWNvZGVGaWxlTmFtZTogdXRmOC51dGY4ZGVjb2RlXG4gICAgfSk7XG5cbiAgICBpZiAobm9kZWpzVXRpbHMuaXNOb2RlICYmIG5vZGVqc1V0aWxzLmlzU3RyZWFtKGRhdGEpKSB7XG4gICAgICAgIHJldHVybiBleHRlcm5hbC5Qcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJKU1ppcCBjYW4ndCBhY2NlcHQgYSBzdHJlYW0gd2hlbiBsb2FkaW5nIGEgemlwIGZpbGUuXCIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXRpbHMucHJlcGFyZUNvbnRlbnQoXCJ0aGUgbG9hZGVkIHppcCBmaWxlXCIsIGRhdGEsIHRydWUsIG9wdGlvbnMub3B0aW1pemVkQmluYXJ5U3RyaW5nLCBvcHRpb25zLmJhc2U2NClcbiAgICAudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciB6aXBFbnRyaWVzID0gbmV3IFppcEVudHJpZXMob3B0aW9ucyk7XG4gICAgICAgIHppcEVudHJpZXMubG9hZChkYXRhKTtcbiAgICAgICAgcmV0dXJuIHppcEVudHJpZXM7XG4gICAgfSkudGhlbihmdW5jdGlvbiBjaGVja0NSQzMyKHppcEVudHJpZXMpIHtcbiAgICAgICAgdmFyIHByb21pc2VzID0gW2V4dGVybmFsLlByb21pc2UucmVzb2x2ZSh6aXBFbnRyaWVzKV07XG4gICAgICAgIHZhciBmaWxlcyA9IHppcEVudHJpZXMuZmlsZXM7XG4gICAgICAgIGlmIChvcHRpb25zLmNoZWNrQ1JDMzIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGNoZWNrRW50cnlDUkMzMihmaWxlc1tpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHRlcm5hbC5Qcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgfSkudGhlbihmdW5jdGlvbiBhZGRGaWxlcyhyZXN1bHRzKSB7XG4gICAgICAgIHZhciB6aXBFbnRyaWVzID0gcmVzdWx0cy5zaGlmdCgpO1xuICAgICAgICB2YXIgZmlsZXMgPSB6aXBFbnRyaWVzLmZpbGVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXQgPSBmaWxlc1tpXTtcbiAgICAgICAgICAgIHppcC5maWxlKGlucHV0LmZpbGVOYW1lU3RyLCBpbnB1dC5kZWNvbXByZXNzZWQsIHtcbiAgICAgICAgICAgICAgICBiaW5hcnk6IHRydWUsXG4gICAgICAgICAgICAgICAgb3B0aW1pemVkQmluYXJ5U3RyaW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgIGRhdGU6IGlucHV0LmRhdGUsXG4gICAgICAgICAgICAgICAgZGlyOiBpbnB1dC5kaXIsXG4gICAgICAgICAgICAgICAgY29tbWVudCA6IGlucHV0LmZpbGVDb21tZW50U3RyLmxlbmd0aCA/IGlucHV0LmZpbGVDb21tZW50U3RyIDogbnVsbCxcbiAgICAgICAgICAgICAgICB1bml4UGVybWlzc2lvbnMgOiBpbnB1dC51bml4UGVybWlzc2lvbnMsXG4gICAgICAgICAgICAgICAgZG9zUGVybWlzc2lvbnMgOiBpbnB1dC5kb3NQZXJtaXNzaW9ucyxcbiAgICAgICAgICAgICAgICBjcmVhdGVGb2xkZXJzOiBvcHRpb25zLmNyZWF0ZUZvbGRlcnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh6aXBFbnRyaWVzLnppcENvbW1lbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICB6aXAuY29tbWVudCA9IHppcEVudHJpZXMuemlwQ29tbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB6aXA7XG4gICAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoaXMgaXMgcnVubmluZyBpbiBOb2RlanMsIHdpbGwgYmUgdW5kZWZpbmVkIGluIGEgYnJvd3Nlci5cbiAgICAgKiBJbiBhIGJyb3dzZXIsIGJyb3dzZXJpZnkgd29uJ3QgaW5jbHVkZSB0aGlzIGZpbGUgYW5kIHRoZSB3aG9sZSBtb2R1bGVcbiAgICAgKiB3aWxsIGJlIHJlc29sdmVkIGFuIGVtcHR5IG9iamVjdC5cbiAgICAgKi9cbiAgICBpc05vZGUgOiB0eXBlb2YgQnVmZmVyICE9PSBcInVuZGVmaW5lZFwiLFxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBub2RlanMgQnVmZmVyIGZyb20gYW4gZXhpc3RpbmcgY29udGVudC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSB0aGUgZGF0YSB0byBwYXNzIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZW5jb2RpbmcgdGhlIGVuY29kaW5nIHRvIHVzZS5cbiAgICAgKiBAcmV0dXJuIHtCdWZmZXJ9IGEgbmV3IEJ1ZmZlci5cbiAgICAgKi9cbiAgICBuZXdCdWZmZXJGcm9tOiBmdW5jdGlvbihkYXRhLCBlbmNvZGluZykge1xuICAgICAgICBpZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmZyb20gIT09IFVpbnQ4QXJyYXkuZnJvbSkge1xuICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGRhdGEsIGVuY29kaW5nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIC8vIFNhZmVndWFyZCBmb3Igb2xkIE5vZGUuanMgdmVyc2lvbnMuIE9uIG5ld2VyIHZlcnNpb25zLFxuICAgICAgICAgICAgICAgIC8vIEJ1ZmZlci5mcm9tKG51bWJlcikgLyBCdWZmZXIobnVtYmVyLCBlbmNvZGluZykgYWxyZWFkeSB0aHJvdy5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgXFxcImRhdGFcXFwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoZGF0YSwgZW5jb2RpbmcpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgbm9kZWpzIEJ1ZmZlciB3aXRoIHRoZSBzcGVjaWZpZWQgc2l6ZS5cbiAgICAgKiBAcGFyYW0ge0ludGVnZXJ9IHNpemUgdGhlIHNpemUgb2YgdGhlIGJ1ZmZlci5cbiAgICAgKiBAcmV0dXJuIHtCdWZmZXJ9IGEgbmV3IEJ1ZmZlci5cbiAgICAgKi9cbiAgICBhbGxvY0J1ZmZlcjogZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgICAgaWYgKEJ1ZmZlci5hbGxvYykge1xuICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5hbGxvYyhzaXplKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBidWYgPSBuZXcgQnVmZmVyKHNpemUpO1xuICAgICAgICAgICAgYnVmLmZpbGwoMCk7XG4gICAgICAgICAgICByZXR1cm4gYnVmO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBGaW5kIG91dCBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGIgdGhlIG9iamVjdCB0byB0ZXN0LlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIG9iamVjdCBpcyBhIEJ1ZmZlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGlzQnVmZmVyIDogZnVuY3Rpb24oYil7XG4gICAgICAgIHJldHVybiBCdWZmZXIuaXNCdWZmZXIoYik7XG4gICAgfSxcblxuICAgIGlzU3RyZWFtIDogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICYmXG4gICAgICAgICAgICB0eXBlb2Ygb2JqLm9uID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgICAgIHR5cGVvZiBvYmoucGF1c2UgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICAgICAgdHlwZW9mIG9iai5yZXN1bWUgPT09IFwiZnVuY3Rpb25cIjtcbiAgICB9XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4uL3N0cmVhbS9HZW5lcmljV29ya2VyJyk7XG5cbi8qKlxuICogQSB3b3JrZXIgdGhhdCB1c2UgYSBub2RlanMgc3RyZWFtIGFzIHNvdXJjZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IGZpbGVuYW1lIHRoZSBuYW1lIG9mIHRoZSBmaWxlIGVudHJ5IGZvciB0aGlzIHN0cmVhbS5cbiAqIEBwYXJhbSB7UmVhZGFibGV9IHN0cmVhbSB0aGUgbm9kZWpzIHN0cmVhbS5cbiAqL1xuZnVuY3Rpb24gTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyKGZpbGVuYW1lLCBzdHJlYW0pIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJOb2RlanMgc3RyZWFtIGlucHV0IGFkYXB0ZXIgZm9yIFwiICsgZmlsZW5hbWUpO1xuICAgIHRoaXMuX3Vwc3RyZWFtRW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9iaW5kU3RyZWFtKHN0cmVhbSk7XG59XG5cbnV0aWxzLmluaGVyaXRzKE5vZGVqc1N0cmVhbUlucHV0QWRhcHRlciwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogUHJlcGFyZSB0aGUgc3RyZWFtIGFuZCBiaW5kIHRoZSBjYWxsYmFja3Mgb24gaXQuXG4gKiBEbyB0aGlzIEFTQVAgb24gbm9kZSAwLjEwICEgQSBsYXp5IGJpbmRpbmcgZG9lc24ndCBhbHdheXMgd29yay5cbiAqIEBwYXJhbSB7U3RyZWFtfSBzdHJlYW0gdGhlIG5vZGVqcyBzdHJlYW0gdG8gdXNlLlxuICovXG5Ob2RlanNTdHJlYW1JbnB1dEFkYXB0ZXIucHJvdG90eXBlLl9iaW5kU3RyZWFtID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLl9zdHJlYW0gPSBzdHJlYW07XG4gICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgc3RyZWFtXG4gICAgLm9uKFwiZGF0YVwiLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgc2VsZi5wdXNoKHtcbiAgICAgICAgICAgIGRhdGE6IGNodW5rLFxuICAgICAgICAgICAgbWV0YSA6IHtcbiAgICAgICAgICAgICAgICBwZXJjZW50IDogMFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KVxuICAgIC5vbihcImVycm9yXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmKHNlbGYuaXNQYXVzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGVkRXJyb3IgPSBlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH0pXG4gICAgLm9uKFwiZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYoc2VsZi5pc1BhdXNlZCkge1xuICAgICAgICAgICAgc2VsZi5fdXBzdHJlYW1FbmRlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmVuZCgpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZighR2VuZXJpY1dvcmtlci5wcm90b3R5cGUucGF1c2UuY2FsbCh0aGlzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuX3N0cmVhbS5wYXVzZSgpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbk5vZGVqc1N0cmVhbUlucHV0QWRhcHRlci5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKCFHZW5lcmljV29ya2VyLnByb3RvdHlwZS5yZXN1bWUuY2FsbCh0aGlzKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYodGhpcy5fdXBzdHJlYW1FbmRlZCkge1xuICAgICAgICB0aGlzLmVuZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3N0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKS5SZWFkYWJsZTtcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnV0aWxzLmluaGVyaXRzKE5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIsIFJlYWRhYmxlKTtcblxuLyoqXG4qIEEgbm9kZWpzIHN0cmVhbSB1c2luZyBhIHdvcmtlciBhcyBzb3VyY2UuXG4qIEBzZWUgdGhlIFNvdXJjZVdyYXBwZXIgaW4gaHR0cDovL25vZGVqcy5vcmcvYXBpL3N0cmVhbS5odG1sXG4qIEBjb25zdHJ1Y3RvclxuKiBAcGFyYW0ge1N0cmVhbUhlbHBlcn0gaGVscGVyIHRoZSBoZWxwZXIgd3JhcHBpbmcgdGhlIHdvcmtlclxuKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgbm9kZWpzIHN0cmVhbSBvcHRpb25zXG4qIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZUNiIHRoZSB1cGRhdGUgY2FsbGJhY2suXG4qL1xuZnVuY3Rpb24gTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlcihoZWxwZXIsIG9wdGlvbnMsIHVwZGF0ZUNiKSB7XG4gICAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICB0aGlzLl9oZWxwZXIgPSBoZWxwZXI7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaGVscGVyLm9uKFwiZGF0YVwiLCBmdW5jdGlvbiAoZGF0YSwgbWV0YSkge1xuICAgICAgICBpZiAoIXNlbGYucHVzaChkYXRhKSkge1xuICAgICAgICAgICAgc2VsZi5faGVscGVyLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYodXBkYXRlQ2IpIHtcbiAgICAgICAgICAgIHVwZGF0ZUNiKG1ldGEpO1xuICAgICAgICB9XG4gICAgfSlcbiAgICAub24oXCJlcnJvclwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlKTtcbiAgICB9KVxuICAgIC5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYucHVzaChudWxsKTtcbiAgICB9KTtcbn1cblxuXG5Ob2RlanNTdHJlYW1PdXRwdXRBZGFwdGVyLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2hlbHBlci5yZXN1bWUoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlcjtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1dGY4ID0gcmVxdWlyZSgnLi91dGY4Jyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4vc3RyZWFtL0dlbmVyaWNXb3JrZXInKTtcbnZhciBTdHJlYW1IZWxwZXIgPSByZXF1aXJlKCcuL3N0cmVhbS9TdHJlYW1IZWxwZXInKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vZGVmYXVsdHMnKTtcbnZhciBDb21wcmVzc2VkT2JqZWN0ID0gcmVxdWlyZSgnLi9jb21wcmVzc2VkT2JqZWN0Jyk7XG52YXIgWmlwT2JqZWN0ID0gcmVxdWlyZSgnLi96aXBPYmplY3QnKTtcbnZhciBnZW5lcmF0ZSA9IHJlcXVpcmUoXCIuL2dlbmVyYXRlXCIpO1xudmFyIG5vZGVqc1V0aWxzID0gcmVxdWlyZShcIi4vbm9kZWpzVXRpbHNcIik7XG52YXIgTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyID0gcmVxdWlyZShcIi4vbm9kZWpzL05vZGVqc1N0cmVhbUlucHV0QWRhcHRlclwiKTtcblxuXG4vKipcbiAqIEFkZCBhIGZpbGUgaW4gdGhlIGN1cnJlbnQgZm9sZGVyLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBmaWxlXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gZGF0YSB0aGUgZGF0YSBvZiB0aGUgZmlsZVxuICogQHBhcmFtIHtPYmplY3R9IG9yaWdpbmFsT3B0aW9ucyB0aGUgb3B0aW9ucyBvZiB0aGUgZmlsZVxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgbmV3IGZpbGUuXG4gKi9cbnZhciBmaWxlQWRkID0gZnVuY3Rpb24obmFtZSwgZGF0YSwgb3JpZ2luYWxPcHRpb25zKSB7XG4gICAgLy8gYmUgc3VyZSBzdWIgZm9sZGVycyBleGlzdFxuICAgIHZhciBkYXRhVHlwZSA9IHV0aWxzLmdldFR5cGVPZihkYXRhKSxcbiAgICAgICAgcGFyZW50O1xuXG5cbiAgICAvKlxuICAgICAqIENvcnJlY3Qgb3B0aW9ucy5cbiAgICAgKi9cblxuICAgIHZhciBvID0gdXRpbHMuZXh0ZW5kKG9yaWdpbmFsT3B0aW9ucyB8fCB7fSwgZGVmYXVsdHMpO1xuICAgIG8uZGF0ZSA9IG8uZGF0ZSB8fCBuZXcgRGF0ZSgpO1xuICAgIGlmIChvLmNvbXByZXNzaW9uICE9PSBudWxsKSB7XG4gICAgICAgIG8uY29tcHJlc3Npb24gPSBvLmNvbXByZXNzaW9uLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBvLnVuaXhQZXJtaXNzaW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBvLnVuaXhQZXJtaXNzaW9ucyA9IHBhcnNlSW50KG8udW5peFBlcm1pc3Npb25zLCA4KTtcbiAgICB9XG5cbiAgICAvLyBVTlhfSUZESVIgIDAwNDAwMDAgc2VlIHppcGluZm8uY1xuICAgIGlmIChvLnVuaXhQZXJtaXNzaW9ucyAmJiAoby51bml4UGVybWlzc2lvbnMgJiAweDQwMDApKSB7XG4gICAgICAgIG8uZGlyID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gQml0IDQgICAgRGlyZWN0b3J5XG4gICAgaWYgKG8uZG9zUGVybWlzc2lvbnMgJiYgKG8uZG9zUGVybWlzc2lvbnMgJiAweDAwMTApKSB7XG4gICAgICAgIG8uZGlyID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoby5kaXIpIHtcbiAgICAgICAgbmFtZSA9IGZvcmNlVHJhaWxpbmdTbGFzaChuYW1lKTtcbiAgICB9XG4gICAgaWYgKG8uY3JlYXRlRm9sZGVycyAmJiAocGFyZW50ID0gcGFyZW50Rm9sZGVyKG5hbWUpKSkge1xuICAgICAgICBmb2xkZXJBZGQuY2FsbCh0aGlzLCBwYXJlbnQsIHRydWUpO1xuICAgIH1cblxuICAgIHZhciBpc1VuaWNvZGVTdHJpbmcgPSBkYXRhVHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBvLmJpbmFyeSA9PT0gZmFsc2UgJiYgby5iYXNlNjQgPT09IGZhbHNlO1xuICAgIGlmICghb3JpZ2luYWxPcHRpb25zIHx8IHR5cGVvZiBvcmlnaW5hbE9wdGlvbnMuYmluYXJ5ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIG8uYmluYXJ5ID0gIWlzVW5pY29kZVN0cmluZztcbiAgICB9XG5cblxuICAgIHZhciBpc0NvbXByZXNzZWRFbXB0eSA9IChkYXRhIGluc3RhbmNlb2YgQ29tcHJlc3NlZE9iamVjdCkgJiYgZGF0YS51bmNvbXByZXNzZWRTaXplID09PSAwO1xuXG4gICAgaWYgKGlzQ29tcHJlc3NlZEVtcHR5IHx8IG8uZGlyIHx8ICFkYXRhIHx8IGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIG8uYmFzZTY0ID0gZmFsc2U7XG4gICAgICAgIG8uYmluYXJ5ID0gdHJ1ZTtcbiAgICAgICAgZGF0YSA9IFwiXCI7XG4gICAgICAgIG8uY29tcHJlc3Npb24gPSBcIlNUT1JFXCI7XG4gICAgICAgIGRhdGFUeXBlID0gXCJzdHJpbmdcIjtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvbnZlcnQgY29udGVudCB0byBmaXQuXG4gICAgICovXG5cbiAgICB2YXIgemlwT2JqZWN0Q29udGVudCA9IG51bGw7XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBDb21wcmVzc2VkT2JqZWN0IHx8IGRhdGEgaW5zdGFuY2VvZiBHZW5lcmljV29ya2VyKSB7XG4gICAgICAgIHppcE9iamVjdENvbnRlbnQgPSBkYXRhO1xuICAgIH0gZWxzZSBpZiAobm9kZWpzVXRpbHMuaXNOb2RlICYmIG5vZGVqc1V0aWxzLmlzU3RyZWFtKGRhdGEpKSB7XG4gICAgICAgIHppcE9iamVjdENvbnRlbnQgPSBuZXcgTm9kZWpzU3RyZWFtSW5wdXRBZGFwdGVyKG5hbWUsIGRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHppcE9iamVjdENvbnRlbnQgPSB1dGlscy5wcmVwYXJlQ29udGVudChuYW1lLCBkYXRhLCBvLmJpbmFyeSwgby5vcHRpbWl6ZWRCaW5hcnlTdHJpbmcsIG8uYmFzZTY0KTtcbiAgICB9XG5cbiAgICB2YXIgb2JqZWN0ID0gbmV3IFppcE9iamVjdChuYW1lLCB6aXBPYmplY3RDb250ZW50LCBvKTtcbiAgICB0aGlzLmZpbGVzW25hbWVdID0gb2JqZWN0O1xuICAgIC8qXG4gICAgVE9ETzogd2UgY2FuJ3QgdGhyb3cgYW4gZXhjZXB0aW9uIGJlY2F1c2Ugd2UgaGF2ZSBhc3luYyBwcm9taXNlc1xuICAgICh3ZSBjYW4gaGF2ZSBhIHByb21pc2Ugb2YgYSBEYXRlKCkgZm9yIGV4YW1wbGUpIGJ1dCByZXR1cm5pbmcgYVxuICAgIHByb21pc2UgaXMgdXNlbGVzcyBiZWNhdXNlIGZpbGUobmFtZSwgZGF0YSkgcmV0dXJucyB0aGUgSlNaaXBcbiAgICBvYmplY3QgZm9yIGNoYWluaW5nLiBTaG91bGQgd2UgYnJlYWsgdGhhdCB0byBhbGxvdyB0aGUgdXNlclxuICAgIHRvIGNhdGNoIHRoZSBlcnJvciA/XG5cbiAgICByZXR1cm4gZXh0ZXJuYWwuUHJvbWlzZS5yZXNvbHZlKHppcE9iamVjdENvbnRlbnQpXG4gICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0pO1xuICAgICovXG59O1xuXG4vKipcbiAqIEZpbmQgdGhlIHBhcmVudCBmb2xkZXIgb2YgdGhlIHBhdGguXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggdGhlIHBhdGggdG8gdXNlXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBwYXJlbnQgZm9sZGVyLCBvciBcIlwiXG4gKi9cbnZhciBwYXJlbnRGb2xkZXIgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgIGlmIChwYXRoLnNsaWNlKC0xKSA9PT0gJy8nKSB7XG4gICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZygwLCBwYXRoLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICB2YXIgbGFzdFNsYXNoID0gcGF0aC5sYXN0SW5kZXhPZignLycpO1xuICAgIHJldHVybiAobGFzdFNsYXNoID4gMCkgPyBwYXRoLnN1YnN0cmluZygwLCBsYXN0U2xhc2gpIDogXCJcIjtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcGF0aCB3aXRoIGEgc2xhc2ggYXQgdGhlIGVuZC5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCB0aGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIHBhdGggd2l0aCBhIHRyYWlsaW5nIHNsYXNoLlxuICovXG52YXIgZm9yY2VUcmFpbGluZ1NsYXNoID0gZnVuY3Rpb24ocGF0aCkge1xuICAgIC8vIENoZWNrIHRoZSBuYW1lIGVuZHMgd2l0aCBhIC9cbiAgICBpZiAocGF0aC5zbGljZSgtMSkgIT09IFwiL1wiKSB7XG4gICAgICAgIHBhdGggKz0gXCIvXCI7IC8vIElFIGRvZXNuJ3QgbGlrZSBzdWJzdHIoLTEpXG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufTtcblxuLyoqXG4gKiBBZGQgYSAoc3ViKSBmb2xkZXIgaW4gdGhlIGN1cnJlbnQgZm9sZGVyLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBmb2xkZXIncyBuYW1lXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBbY3JlYXRlRm9sZGVyc10gSWYgdHJ1ZSwgYXV0b21hdGljYWxseSBjcmVhdGUgc3ViXG4gKiAgZm9sZGVycy4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBuZXcgZm9sZGVyLlxuICovXG52YXIgZm9sZGVyQWRkID0gZnVuY3Rpb24obmFtZSwgY3JlYXRlRm9sZGVycykge1xuICAgIGNyZWF0ZUZvbGRlcnMgPSAodHlwZW9mIGNyZWF0ZUZvbGRlcnMgIT09ICd1bmRlZmluZWQnKSA/IGNyZWF0ZUZvbGRlcnMgOiBkZWZhdWx0cy5jcmVhdGVGb2xkZXJzO1xuXG4gICAgbmFtZSA9IGZvcmNlVHJhaWxpbmdTbGFzaChuYW1lKTtcblxuICAgIC8vIERvZXMgdGhpcyBmb2xkZXIgYWxyZWFkeSBleGlzdD9cbiAgICBpZiAoIXRoaXMuZmlsZXNbbmFtZV0pIHtcbiAgICAgICAgZmlsZUFkZC5jYWxsKHRoaXMsIG5hbWUsIG51bGwsIHtcbiAgICAgICAgICAgIGRpcjogdHJ1ZSxcbiAgICAgICAgICAgIGNyZWF0ZUZvbGRlcnM6IGNyZWF0ZUZvbGRlcnNcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbGVzW25hbWVdO1xufTtcblxuLyoqXG4qIENyb3NzLXdpbmRvdywgY3Jvc3MtTm9kZS1jb250ZXh0IHJlZ3VsYXIgZXhwcmVzc2lvbiBkZXRlY3Rpb25cbiogQHBhcmFtICB7T2JqZWN0fSAgb2JqZWN0IEFueXRoaW5nXG4qIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICB0cnVlIGlmIHRoZSBvYmplY3QgaXMgYSByZWd1bGFyIGV4cHJlc3Npb24sXG4qIGZhbHNlIG90aGVyd2lzZVxuKi9cbmZ1bmN0aW9uIGlzUmVnRXhwKG9iamVjdCkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PT0gXCJbb2JqZWN0IFJlZ0V4cF1cIjtcbn1cblxuLy8gcmV0dXJuIHRoZSBhY3R1YWwgcHJvdG90eXBlIG9mIEpTWmlwXG52YXIgb3V0ID0ge1xuICAgIC8qKlxuICAgICAqIEBzZWUgbG9hZEFzeW5jXG4gICAgICovXG4gICAgbG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgbWV0aG9kIGhhcyBiZWVuIHJlbW92ZWQgaW4gSlNaaXAgMy4wLCBwbGVhc2UgY2hlY2sgdGhlIHVwZ3JhZGUgZ3VpZGUuXCIpO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIENhbGwgYSBjYWxsYmFjayBmdW5jdGlvbiBmb3IgZWFjaCBlbnRyeSBhdCB0aGlzIGZvbGRlciBsZXZlbC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiB0aGUgY2FsbGJhY2sgZnVuY3Rpb246XG4gICAgICogZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCwgZmlsZSkgey4uLn1cbiAgICAgKiBJdCB0YWtlcyAyIGFyZ3VtZW50cyA6IHRoZSByZWxhdGl2ZSBwYXRoIGFuZCB0aGUgZmlsZS5cbiAgICAgKi9cbiAgICBmb3JFYWNoOiBmdW5jdGlvbihjYikge1xuICAgICAgICB2YXIgZmlsZW5hbWUsIHJlbGF0aXZlUGF0aCwgZmlsZTtcbiAgICAgICAgZm9yIChmaWxlbmFtZSBpbiB0aGlzLmZpbGVzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZmlsZXMuaGFzT3duUHJvcGVydHkoZmlsZW5hbWUpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWxlID0gdGhpcy5maWxlc1tmaWxlbmFtZV07XG4gICAgICAgICAgICByZWxhdGl2ZVBhdGggPSBmaWxlbmFtZS5zbGljZSh0aGlzLnJvb3QubGVuZ3RoLCBmaWxlbmFtZS5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKHJlbGF0aXZlUGF0aCAmJiBmaWxlbmFtZS5zbGljZSgwLCB0aGlzLnJvb3QubGVuZ3RoKSA9PT0gdGhpcy5yb290KSB7IC8vIHRoZSBmaWxlIGlzIGluIHRoZSBjdXJyZW50IHJvb3RcbiAgICAgICAgICAgICAgICBjYihyZWxhdGl2ZVBhdGgsIGZpbGUpOyAvLyBUT0RPIHJldmVyc2UgdGhlIHBhcmFtZXRlcnMgPyBuZWVkIHRvIGJlIGNsZWFuIEFORCBjb25zaXN0ZW50IHdpdGggdGhlIGZpbHRlciBzZWFyY2ggZm4uLi5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGaWx0ZXIgbmVzdGVkIGZpbGVzL2ZvbGRlcnMgd2l0aCB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNlYXJjaCB0aGUgcHJlZGljYXRlIHRvIHVzZSA6XG4gICAgICogZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCwgZmlsZSkgey4uLn1cbiAgICAgKiBJdCB0YWtlcyAyIGFyZ3VtZW50cyA6IHRoZSByZWxhdGl2ZSBwYXRoIGFuZCB0aGUgZmlsZS5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQW4gYXJyYXkgb2YgbWF0Y2hpbmcgZWxlbWVudHMuXG4gICAgICovXG4gICAgZmlsdGVyOiBmdW5jdGlvbihzZWFyY2gpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHJlbGF0aXZlUGF0aCwgZW50cnkpIHtcbiAgICAgICAgICAgIGlmIChzZWFyY2gocmVsYXRpdmVQYXRoLCBlbnRyeSkpIHsgLy8gdGhlIGZpbGUgbWF0Y2hlcyB0aGUgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChlbnRyeSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIGZpbGUgdG8gdGhlIHppcCBmaWxlLCBvciBzZWFyY2ggYSBmaWxlLlxuICAgICAqIEBwYXJhbSAgIHtzdHJpbmd8UmVnRXhwfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBmaWxlIHRvIGFkZCAoaWYgZGF0YSBpcyBkZWZpbmVkKSxcbiAgICAgKiB0aGUgbmFtZSBvZiB0aGUgZmlsZSB0byBmaW5kIChpZiBubyBkYXRhKSBvciBhIHJlZ2V4IHRvIG1hdGNoIGZpbGVzLlxuICAgICAqIEBwYXJhbSAgIHtTdHJpbmd8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGRhdGEgIFRoZSBmaWxlIGRhdGEsIGVpdGhlciByYXcgb3IgYmFzZTY0IGVuY29kZWRcbiAgICAgKiBAcGFyYW0gICB7T2JqZWN0fSBvICAgICBGaWxlIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuICB7SlNaaXB8T2JqZWN0fEFycmF5fSB0aGlzIEpTWmlwIG9iamVjdCAod2hlbiBhZGRpbmcgYSBmaWxlKSxcbiAgICAgKiBhIGZpbGUgKHdoZW4gc2VhcmNoaW5nIGJ5IHN0cmluZykgb3IgYW4gYXJyYXkgb2YgZmlsZXMgKHdoZW4gc2VhcmNoaW5nIGJ5IHJlZ2V4KS5cbiAgICAgKi9cbiAgICBmaWxlOiBmdW5jdGlvbihuYW1lLCBkYXRhLCBvKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBpZiAoaXNSZWdFeHAobmFtZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVnZXhwID0gbmFtZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24ocmVsYXRpdmVQYXRoLCBmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhZmlsZS5kaXIgJiYgcmVnZXhwLnRlc3QocmVsYXRpdmVQYXRoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyAvLyB0ZXh0XG4gICAgICAgICAgICAgICAgdmFyIG9iaiA9IHRoaXMuZmlsZXNbdGhpcy5yb290ICsgbmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKG9iaiAmJiAhb2JqLmRpcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gbW9yZSB0aGFuIG9uZSBhcmd1bWVudCA6IHdlIGhhdmUgZGF0YSAhXG4gICAgICAgICAgICBuYW1lID0gdGhpcy5yb290ICsgbmFtZTtcbiAgICAgICAgICAgIGZpbGVBZGQuY2FsbCh0aGlzLCBuYW1lLCBkYXRhLCBvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgZGlyZWN0b3J5IHRvIHRoZSB6aXAgZmlsZSwgb3Igc2VhcmNoLlxuICAgICAqIEBwYXJhbSAgIHtTdHJpbmd8UmVnRXhwfSBhcmcgVGhlIG5hbWUgb2YgdGhlIGRpcmVjdG9yeSB0byBhZGQsIG9yIGEgcmVnZXggdG8gc2VhcmNoIGZvbGRlcnMuXG4gICAgICogQHJldHVybiAge0pTWmlwfSBhbiBvYmplY3Qgd2l0aCB0aGUgbmV3IGRpcmVjdG9yeSBhcyB0aGUgcm9vdCwgb3IgYW4gYXJyYXkgY29udGFpbmluZyBtYXRjaGluZyBmb2xkZXJzLlxuICAgICAqL1xuICAgIGZvbGRlcjogZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIGlmICghYXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1JlZ0V4cChhcmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24ocmVsYXRpdmVQYXRoLCBmaWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbGUuZGlyICYmIGFyZy50ZXN0KHJlbGF0aXZlUGF0aCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVsc2UsIG5hbWUgaXMgYSBuZXcgZm9sZGVyXG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5yb290ICsgYXJnO1xuICAgICAgICB2YXIgbmV3Rm9sZGVyID0gZm9sZGVyQWRkLmNhbGwodGhpcywgbmFtZSk7XG5cbiAgICAgICAgLy8gQWxsb3cgY2hhaW5pbmcgYnkgcmV0dXJuaW5nIGEgbmV3IG9iamVjdCB3aXRoIHRoaXMgZm9sZGVyIGFzIHRoZSByb290XG4gICAgICAgIHZhciByZXQgPSB0aGlzLmNsb25lKCk7XG4gICAgICAgIHJldC5yb290ID0gbmV3Rm9sZGVyLm5hbWU7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlbGV0ZSBhIGZpbGUsIG9yIGEgZGlyZWN0b3J5IGFuZCBhbGwgc3ViLWZpbGVzLCBmcm9tIHRoZSB6aXBcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZmlsZSB0byBkZWxldGVcbiAgICAgKiBAcmV0dXJuIHtKU1ppcH0gdGhpcyBKU1ppcCBvYmplY3RcbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgbmFtZSA9IHRoaXMucm9vdCArIG5hbWU7XG4gICAgICAgIHZhciBmaWxlID0gdGhpcy5maWxlc1tuYW1lXTtcbiAgICAgICAgaWYgKCFmaWxlKSB7XG4gICAgICAgICAgICAvLyBMb29rIGZvciBhbnkgZm9sZGVyc1xuICAgICAgICAgICAgaWYgKG5hbWUuc2xpY2UoLTEpICE9PSBcIi9cIikge1xuICAgICAgICAgICAgICAgIG5hbWUgKz0gXCIvXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWxlID0gdGhpcy5maWxlc1tuYW1lXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaWxlICYmICFmaWxlLmRpcikge1xuICAgICAgICAgICAgLy8gZmlsZVxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZmlsZXNbbmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBtYXliZSBhIGZvbGRlciwgZGVsZXRlIHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgICB2YXIga2lkcyA9IHRoaXMuZmlsdGVyKGZ1bmN0aW9uKHJlbGF0aXZlUGF0aCwgZmlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmaWxlLm5hbWUuc2xpY2UoMCwgbmFtZS5sZW5ndGgpID09PSBuYW1lO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtpZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5maWxlc1traWRzW2ldLm5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIHRoZSBjb21wbGV0ZSB6aXAgZmlsZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIGdlbmVyYXRlIHRoZSB6aXAgZmlsZSA6XG4gICAgICogLSBjb21wcmVzc2lvbiwgXCJTVE9SRVwiIGJ5IGRlZmF1bHQuXG4gICAgICogLSB0eXBlLCBcImJhc2U2NFwiIGJ5IGRlZmF1bHQuIFZhbHVlcyBhcmUgOiBzdHJpbmcsIGJhc2U2NCwgdWludDhhcnJheSwgYXJyYXlidWZmZXIsIGJsb2IuXG4gICAgICogQHJldHVybiB7U3RyaW5nfFVpbnQ4QXJyYXl8QXJyYXlCdWZmZXJ8QnVmZmVyfEJsb2J9IHRoZSB6aXAgZmlsZVxuICAgICAqL1xuICAgIGdlbmVyYXRlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgbWV0aG9kIGhhcyBiZWVuIHJlbW92ZWQgaW4gSlNaaXAgMy4wLCBwbGVhc2UgY2hlY2sgdGhlIHVwZ3JhZGUgZ3VpZGUuXCIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSB0aGUgY29tcGxldGUgemlwIGZpbGUgYXMgYW4gaW50ZXJuYWwgc3RyZWFtLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRoZSBvcHRpb25zIHRvIGdlbmVyYXRlIHRoZSB6aXAgZmlsZSA6XG4gICAgICogLSBjb21wcmVzc2lvbiwgXCJTVE9SRVwiIGJ5IGRlZmF1bHQuXG4gICAgICogLSB0eXBlLCBcImJhc2U2NFwiIGJ5IGRlZmF1bHQuIFZhbHVlcyBhcmUgOiBzdHJpbmcsIGJhc2U2NCwgdWludDhhcnJheSwgYXJyYXlidWZmZXIsIGJsb2IuXG4gICAgICogQHJldHVybiB7U3RyZWFtSGVscGVyfSB0aGUgc3RyZWFtZWQgemlwIGZpbGUuXG4gICAgICovXG4gICAgZ2VuZXJhdGVJbnRlcm5hbFN0cmVhbTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIHdvcmtlciwgb3B0cyA9IHt9O1xuICAgICAgdHJ5IHtcbiAgICAgICAgICBvcHRzID0gdXRpbHMuZXh0ZW5kKG9wdGlvbnMgfHwge30sIHtcbiAgICAgICAgICAgICAgc3RyZWFtRmlsZXM6IGZhbHNlLFxuICAgICAgICAgICAgICBjb21wcmVzc2lvbjogXCJTVE9SRVwiLFxuICAgICAgICAgICAgICBjb21wcmVzc2lvbk9wdGlvbnMgOiBudWxsLFxuICAgICAgICAgICAgICB0eXBlOiBcIlwiLFxuICAgICAgICAgICAgICBwbGF0Zm9ybTogXCJET1NcIixcbiAgICAgICAgICAgICAgY29tbWVudDogbnVsbCxcbiAgICAgICAgICAgICAgbWltZVR5cGU6ICdhcHBsaWNhdGlvbi96aXAnLFxuICAgICAgICAgICAgICBlbmNvZGVGaWxlTmFtZTogdXRmOC51dGY4ZW5jb2RlXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBvcHRzLnR5cGUgPSBvcHRzLnR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICBvcHRzLmNvbXByZXNzaW9uID0gb3B0cy5jb21wcmVzc2lvbi50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgICAgLy8gXCJiaW5hcnlzdHJpbmdcIiBpcyBwcmVmZXJyZWQgYnV0IHRoZSBpbnRlcm5hbHMgdXNlIFwic3RyaW5nXCIuXG4gICAgICAgICAgaWYob3B0cy50eXBlID09PSBcImJpbmFyeXN0cmluZ1wiKSB7XG4gICAgICAgICAgICBvcHRzLnR5cGUgPSBcInN0cmluZ1wiO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghb3B0cy50eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBvdXRwdXQgdHlwZSBzcGVjaWZpZWQuXCIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHV0aWxzLmNoZWNrU3VwcG9ydChvcHRzLnR5cGUpO1xuXG4gICAgICAgICAgLy8gYWNjZXB0IG5vZGVqcyBgcHJvY2Vzcy5wbGF0Zm9ybWBcbiAgICAgICAgICBpZihcbiAgICAgICAgICAgICAgb3B0cy5wbGF0Zm9ybSA9PT0gJ2RhcndpbicgfHxcbiAgICAgICAgICAgICAgb3B0cy5wbGF0Zm9ybSA9PT0gJ2ZyZWVic2QnIHx8XG4gICAgICAgICAgICAgIG9wdHMucGxhdGZvcm0gPT09ICdsaW51eCcgfHxcbiAgICAgICAgICAgICAgb3B0cy5wbGF0Zm9ybSA9PT0gJ3N1bm9zJ1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgICBvcHRzLnBsYXRmb3JtID0gXCJVTklYXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG4gICAgICAgICAgICAgIG9wdHMucGxhdGZvcm0gPSBcIkRPU1wiO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjb21tZW50ID0gb3B0cy5jb21tZW50IHx8IHRoaXMuY29tbWVudCB8fCBcIlwiO1xuICAgICAgICAgIHdvcmtlciA9IGdlbmVyYXRlLmdlbmVyYXRlV29ya2VyKHRoaXMsIG9wdHMsIGNvbW1lbnQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB3b3JrZXIgPSBuZXcgR2VuZXJpY1dvcmtlcihcImVycm9yXCIpO1xuICAgICAgICB3b3JrZXIuZXJyb3IoZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFN0cmVhbUhlbHBlcih3b3JrZXIsIG9wdHMudHlwZSB8fCBcInN0cmluZ1wiLCBvcHRzLm1pbWVUeXBlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIHRoZSBjb21wbGV0ZSB6aXAgZmlsZSBhc3luY2hyb25vdXNseS5cbiAgICAgKiBAc2VlIGdlbmVyYXRlSW50ZXJuYWxTdHJlYW1cbiAgICAgKi9cbiAgICBnZW5lcmF0ZUFzeW5jOiBmdW5jdGlvbihvcHRpb25zLCBvblVwZGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUludGVybmFsU3RyZWFtKG9wdGlvbnMpLmFjY3VtdWxhdGUob25VcGRhdGUpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgdGhlIGNvbXBsZXRlIHppcCBmaWxlIGFzeW5jaHJvbm91c2x5LlxuICAgICAqIEBzZWUgZ2VuZXJhdGVJbnRlcm5hbFN0cmVhbVxuICAgICAqL1xuICAgIGdlbmVyYXRlTm9kZVN0cmVhbTogZnVuY3Rpb24ob3B0aW9ucywgb25VcGRhdGUpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIGlmICghb3B0aW9ucy50eXBlKSB7XG4gICAgICAgICAgICBvcHRpb25zLnR5cGUgPSBcIm5vZGVidWZmZXJcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUludGVybmFsU3RyZWFtKG9wdGlvbnMpLnRvTm9kZWpzU3RyZWFtKG9uVXBkYXRlKTtcbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBvdXQ7XG4iLCIvKlxuICogVGhpcyBmaWxlIGlzIHVzZWQgYnkgbW9kdWxlIGJ1bmRsZXJzIChicm93c2VyaWZ5L3dlYnBhY2svZXRjKSB3aGVuXG4gKiBpbmNsdWRpbmcgYSBzdHJlYW0gaW1wbGVtZW50YXRpb24uIFdlIHVzZSBcInJlYWRhYmxlLXN0cmVhbVwiIHRvIGdldCBhXG4gKiBjb25zaXN0ZW50IGJlaGF2aW9yIGJldHdlZW4gbm9kZWpzIHZlcnNpb25zIGJ1dCBidW5kbGVycyBvZnRlbiBoYXZlIGEgc2hpbVxuICogZm9yIFwic3RyZWFtXCIuIFVzaW5nIHRoaXMgc2hpbSBncmVhdGx5IGltcHJvdmUgdGhlIGNvbXBhdGliaWxpdHkgYW5kIGdyZWF0bHlcbiAqIHJlZHVjZSB0aGUgZmluYWwgc2l6ZSBvZiB0aGUgYnVuZGxlIChvbmx5IG9uZSBzdHJlYW0gaW1wbGVtZW50YXRpb24sIG5vdFxuICogdHdvKS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIERhdGFSZWFkZXIgPSByZXF1aXJlKCcuL0RhdGFSZWFkZXInKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIEFycmF5UmVhZGVyKGRhdGEpIHtcbiAgICBEYXRhUmVhZGVyLmNhbGwodGhpcywgZGF0YSk7XG5cdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcblx0XHRkYXRhW2ldID0gZGF0YVtpXSAmIDB4RkY7XG5cdH1cbn1cbnV0aWxzLmluaGVyaXRzKEFycmF5UmVhZGVyLCBEYXRhUmVhZGVyKTtcbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLmJ5dGVBdFxuICovXG5BcnJheVJlYWRlci5wcm90b3R5cGUuYnl0ZUF0ID0gZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiB0aGlzLmRhdGFbdGhpcy56ZXJvICsgaV07XG59O1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIubGFzdEluZGV4T2ZTaWduYXR1cmVcbiAqL1xuQXJyYXlSZWFkZXIucHJvdG90eXBlLmxhc3RJbmRleE9mU2lnbmF0dXJlID0gZnVuY3Rpb24oc2lnKSB7XG4gICAgdmFyIHNpZzAgPSBzaWcuY2hhckNvZGVBdCgwKSxcbiAgICAgICAgc2lnMSA9IHNpZy5jaGFyQ29kZUF0KDEpLFxuICAgICAgICBzaWcyID0gc2lnLmNoYXJDb2RlQXQoMiksXG4gICAgICAgIHNpZzMgPSBzaWcuY2hhckNvZGVBdCgzKTtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSA0OyBpID49IDA7IC0taSkge1xuICAgICAgICBpZiAodGhpcy5kYXRhW2ldID09PSBzaWcwICYmIHRoaXMuZGF0YVtpICsgMV0gPT09IHNpZzEgJiYgdGhpcy5kYXRhW2kgKyAyXSA9PT0gc2lnMiAmJiB0aGlzLmRhdGFbaSArIDNdID09PSBzaWczKSB7XG4gICAgICAgICAgICByZXR1cm4gaSAtIHRoaXMuemVybztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbn07XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5yZWFkQW5kQ2hlY2tTaWduYXR1cmVcbiAqL1xuQXJyYXlSZWFkZXIucHJvdG90eXBlLnJlYWRBbmRDaGVja1NpZ25hdHVyZSA9IGZ1bmN0aW9uIChzaWcpIHtcbiAgICB2YXIgc2lnMCA9IHNpZy5jaGFyQ29kZUF0KDApLFxuICAgICAgICBzaWcxID0gc2lnLmNoYXJDb2RlQXQoMSksXG4gICAgICAgIHNpZzIgPSBzaWcuY2hhckNvZGVBdCgyKSxcbiAgICAgICAgc2lnMyA9IHNpZy5jaGFyQ29kZUF0KDMpLFxuICAgICAgICBkYXRhID0gdGhpcy5yZWFkRGF0YSg0KTtcbiAgICByZXR1cm4gc2lnMCA9PT0gZGF0YVswXSAmJiBzaWcxID09PSBkYXRhWzFdICYmIHNpZzIgPT09IGRhdGFbMl0gJiYgc2lnMyA9PT0gZGF0YVszXTtcbn07XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5yZWFkRGF0YVxuICovXG5BcnJheVJlYWRlci5wcm90b3R5cGUucmVhZERhdGEgPSBmdW5jdGlvbihzaXplKSB7XG4gICAgdGhpcy5jaGVja09mZnNldChzaXplKTtcbiAgICBpZihzaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLnplcm8gKyB0aGlzLmluZGV4LCB0aGlzLnplcm8gKyB0aGlzLmluZGV4ICsgc2l6ZSk7XG4gICAgdGhpcy5pbmRleCArPSBzaXplO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBBcnJheVJlYWRlcjtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIERhdGFSZWFkZXIoZGF0YSkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7IC8vIHR5cGUgOiBzZWUgaW1wbGVtZW50YXRpb25cbiAgICB0aGlzLmxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgIHRoaXMuaW5kZXggPSAwO1xuICAgIHRoaXMuemVybyA9IDA7XG59XG5EYXRhUmVhZGVyLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBDaGVjayB0aGF0IHRoZSBvZmZzZXQgd2lsbCBub3QgZ28gdG9vIGZhci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb2Zmc2V0IHRoZSBhZGRpdGlvbmFsIG9mZnNldCB0byBjaGVjay5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gYW4gRXJyb3IgaWYgdGhlIG9mZnNldCBpcyBvdXQgb2YgYm91bmRzLlxuICAgICAqL1xuICAgIGNoZWNrT2Zmc2V0OiBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5jaGVja0luZGV4KHRoaXMuaW5kZXggKyBvZmZzZXQpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhhdCB0aGUgc3BlY2lmaWVkIGluZGV4IHdpbGwgbm90IGJlIHRvbyBmYXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5ld0luZGV4IHRoZSBpbmRleCB0byBjaGVjay5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gYW4gRXJyb3IgaWYgdGhlIGluZGV4IGlzIG91dCBvZiBib3VuZHMuXG4gICAgICovXG4gICAgY2hlY2tJbmRleDogZnVuY3Rpb24obmV3SW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoIDwgdGhpcy56ZXJvICsgbmV3SW5kZXggfHwgbmV3SW5kZXggPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbmQgb2YgZGF0YSByZWFjaGVkIChkYXRhIGxlbmd0aCA9IFwiICsgdGhpcy5sZW5ndGggKyBcIiwgYXNrZWQgaW5kZXggPSBcIiArIChuZXdJbmRleCkgKyBcIikuIENvcnJ1cHRlZCB6aXAgP1wiKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2hhbmdlIHRoZSBpbmRleC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbmV3SW5kZXggVGhlIG5ldyBpbmRleC5cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIG5ldyBpbmRleCBpcyBvdXQgb2YgdGhlIGRhdGEuXG4gICAgICovXG4gICAgc2V0SW5kZXg6IGZ1bmN0aW9uKG5ld0luZGV4KSB7XG4gICAgICAgIHRoaXMuY2hlY2tJbmRleChuZXdJbmRleCk7XG4gICAgICAgIHRoaXMuaW5kZXggPSBuZXdJbmRleDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNraXAgdGhlIG5leHQgbiBieXRlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHNraXAuXG4gICAgICogQHRocm93cyB7RXJyb3J9IGlmIHRoZSBuZXcgaW5kZXggaXMgb3V0IG9mIHRoZSBkYXRhLlxuICAgICAqL1xuICAgIHNraXA6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgdGhpcy5zZXRJbmRleCh0aGlzLmluZGV4ICsgbik7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGJ5dGUgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaSB0aGUgaW5kZXggdG8gdXNlLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gYSBieXRlLlxuICAgICAqL1xuICAgIGJ5dGVBdDogZnVuY3Rpb24oaSkge1xuICAgICAgICAvLyBzZWUgaW1wbGVtZW50YXRpb25zXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5leHQgbnVtYmVyIHdpdGggYSBnaXZlbiBieXRlIHNpemUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgdGhlIG51bWJlciBvZiBieXRlcyB0byByZWFkLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gdGhlIGNvcnJlc3BvbmRpbmcgbnVtYmVyLlxuICAgICAqL1xuICAgIHJlYWRJbnQ6IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IDAsXG4gICAgICAgICAgICBpO1xuICAgICAgICB0aGlzLmNoZWNrT2Zmc2V0KHNpemUpO1xuICAgICAgICBmb3IgKGkgPSB0aGlzLmluZGV4ICsgc2l6ZSAtIDE7IGkgPj0gdGhpcy5pbmRleDsgaS0tKSB7XG4gICAgICAgICAgICByZXN1bHQgPSAocmVzdWx0IDw8IDgpICsgdGhpcy5ieXRlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmRleCArPSBzaXplO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBuZXh0IHN0cmluZyB3aXRoIGEgZ2l2ZW4gYnl0ZSBzaXplLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplIHRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gcmVhZC5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBjb3JyZXNwb25kaW5nIHN0cmluZy5cbiAgICAgKi9cbiAgICByZWFkU3RyaW5nOiBmdW5jdGlvbihzaXplKSB7XG4gICAgICAgIHJldHVybiB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCB0aGlzLnJlYWREYXRhKHNpemUpKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEdldCByYXcgZGF0YSB3aXRob3V0IGNvbnZlcnNpb24sIDxzaXplPiBieXRlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgcmF3IGRhdGEsIGltcGxlbWVudGF0aW9uIHNwZWNpZmljLlxuICAgICAqL1xuICAgIHJlYWREYXRhOiBmdW5jdGlvbihzaXplKSB7XG4gICAgICAgIC8vIHNlZSBpbXBsZW1lbnRhdGlvbnNcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIGxhc3Qgb2NjdXJyZW5jZSBvZiBhIHppcCBzaWduYXR1cmUgKDQgYnl0ZXMpLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzaWcgdGhlIHNpZ25hdHVyZSB0byBmaW5kLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gdGhlIGluZGV4IG9mIHRoZSBsYXN0IG9jY3VycmVuY2UsIC0xIGlmIG5vdCBmb3VuZC5cbiAgICAgKi9cbiAgICBsYXN0SW5kZXhPZlNpZ25hdHVyZTogZnVuY3Rpb24oc2lnKSB7XG4gICAgICAgIC8vIHNlZSBpbXBsZW1lbnRhdGlvbnNcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIHNpZ25hdHVyZSAoNCBieXRlcykgYXQgdGhlIGN1cnJlbnQgcG9zaXRpb24gYW5kIGNvbXBhcmUgaXQgd2l0aCBzaWcuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNpZyB0aGUgZXhwZWN0ZWQgc2lnbmF0dXJlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgc2lnbmF0dXJlIG1hdGNoZXMsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICByZWFkQW5kQ2hlY2tTaWduYXR1cmU6IGZ1bmN0aW9uKHNpZykge1xuICAgICAgICAvLyBzZWUgaW1wbGVtZW50YXRpb25zXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG5leHQgZGF0ZS5cbiAgICAgKiBAcmV0dXJuIHtEYXRlfSB0aGUgZGF0ZS5cbiAgICAgKi9cbiAgICByZWFkRGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkb3N0aW1lID0gdGhpcy5yZWFkSW50KDQpO1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoXG4gICAgICAgICgoZG9zdGltZSA+PiAyNSkgJiAweDdmKSArIDE5ODAsIC8vIHllYXJcbiAgICAgICAgKChkb3N0aW1lID4+IDIxKSAmIDB4MGYpIC0gMSwgLy8gbW9udGhcbiAgICAgICAgKGRvc3RpbWUgPj4gMTYpICYgMHgxZiwgLy8gZGF5XG4gICAgICAgIChkb3N0aW1lID4+IDExKSAmIDB4MWYsIC8vIGhvdXJcbiAgICAgICAgKGRvc3RpbWUgPj4gNSkgJiAweDNmLCAvLyBtaW51dGVcbiAgICAgICAgKGRvc3RpbWUgJiAweDFmKSA8PCAxKSk7IC8vIHNlY29uZFxuICAgIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IERhdGFSZWFkZXI7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgVWludDhBcnJheVJlYWRlciA9IHJlcXVpcmUoJy4vVWludDhBcnJheVJlYWRlcicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gTm9kZUJ1ZmZlclJlYWRlcihkYXRhKSB7XG4gICAgVWludDhBcnJheVJlYWRlci5jYWxsKHRoaXMsIGRhdGEpO1xufVxudXRpbHMuaW5oZXJpdHMoTm9kZUJ1ZmZlclJlYWRlciwgVWludDhBcnJheVJlYWRlcik7XG5cbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLnJlYWREYXRhXG4gKi9cbk5vZGVCdWZmZXJSZWFkZXIucHJvdG90eXBlLnJlYWREYXRhID0gZnVuY3Rpb24oc2l6ZSkge1xuICAgIHRoaXMuY2hlY2tPZmZzZXQoc2l6ZSk7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLnplcm8gKyB0aGlzLmluZGV4LCB0aGlzLnplcm8gKyB0aGlzLmluZGV4ICsgc2l6ZSk7XG4gICAgdGhpcy5pbmRleCArPSBzaXplO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBOb2RlQnVmZmVyUmVhZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIERhdGFSZWFkZXIgPSByZXF1aXJlKCcuL0RhdGFSZWFkZXInKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIFN0cmluZ1JlYWRlcihkYXRhKSB7XG4gICAgRGF0YVJlYWRlci5jYWxsKHRoaXMsIGRhdGEpO1xufVxudXRpbHMuaW5oZXJpdHMoU3RyaW5nUmVhZGVyLCBEYXRhUmVhZGVyKTtcbi8qKlxuICogQHNlZSBEYXRhUmVhZGVyLmJ5dGVBdFxuICovXG5TdHJpbmdSZWFkZXIucHJvdG90eXBlLmJ5dGVBdCA9IGZ1bmN0aW9uKGkpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmNoYXJDb2RlQXQodGhpcy56ZXJvICsgaSk7XG59O1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIubGFzdEluZGV4T2ZTaWduYXR1cmVcbiAqL1xuU3RyaW5nUmVhZGVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZlNpZ25hdHVyZSA9IGZ1bmN0aW9uKHNpZykge1xuICAgIHJldHVybiB0aGlzLmRhdGEubGFzdEluZGV4T2Yoc2lnKSAtIHRoaXMuemVybztcbn07XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5yZWFkQW5kQ2hlY2tTaWduYXR1cmVcbiAqL1xuU3RyaW5nUmVhZGVyLnByb3RvdHlwZS5yZWFkQW5kQ2hlY2tTaWduYXR1cmUgPSBmdW5jdGlvbiAoc2lnKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLnJlYWREYXRhKDQpO1xuICAgIHJldHVybiBzaWcgPT09IGRhdGE7XG59O1xuLyoqXG4gKiBAc2VlIERhdGFSZWFkZXIucmVhZERhdGFcbiAqL1xuU3RyaW5nUmVhZGVyLnByb3RvdHlwZS5yZWFkRGF0YSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICB0aGlzLmNoZWNrT2Zmc2V0KHNpemUpO1xuICAgIC8vIHRoaXMgd2lsbCB3b3JrIGJlY2F1c2UgdGhlIGNvbnN0cnVjdG9yIGFwcGxpZWQgdGhlIFwiJiAweGZmXCIgbWFzay5cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5kYXRhLnNsaWNlKHRoaXMuemVybyArIHRoaXMuaW5kZXgsIHRoaXMuemVybyArIHRoaXMuaW5kZXggKyBzaXplKTtcbiAgICB0aGlzLmluZGV4ICs9IHNpemU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IFN0cmluZ1JlYWRlcjtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBBcnJheVJlYWRlciA9IHJlcXVpcmUoJy4vQXJyYXlSZWFkZXInKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIFVpbnQ4QXJyYXlSZWFkZXIoZGF0YSkge1xuICAgIEFycmF5UmVhZGVyLmNhbGwodGhpcywgZGF0YSk7XG59XG51dGlscy5pbmhlcml0cyhVaW50OEFycmF5UmVhZGVyLCBBcnJheVJlYWRlcik7XG4vKipcbiAqIEBzZWUgRGF0YVJlYWRlci5yZWFkRGF0YVxuICovXG5VaW50OEFycmF5UmVhZGVyLnByb3RvdHlwZS5yZWFkRGF0YSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICB0aGlzLmNoZWNrT2Zmc2V0KHNpemUpO1xuICAgIGlmKHNpemUgPT09IDApIHtcbiAgICAgICAgLy8gaW4gSUUxMCwgd2hlbiB1c2luZyBzdWJhcnJheShpZHgsIGlkeCksIHdlIGdldCB0aGUgYXJyYXkgWzB4MDBdIGluc3RlYWQgb2YgW10uXG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSgwKTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMuZGF0YS5zdWJhcnJheSh0aGlzLnplcm8gKyB0aGlzLmluZGV4LCB0aGlzLnplcm8gKyB0aGlzLmluZGV4ICsgc2l6ZSk7XG4gICAgdGhpcy5pbmRleCArPSBzaXplO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBVaW50OEFycmF5UmVhZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIHN1cHBvcnQgPSByZXF1aXJlKCcuLi9zdXBwb3J0Jyk7XG52YXIgQXJyYXlSZWFkZXIgPSByZXF1aXJlKCcuL0FycmF5UmVhZGVyJyk7XG52YXIgU3RyaW5nUmVhZGVyID0gcmVxdWlyZSgnLi9TdHJpbmdSZWFkZXInKTtcbnZhciBOb2RlQnVmZmVyUmVhZGVyID0gcmVxdWlyZSgnLi9Ob2RlQnVmZmVyUmVhZGVyJyk7XG52YXIgVWludDhBcnJheVJlYWRlciA9IHJlcXVpcmUoJy4vVWludDhBcnJheVJlYWRlcicpO1xuXG4vKipcbiAqIENyZWF0ZSBhIHJlYWRlciBhZGFwdGVkIHRvIHRoZSBkYXRhLlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGRhdGEgdGhlIGRhdGEgdG8gcmVhZC5cbiAqIEByZXR1cm4ge0RhdGFSZWFkZXJ9IHRoZSBkYXRhIHJlYWRlci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciB0eXBlID0gdXRpbHMuZ2V0VHlwZU9mKGRhdGEpO1xuICAgIHV0aWxzLmNoZWNrU3VwcG9ydCh0eXBlKTtcbiAgICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIiAmJiAhc3VwcG9ydC51aW50OGFycmF5KSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyaW5nUmVhZGVyKGRhdGEpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJub2RlYnVmZmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlQnVmZmVyUmVhZGVyKGRhdGEpO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydC51aW50OGFycmF5KSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheVJlYWRlcih1dGlscy50cmFuc2Zvcm1UbyhcInVpbnQ4YXJyYXlcIiwgZGF0YSkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEFycmF5UmVhZGVyKHV0aWxzLnRyYW5zZm9ybVRvKFwiYXJyYXlcIiwgZGF0YSkpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbmV4cG9ydHMuTE9DQUxfRklMRV9IRUFERVIgPSBcIlBLXFx4MDNcXHgwNFwiO1xuZXhwb3J0cy5DRU5UUkFMX0ZJTEVfSEVBREVSID0gXCJQS1xceDAxXFx4MDJcIjtcbmV4cG9ydHMuQ0VOVFJBTF9ESVJFQ1RPUllfRU5EID0gXCJQS1xceDA1XFx4MDZcIjtcbmV4cG9ydHMuWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfTE9DQVRPUiA9IFwiUEtcXHgwNlxceDA3XCI7XG5leHBvcnRzLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0VORCA9IFwiUEtcXHgwNlxceDA2XCI7XG5leHBvcnRzLkRBVEFfREVTQ1JJUFRPUiA9IFwiUEtcXHgwN1xceDA4XCI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZSgnLi9HZW5lcmljV29ya2VyJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG4vKipcbiAqIEEgd29ya2VyIHdoaWNoIGNvbnZlcnQgY2h1bmtzIHRvIGEgc3BlY2lmaWVkIHR5cGUuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBkZXN0VHlwZSB0aGUgZGVzdGluYXRpb24gdHlwZS5cbiAqL1xuZnVuY3Rpb24gQ29udmVydFdvcmtlcihkZXN0VHlwZSkge1xuICAgIEdlbmVyaWNXb3JrZXIuY2FsbCh0aGlzLCBcIkNvbnZlcnRXb3JrZXIgdG8gXCIgKyBkZXN0VHlwZSk7XG4gICAgdGhpcy5kZXN0VHlwZSA9IGRlc3RUeXBlO1xufVxudXRpbHMuaW5oZXJpdHMoQ29udmVydFdvcmtlciwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnByb2Nlc3NDaHVua1xuICovXG5Db252ZXJ0V29ya2VyLnByb3RvdHlwZS5wcm9jZXNzQ2h1bmsgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICB0aGlzLnB1c2goe1xuICAgICAgICBkYXRhIDogdXRpbHMudHJhbnNmb3JtVG8odGhpcy5kZXN0VHlwZSwgY2h1bmsuZGF0YSksXG4gICAgICAgIG1ldGEgOiBjaHVuay5tZXRhXG4gICAgfSk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBDb252ZXJ0V29ya2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4vR2VuZXJpY1dvcmtlcicpO1xudmFyIGNyYzMyID0gcmVxdWlyZSgnLi4vY3JjMzInKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbi8qKlxuICogQSB3b3JrZXIgd2hpY2ggY2FsY3VsYXRlIHRoZSBjcmMzMiBvZiB0aGUgZGF0YSBmbG93aW5nIHRocm91Z2guXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQ3JjMzJQcm9iZSgpIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJDcmMzMlByb2JlXCIpO1xuICAgIHRoaXMud2l0aFN0cmVhbUluZm8oXCJjcmMzMlwiLCAwKTtcbn1cbnV0aWxzLmluaGVyaXRzKENyYzMyUHJvYmUsIEdlbmVyaWNXb3JrZXIpO1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5wcm9jZXNzQ2h1bmtcbiAqL1xuQ3JjMzJQcm9iZS5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgdGhpcy5zdHJlYW1JbmZvLmNyYzMyID0gY3JjMzIoY2h1bmsuZGF0YSwgdGhpcy5zdHJlYW1JbmZvLmNyYzMyIHx8IDApO1xuICAgIHRoaXMucHVzaChjaHVuayk7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBDcmMzMlByb2JlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKCcuL0dlbmVyaWNXb3JrZXInKTtcblxuLyoqXG4gKiBBIHdvcmtlciB3aGljaCBjYWxjdWxhdGUgdGhlIHRvdGFsIGxlbmd0aCBvZiB0aGUgZGF0YSBmbG93aW5nIHRocm91Z2guXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wTmFtZSB0aGUgbmFtZSB1c2VkIHRvIGV4cG9zZSB0aGUgbGVuZ3RoXG4gKi9cbmZ1bmN0aW9uIERhdGFMZW5ndGhQcm9iZShwcm9wTmFtZSkge1xuICAgIEdlbmVyaWNXb3JrZXIuY2FsbCh0aGlzLCBcIkRhdGFMZW5ndGhQcm9iZSBmb3IgXCIgKyBwcm9wTmFtZSk7XG4gICAgdGhpcy5wcm9wTmFtZSA9IHByb3BOYW1lO1xuICAgIHRoaXMud2l0aFN0cmVhbUluZm8ocHJvcE5hbWUsIDApO1xufVxudXRpbHMuaW5oZXJpdHMoRGF0YUxlbmd0aFByb2JlLCBHZW5lcmljV29ya2VyKTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucHJvY2Vzc0NodW5rXG4gKi9cbkRhdGFMZW5ndGhQcm9iZS5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgaWYoY2h1bmspIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRoaXMuc3RyZWFtSW5mb1t0aGlzLnByb3BOYW1lXSB8fCAwO1xuICAgICAgICB0aGlzLnN0cmVhbUluZm9bdGhpcy5wcm9wTmFtZV0gPSBsZW5ndGggKyBjaHVuay5kYXRhLmxlbmd0aDtcbiAgICB9XG4gICAgR2VuZXJpY1dvcmtlci5wcm90b3R5cGUucHJvY2Vzc0NodW5rLmNhbGwodGhpcywgY2h1bmspO1xufTtcbm1vZHVsZS5leHBvcnRzID0gRGF0YUxlbmd0aFByb2JlO1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4vR2VuZXJpY1dvcmtlcicpO1xuXG4vLyB0aGUgc2l6ZSBvZiB0aGUgZ2VuZXJhdGVkIGNodW5rc1xuLy8gVE9ETyBleHBvc2UgdGhpcyBhcyBhIHB1YmxpYyB2YXJpYWJsZVxudmFyIERFRkFVTFRfQkxPQ0tfU0laRSA9IDE2ICogMTAyNDtcblxuLyoqXG4gKiBBIHdvcmtlciB0aGF0IHJlYWRzIGEgY29udGVudCBhbmQgZW1pdHMgY2h1bmtzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1Byb21pc2V9IGRhdGFQIHRoZSBwcm9taXNlIG9mIHRoZSBkYXRhIHRvIHNwbGl0XG4gKi9cbmZ1bmN0aW9uIERhdGFXb3JrZXIoZGF0YVApIHtcbiAgICBHZW5lcmljV29ya2VyLmNhbGwodGhpcywgXCJEYXRhV29ya2VyXCIpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLmRhdGFJc1JlYWR5ID0gZmFsc2U7XG4gICAgdGhpcy5pbmRleCA9IDA7XG4gICAgdGhpcy5tYXggPSAwO1xuICAgIHRoaXMuZGF0YSA9IG51bGw7XG4gICAgdGhpcy50eXBlID0gXCJcIjtcblxuICAgIHRoaXMuX3RpY2tTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAgIGRhdGFQLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgc2VsZi5kYXRhSXNSZWFkeSA9IHRydWU7XG4gICAgICAgIHNlbGYuZGF0YSA9IGRhdGE7XG4gICAgICAgIHNlbGYubWF4ID0gZGF0YSAmJiBkYXRhLmxlbmd0aCB8fCAwO1xuICAgICAgICBzZWxmLnR5cGUgPSB1dGlscy5nZXRUeXBlT2YoZGF0YSk7XG4gICAgICAgIGlmKCFzZWxmLmlzUGF1c2VkKSB7XG4gICAgICAgICAgICBzZWxmLl90aWNrQW5kUmVwZWF0KCk7XG4gICAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBzZWxmLmVycm9yKGUpO1xuICAgIH0pO1xufVxuXG51dGlscy5pbmhlcml0cyhEYXRhV29ya2VyLCBHZW5lcmljV29ya2VyKTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIuY2xlYW5VcFxuICovXG5EYXRhV29ya2VyLnByb3RvdHlwZS5jbGVhblVwID0gZnVuY3Rpb24gKCkge1xuICAgIEdlbmVyaWNXb3JrZXIucHJvdG90eXBlLmNsZWFuVXAuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmRhdGEgPSBudWxsO1xufTtcblxuLyoqXG4gKiBAc2VlIEdlbmVyaWNXb3JrZXIucmVzdW1lXG4gKi9cbkRhdGFXb3JrZXIucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZighR2VuZXJpY1dvcmtlci5wcm90b3R5cGUucmVzdW1lLmNhbGwodGhpcykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fdGlja1NjaGVkdWxlZCAmJiB0aGlzLmRhdGFJc1JlYWR5KSB7XG4gICAgICAgIHRoaXMuX3RpY2tTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICB1dGlscy5kZWxheSh0aGlzLl90aWNrQW5kUmVwZWF0LCBbXSwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBUcmlnZ2VyIGEgdGljayBhIHNjaGVkdWxlIGFuIG90aGVyIGNhbGwgdG8gdGhpcyBmdW5jdGlvbi5cbiAqL1xuRGF0YVdvcmtlci5wcm90b3R5cGUuX3RpY2tBbmRSZXBlYXQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl90aWNrU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgaWYodGhpcy5pc1BhdXNlZCB8fCB0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl90aWNrKCk7XG4gICAgaWYoIXRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICB1dGlscy5kZWxheSh0aGlzLl90aWNrQW5kUmVwZWF0LCBbXSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX3RpY2tTY2hlZHVsZWQgPSB0cnVlO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVhZCBhbmQgcHVzaCBhIGNodW5rLlxuICovXG5EYXRhV29ya2VyLnByb3RvdHlwZS5fdGljayA9IGZ1bmN0aW9uKCkge1xuXG4gICAgaWYodGhpcy5pc1BhdXNlZCB8fCB0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBzaXplID0gREVGQVVMVF9CTE9DS19TSVpFO1xuICAgIHZhciBkYXRhID0gbnVsbCwgbmV4dEluZGV4ID0gTWF0aC5taW4odGhpcy5tYXgsIHRoaXMuaW5kZXggKyBzaXplKTtcbiAgICBpZiAodGhpcy5pbmRleCA+PSB0aGlzLm1heCkge1xuICAgICAgICAvLyBFT0ZcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3dpdGNoKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmRhdGEuc3Vic3RyaW5nKHRoaXMuaW5kZXgsIG5leHRJbmRleCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ1aW50OGFycmF5XCI6XG4gICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuZGF0YS5zdWJhcnJheSh0aGlzLmluZGV4LCBuZXh0SW5kZXgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgICAgIGNhc2UgXCJub2RlYnVmZmVyXCI6XG4gICAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuZGF0YS5zbGljZSh0aGlzLmluZGV4LCBuZXh0SW5kZXgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbmRleCA9IG5leHRJbmRleDtcbiAgICAgICAgcmV0dXJuIHRoaXMucHVzaCh7XG4gICAgICAgICAgICBkYXRhIDogZGF0YSxcbiAgICAgICAgICAgIG1ldGEgOiB7XG4gICAgICAgICAgICAgICAgcGVyY2VudCA6IHRoaXMubWF4ID8gdGhpcy5pbmRleCAvIHRoaXMubWF4ICogMTAwIDogMFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFXb3JrZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQSB3b3JrZXIgdGhhdCBkb2VzIG5vdGhpbmcgYnV0IHBhc3NpbmcgY2h1bmtzIHRvIHRoZSBuZXh0IG9uZS4gVGhpcyBpcyBsaWtlXG4gKiBhIG5vZGVqcyBzdHJlYW0gYnV0IHdpdGggc29tZSBkaWZmZXJlbmNlcy4gT24gdGhlIGdvb2Qgc2lkZSA6XG4gKiAtIGl0IHdvcmtzIG9uIElFIDYtOSB3aXRob3V0IGFueSBpc3N1ZSAvIHBvbHlmaWxsXG4gKiAtIGl0IHdlaWdodHMgbGVzcyB0aGFuIHRoZSBmdWxsIGRlcGVuZGVuY2llcyBidW5kbGVkIHdpdGggYnJvd3NlcmlmeVxuICogLSBpdCBmb3J3YXJkcyBlcnJvcnMgKG5vIG5lZWQgdG8gZGVjbGFyZSBhbiBlcnJvciBoYW5kbGVyIEVWRVJZV0hFUkUpXG4gKlxuICogQSBjaHVuayBpcyBhbiBvYmplY3Qgd2l0aCAyIGF0dHJpYnV0ZXMgOiBgbWV0YWAgYW5kIGBkYXRhYC4gVGhlIGZvcm1lciBpcyBhblxuICogb2JqZWN0IGNvbnRhaW5pbmcgYW55dGhpbmcgKGBwZXJjZW50YCBmb3IgZXhhbXBsZSksIHNlZSBlYWNoIHdvcmtlciBmb3IgbW9yZVxuICogZGV0YWlscy4gVGhlIGxhdHRlciBpcyB0aGUgcmVhbCBkYXRhIChTdHJpbmcsIFVpbnQ4QXJyYXksIGV0YykuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgc3RyZWFtIChtYWlubHkgdXNlZCBmb3IgZGVidWdnaW5nIHB1cnBvc2VzKVxuICovXG5mdW5jdGlvbiBHZW5lcmljV29ya2VyKG5hbWUpIHtcbiAgICAvLyB0aGUgbmFtZSBvZiB0aGUgd29ya2VyXG4gICAgdGhpcy5uYW1lID0gbmFtZSB8fCBcImRlZmF1bHRcIjtcbiAgICAvLyBhbiBvYmplY3QgY29udGFpbmluZyBtZXRhZGF0YSBhYm91dCB0aGUgd29ya2VycyBjaGFpblxuICAgIHRoaXMuc3RyZWFtSW5mbyA9IHt9O1xuICAgIC8vIGFuIGVycm9yIHdoaWNoIGhhcHBlbmVkIHdoZW4gdGhlIHdvcmtlciB3YXMgcGF1c2VkXG4gICAgdGhpcy5nZW5lcmF0ZWRFcnJvciA9IG51bGw7XG4gICAgLy8gYW4gb2JqZWN0IGNvbnRhaW5pbmcgbWV0YWRhdGEgdG8gYmUgbWVyZ2VkIGJ5IHRoaXMgd29ya2VyIGludG8gdGhlIGdlbmVyYWwgbWV0YWRhdGFcbiAgICB0aGlzLmV4dHJhU3RyZWFtSW5mbyA9IHt9O1xuICAgIC8vIHRydWUgaWYgdGhlIHN0cmVhbSBpcyBwYXVzZWQgKGFuZCBzaG91bGQgbm90IGRvIGFueXRoaW5nKSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgdGhpcy5pc1BhdXNlZCA9IHRydWU7XG4gICAgLy8gdHJ1ZSBpZiB0aGUgc3RyZWFtIGlzIGZpbmlzaGVkIChhbmQgc2hvdWxkIG5vdCBkbyBhbnl0aGluZyksIGZhbHNlIG90aGVyd2lzZVxuICAgIHRoaXMuaXNGaW5pc2hlZCA9IGZhbHNlO1xuICAgIC8vIHRydWUgaWYgdGhlIHN0cmVhbSBpcyBsb2NrZWQgdG8gcHJldmVudCBmdXJ0aGVyIHN0cnVjdHVyZSB1cGRhdGVzIChwaXBlKSwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgdGhpcy5pc0xvY2tlZCA9IGZhbHNlO1xuICAgIC8vIHRoZSBldmVudCBsaXN0ZW5lcnNcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7XG4gICAgICAgICdkYXRhJzpbXSxcbiAgICAgICAgJ2VuZCc6W10sXG4gICAgICAgICdlcnJvcic6W11cbiAgICB9O1xuICAgIC8vIHRoZSBwcmV2aW91cyB3b3JrZXIsIGlmIGFueVxuICAgIHRoaXMucHJldmlvdXMgPSBudWxsO1xufVxuXG5HZW5lcmljV29ya2VyLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBQdXNoIGEgY2h1bmsgdG8gdGhlIG5leHQgd29ya2Vycy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2h1bmsgdGhlIGNodW5rIHRvIHB1c2hcbiAgICAgKi9cbiAgICBwdXNoIDogZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgIHRoaXMuZW1pdChcImRhdGFcIiwgY2h1bmspO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRW5kIHRoZSBzdHJlYW0uXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGlzIGNhbGwgZW5kZWQgdGhlIHdvcmtlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGVuZCA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZW5kXCIpO1xuICAgICAgICAgICAgdGhpcy5jbGVhblVwKCk7XG4gICAgICAgICAgICB0aGlzLmlzRmluaXNoZWQgPSB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEVuZCB0aGUgc3RyZWFtIHdpdGggYW4gZXJyb3IuXG4gICAgICogQHBhcmFtIHtFcnJvcn0gZSB0aGUgZXJyb3Igd2hpY2ggY2F1c2VkIHRoZSBwcmVtYXR1cmUgZW5kLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhpcyBjYWxsIGVuZGVkIHRoZSB3b3JrZXIgd2l0aCBhbiBlcnJvciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGVycm9yIDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5pc1BhdXNlZCkge1xuICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZWRFcnJvciA9IGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmlzRmluaXNoZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlKTtcblxuICAgICAgICAgICAgLy8gaW4gdGhlIHdvcmtlcnMgY2hhaW4gZXhwbG9kZWQgaW4gdGhlIG1pZGRsZSBvZiB0aGUgY2hhaW4sXG4gICAgICAgICAgICAvLyB0aGUgZXJyb3IgZXZlbnQgd2lsbCBnbyBkb3dud2FyZCBidXQgd2UgYWxzbyBuZWVkIHRvIG5vdGlmeVxuICAgICAgICAgICAgLy8gd29ya2VycyB1cHdhcmQgdGhhdCB0aGVyZSBoYXMgYmVlbiBhbiBlcnJvci5cbiAgICAgICAgICAgIGlmKHRoaXMucHJldmlvdXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNsZWFuVXAoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEFkZCBhIGNhbGxiYWNrIG9uIGFuIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBldmVudCAoZGF0YSwgZW5kLCBlcnJvcilcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciB0aGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWRcbiAgICAgKiBAcmV0dXJuIHtHZW5lcmljV29ya2VyfSB0aGUgY3VycmVudCBvYmplY3QgZm9yIGNoYWluYWJpbGl0eVxuICAgICAqL1xuICAgIG9uIDogZnVuY3Rpb24gKG5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVyc1tuYW1lXS5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDbGVhbiBhbnkgcmVmZXJlbmNlcyB3aGVuIGEgd29ya2VyIGlzIGVuZGluZy5cbiAgICAgKi9cbiAgICBjbGVhblVwIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0cmVhbUluZm8gPSB0aGlzLmdlbmVyYXRlZEVycm9yID0gdGhpcy5leHRyYVN0cmVhbUluZm8gPSBudWxsO1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRyaWdnZXIgYW4gZXZlbnQuIFRoaXMgd2lsbCBjYWxsIHJlZ2lzdGVyZWQgY2FsbGJhY2sgd2l0aCB0aGUgcHJvdmlkZWQgYXJnLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBldmVudCAoZGF0YSwgZW5kLCBlcnJvcilcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXJnIHRoZSBhcmd1bWVudCB0byBjYWxsIHRoZSBjYWxsYmFjayB3aXRoLlxuICAgICAqL1xuICAgIGVtaXQgOiBmdW5jdGlvbiAobmFtZSwgYXJnKSB7XG4gICAgICAgIGlmICh0aGlzLl9saXN0ZW5lcnNbbmFtZV0pIHtcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9saXN0ZW5lcnNbbmFtZV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNbbmFtZV1baV0uY2FsbCh0aGlzLCBhcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDaGFpbiBhIHdvcmtlciB3aXRoIGFuIG90aGVyLlxuICAgICAqIEBwYXJhbSB7V29ya2VyfSBuZXh0IHRoZSB3b3JrZXIgcmVjZWl2aW5nIGV2ZW50cyBmcm9tIHRoZSBjdXJyZW50IG9uZS5cbiAgICAgKiBAcmV0dXJuIHt3b3JrZXJ9IHRoZSBuZXh0IHdvcmtlciBmb3IgY2hhaW5hYmlsaXR5XG4gICAgICovXG4gICAgcGlwZSA6IGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICAgIHJldHVybiBuZXh0LnJlZ2lzdGVyUHJldmlvdXModGhpcyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBTYW1lIGFzIGBwaXBlYCBpbiB0aGUgb3RoZXIgZGlyZWN0aW9uLlxuICAgICAqIFVzaW5nIGFuIEFQSSB3aXRoIGBwaXBlKG5leHQpYCBpcyB2ZXJ5IGVhc3kuXG4gICAgICogSW1wbGVtZW50aW5nIHRoZSBBUEkgd2l0aCB0aGUgcG9pbnQgb2YgdmlldyBvZiB0aGUgbmV4dCBvbmUgcmVnaXN0ZXJpbmdcbiAgICAgKiBhIHNvdXJjZSBpcyBlYXNpZXIsIHNlZSB0aGUgWmlwRmlsZVdvcmtlci5cbiAgICAgKiBAcGFyYW0ge1dvcmtlcn0gcHJldmlvdXMgdGhlIHByZXZpb3VzIHdvcmtlciwgc2VuZGluZyBldmVudHMgdG8gdGhpcyBvbmVcbiAgICAgKiBAcmV0dXJuIHtXb3JrZXJ9IHRoZSBjdXJyZW50IHdvcmtlciBmb3IgY2hhaW5hYmlsaXR5XG4gICAgICovXG4gICAgcmVnaXN0ZXJQcmV2aW91cyA6IGZ1bmN0aW9uIChwcmV2aW91cykge1xuICAgICAgICBpZiAodGhpcy5pc0xvY2tlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0cmVhbSAnXCIgKyB0aGlzICsgXCInIGhhcyBhbHJlYWR5IGJlZW4gdXNlZC5cIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzaGFyaW5nIHRoZSBzdHJlYW1JbmZvLi4uXG4gICAgICAgIHRoaXMuc3RyZWFtSW5mbyA9IHByZXZpb3VzLnN0cmVhbUluZm87XG4gICAgICAgIC8vIC4uLiBhbmQgYWRkaW5nIG91ciBvd24gYml0c1xuICAgICAgICB0aGlzLm1lcmdlU3RyZWFtSW5mbygpO1xuICAgICAgICB0aGlzLnByZXZpb3VzID0gIHByZXZpb3VzO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHByZXZpb3VzLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgICBzZWxmLnByb2Nlc3NDaHVuayhjaHVuayk7XG4gICAgICAgIH0pO1xuICAgICAgICBwcmV2aW91cy5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2VsZi5lbmQoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHByZXZpb3VzLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBzZWxmLmVycm9yKGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBQYXVzZSB0aGUgc3RyZWFtIHNvIGl0IGRvZXNuJ3Qgc2VuZCBldmVudHMgYW55bW9yZS5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoaXMgY2FsbCBwYXVzZWQgdGhlIHdvcmtlciwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHBhdXNlIDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZih0aGlzLmlzUGF1c2VkIHx8IHRoaXMuaXNGaW5pc2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNQYXVzZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmKHRoaXMucHJldmlvdXMpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXMucGF1c2UoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlc3VtZSBhIHBhdXNlZCBzdHJlYW0uXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiB0aGlzIGNhbGwgcmVzdW1lZCB0aGUgd29ya2VyLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgcmVzdW1lIDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZighdGhpcy5pc1BhdXNlZCB8fCB0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzUGF1c2VkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gaWYgdHJ1ZSwgdGhlIHdvcmtlciB0cmllZCB0byByZXN1bWUgYnV0IGZhaWxlZFxuICAgICAgICB2YXIgd2l0aEVycm9yID0gZmFsc2U7XG4gICAgICAgIGlmKHRoaXMuZ2VuZXJhdGVkRXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IodGhpcy5nZW5lcmF0ZWRFcnJvcik7XG4gICAgICAgICAgICB3aXRoRXJyb3IgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMucHJldmlvdXMpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXMucmVzdW1lKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gIXdpdGhFcnJvcjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEZsdXNoIGFueSByZW1haW5pbmcgYnl0ZXMgYXMgdGhlIHN0cmVhbSBpcyBlbmRpbmcuXG4gICAgICovXG4gICAgZmx1c2ggOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGEgY2h1bmsuIFRoaXMgaXMgdXN1YWxseSB0aGUgbWV0aG9kIG92ZXJyaWRkZW4uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNodW5rIHRoZSBjaHVuayB0byBwcm9jZXNzLlxuICAgICAqL1xuICAgIHByb2Nlc3NDaHVuayA6IGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICAgIHRoaXMucHVzaChjaHVuayk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBZGQgYSBrZXkvdmFsdWUgdG8gYmUgYWRkZWQgaW4gdGhlIHdvcmtlcnMgY2hhaW4gc3RyZWFtSW5mbyBvbmNlIGFjdGl2YXRlZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IHRoZSBrZXkgdG8gdXNlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIHRoZSBhc3NvY2lhdGVkIHZhbHVlXG4gICAgICogQHJldHVybiB7V29ya2VyfSB0aGUgY3VycmVudCB3b3JrZXIgZm9yIGNoYWluYWJpbGl0eVxuICAgICAqL1xuICAgIHdpdGhTdHJlYW1JbmZvIDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5leHRyYVN0cmVhbUluZm9ba2V5XSA9IHZhbHVlO1xuICAgICAgICB0aGlzLm1lcmdlU3RyZWFtSW5mbygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIE1lcmdlIHRoaXMgd29ya2VyJ3Mgc3RyZWFtSW5mbyBpbnRvIHRoZSBjaGFpbidzIHN0cmVhbUluZm8uXG4gICAgICovXG4gICAgbWVyZ2VTdHJlYW1JbmZvIDogZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IodmFyIGtleSBpbiB0aGlzLmV4dHJhU3RyZWFtSW5mbykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmV4dHJhU3RyZWFtSW5mby5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0cmVhbUluZm9ba2V5XSA9IHRoaXMuZXh0cmFTdHJlYW1JbmZvW2tleV07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTG9jayB0aGUgc3RyZWFtIHRvIHByZXZlbnQgZnVydGhlciB1cGRhdGVzIG9uIHRoZSB3b3JrZXJzIGNoYWluLlxuICAgICAqIEFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QsIGFsbCBjYWxscyB0byBwaXBlIHdpbGwgZmFpbC5cbiAgICAgKi9cbiAgICBsb2NrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTG9ja2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3RyZWFtICdcIiArIHRoaXMgKyBcIicgaGFzIGFscmVhZHkgYmVlbiB1c2VkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzTG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMucHJldmlvdXMpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXMubG9jaygpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogUHJldHR5IHByaW50IHRoZSB3b3JrZXJzIGNoYWluLlxuICAgICAqL1xuICAgIHRvU3RyaW5nIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWUgPSBcIldvcmtlciBcIiArIHRoaXMubmFtZTtcbiAgICAgICAgaWYgKHRoaXMucHJldmlvdXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByZXZpb3VzICsgXCIgLT4gXCIgKyBtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR2VuZXJpY1dvcmtlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBDb252ZXJ0V29ya2VyID0gcmVxdWlyZSgnLi9Db252ZXJ0V29ya2VyJyk7XG52YXIgR2VuZXJpY1dvcmtlciA9IHJlcXVpcmUoJy4vR2VuZXJpY1dvcmtlcicpO1xudmFyIGJhc2U2NCA9IHJlcXVpcmUoJy4uL2Jhc2U2NCcpO1xudmFyIHN1cHBvcnQgPSByZXF1aXJlKFwiLi4vc3VwcG9ydFwiKTtcbnZhciBleHRlcm5hbCA9IHJlcXVpcmUoXCIuLi9leHRlcm5hbFwiKTtcblxudmFyIE5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIgPSBudWxsO1xuaWYgKHN1cHBvcnQubm9kZXN0cmVhbSkge1xuICAgIHRyeSB7XG4gICAgICAgIE5vZGVqc1N0cmVhbU91dHB1dEFkYXB0ZXIgPSByZXF1aXJlKCcuLi9ub2RlanMvTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlcicpO1xuICAgIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBBcHBseSB0aGUgZmluYWwgdHJhbnNmb3JtYXRpb24gb2YgdGhlIGRhdGEuIElmIHRoZSB1c2VyIHdhbnRzIGEgQmxvYiBmb3JcbiAqIGV4YW1wbGUsIGl0J3MgZWFzaWVyIHRvIHdvcmsgd2l0aCBhbiBVOGludEFycmF5IGFuZCBmaW5hbGx5IGRvIHRoZVxuICogQXJyYXlCdWZmZXIvQmxvYiBjb252ZXJzaW9uLlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIG5hbWUgb2YgdGhlIGZpbmFsIHR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfFVpbnQ4QXJyYXl8QnVmZmVyfSBjb250ZW50IHRoZSBjb250ZW50IHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtTdHJpbmd9IG1pbWVUeXBlIHRoZSBtaW1lIHR5cGUgb2YgdGhlIGNvbnRlbnQsIGlmIGFwcGxpY2FibGUuXG4gKiBAcmV0dXJuIHtTdHJpbmd8VWludDhBcnJheXxBcnJheUJ1ZmZlcnxCdWZmZXJ8QmxvYn0gdGhlIGNvbnRlbnQgaW4gdGhlIHJpZ2h0IGZvcm1hdC5cbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtWmlwT3V0cHV0KHR5cGUsIGNvbnRlbnQsIG1pbWVUeXBlKSB7XG4gICAgc3dpdGNoKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcImJsb2JcIiA6XG4gICAgICAgICAgICByZXR1cm4gdXRpbHMubmV3QmxvYih1dGlscy50cmFuc2Zvcm1UbyhcImFycmF5YnVmZmVyXCIsIGNvbnRlbnQpLCBtaW1lVHlwZSk7XG4gICAgICAgIGNhc2UgXCJiYXNlNjRcIiA6XG4gICAgICAgICAgICByZXR1cm4gYmFzZTY0LmVuY29kZShjb250ZW50KTtcbiAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICByZXR1cm4gdXRpbHMudHJhbnNmb3JtVG8odHlwZSwgY29udGVudCk7XG4gICAgfVxufVxuXG4vKipcbiAqIENvbmNhdGVuYXRlIGFuIGFycmF5IG9mIGRhdGEgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgdHlwZSBvZiB0aGUgZGF0YSBpbiB0aGUgZ2l2ZW4gYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhQXJyYXkgdGhlIGFycmF5IGNvbnRhaW5pbmcgdGhlIGRhdGEgY2h1bmtzIHRvIGNvbmNhdGVuYXRlXG4gKiBAcmV0dXJuIHtTdHJpbmd8VWludDhBcnJheXxCdWZmZXJ9IHRoZSBjb25jYXRlbmF0ZWQgZGF0YVxuICogQHRocm93cyBFcnJvciBpZiB0aGUgYXNrZWQgdHlwZSBpcyB1bnN1cHBvcnRlZFxuICovXG5mdW5jdGlvbiBjb25jYXQgKHR5cGUsIGRhdGFBcnJheSkge1xuICAgIHZhciBpLCBpbmRleCA9IDAsIHJlcyA9IG51bGwsIHRvdGFsTGVuZ3RoID0gMDtcbiAgICBmb3IoaSA9IDA7IGkgPCBkYXRhQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdG90YWxMZW5ndGggKz0gZGF0YUFycmF5W2ldLmxlbmd0aDtcbiAgICB9XG4gICAgc3dpdGNoKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIGRhdGFBcnJheS5qb2luKFwiXCIpO1xuICAgICAgICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGRhdGFBcnJheSk7XG4gICAgICAgIGNhc2UgXCJ1aW50OGFycmF5XCI6XG4gICAgICAgICAgICByZXMgPSBuZXcgVWludDhBcnJheSh0b3RhbExlbmd0aCk7XG4gICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBkYXRhQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXMuc2V0KGRhdGFBcnJheVtpXSwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIGluZGV4ICs9IGRhdGFBcnJheVtpXS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICBjYXNlIFwibm9kZWJ1ZmZlclwiOlxuICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoZGF0YUFycmF5KTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvbmNhdCA6IHVuc3VwcG9ydGVkIHR5cGUgJ1wiICArIHR5cGUgKyBcIidcIik7XG4gICAgfVxufVxuXG4vKipcbiAqIExpc3RlbiBhIFN0cmVhbUhlbHBlciwgYWNjdW11bGF0ZSBpdHMgY29udGVudCBhbmQgY29uY2F0ZW5hdGUgaXQgaW50byBhXG4gKiBjb21wbGV0ZSBibG9jay5cbiAqIEBwYXJhbSB7U3RyZWFtSGVscGVyfSBoZWxwZXIgdGhlIGhlbHBlciB0byB1c2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVDYWxsYmFjayBhIGNhbGxiYWNrIGNhbGxlZCBvbiBlYWNoIHVwZGF0ZS4gQ2FsbGVkXG4gKiB3aXRoIG9uZSBhcmcgOlxuICogLSB0aGUgbWV0YWRhdGEgbGlua2VkIHRvIHRoZSB1cGRhdGUgcmVjZWl2ZWQuXG4gKiBAcmV0dXJuIFByb21pc2UgdGhlIHByb21pc2UgZm9yIHRoZSBhY2N1bXVsYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGUoaGVscGVyLCB1cGRhdGVDYWxsYmFjaykge1xuICAgIHJldHVybiBuZXcgZXh0ZXJuYWwuUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICAgICAgdmFyIGRhdGFBcnJheSA9IFtdO1xuICAgICAgICB2YXIgY2h1bmtUeXBlID0gaGVscGVyLl9pbnRlcm5hbFR5cGUsXG4gICAgICAgICAgICByZXN1bHRUeXBlID0gaGVscGVyLl9vdXRwdXRUeXBlLFxuICAgICAgICAgICAgbWltZVR5cGUgPSBoZWxwZXIuX21pbWVUeXBlO1xuICAgICAgICBoZWxwZXJcbiAgICAgICAgLm9uKCdkYXRhJywgZnVuY3Rpb24gKGRhdGEsIG1ldGEpIHtcbiAgICAgICAgICAgIGRhdGFBcnJheS5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgaWYodXBkYXRlQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVDYWxsYmFjayhtZXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgZGF0YUFycmF5ID0gW107XG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdlbmQnLCBmdW5jdGlvbiAoKXtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRyYW5zZm9ybVppcE91dHB1dChyZXN1bHRUeXBlLCBjb25jYXQoY2h1bmtUeXBlLCBkYXRhQXJyYXkpLCBtaW1lVHlwZSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGFBcnJheSA9IFtdO1xuICAgICAgICB9KVxuICAgICAgICAucmVzdW1lKCk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQW4gaGVscGVyIHRvIGVhc2lseSB1c2Ugd29ya2VycyBvdXRzaWRlIG9mIEpTWmlwLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1dvcmtlcn0gd29ya2VyIHRoZSB3b3JrZXIgdG8gd3JhcFxuICogQHBhcmFtIHtTdHJpbmd9IG91dHB1dFR5cGUgdGhlIHR5cGUgb2YgZGF0YSBleHBlY3RlZCBieSB0aGUgdXNlXG4gKiBAcGFyYW0ge1N0cmluZ30gbWltZVR5cGUgdGhlIG1pbWUgdHlwZSBvZiB0aGUgY29udGVudCwgaWYgYXBwbGljYWJsZS5cbiAqL1xuZnVuY3Rpb24gU3RyZWFtSGVscGVyKHdvcmtlciwgb3V0cHV0VHlwZSwgbWltZVR5cGUpIHtcbiAgICB2YXIgaW50ZXJuYWxUeXBlID0gb3V0cHV0VHlwZTtcbiAgICBzd2l0Y2gob3V0cHV0VHlwZSkge1xuICAgICAgICBjYXNlIFwiYmxvYlwiOlxuICAgICAgICBjYXNlIFwiYXJyYXlidWZmZXJcIjpcbiAgICAgICAgICAgIGludGVybmFsVHlwZSA9IFwidWludDhhcnJheVwiO1xuICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImJhc2U2NFwiOlxuICAgICAgICAgICAgaW50ZXJuYWxUeXBlID0gXCJzdHJpbmdcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgICAgLy8gdGhlIHR5cGUgdXNlZCBpbnRlcm5hbGx5XG4gICAgICAgIHRoaXMuX2ludGVybmFsVHlwZSA9IGludGVybmFsVHlwZTtcbiAgICAgICAgLy8gdGhlIHR5cGUgdXNlZCB0byBvdXRwdXQgcmVzdWx0c1xuICAgICAgICB0aGlzLl9vdXRwdXRUeXBlID0gb3V0cHV0VHlwZTtcbiAgICAgICAgLy8gdGhlIG1pbWUgdHlwZVxuICAgICAgICB0aGlzLl9taW1lVHlwZSA9IG1pbWVUeXBlO1xuICAgICAgICB1dGlscy5jaGVja1N1cHBvcnQoaW50ZXJuYWxUeXBlKTtcbiAgICAgICAgdGhpcy5fd29ya2VyID0gd29ya2VyLnBpcGUobmV3IENvbnZlcnRXb3JrZXIoaW50ZXJuYWxUeXBlKSk7XG4gICAgICAgIC8vIHRoZSBsYXN0IHdvcmtlcnMgY2FuIGJlIHJld2lyZWQgd2l0aG91dCBpc3N1ZXMgYnV0IHdlIG5lZWQgdG9cbiAgICAgICAgLy8gcHJldmVudCBhbnkgdXBkYXRlcyBvbiBwcmV2aW91cyB3b3JrZXJzLlxuICAgICAgICB3b3JrZXIubG9jaygpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgICB0aGlzLl93b3JrZXIgPSBuZXcgR2VuZXJpY1dvcmtlcihcImVycm9yXCIpO1xuICAgICAgICB0aGlzLl93b3JrZXIuZXJyb3IoZSk7XG4gICAgfVxufVxuXG5TdHJlYW1IZWxwZXIucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIExpc3RlbiBhIFN0cmVhbUhlbHBlciwgYWNjdW11bGF0ZSBpdHMgY29udGVudCBhbmQgY29uY2F0ZW5hdGUgaXQgaW50byBhXG4gICAgICogY29tcGxldGUgYmxvY2suXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdXBkYXRlQ2IgdGhlIHVwZGF0ZSBjYWxsYmFjay5cbiAgICAgKiBAcmV0dXJuIFByb21pc2UgdGhlIHByb21pc2UgZm9yIHRoZSBhY2N1bXVsYXRpb24uXG4gICAgICovXG4gICAgYWNjdW11bGF0ZSA6IGZ1bmN0aW9uICh1cGRhdGVDYikge1xuICAgICAgICByZXR1cm4gYWNjdW11bGF0ZSh0aGlzLCB1cGRhdGVDYik7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBBZGQgYSBsaXN0ZW5lciBvbiBhbiBldmVudCB0cmlnZ2VyZWQgb24gYSBzdHJlYW0uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGV2dCB0aGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiB0aGUgbGlzdGVuZXJcbiAgICAgKiBAcmV0dXJuIHtTdHJlYW1IZWxwZXJ9IHRoZSBjdXJyZW50IGhlbHBlci5cbiAgICAgKi9cbiAgICBvbiA6IGZ1bmN0aW9uIChldnQsIGZuKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICBpZihldnQgPT09IFwiZGF0YVwiKSB7XG4gICAgICAgICAgICB0aGlzLl93b3JrZXIub24oZXZ0LCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgICAgICBmbi5jYWxsKHNlbGYsIGNodW5rLmRhdGEsIGNodW5rLm1ldGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl93b3JrZXIub24oZXZ0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdXRpbHMuZGVsYXkoZm4sIGFyZ3VtZW50cywgc2VsZik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlc3VtZSB0aGUgZmxvdyBvZiBjaHVua3MuXG4gICAgICogQHJldHVybiB7U3RyZWFtSGVscGVyfSB0aGUgY3VycmVudCBoZWxwZXIuXG4gICAgICovXG4gICAgcmVzdW1lIDogZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlscy5kZWxheSh0aGlzLl93b3JrZXIucmVzdW1lLCBbXSwgdGhpcy5fd29ya2VyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBQYXVzZSB0aGUgZmxvdyBvZiBjaHVua3MuXG4gICAgICogQHJldHVybiB7U3RyZWFtSGVscGVyfSB0aGUgY3VycmVudCBoZWxwZXIuXG4gICAgICovXG4gICAgcGF1c2UgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3dvcmtlci5wYXVzZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIG5vZGVqcyBzdHJlYW0gZm9yIHRoaXMgaGVscGVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZUNiIHRoZSB1cGRhdGUgY2FsbGJhY2suXG4gICAgICogQHJldHVybiB7Tm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlcn0gdGhlIG5vZGVqcyBzdHJlYW0uXG4gICAgICovXG4gICAgdG9Ob2RlanNTdHJlYW0gOiBmdW5jdGlvbiAodXBkYXRlQ2IpIHtcbiAgICAgICAgdXRpbHMuY2hlY2tTdXBwb3J0KFwibm9kZXN0cmVhbVwiKTtcbiAgICAgICAgaWYgKHRoaXMuX291dHB1dFR5cGUgIT09IFwibm9kZWJ1ZmZlclwiKSB7XG4gICAgICAgICAgICAvLyBhbiBvYmplY3Qgc3RyZWFtIGNvbnRhaW5pbmcgYmxvYi9hcnJheWJ1ZmZlci91aW50OGFycmF5L3N0cmluZ1xuICAgICAgICAgICAgLy8gaXMgc3RyYW5nZSBhbmQgSSBkb24ndCBrbm93IGlmIGl0IHdvdWxkIGJlIHVzZWZ1bC5cbiAgICAgICAgICAgIC8vIEkgeW91IGZpbmQgdGhpcyBjb21tZW50IGFuZCBoYXZlIGEgZ29vZCB1c2VjYXNlLCBwbGVhc2Ugb3BlbiBhXG4gICAgICAgICAgICAvLyBidWcgcmVwb3J0ICFcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLl9vdXRwdXRUeXBlICsgXCIgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIG1ldGhvZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgTm9kZWpzU3RyZWFtT3V0cHV0QWRhcHRlcih0aGlzLCB7XG4gICAgICAgICAgICBvYmplY3RNb2RlIDogdGhpcy5fb3V0cHV0VHlwZSAhPT0gXCJub2RlYnVmZmVyXCJcbiAgICAgICAgfSwgdXBkYXRlQ2IpO1xuICAgIH1cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW1IZWxwZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuYmFzZTY0ID0gdHJ1ZTtcbmV4cG9ydHMuYXJyYXkgPSB0cnVlO1xuZXhwb3J0cy5zdHJpbmcgPSB0cnVlO1xuZXhwb3J0cy5hcnJheWJ1ZmZlciA9IHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIjtcbmV4cG9ydHMubm9kZWJ1ZmZlciA9IHR5cGVvZiBCdWZmZXIgIT09IFwidW5kZWZpbmVkXCI7XG4vLyBjb250YWlucyB0cnVlIGlmIEpTWmlwIGNhbiByZWFkL2dlbmVyYXRlIFVpbnQ4QXJyYXksIGZhbHNlIG90aGVyd2lzZS5cbmV4cG9ydHMudWludDhhcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSBcInVuZGVmaW5lZFwiO1xuXG5pZiAodHlwZW9mIEFycmF5QnVmZmVyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgZXhwb3J0cy5ibG9iID0gZmFsc2U7XG59XG5lbHNlIHtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKDApO1xuICAgIHRyeSB7XG4gICAgICAgIGV4cG9ydHMuYmxvYiA9IG5ldyBCbG9iKFtidWZmZXJdLCB7XG4gICAgICAgICAgICB0eXBlOiBcImFwcGxpY2F0aW9uL3ppcFwiXG4gICAgICAgIH0pLnNpemUgPT09IDA7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgQnVpbGRlciA9IHNlbGYuQmxvYkJ1aWxkZXIgfHwgc2VsZi5XZWJLaXRCbG9iQnVpbGRlciB8fCBzZWxmLk1vekJsb2JCdWlsZGVyIHx8IHNlbGYuTVNCbG9iQnVpbGRlcjtcbiAgICAgICAgICAgIHZhciBidWlsZGVyID0gbmV3IEJ1aWxkZXIoKTtcbiAgICAgICAgICAgIGJ1aWxkZXIuYXBwZW5kKGJ1ZmZlcik7XG4gICAgICAgICAgICBleHBvcnRzLmJsb2IgPSBidWlsZGVyLmdldEJsb2IoJ2FwcGxpY2F0aW9uL3ppcCcpLnNpemUgPT09IDA7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGV4cG9ydHMuYmxvYiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG50cnkge1xuICAgIGV4cG9ydHMubm9kZXN0cmVhbSA9ICEhcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJykuUmVhZGFibGU7XG59IGNhdGNoKGUpIHtcbiAgICBleHBvcnRzLm5vZGVzdHJlYW0gPSBmYWxzZTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIHN1cHBvcnQgPSByZXF1aXJlKCcuL3N1cHBvcnQnKTtcbnZhciBub2RlanNVdGlscyA9IHJlcXVpcmUoJy4vbm9kZWpzVXRpbHMnKTtcbnZhciBHZW5lcmljV29ya2VyID0gcmVxdWlyZSgnLi9zdHJlYW0vR2VuZXJpY1dvcmtlcicpO1xuXG4vKipcbiAqIFRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIGNvbWUgZnJvbSBwYWtvLCBmcm9tIHBha28vbGliL3V0aWxzL3N0cmluZ3NcbiAqIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSwgc2VlIHBha28gaHR0cHM6Ly9naXRodWIuY29tL25vZGVjYS9wYWtvL1xuICovXG5cbi8vIFRhYmxlIHdpdGggdXRmOCBsZW5ndGhzIChjYWxjdWxhdGVkIGJ5IGZpcnN0IGJ5dGUgb2Ygc2VxdWVuY2UpXG4vLyBOb3RlLCB0aGF0IDUgJiA2LWJ5dGUgdmFsdWVzIGFuZCBzb21lIDQtYnl0ZSB2YWx1ZXMgY2FuIG5vdCBiZSByZXByZXNlbnRlZCBpbiBKUyxcbi8vIGJlY2F1c2UgbWF4IHBvc3NpYmxlIGNvZGVwb2ludCBpcyAweDEwZmZmZlxudmFyIF91dGY4bGVuID0gbmV3IEFycmF5KDI1Nik7XG5mb3IgKHZhciBpPTA7IGk8MjU2OyBpKyspIHtcbiAgX3V0ZjhsZW5baV0gPSAoaSA+PSAyNTIgPyA2IDogaSA+PSAyNDggPyA1IDogaSA+PSAyNDAgPyA0IDogaSA+PSAyMjQgPyAzIDogaSA+PSAxOTIgPyAyIDogMSk7XG59XG5fdXRmOGxlblsyNTRdPV91dGY4bGVuWzI1NF09MTsgLy8gSW52YWxpZCBzZXF1ZW5jZSBzdGFydFxuXG4vLyBjb252ZXJ0IHN0cmluZyB0byBhcnJheSAodHlwZWQsIHdoZW4gcG9zc2libGUpXG52YXIgc3RyaW5nMmJ1ZiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICB2YXIgYnVmLCBjLCBjMiwgbV9wb3MsIGksIHN0cl9sZW4gPSBzdHIubGVuZ3RoLCBidWZfbGVuID0gMDtcblxuICAgIC8vIGNvdW50IGJpbmFyeSBzaXplXG4gICAgZm9yIChtX3BvcyA9IDA7IG1fcG9zIDwgc3RyX2xlbjsgbV9wb3MrKykge1xuICAgICAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgICAgICBpZiAoKGMgJiAweGZjMDApID09PSAweGQ4MDAgJiYgKG1fcG9zKzEgPCBzdHJfbGVuKSkge1xuICAgICAgICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcysxKTtcbiAgICAgICAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgICAgICAgICBtX3BvcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJ1Zl9sZW4gKz0gYyA8IDB4ODAgPyAxIDogYyA8IDB4ODAwID8gMiA6IGMgPCAweDEwMDAwID8gMyA6IDQ7XG4gICAgfVxuXG4gICAgLy8gYWxsb2NhdGUgYnVmZmVyXG4gICAgaWYgKHN1cHBvcnQudWludDhhcnJheSkge1xuICAgICAgICBidWYgPSBuZXcgVWludDhBcnJheShidWZfbGVuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBidWYgPSBuZXcgQXJyYXkoYnVmX2xlbik7XG4gICAgfVxuXG4gICAgLy8gY29udmVydFxuICAgIGZvciAoaT0wLCBtX3BvcyA9IDA7IGkgPCBidWZfbGVuOyBtX3BvcysrKSB7XG4gICAgICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7XG4gICAgICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MrMSA8IHN0cl9sZW4pKSB7XG4gICAgICAgICAgICBjMiA9IHN0ci5jaGFyQ29kZUF0KG1fcG9zKzEpO1xuICAgICAgICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICAgICAgICAgIGMgPSAweDEwMDAwICsgKChjIC0gMHhkODAwKSA8PCAxMCkgKyAoYzIgLSAweGRjMDApO1xuICAgICAgICAgICAgICAgIG1fcG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAgICAgICAvKiBvbmUgYnl0ZSAqL1xuICAgICAgICAgICAgYnVmW2krK10gPSBjO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgICAgICAgLyogdHdvIGJ5dGVzICovXG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4QzAgfCAoYyA+Pj4gNik7XG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICAgICAgICAvKiB0aHJlZSBieXRlcyAqL1xuICAgICAgICAgICAgYnVmW2krK10gPSAweEUwIHwgKGMgPj4+IDEyKTtcbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICAgICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLyogZm91ciBieXRlcyAqL1xuICAgICAgICAgICAgYnVmW2krK10gPSAweGYwIHwgKGMgPj4+IDE4KTtcbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiAxMiAmIDB4M2YpO1xuICAgICAgICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDYgJiAweDNmKTtcbiAgICAgICAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYnVmO1xufTtcblxuLy8gQ2FsY3VsYXRlIG1heCBwb3NzaWJsZSBwb3NpdGlvbiBpbiB1dGY4IGJ1ZmZlcixcbi8vIHRoYXQgd2lsbCBub3QgYnJlYWsgc2VxdWVuY2UuIElmIHRoYXQncyBub3QgcG9zc2libGVcbi8vIC0gKHZlcnkgc21hbGwgbGltaXRzKSByZXR1cm4gbWF4IHNpemUgYXMgaXMuXG4vL1xuLy8gYnVmW10gLSB1dGY4IGJ5dGVzIGFycmF5XG4vLyBtYXggICAtIGxlbmd0aCBsaW1pdCAobWFuZGF0b3J5KTtcbnZhciB1dGY4Ym9yZGVyID0gZnVuY3Rpb24oYnVmLCBtYXgpIHtcbiAgICB2YXIgcG9zO1xuXG4gICAgbWF4ID0gbWF4IHx8IGJ1Zi5sZW5ndGg7XG4gICAgaWYgKG1heCA+IGJ1Zi5sZW5ndGgpIHsgbWF4ID0gYnVmLmxlbmd0aDsgfVxuXG4gICAgLy8gZ28gYmFjayBmcm9tIGxhc3QgcG9zaXRpb24sIHVudGlsIHN0YXJ0IG9mIHNlcXVlbmNlIGZvdW5kXG4gICAgcG9zID0gbWF4LTE7XG4gICAgd2hpbGUgKHBvcyA+PSAwICYmIChidWZbcG9zXSAmIDB4QzApID09PSAweDgwKSB7IHBvcy0tOyB9XG5cbiAgICAvLyBGdWNrdXAgLSB2ZXJ5IHNtYWxsIGFuZCBicm9rZW4gc2VxdWVuY2UsXG4gICAgLy8gcmV0dXJuIG1heCwgYmVjYXVzZSB3ZSBzaG91bGQgcmV0dXJuIHNvbWV0aGluZyBhbnl3YXkuXG4gICAgaWYgKHBvcyA8IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gICAgLy8gSWYgd2UgY2FtZSB0byBzdGFydCBvZiBidWZmZXIgLSB0aGF0IG1lYW5zIHZ1ZmZlciBpcyB0b28gc21hbGwsXG4gICAgLy8gcmV0dXJuIG1heCB0b28uXG4gICAgaWYgKHBvcyA9PT0gMCkgeyByZXR1cm4gbWF4OyB9XG5cbiAgICByZXR1cm4gKHBvcyArIF91dGY4bGVuW2J1Zltwb3NdXSA+IG1heCkgPyBwb3MgOiBtYXg7XG59O1xuXG4vLyBjb252ZXJ0IGFycmF5IHRvIHN0cmluZ1xudmFyIGJ1ZjJzdHJpbmcgPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgdmFyIHN0ciwgaSwgb3V0LCBjLCBjX2xlbjtcbiAgICB2YXIgbGVuID0gYnVmLmxlbmd0aDtcblxuICAgIC8vIFJlc2VydmUgbWF4IHBvc3NpYmxlIGxlbmd0aCAoMiB3b3JkcyBwZXIgY2hhcilcbiAgICAvLyBOQjogYnkgdW5rbm93biByZWFzb25zLCBBcnJheSBpcyBzaWduaWZpY2FudGx5IGZhc3RlciBmb3JcbiAgICAvLyAgICAgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSB0aGFuIFVpbnQxNkFycmF5LlxuICAgIHZhciB1dGYxNmJ1ZiA9IG5ldyBBcnJheShsZW4qMik7XG5cbiAgICBmb3IgKG91dD0wLCBpPTA7IGk8bGVuOykge1xuICAgICAgICBjID0gYnVmW2krK107XG4gICAgICAgIC8vIHF1aWNrIHByb2Nlc3MgYXNjaWlcbiAgICAgICAgaWYgKGMgPCAweDgwKSB7IHV0ZjE2YnVmW291dCsrXSA9IGM7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgY19sZW4gPSBfdXRmOGxlbltjXTtcbiAgICAgICAgLy8gc2tpcCA1ICYgNiBieXRlIGNvZGVzXG4gICAgICAgIGlmIChjX2xlbiA+IDQpIHsgdXRmMTZidWZbb3V0KytdID0gMHhmZmZkOyBpICs9IGNfbGVuLTE7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgLy8gYXBwbHkgbWFzayBvbiBmaXJzdCBieXRlXG4gICAgICAgIGMgJj0gY19sZW4gPT09IDIgPyAweDFmIDogY19sZW4gPT09IDMgPyAweDBmIDogMHgwNztcbiAgICAgICAgLy8gam9pbiB0aGUgcmVzdFxuICAgICAgICB3aGlsZSAoY19sZW4gPiAxICYmIGkgPCBsZW4pIHtcbiAgICAgICAgICAgIGMgPSAoYyA8PCA2KSB8IChidWZbaSsrXSAmIDB4M2YpO1xuICAgICAgICAgICAgY19sZW4tLTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRlcm1pbmF0ZWQgYnkgZW5kIG9mIHN0cmluZz9cbiAgICAgICAgaWYgKGNfbGVuID4gMSkgeyB1dGYxNmJ1ZltvdXQrK10gPSAweGZmZmQ7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgaWYgKGMgPCAweDEwMDAwKSB7XG4gICAgICAgICAgICB1dGYxNmJ1ZltvdXQrK10gPSBjO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYyAtPSAweDEwMDAwO1xuICAgICAgICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkODAwIHwgKChjID4+IDEwKSAmIDB4M2ZmKTtcbiAgICAgICAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZGMwMCB8IChjICYgMHgzZmYpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2hyaW5rQnVmKHV0ZjE2YnVmLCBvdXQpXG4gICAgaWYgKHV0ZjE2YnVmLmxlbmd0aCAhPT0gb3V0KSB7XG4gICAgICAgIGlmKHV0ZjE2YnVmLnN1YmFycmF5KSB7XG4gICAgICAgICAgICB1dGYxNmJ1ZiA9IHV0ZjE2YnVmLnN1YmFycmF5KDAsIG91dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1dGYxNmJ1Zi5sZW5ndGggPSBvdXQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCB1dGYxNmJ1Zik7XG4gICAgcmV0dXJuIHV0aWxzLmFwcGx5RnJvbUNoYXJDb2RlKHV0ZjE2YnVmKTtcbn07XG5cblxuLy8gVGhhdCdzIGFsbCBmb3IgdGhlIHBha28gZnVuY3Rpb25zLlxuXG5cbi8qKlxuICogVHJhbnNmb3JtIGEgamF2YXNjcmlwdCBzdHJpbmcgaW50byBhbiBhcnJheSAodHlwZWQgaWYgcG9zc2libGUpIG9mIGJ5dGVzLFxuICogVVRGLTggZW5jb2RlZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgdGhlIHN0cmluZyB0byBlbmNvZGVcbiAqIEByZXR1cm4ge0FycmF5fFVpbnQ4QXJyYXl8QnVmZmVyfSB0aGUgVVRGLTggZW5jb2RlZCBzdHJpbmcuXG4gKi9cbmV4cG9ydHMudXRmOGVuY29kZSA9IGZ1bmN0aW9uIHV0ZjhlbmNvZGUoc3RyKSB7XG4gICAgaWYgKHN1cHBvcnQubm9kZWJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gbm9kZWpzVXRpbHMubmV3QnVmZmVyRnJvbShzdHIsIFwidXRmLThcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZzJidWYoc3RyKTtcbn07XG5cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBieXRlcyBhcnJheSAob3IgYSByZXByZXNlbnRhdGlvbikgcmVwcmVzZW50aW5nIGFuIFVURi04IGVuY29kZWRcbiAqIHN0cmluZyBpbnRvIGEgamF2YXNjcmlwdCBzdHJpbmcuXG4gKiBAcGFyYW0ge0FycmF5fFVpbnQ4QXJyYXl8QnVmZmVyfSBidWYgdGhlIGRhdGEgZGUgZGVjb2RlXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBkZWNvZGVkIHN0cmluZy5cbiAqL1xuZXhwb3J0cy51dGY4ZGVjb2RlID0gZnVuY3Rpb24gdXRmOGRlY29kZShidWYpIHtcbiAgICBpZiAoc3VwcG9ydC5ub2RlYnVmZmVyKSB7XG4gICAgICAgIHJldHVybiB1dGlscy50cmFuc2Zvcm1UbyhcIm5vZGVidWZmZXJcIiwgYnVmKS50b1N0cmluZyhcInV0Zi04XCIpO1xuICAgIH1cblxuICAgIGJ1ZiA9IHV0aWxzLnRyYW5zZm9ybVRvKHN1cHBvcnQudWludDhhcnJheSA/IFwidWludDhhcnJheVwiIDogXCJhcnJheVwiLCBidWYpO1xuXG4gICAgcmV0dXJuIGJ1ZjJzdHJpbmcoYnVmKTtcbn07XG5cbi8qKlxuICogQSB3b3JrZXIgdG8gZGVjb2RlIHV0ZjggZW5jb2RlZCBiaW5hcnkgY2h1bmtzIGludG8gc3RyaW5nIGNodW5rcy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBVdGY4RGVjb2RlV29ya2VyKCkge1xuICAgIEdlbmVyaWNXb3JrZXIuY2FsbCh0aGlzLCBcInV0Zi04IGRlY29kZVwiKTtcbiAgICAvLyB0aGUgbGFzdCBieXRlcyBpZiBhIGNodW5rIGRpZG4ndCBlbmQgd2l0aCBhIGNvbXBsZXRlIGNvZGVwb2ludC5cbiAgICB0aGlzLmxlZnRPdmVyID0gbnVsbDtcbn1cbnV0aWxzLmluaGVyaXRzKFV0ZjhEZWNvZGVXb3JrZXIsIEdlbmVyaWNXb3JrZXIpO1xuXG4vKipcbiAqIEBzZWUgR2VuZXJpY1dvcmtlci5wcm9jZXNzQ2h1bmtcbiAqL1xuVXRmOERlY29kZVdvcmtlci5wcm90b3R5cGUucHJvY2Vzc0NodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG5cbiAgICB2YXIgZGF0YSA9IHV0aWxzLnRyYW5zZm9ybVRvKHN1cHBvcnQudWludDhhcnJheSA/IFwidWludDhhcnJheVwiIDogXCJhcnJheVwiLCBjaHVuay5kYXRhKTtcblxuICAgIC8vIDFzdCBzdGVwLCByZS11c2Ugd2hhdCdzIGxlZnQgb2YgdGhlIHByZXZpb3VzIGNodW5rXG4gICAgaWYgKHRoaXMubGVmdE92ZXIgJiYgdGhpcy5sZWZ0T3Zlci5sZW5ndGgpIHtcbiAgICAgICAgaWYoc3VwcG9ydC51aW50OGFycmF5KSB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNEYXRhID0gZGF0YTtcbiAgICAgICAgICAgIGRhdGEgPSBuZXcgVWludDhBcnJheShwcmV2aW91c0RhdGEubGVuZ3RoICsgdGhpcy5sZWZ0T3Zlci5sZW5ndGgpO1xuICAgICAgICAgICAgZGF0YS5zZXQodGhpcy5sZWZ0T3ZlciwgMCk7XG4gICAgICAgICAgICBkYXRhLnNldChwcmV2aW91c0RhdGEsIHRoaXMubGVmdE92ZXIubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLmxlZnRPdmVyLmNvbmNhdChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlZnRPdmVyID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEJvdW5kYXJ5ID0gdXRmOGJvcmRlcihkYXRhKTtcbiAgICB2YXIgdXNhYmxlRGF0YSA9IGRhdGE7XG4gICAgaWYgKG5leHRCb3VuZGFyeSAhPT0gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHN1cHBvcnQudWludDhhcnJheSkge1xuICAgICAgICAgICAgdXNhYmxlRGF0YSA9IGRhdGEuc3ViYXJyYXkoMCwgbmV4dEJvdW5kYXJ5KTtcbiAgICAgICAgICAgIHRoaXMubGVmdE92ZXIgPSBkYXRhLnN1YmFycmF5KG5leHRCb3VuZGFyeSwgZGF0YS5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXNhYmxlRGF0YSA9IGRhdGEuc2xpY2UoMCwgbmV4dEJvdW5kYXJ5KTtcbiAgICAgICAgICAgIHRoaXMubGVmdE92ZXIgPSBkYXRhLnNsaWNlKG5leHRCb3VuZGFyeSwgZGF0YS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5wdXNoKHtcbiAgICAgICAgZGF0YSA6IGV4cG9ydHMudXRmOGRlY29kZSh1c2FibGVEYXRhKSxcbiAgICAgICAgbWV0YSA6IGNodW5rLm1ldGFcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLmZsdXNoXG4gKi9cblV0ZjhEZWNvZGVXb3JrZXIucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKHRoaXMubGVmdE92ZXIgJiYgdGhpcy5sZWZ0T3Zlci5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5wdXNoKHtcbiAgICAgICAgICAgIGRhdGEgOiBleHBvcnRzLnV0ZjhkZWNvZGUodGhpcy5sZWZ0T3ZlciksXG4gICAgICAgICAgICBtZXRhIDoge31cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubGVmdE92ZXIgPSBudWxsO1xuICAgIH1cbn07XG5leHBvcnRzLlV0ZjhEZWNvZGVXb3JrZXIgPSBVdGY4RGVjb2RlV29ya2VyO1xuXG4vKipcbiAqIEEgd29ya2VyIHRvIGVuZGNvZGUgc3RyaW5nIGNodW5rcyBpbnRvIHV0ZjggZW5jb2RlZCBiaW5hcnkgY2h1bmtzLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFV0ZjhFbmNvZGVXb3JrZXIoKSB7XG4gICAgR2VuZXJpY1dvcmtlci5jYWxsKHRoaXMsIFwidXRmLTggZW5jb2RlXCIpO1xufVxudXRpbHMuaW5oZXJpdHMoVXRmOEVuY29kZVdvcmtlciwgR2VuZXJpY1dvcmtlcik7XG5cbi8qKlxuICogQHNlZSBHZW5lcmljV29ya2VyLnByb2Nlc3NDaHVua1xuICovXG5VdGY4RW5jb2RlV29ya2VyLnByb3RvdHlwZS5wcm9jZXNzQ2h1bmsgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICB0aGlzLnB1c2goe1xuICAgICAgICBkYXRhIDogZXhwb3J0cy51dGY4ZW5jb2RlKGNodW5rLmRhdGEpLFxuICAgICAgICBtZXRhIDogY2h1bmsubWV0YVxuICAgIH0pO1xufTtcbmV4cG9ydHMuVXRmOEVuY29kZVdvcmtlciA9IFV0ZjhFbmNvZGVXb3JrZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzdXBwb3J0ID0gcmVxdWlyZSgnLi9zdXBwb3J0Jyk7XG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnLi9iYXNlNjQnKTtcbnZhciBub2RlanNVdGlscyA9IHJlcXVpcmUoJy4vbm9kZWpzVXRpbHMnKTtcbnZhciBzZXRJbW1lZGlhdGUgPSByZXF1aXJlKCdzZXQtaW1tZWRpYXRlLXNoaW0nKTtcbnZhciBleHRlcm5hbCA9IHJlcXVpcmUoXCIuL2V4dGVybmFsXCIpO1xuXG5cbi8qKlxuICogQ29udmVydCBhIHN0cmluZyB0aGF0IHBhc3MgYXMgYSBcImJpbmFyeSBzdHJpbmdcIjogaXQgc2hvdWxkIHJlcHJlc2VudCBhIGJ5dGVcbiAqIGFycmF5IGJ1dCBtYXkgaGF2ZSA+IDI1NSBjaGFyIGNvZGVzLiBCZSBzdXJlIHRvIHRha2Ugb25seSB0aGUgZmlyc3QgYnl0ZVxuICogYW5kIHJldHVybnMgdGhlIGJ5dGUgYXJyYXkuXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIHRoZSBzdHJpbmcgdG8gdHJhbnNmb3JtLlxuICogQHJldHVybiB7QXJyYXl8VWludDhBcnJheX0gdGhlIHN0cmluZyBpbiBhIGJpbmFyeSBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZzJiaW5hcnkoc3RyKSB7XG4gICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgaWYgKHN1cHBvcnQudWludDhhcnJheSkge1xuICAgICAgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoc3RyLmxlbmd0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IG5ldyBBcnJheShzdHIubGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cmluZ1RvQXJyYXlMaWtlKHN0ciwgcmVzdWx0KTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgYmxvYiB3aXRoIHRoZSBnaXZlbiBjb250ZW50IGFuZCB0aGUgZ2l2ZW4gdHlwZS5cbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5QnVmZmVyfSBwYXJ0IHRoZSBjb250ZW50IHRvIHB1dCBpbiB0aGUgYmxvYi4gRE8gTk9UIHVzZVxuICogYW4gVWludDhBcnJheSBiZWNhdXNlIHRoZSBzdG9jayBicm93c2VyIG9mIGFuZHJvaWQgNCB3b24ndCBhY2NlcHQgaXQgKGl0XG4gKiB3aWxsIGJlIHNpbGVudGx5IGNvbnZlcnRlZCB0byBhIHN0cmluZywgXCJbb2JqZWN0IFVpbnQ4QXJyYXldXCIpLlxuICpcbiAqIFVzZSBvbmx5IE9ORSBwYXJ0IHRvIGJ1aWxkIHRoZSBibG9iIHRvIGF2b2lkIGEgbWVtb3J5IGxlYWsgaW4gSUUxMSAvIEVkZ2U6XG4gKiB3aGVuIGEgbGFyZ2UgYW1vdW50IG9mIEFycmF5IGlzIHVzZWQgdG8gY3JlYXRlIHRoZSBCbG9iLCB0aGUgYW1vdW50IG9mXG4gKiBtZW1vcnkgY29uc3VtZWQgaXMgbmVhcmx5IDEwMCB0aW1lcyB0aGUgb3JpZ2luYWwgZGF0YSBhbW91bnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIG1pbWUgdHlwZSBvZiB0aGUgYmxvYi5cbiAqIEByZXR1cm4ge0Jsb2J9IHRoZSBjcmVhdGVkIGJsb2IuXG4gKi9cbmV4cG9ydHMubmV3QmxvYiA9IGZ1bmN0aW9uKHBhcnQsIHR5cGUpIHtcbiAgICBleHBvcnRzLmNoZWNrU3VwcG9ydChcImJsb2JcIik7XG5cbiAgICB0cnkge1xuICAgICAgICAvLyBCbG9iIGNvbnN0cnVjdG9yXG4gICAgICAgIHJldHVybiBuZXcgQmxvYihbcGFydF0sIHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIGRlcHJlY2F0ZWQsIGJyb3dzZXIgb25seSwgb2xkIHdheVxuICAgICAgICAgICAgdmFyIEJ1aWxkZXIgPSBzZWxmLkJsb2JCdWlsZGVyIHx8IHNlbGYuV2ViS2l0QmxvYkJ1aWxkZXIgfHwgc2VsZi5Nb3pCbG9iQnVpbGRlciB8fCBzZWxmLk1TQmxvYkJ1aWxkZXI7XG4gICAgICAgICAgICB2YXIgYnVpbGRlciA9IG5ldyBCdWlsZGVyKCk7XG4gICAgICAgICAgICBidWlsZGVyLmFwcGVuZChwYXJ0KTtcbiAgICAgICAgICAgIHJldHVybiBidWlsZGVyLmdldEJsb2IodHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcblxuICAgICAgICAgICAgLy8gd2VsbCwgZnVjayA/IVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQnVnIDogY2FuJ3QgY29uc3RydWN0IHRoZSBCbG9iLlwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59O1xuLyoqXG4gKiBUaGUgaWRlbnRpdHkgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXQgdGhlIGlucHV0LlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgc2FtZSBpbnB1dC5cbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQ7XG59XG5cbi8qKlxuICogRmlsbCBpbiBhbiBhcnJheSB3aXRoIGEgc3RyaW5nLlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciB0aGUgc3RyaW5nIHRvIHVzZS5cbiAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGFycmF5IHRoZSBhcnJheSB0byBmaWxsIGluICh3aWxsIGJlIG11dGF0ZWQpLlxuICogQHJldHVybiB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IHRoZSB1cGRhdGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBzdHJpbmdUb0FycmF5TGlrZShzdHIsIGFycmF5KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgYXJyYXlbaV0gPSBzdHIuY2hhckNvZGVBdChpKSAmIDB4RkY7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cblxuLyoqXG4gKiBBbiBoZWxwZXIgZm9yIHRoZSBmdW5jdGlvbiBhcnJheUxpa2VUb1N0cmluZy5cbiAqIFRoaXMgY29udGFpbnMgc3RhdGljIGluZm9ybWF0aW9uIGFuZCBmdW5jdGlvbnMgdGhhdFxuICogY2FuIGJlIG9wdGltaXplZCBieSB0aGUgYnJvd3NlciBKSVQgY29tcGlsZXIuXG4gKi9cbnZhciBhcnJheVRvU3RyaW5nSGVscGVyID0ge1xuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSBhbiBhcnJheSBvZiBpbnQgaW50byBhIHN0cmluZywgY2h1bmsgYnkgY2h1bmsuXG4gICAgICogU2VlIHRoZSBwZXJmb3JtYW5jZXMgbm90ZXMgb24gYXJyYXlMaWtlVG9TdHJpbmcuXG4gICAgICogQHBhcmFtIHtBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gYXJyYXkgdGhlIGFycmF5IHRvIHRyYW5zZm9ybS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgdHlwZSBvZiB0aGUgYXJyYXkuXG4gICAgICogQHBhcmFtIHtJbnRlZ2VyfSBjaHVuayB0aGUgY2h1bmsgc2l6ZS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSByZXN1bHRpbmcgc3RyaW5nLlxuICAgICAqIEB0aHJvd3MgRXJyb3IgaWYgdGhlIGNodW5rIGlzIHRvbyBiaWcgZm9yIHRoZSBzdGFjay5cbiAgICAgKi9cbiAgICBzdHJpbmdpZnlCeUNodW5rOiBmdW5jdGlvbihhcnJheSwgdHlwZSwgY2h1bmspIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdLCBrID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICAvLyBzaG9ydGN1dFxuICAgICAgICBpZiAobGVuIDw9IGNodW5rKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBhcnJheSk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGsgPCBsZW4pIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcImFycmF5XCIgfHwgdHlwZSA9PT0gXCJub2RlYnVmZmVyXCIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGFycmF5LnNsaWNlKGssIE1hdGgubWluKGsgKyBjaHVuaywgbGVuKSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYXJyYXkuc3ViYXJyYXkoaywgTWF0aC5taW4oayArIGNodW5rLCBsZW4pKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgayArPSBjaHVuaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oXCJcIik7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDYWxsIFN0cmluZy5mcm9tQ2hhckNvZGUgb24gZXZlcnkgaXRlbSBpbiB0aGUgYXJyYXkuXG4gICAgICogVGhpcyBpcyB0aGUgbmFpdmUgaW1wbGVtZW50YXRpb24sIHdoaWNoIGdlbmVyYXRlIEEgTE9UIG9mIGludGVybWVkaWF0ZSBzdHJpbmcuXG4gICAgICogVGhpcyBzaG91bGQgYmUgdXNlZCB3aGVuIGV2ZXJ5dGhpbmcgZWxzZSBmYWlsLlxuICAgICAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGFycmF5IHRoZSBhcnJheSB0byB0cmFuc2Zvcm0uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSB0aGUgcmVzdWx0LlxuICAgICAqL1xuICAgIHN0cmluZ2lmeUJ5Q2hhcjogZnVuY3Rpb24oYXJyYXkpe1xuICAgICAgICB2YXIgcmVzdWx0U3RyID0gXCJcIjtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHRTdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShhcnJheVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdFN0cjtcbiAgICB9LFxuICAgIGFwcGx5Q2FuQmVVc2VkIDoge1xuICAgICAgICAvKipcbiAgICAgICAgICogdHJ1ZSBpZiB0aGUgYnJvd3NlciBhY2NlcHRzIHRvIHVzZSBTdHJpbmcuZnJvbUNoYXJDb2RlIG9uIFVpbnQ4QXJyYXlcbiAgICAgICAgICovXG4gICAgICAgIHVpbnQ4YXJyYXkgOiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VwcG9ydC51aW50OGFycmF5ICYmIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkoMSkpLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0cnVlIGlmIHRoZSBicm93c2VyIGFjY2VwdHMgdG8gdXNlIFN0cmluZy5mcm9tQ2hhckNvZGUgb24gbm9kZWpzIEJ1ZmZlci5cbiAgICAgICAgICovXG4gICAgICAgIG5vZGVidWZmZXIgOiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3VwcG9ydC5ub2RlYnVmZmVyICYmIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbm9kZWpzVXRpbHMuYWxsb2NCdWZmZXIoMSkpLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKClcbiAgICB9XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSBhbiBhcnJheS1saWtlIG9iamVjdCB0byBhIHN0cmluZy5cbiAqIEBwYXJhbSB7QXJyYXl8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGFycmF5IHRoZSBhcnJheSB0byB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSByZXN1bHQuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZVRvU3RyaW5nKGFycmF5KSB7XG4gICAgLy8gUGVyZm9ybWFuY2VzIG5vdGVzIDpcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYXJyYXkpIGlzIHRoZSBmYXN0ZXN0LCBzZWVcbiAgICAvLyBzZWUgaHR0cDovL2pzcGVyZi5jb20vY29udmVydGluZy1hLXVpbnQ4YXJyYXktdG8tYS1zdHJpbmcvMlxuICAgIC8vIGJ1dCB0aGUgc3RhY2sgaXMgbGltaXRlZCAoYW5kIHdlIGNhbiBnZXQgaHVnZSBhcnJheXMgISkuXG4gICAgLy9cbiAgICAvLyByZXN1bHQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShhcnJheVtpXSk7IGdlbmVyYXRlIHRvbyBtYW55IHN0cmluZ3MgIVxuICAgIC8vXG4gICAgLy8gVGhpcyBjb2RlIGlzIGluc3BpcmVkIGJ5IGh0dHA6Ly9qc3BlcmYuY29tL2FycmF5YnVmZmVyLXRvLXN0cmluZy1hcHBseS1wZXJmb3JtYW5jZS8yXG4gICAgLy8gVE9ETyA6IHdlIG5vdyBoYXZlIHdvcmtlcnMgdGhhdCBzcGxpdCB0aGUgd29yay4gRG8gd2Ugc3RpbGwgbmVlZCB0aGF0ID9cbiAgICB2YXIgY2h1bmsgPSA2NTUzNixcbiAgICAgICAgdHlwZSA9IGV4cG9ydHMuZ2V0VHlwZU9mKGFycmF5KSxcbiAgICAgICAgY2FuVXNlQXBwbHkgPSB0cnVlO1xuICAgIGlmICh0eXBlID09PSBcInVpbnQ4YXJyYXlcIikge1xuICAgICAgICBjYW5Vc2VBcHBseSA9IGFycmF5VG9TdHJpbmdIZWxwZXIuYXBwbHlDYW5CZVVzZWQudWludDhhcnJheTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwibm9kZWJ1ZmZlclwiKSB7XG4gICAgICAgIGNhblVzZUFwcGx5ID0gYXJyYXlUb1N0cmluZ0hlbHBlci5hcHBseUNhbkJlVXNlZC5ub2RlYnVmZmVyO1xuICAgIH1cblxuICAgIGlmIChjYW5Vc2VBcHBseSkge1xuICAgICAgICB3aGlsZSAoY2h1bmsgPiAxKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheVRvU3RyaW5nSGVscGVyLnN0cmluZ2lmeUJ5Q2h1bmsoYXJyYXksIHR5cGUsIGNodW5rKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjaHVuayA9IE1hdGguZmxvb3IoY2h1bmsgLyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIG5vIGFwcGx5IG9yIGNodW5rIGVycm9yIDogc2xvdyBhbmQgcGFpbmZ1bCBhbGdvcml0aG1cbiAgICAvLyBkZWZhdWx0IGJyb3dzZXIgb24gYW5kcm9pZCA0LipcbiAgICByZXR1cm4gYXJyYXlUb1N0cmluZ0hlbHBlci5zdHJpbmdpZnlCeUNoYXIoYXJyYXkpO1xufVxuXG5leHBvcnRzLmFwcGx5RnJvbUNoYXJDb2RlID0gYXJyYXlMaWtlVG9TdHJpbmc7XG5cblxuLyoqXG4gKiBDb3B5IHRoZSBkYXRhIGZyb20gYW4gYXJyYXktbGlrZSB0byBhbiBvdGhlciBhcnJheS1saWtlLlxuICogQHBhcmFtIHtBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gYXJyYXlGcm9tIHRoZSBvcmlnaW4gYXJyYXkuXG4gKiBAcGFyYW0ge0FycmF5fEFycmF5QnVmZmVyfFVpbnQ4QXJyYXl8QnVmZmVyfSBhcnJheVRvIHRoZSBkZXN0aW5hdGlvbiBhcnJheSB3aGljaCB3aWxsIGJlIG11dGF0ZWQuXG4gKiBAcmV0dXJuIHtBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gdGhlIHVwZGF0ZWQgZGVzdGluYXRpb24gYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZVRvQXJyYXlMaWtlKGFycmF5RnJvbSwgYXJyYXlUbykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlGcm9tLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycmF5VG9baV0gPSBhcnJheUZyb21baV07XG4gICAgfVxuICAgIHJldHVybiBhcnJheVRvO1xufVxuXG4vLyBhIG1hdHJpeCBjb250YWluaW5nIGZ1bmN0aW9ucyB0byB0cmFuc2Zvcm0gZXZlcnl0aGluZyBpbnRvIGV2ZXJ5dGhpbmcuXG52YXIgdHJhbnNmb3JtID0ge307XG5cbi8vIHN0cmluZyB0byA/XG50cmFuc2Zvcm1bXCJzdHJpbmdcIl0gPSB7XG4gICAgXCJzdHJpbmdcIjogaWRlbnRpdHksXG4gICAgXCJhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nVG9BcnJheUxpa2UoaW5wdXQsIG5ldyBBcnJheShpbnB1dC5sZW5ndGgpKTtcbiAgICB9LFxuICAgIFwiYXJyYXlidWZmZXJcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVtcInN0cmluZ1wiXVtcInVpbnQ4YXJyYXlcIl0oaW5wdXQpLmJ1ZmZlcjtcbiAgICB9LFxuICAgIFwidWludDhhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nVG9BcnJheUxpa2UoaW5wdXQsIG5ldyBVaW50OEFycmF5KGlucHV0Lmxlbmd0aCkpO1xuICAgIH0sXG4gICAgXCJub2RlYnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdUb0FycmF5TGlrZShpbnB1dCwgbm9kZWpzVXRpbHMuYWxsb2NCdWZmZXIoaW5wdXQubGVuZ3RoKSk7XG4gICAgfVxufTtcblxuLy8gYXJyYXkgdG8gP1xudHJhbnNmb3JtW1wiYXJyYXlcIl0gPSB7XG4gICAgXCJzdHJpbmdcIjogYXJyYXlMaWtlVG9TdHJpbmcsXG4gICAgXCJhcnJheVwiOiBpZGVudGl0eSxcbiAgICBcImFycmF5YnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiAobmV3IFVpbnQ4QXJyYXkoaW5wdXQpKS5idWZmZXI7XG4gICAgfSxcbiAgICBcInVpbnQ4YXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGlucHV0KTtcbiAgICB9LFxuICAgIFwibm9kZWJ1ZmZlclwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gbm9kZWpzVXRpbHMubmV3QnVmZmVyRnJvbShpbnB1dCk7XG4gICAgfVxufTtcblxuLy8gYXJyYXlidWZmZXIgdG8gP1xudHJhbnNmb3JtW1wiYXJyYXlidWZmZXJcIl0gPSB7XG4gICAgXCJzdHJpbmdcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TGlrZVRvU3RyaW5nKG5ldyBVaW50OEFycmF5KGlucHV0KSk7XG4gICAgfSxcbiAgICBcImFycmF5XCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBhcnJheUxpa2VUb0FycmF5TGlrZShuZXcgVWludDhBcnJheShpbnB1dCksIG5ldyBBcnJheShpbnB1dC5ieXRlTGVuZ3RoKSk7XG4gICAgfSxcbiAgICBcImFycmF5YnVmZmVyXCI6IGlkZW50aXR5LFxuICAgIFwidWludDhhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaW5wdXQpO1xuICAgIH0sXG4gICAgXCJub2RlYnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBub2RlanNVdGlscy5uZXdCdWZmZXJGcm9tKG5ldyBVaW50OEFycmF5KGlucHV0KSk7XG4gICAgfVxufTtcblxuLy8gdWludDhhcnJheSB0byA/XG50cmFuc2Zvcm1bXCJ1aW50OGFycmF5XCJdID0ge1xuICAgIFwic3RyaW5nXCI6IGFycmF5TGlrZVRvU3RyaW5nLFxuICAgIFwiYXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXlMaWtlKGlucHV0LCBuZXcgQXJyYXkoaW5wdXQubGVuZ3RoKSk7XG4gICAgfSxcbiAgICBcImFycmF5YnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dC5idWZmZXI7XG4gICAgfSxcbiAgICBcInVpbnQ4YXJyYXlcIjogaWRlbnRpdHksXG4gICAgXCJub2RlYnVmZmVyXCI6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBub2RlanNVdGlscy5uZXdCdWZmZXJGcm9tKGlucHV0KTtcbiAgICB9XG59O1xuXG4vLyBub2RlYnVmZmVyIHRvID9cbnRyYW5zZm9ybVtcIm5vZGVidWZmZXJcIl0gPSB7XG4gICAgXCJzdHJpbmdcIjogYXJyYXlMaWtlVG9TdHJpbmcsXG4gICAgXCJhcnJheVwiOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gYXJyYXlMaWtlVG9BcnJheUxpa2UoaW5wdXQsIG5ldyBBcnJheShpbnB1dC5sZW5ndGgpKTtcbiAgICB9LFxuICAgIFwiYXJyYXlidWZmZXJcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVtcIm5vZGVidWZmZXJcIl1bXCJ1aW50OGFycmF5XCJdKGlucHV0KS5idWZmZXI7XG4gICAgfSxcbiAgICBcInVpbnQ4YXJyYXlcIjogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXlMaWtlKGlucHV0LCBuZXcgVWludDhBcnJheShpbnB1dC5sZW5ndGgpKTtcbiAgICB9LFxuICAgIFwibm9kZWJ1ZmZlclwiOiBpZGVudGl0eVxufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYW4gaW5wdXQgaW50byBhbnkgdHlwZS5cbiAqIFRoZSBzdXBwb3J0ZWQgb3V0cHV0IHR5cGUgYXJlIDogc3RyaW5nLCBhcnJheSwgdWludDhhcnJheSwgYXJyYXlidWZmZXIsIG5vZGVidWZmZXIuXG4gKiBJZiBubyBvdXRwdXQgdHlwZSBpcyBzcGVjaWZpZWQsIHRoZSB1bm1vZGlmaWVkIGlucHV0IHdpbGwgYmUgcmV0dXJuZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gb3V0cHV0VHlwZSB0aGUgb3V0cHV0IHR5cGUuXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheXxBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gaW5wdXQgdGhlIGlucHV0IHRvIGNvbnZlcnQuXG4gKiBAdGhyb3dzIHtFcnJvcn0gYW4gRXJyb3IgaWYgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHRoZSByZXF1ZXN0ZWQgb3V0cHV0IHR5cGUuXG4gKi9cbmV4cG9ydHMudHJhbnNmb3JtVG8gPSBmdW5jdGlvbihvdXRwdXRUeXBlLCBpbnB1dCkge1xuICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgLy8gdW5kZWZpbmVkLCBudWxsLCBldGNcbiAgICAgICAgLy8gYW4gZW1wdHkgc3RyaW5nIHdvbid0IGhhcm0uXG4gICAgICAgIGlucHV0ID0gXCJcIjtcbiAgICB9XG4gICAgaWYgKCFvdXRwdXRUeXBlKSB7XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgZXhwb3J0cy5jaGVja1N1cHBvcnQob3V0cHV0VHlwZSk7XG4gICAgdmFyIGlucHV0VHlwZSA9IGV4cG9ydHMuZ2V0VHlwZU9mKGlucHV0KTtcbiAgICB2YXIgcmVzdWx0ID0gdHJhbnNmb3JtW2lucHV0VHlwZV1bb3V0cHV0VHlwZV0oaW5wdXQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgdHlwZSBvZiB0aGUgaW5wdXQuXG4gKiBUaGUgdHlwZSB3aWxsIGJlIGluIGEgZm9ybWF0IHZhbGlkIGZvciBKU1ppcC51dGlscy50cmFuc2Zvcm1UbyA6IHN0cmluZywgYXJyYXksIHVpbnQ4YXJyYXksIGFycmF5YnVmZmVyLlxuICogQHBhcmFtIHtPYmplY3R9IGlucHV0IHRoZSBpbnB1dCB0byBpZGVudGlmeS5cbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIChsb3dlcmNhc2UpIHR5cGUgb2YgdGhlIGlucHV0LlxuICovXG5leHBvcnRzLmdldFR5cGVPZiA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09IFwiW29iamVjdCBBcnJheV1cIikge1xuICAgICAgICByZXR1cm4gXCJhcnJheVwiO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydC5ub2RlYnVmZmVyICYmIG5vZGVqc1V0aWxzLmlzQnVmZmVyKGlucHV0KSkge1xuICAgICAgICByZXR1cm4gXCJub2RlYnVmZmVyXCI7XG4gICAgfVxuICAgIGlmIChzdXBwb3J0LnVpbnQ4YXJyYXkgJiYgaW5wdXQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIHJldHVybiBcInVpbnQ4YXJyYXlcIjtcbiAgICB9XG4gICAgaWYgKHN1cHBvcnQuYXJyYXlidWZmZXIgJiYgaW5wdXQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gXCJhcnJheWJ1ZmZlclwiO1xuICAgIH1cbn07XG5cbi8qKlxuICogVGhyb3cgYW4gZXhjZXB0aW9uIGlmIHRoZSB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgdHlwZSB0byBjaGVjay5cbiAqIEB0aHJvd3Mge0Vycm9yfSBhbiBFcnJvciBpZiB0aGUgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgdGhlIHJlcXVlc3RlZCB0eXBlLlxuICovXG5leHBvcnRzLmNoZWNrU3VwcG9ydCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICB2YXIgc3VwcG9ydGVkID0gc3VwcG9ydFt0eXBlLnRvTG93ZXJDYXNlKCldO1xuICAgIGlmICghc3VwcG9ydGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih0eXBlICsgXCIgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIHBsYXRmb3JtXCIpO1xuICAgIH1cbn07XG5cbmV4cG9ydHMuTUFYX1ZBTFVFXzE2QklUUyA9IDY1NTM1O1xuZXhwb3J0cy5NQVhfVkFMVUVfMzJCSVRTID0gLTE7IC8vIHdlbGwsIFwiXFx4RkZcXHhGRlxceEZGXFx4RkZcXHhGRlxceEZGXFx4RkZcXHhGRlwiIGlzIHBhcnNlZCBhcyAtMVxuXG4vKipcbiAqIFByZXR0aWZ5IGEgc3RyaW5nIHJlYWQgYXMgYmluYXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciB0aGUgc3RyaW5nIHRvIHByZXR0aWZ5LlxuICogQHJldHVybiB7c3RyaW5nfSBhIHByZXR0eSBzdHJpbmcuXG4gKi9cbmV4cG9ydHMucHJldHR5ID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgdmFyIHJlcyA9ICcnLFxuICAgICAgICBjb2RlLCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCAoc3RyIHx8IFwiXCIpLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgcmVzICs9ICdcXFxceCcgKyAoY29kZSA8IDE2ID8gXCIwXCIgOiBcIlwiKSArIGNvZGUudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59O1xuXG4vKipcbiAqIERlZmVyIHRoZSBjYWxsIG9mIGEgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB0aGUgZnVuY3Rpb24gdG8gY2FsbCBhc3luY2hyb25vdXNseS5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgdGhlIGFyZ3VtZW50cyB0byBnaXZlIHRvIHRoZSBjYWxsYmFjay5cbiAqL1xuZXhwb3J0cy5kZWxheSA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBhcmdzLCBzZWxmKSB7XG4gICAgc2V0SW1tZWRpYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FsbGJhY2suYXBwbHkoc2VsZiB8fCBudWxsLCBhcmdzIHx8IFtdKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogRXh0ZW5kcyBhIHByb3RvdHlwZSB3aXRoIGFuIG90aGVyLCB3aXRob3V0IGNhbGxpbmcgYSBjb25zdHJ1Y3RvciB3aXRoXG4gKiBzaWRlIGVmZmVjdHMuIEluc3BpcmVkIGJ5IG5vZGVqcycgYHV0aWxzLmluaGVyaXRzYFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3RvciB0aGUgY29uc3RydWN0b3IgdG8gYXVnbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3VwZXJDdG9yIHRoZSBwYXJlbnQgY29uc3RydWN0b3IgdG8gdXNlXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSBmdW5jdGlvbiAoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgdmFyIE9iaiA9IGZ1bmN0aW9uKCkge307XG4gICAgT2JqLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGU7XG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgT2JqKCk7XG59O1xuXG4vKipcbiAqIE1lcmdlIHRoZSBvYmplY3RzIHBhc3NlZCBhcyBwYXJhbWV0ZXJzIGludG8gYSBuZXcgb25lLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSB2YXJfYXJncyBBbGwgb2JqZWN0cyB0byBtZXJnZS5cbiAqIEByZXR1cm4ge09iamVjdH0gYSBuZXcgb2JqZWN0IHdpdGggdGhlIGRhdGEgb2YgdGhlIG90aGVycy5cbiAqL1xuZXhwb3J0cy5leHRlbmQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzdWx0ID0ge30sIGksIGF0dHI7XG4gICAgZm9yIChpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyAvLyBhcmd1bWVudHMgaXMgbm90IGVudW1lcmFibGUgaW4gc29tZSBicm93c2Vyc1xuICAgICAgICBmb3IgKGF0dHIgaW4gYXJndW1lbnRzW2ldKSB7XG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldLmhhc093blByb3BlcnR5KGF0dHIpICYmIHR5cGVvZiByZXN1bHRbYXR0cl0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbYXR0cl0gPSBhcmd1bWVudHNbaV1bYXR0cl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtIGFyYml0cmFyeSBjb250ZW50IGludG8gYSBQcm9taXNlLlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgYSBuYW1lIGZvciB0aGUgY29udGVudCBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhIHRoZSBjb250ZW50IHRvIHByb2Nlc3MuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzQmluYXJ5IHRydWUgaWYgdGhlIGNvbnRlbnQgaXMgbm90IGFuIHVuaWNvZGUgc3RyaW5nXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzT3B0aW1pemVkQmluYXJ5U3RyaW5nIHRydWUgaWYgdGhlIHN0cmluZyBjb250ZW50IG9ubHkgaGFzIG9uZSBieXRlIHBlciBjaGFyYWN0ZXIuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzQmFzZTY0IHRydWUgaWYgdGhlIHN0cmluZyBjb250ZW50IGlzIGVuY29kZWQgd2l0aCBiYXNlNjQuXG4gKiBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgaW4gYSBmb3JtYXQgdXNhYmxlIGJ5IEpTWmlwLlxuICovXG5leHBvcnRzLnByZXBhcmVDb250ZW50ID0gZnVuY3Rpb24obmFtZSwgaW5wdXREYXRhLCBpc0JpbmFyeSwgaXNPcHRpbWl6ZWRCaW5hcnlTdHJpbmcsIGlzQmFzZTY0KSB7XG5cbiAgICAvLyBpZiBpbnB1dERhdGEgaXMgYWxyZWFkeSBhIHByb21pc2UsIHRoaXMgZmxhdHRlbiBpdC5cbiAgICB2YXIgcHJvbWlzZSA9IGV4dGVybmFsLlByb21pc2UucmVzb2x2ZShpbnB1dERhdGEpLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIHZhciBpc0Jsb2IgPSBzdXBwb3J0LmJsb2IgJiYgKGRhdGEgaW5zdGFuY2VvZiBCbG9iIHx8IFsnW29iamVjdCBGaWxlXScsICdbb2JqZWN0IEJsb2JdJ10uaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZGF0YSkpICE9PSAtMSk7XG5cbiAgICAgICAgaWYgKGlzQmxvYiAmJiB0eXBlb2YgRmlsZVJlYWRlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBleHRlcm5hbC5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblxuICAgICAgICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZS50YXJnZXQucmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZS50YXJnZXQuZXJyb3IpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBkYXRhVHlwZSA9IGV4cG9ydHMuZ2V0VHlwZU9mKGRhdGEpO1xuXG4gICAgICAgIGlmICghZGF0YVR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBleHRlcm5hbC5Qcm9taXNlLnJlamVjdChcbiAgICAgICAgICAgICAgICBuZXcgRXJyb3IoXCJDYW4ndCByZWFkIHRoZSBkYXRhIG9mICdcIiArIG5hbWUgKyBcIicuIElzIGl0IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJpbiBhIHN1cHBvcnRlZCBKYXZhU2NyaXB0IHR5cGUgKFN0cmluZywgQmxvYiwgQXJyYXlCdWZmZXIsIGV0YykgP1wiKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzcGVjaWFsIGNhc2UgOiBpdCdzIHdheSBlYXNpZXIgdG8gd29yayB3aXRoIFVpbnQ4QXJyYXkgdGhhbiB3aXRoIEFycmF5QnVmZmVyXG4gICAgICAgIGlmIChkYXRhVHlwZSA9PT0gXCJhcnJheWJ1ZmZlclwiKSB7XG4gICAgICAgICAgICBkYXRhID0gZXhwb3J0cy50cmFuc2Zvcm1UbyhcInVpbnQ4YXJyYXlcIiwgZGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YVR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmIChpc0Jhc2U2NCkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBiYXNlNjQuZGVjb2RlKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNCaW5hcnkpIHtcbiAgICAgICAgICAgICAgICAvLyBvcHRpbWl6ZWRCaW5hcnlTdHJpbmcgPT09IHRydWUgbWVhbnMgdGhhdCB0aGUgZmlsZSBoYXMgYWxyZWFkeSBiZWVuIGZpbHRlcmVkIHdpdGggYSAweEZGIG1hc2tcbiAgICAgICAgICAgICAgICBpZiAoaXNPcHRpbWl6ZWRCaW5hcnlTdHJpbmcgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhIHN0cmluZywgbm90IGluIGEgYmFzZTY0IGZvcm1hdC5cbiAgICAgICAgICAgICAgICAgICAgLy8gQmUgc3VyZSB0aGF0IHRoaXMgaXMgYSBjb3JyZWN0IFwiYmluYXJ5IHN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBzdHJpbmcyYmluYXJ5KGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgcmVhZGVyRm9yID0gcmVxdWlyZSgnLi9yZWFkZXIvcmVhZGVyRm9yJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgc2lnID0gcmVxdWlyZSgnLi9zaWduYXR1cmUnKTtcbnZhciBaaXBFbnRyeSA9IHJlcXVpcmUoJy4vemlwRW50cnknKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgnLi91dGY4Jyk7XG52YXIgc3VwcG9ydCA9IHJlcXVpcmUoJy4vc3VwcG9ydCcpO1xuLy8gIGNsYXNzIFppcEVudHJpZXMge3t7XG4vKipcbiAqIEFsbCB0aGUgZW50cmllcyBpbiB0aGUgemlwIGZpbGUuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBsb2FkT3B0aW9ucyBPcHRpb25zIGZvciBsb2FkaW5nIHRoZSBzdHJlYW0uXG4gKi9cbmZ1bmN0aW9uIFppcEVudHJpZXMobG9hZE9wdGlvbnMpIHtcbiAgICB0aGlzLmZpbGVzID0gW107XG4gICAgdGhpcy5sb2FkT3B0aW9ucyA9IGxvYWRPcHRpb25zO1xufVxuWmlwRW50cmllcy5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhhdCB0aGUgcmVhZGVyIGlzIG9uIHRoZSBzcGVjaWZpZWQgc2lnbmF0dXJlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHBlY3RlZFNpZ25hdHVyZSB0aGUgZXhwZWN0ZWQgc2lnbmF0dXJlLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBpZiBpdCBpcyBhbiBvdGhlciBzaWduYXR1cmUuXG4gICAgICovXG4gICAgY2hlY2tTaWduYXR1cmU6IGZ1bmN0aW9uKGV4cGVjdGVkU2lnbmF0dXJlKSB7XG4gICAgICAgIGlmICghdGhpcy5yZWFkZXIucmVhZEFuZENoZWNrU2lnbmF0dXJlKGV4cGVjdGVkU2lnbmF0dXJlKSkge1xuICAgICAgICAgICAgdGhpcy5yZWFkZXIuaW5kZXggLT0gNDtcbiAgICAgICAgICAgIHZhciBzaWduYXR1cmUgPSB0aGlzLnJlYWRlci5yZWFkU3RyaW5nKDQpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcCBvciBidWc6IHVuZXhwZWN0ZWQgc2lnbmF0dXJlIFwiICsgXCIoXCIgKyB1dGlscy5wcmV0dHkoc2lnbmF0dXJlKSArIFwiLCBleHBlY3RlZCBcIiArIHV0aWxzLnByZXR0eShleHBlY3RlZFNpZ25hdHVyZSkgKyBcIilcIik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBnaXZlbiBzaWduYXR1cmUgaXMgYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhc2tlZEluZGV4IHRoZSBpbmRleCB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwZWN0ZWRTaWduYXR1cmUgdGhlIHNpZ25hdHVyZSB0byBleHBlY3QuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgc2lnbmF0dXJlIGlzIGhlcmUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBpc1NpZ25hdHVyZTogZnVuY3Rpb24oYXNrZWRJbmRleCwgZXhwZWN0ZWRTaWduYXR1cmUpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IHRoaXMucmVhZGVyLmluZGV4O1xuICAgICAgICB0aGlzLnJlYWRlci5zZXRJbmRleChhc2tlZEluZGV4KTtcbiAgICAgICAgdmFyIHNpZ25hdHVyZSA9IHRoaXMucmVhZGVyLnJlYWRTdHJpbmcoNCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBzaWduYXR1cmUgPT09IGV4cGVjdGVkU2lnbmF0dXJlO1xuICAgICAgICB0aGlzLnJlYWRlci5zZXRJbmRleChjdXJyZW50SW5kZXgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgZW5kIG9mIHRoZSBjZW50cmFsIGRpcmVjdG9yeS5cbiAgICAgKi9cbiAgICByZWFkQmxvY2tFbmRPZkNlbnRyYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRpc2tOdW1iZXIgPSB0aGlzLnJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmRpc2tXaXRoQ2VudHJhbERpclN0YXJ0ID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5jZW50cmFsRGlyUmVjb3Jkc09uVGhpc0Rpc2sgPSB0aGlzLnJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmNlbnRyYWxEaXJSZWNvcmRzID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5jZW50cmFsRGlyU2l6ZSA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHRoaXMuY2VudHJhbERpck9mZnNldCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG5cbiAgICAgICAgdGhpcy56aXBDb21tZW50TGVuZ3RoID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgLy8gd2FybmluZyA6IHRoZSBlbmNvZGluZyBkZXBlbmRzIG9mIHRoZSBzeXN0ZW0gbG9jYWxlXG4gICAgICAgIC8vIE9uIGEgbGludXggbWFjaGluZSB3aXRoIExBTkc9ZW5fVVMudXRmOCwgdGhpcyBmaWVsZCBpcyB1dGY4IGVuY29kZWQuXG4gICAgICAgIC8vIE9uIGEgd2luZG93cyBtYWNoaW5lLCB0aGlzIGZpZWxkIGlzIGVuY29kZWQgd2l0aCB0aGUgbG9jYWxpemVkIHdpbmRvd3MgY29kZSBwYWdlLlxuICAgICAgICB2YXIgemlwQ29tbWVudCA9IHRoaXMucmVhZGVyLnJlYWREYXRhKHRoaXMuemlwQ29tbWVudExlbmd0aCk7XG4gICAgICAgIHZhciBkZWNvZGVQYXJhbVR5cGUgPSBzdXBwb3J0LnVpbnQ4YXJyYXkgPyBcInVpbnQ4YXJyYXlcIiA6IFwiYXJyYXlcIjtcbiAgICAgICAgLy8gVG8gZ2V0IGNvbnNpc3RlbnQgYmVoYXZpb3Igd2l0aCB0aGUgZ2VuZXJhdGlvbiBwYXJ0LCB3ZSB3aWxsIGFzc3VtZSB0aGF0XG4gICAgICAgIC8vIHRoaXMgaXMgdXRmOCBlbmNvZGVkIHVubGVzcyBzcGVjaWZpZWQgb3RoZXJ3aXNlLlxuICAgICAgICB2YXIgZGVjb2RlQ29udGVudCA9IHV0aWxzLnRyYW5zZm9ybVRvKGRlY29kZVBhcmFtVHlwZSwgemlwQ29tbWVudCk7XG4gICAgICAgIHRoaXMuemlwQ29tbWVudCA9IHRoaXMubG9hZE9wdGlvbnMuZGVjb2RlRmlsZU5hbWUoZGVjb2RlQ29udGVudCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBlbmQgb2YgdGhlIFppcCA2NCBjZW50cmFsIGRpcmVjdG9yeS5cbiAgICAgKiBOb3QgbWVyZ2VkIHdpdGggdGhlIG1ldGhvZCByZWFkRW5kT2ZDZW50cmFsIDpcbiAgICAgKiBUaGUgZW5kIG9mIGNlbnRyYWwgY2FuIGNvZXhpc3Qgd2l0aCBpdHMgWmlwNjQgYnJvdGhlcixcbiAgICAgKiBJIGRvbid0IHdhbnQgdG8gcmVhZCB0aGUgd3JvbmcgbnVtYmVyIG9mIGJ5dGVzICFcbiAgICAgKi9cbiAgICByZWFkQmxvY2taaXA2NEVuZE9mQ2VudHJhbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuemlwNjRFbmRPZkNlbnRyYWxTaXplID0gdGhpcy5yZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgdGhpcy5yZWFkZXIuc2tpcCg0KTtcbiAgICAgICAgLy8gdGhpcy52ZXJzaW9uTWFkZUJ5ID0gdGhpcy5yZWFkZXIucmVhZFN0cmluZygyKTtcbiAgICAgICAgLy8gdGhpcy52ZXJzaW9uTmVlZGVkID0gdGhpcy5yZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5kaXNrTnVtYmVyID0gdGhpcy5yZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgdGhpcy5kaXNrV2l0aENlbnRyYWxEaXJTdGFydCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHRoaXMuY2VudHJhbERpclJlY29yZHNPblRoaXNEaXNrID0gdGhpcy5yZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgdGhpcy5jZW50cmFsRGlyUmVjb3JkcyA9IHRoaXMucmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIHRoaXMuY2VudHJhbERpclNpemUgPSB0aGlzLnJlYWRlci5yZWFkSW50KDgpO1xuICAgICAgICB0aGlzLmNlbnRyYWxEaXJPZmZzZXQgPSB0aGlzLnJlYWRlci5yZWFkSW50KDgpO1xuXG4gICAgICAgIHRoaXMuemlwNjRFeHRlbnNpYmxlRGF0YSA9IHt9O1xuICAgICAgICB2YXIgZXh0cmFEYXRhU2l6ZSA9IHRoaXMuemlwNjRFbmRPZkNlbnRyYWxTaXplIC0gNDQsXG4gICAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgICBleHRyYUZpZWxkSWQsXG4gICAgICAgICAgICBleHRyYUZpZWxkTGVuZ3RoLFxuICAgICAgICAgICAgZXh0cmFGaWVsZFZhbHVlO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBleHRyYURhdGFTaXplKSB7XG4gICAgICAgICAgICBleHRyYUZpZWxkSWQgPSB0aGlzLnJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICAgICAgZXh0cmFGaWVsZExlbmd0aCA9IHRoaXMucmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgICAgICBleHRyYUZpZWxkVmFsdWUgPSB0aGlzLnJlYWRlci5yZWFkRGF0YShleHRyYUZpZWxkTGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMuemlwNjRFeHRlbnNpYmxlRGF0YVtleHRyYUZpZWxkSWRdID0ge1xuICAgICAgICAgICAgICAgIGlkOiBleHRyYUZpZWxkSWQsXG4gICAgICAgICAgICAgICAgbGVuZ3RoOiBleHRyYUZpZWxkTGVuZ3RoLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBleHRyYUZpZWxkVmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGVuZCBvZiB0aGUgWmlwIDY0IGNlbnRyYWwgZGlyZWN0b3J5IGxvY2F0b3IuXG4gICAgICovXG4gICAgcmVhZEJsb2NrWmlwNjRFbmRPZkNlbnRyYWxMb2NhdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kaXNrV2l0aFppcDY0Q2VudHJhbERpclN0YXJ0ID0gdGhpcy5yZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgdGhpcy5yZWxhdGl2ZU9mZnNldEVuZE9mWmlwNjRDZW50cmFsRGlyID0gdGhpcy5yZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgdGhpcy5kaXNrc0NvdW50ID0gdGhpcy5yZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgaWYgKHRoaXMuZGlza3NDb3VudCA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11bHRpLXZvbHVtZXMgemlwIGFyZSBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBsb2NhbCBmaWxlcywgYmFzZWQgb24gdGhlIG9mZnNldCByZWFkIGluIHRoZSBjZW50cmFsIHBhcnQuXG4gICAgICovXG4gICAgcmVhZExvY2FsRmlsZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaSwgZmlsZTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZpbGUgPSB0aGlzLmZpbGVzW2ldO1xuICAgICAgICAgICAgdGhpcy5yZWFkZXIuc2V0SW5kZXgoZmlsZS5sb2NhbEhlYWRlck9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLmNoZWNrU2lnbmF0dXJlKHNpZy5MT0NBTF9GSUxFX0hFQURFUik7XG4gICAgICAgICAgICBmaWxlLnJlYWRMb2NhbFBhcnQodGhpcy5yZWFkZXIpO1xuICAgICAgICAgICAgZmlsZS5oYW5kbGVVVEY4KCk7XG4gICAgICAgICAgICBmaWxlLnByb2Nlc3NBdHRyaWJ1dGVzKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGNlbnRyYWwgZGlyZWN0b3J5LlxuICAgICAqL1xuICAgIHJlYWRDZW50cmFsRGlyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGZpbGU7XG5cbiAgICAgICAgdGhpcy5yZWFkZXIuc2V0SW5kZXgodGhpcy5jZW50cmFsRGlyT2Zmc2V0KTtcbiAgICAgICAgd2hpbGUgKHRoaXMucmVhZGVyLnJlYWRBbmRDaGVja1NpZ25hdHVyZShzaWcuQ0VOVFJBTF9GSUxFX0hFQURFUikpIHtcbiAgICAgICAgICAgIGZpbGUgPSBuZXcgWmlwRW50cnkoe1xuICAgICAgICAgICAgICAgIHppcDY0OiB0aGlzLnppcDY0XG4gICAgICAgICAgICB9LCB0aGlzLmxvYWRPcHRpb25zKTtcbiAgICAgICAgICAgIGZpbGUucmVhZENlbnRyYWxQYXJ0KHRoaXMucmVhZGVyKTtcbiAgICAgICAgICAgIHRoaXMuZmlsZXMucHVzaChmaWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmNlbnRyYWxEaXJSZWNvcmRzICE9PSB0aGlzLmZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2VudHJhbERpclJlY29yZHMgIT09IDAgJiYgdGhpcy5maWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBleHBlY3RlZCBzb21lIHJlY29yZHMgYnV0IGNvdWxkbid0IGZpbmQgQU5ZLlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgcmVhbGx5IHN1c3BpY2lvdXMsIGFzIGlmIHNvbWV0aGluZyB3ZW50IHdyb25nLlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXAgb3IgYnVnOiBleHBlY3RlZCBcIiArIHRoaXMuY2VudHJhbERpclJlY29yZHMgKyBcIiByZWNvcmRzIGluIGNlbnRyYWwgZGlyLCBnb3QgXCIgKyB0aGlzLmZpbGVzLmxlbmd0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdlIGZvdW5kIHNvbWUgcmVjb3JkcyBidXQgbm90IGFsbC5cbiAgICAgICAgICAgICAgICAvLyBTb21ldGhpbmcgaXMgd3JvbmcgYnV0IHdlIGdvdCBzb21ldGhpbmcgZm9yIHRoZSB1c2VyOiBubyBlcnJvciBoZXJlLlxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybihcImV4cGVjdGVkXCIsIHRoaXMuY2VudHJhbERpclJlY29yZHMsIFwicmVjb3JkcyBpbiBjZW50cmFsIGRpciwgZ290XCIsIHRoaXMuZmlsZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5LlxuICAgICAqL1xuICAgIHJlYWRFbmRPZkNlbnRyYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5yZWFkZXIubGFzdEluZGV4T2ZTaWduYXR1cmUoc2lnLkNFTlRSQUxfRElSRUNUT1JZX0VORCk7XG4gICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgY29udGVudCBpcyBhIHRydW5jYXRlZCB6aXAgb3IgY29tcGxldGUgZ2FyYmFnZS5cbiAgICAgICAgICAgIC8vIEEgXCJMT0NBTF9GSUxFX0hFQURFUlwiIGlzIG5vdCByZXF1aXJlZCBhdCB0aGUgYmVnaW5uaW5nIChhdXRvXG4gICAgICAgICAgICAvLyBleHRyYWN0aWJsZSB6aXAgZm9yIGV4YW1wbGUpIGJ1dCBpdCBjYW4gZ2l2ZSBhIGdvb2QgaGludC5cbiAgICAgICAgICAgIC8vIElmIGFuIGFqYXggcmVxdWVzdCB3YXMgdXNlZCB3aXRob3V0IHJlc3BvbnNlVHlwZSwgd2Ugd2lsbCBhbHNvXG4gICAgICAgICAgICAvLyBnZXQgdW5yZWFkYWJsZSBkYXRhLlxuICAgICAgICAgICAgdmFyIGlzR2FyYmFnZSA9ICF0aGlzLmlzU2lnbmF0dXJlKDAsIHNpZy5MT0NBTF9GSUxFX0hFQURFUik7XG5cbiAgICAgICAgICAgIGlmIChpc0dhcmJhZ2UpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBmaW5kIGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSA6IGlzIHRoaXMgYSB6aXAgZmlsZSA/IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJJZiBpdCBpcywgc2VlIGh0dHBzOi8vc3R1ay5naXRodWIuaW8vanN6aXAvZG9jdW1lbnRhdGlvbi9ob3d0by9yZWFkX3ppcC5odG1sXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwOiBjYW4ndCBmaW5kIGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeVwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVhZGVyLnNldEluZGV4KG9mZnNldCk7XG4gICAgICAgIHZhciBlbmRPZkNlbnRyYWxEaXJPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMuY2hlY2tTaWduYXR1cmUoc2lnLkNFTlRSQUxfRElSRUNUT1JZX0VORCk7XG4gICAgICAgIHRoaXMucmVhZEJsb2NrRW5kT2ZDZW50cmFsKCk7XG5cblxuICAgICAgICAvKiBleHRyYWN0IGZyb20gdGhlIHppcCBzcGVjIDpcbiAgICAgICAgICAgIDQpICBJZiBvbmUgb2YgdGhlIGZpZWxkcyBpbiB0aGUgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5XG4gICAgICAgICAgICAgICAgcmVjb3JkIGlzIHRvbyBzbWFsbCB0byBob2xkIHJlcXVpcmVkIGRhdGEsIHRoZSBmaWVsZFxuICAgICAgICAgICAgICAgIHNob3VsZCBiZSBzZXQgdG8gLTEgKDB4RkZGRiBvciAweEZGRkZGRkZGKSBhbmQgdGhlXG4gICAgICAgICAgICAgICAgWklQNjQgZm9ybWF0IHJlY29yZCBzaG91bGQgYmUgY3JlYXRlZC5cbiAgICAgICAgICAgIDUpICBUaGUgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5IHJlY29yZCBhbmQgdGhlXG4gICAgICAgICAgICAgICAgWmlwNjQgZW5kIG9mIGNlbnRyYWwgZGlyZWN0b3J5IGxvY2F0b3IgcmVjb3JkIG11c3RcbiAgICAgICAgICAgICAgICByZXNpZGUgb24gdGhlIHNhbWUgZGlzayB3aGVuIHNwbGl0dGluZyBvciBzcGFubmluZ1xuICAgICAgICAgICAgICAgIGFuIGFyY2hpdmUuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5kaXNrTnVtYmVyID09PSB1dGlscy5NQVhfVkFMVUVfMTZCSVRTIHx8IHRoaXMuZGlza1dpdGhDZW50cmFsRGlyU3RhcnQgPT09IHV0aWxzLk1BWF9WQUxVRV8xNkJJVFMgfHwgdGhpcy5jZW50cmFsRGlyUmVjb3Jkc09uVGhpc0Rpc2sgPT09IHV0aWxzLk1BWF9WQUxVRV8xNkJJVFMgfHwgdGhpcy5jZW50cmFsRGlyUmVjb3JkcyA9PT0gdXRpbHMuTUFYX1ZBTFVFXzE2QklUUyB8fCB0aGlzLmNlbnRyYWxEaXJTaXplID09PSB1dGlscy5NQVhfVkFMVUVfMzJCSVRTIHx8IHRoaXMuY2VudHJhbERpck9mZnNldCA9PT0gdXRpbHMuTUFYX1ZBTFVFXzMyQklUUykge1xuICAgICAgICAgICAgdGhpcy56aXA2NCA9IHRydWU7XG5cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICBXYXJuaW5nIDogdGhlIHppcDY0IGV4dGVuc2lvbiBpcyBzdXBwb3J0ZWQsIGJ1dCBPTkxZIGlmIHRoZSA2NGJpdHMgaW50ZWdlciByZWFkIGZyb21cbiAgICAgICAgICAgIHRoZSB6aXAgZmlsZSBjYW4gZml0IGludG8gYSAzMmJpdHMgaW50ZWdlci4gVGhpcyBjYW5ub3QgYmUgc29sdmVkIDogSmF2YVNjcmlwdCByZXByZXNlbnRzXG4gICAgICAgICAgICBhbGwgbnVtYmVycyBhcyA2NC1iaXQgZG91YmxlIHByZWNpc2lvbiBJRUVFIDc1NCBmbG9hdGluZyBwb2ludCBudW1iZXJzLlxuICAgICAgICAgICAgU28sIHdlIGhhdmUgNTNiaXRzIGZvciBpbnRlZ2VycyBhbmQgYml0d2lzZSBvcGVyYXRpb25zIHRyZWF0IGV2ZXJ5dGhpbmcgYXMgMzJiaXRzLlxuICAgICAgICAgICAgc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL0JpdHdpc2VfT3BlcmF0b3JzXG4gICAgICAgICAgICBhbmQgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL3B1YmxpY2F0aW9ucy9maWxlcy9FQ01BLVNUL0VDTUEtMjYyLnBkZiBzZWN0aW9uIDguNVxuICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgLy8gc2hvdWxkIGxvb2sgZm9yIGEgemlwNjQgRU9DRCBsb2NhdG9yXG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLnJlYWRlci5sYXN0SW5kZXhPZlNpZ25hdHVyZShzaWcuWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfTE9DQVRPUik7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvcnJ1cHRlZCB6aXA6IGNhbid0IGZpbmQgdGhlIFpJUDY0IGVuZCBvZiBjZW50cmFsIGRpcmVjdG9yeSBsb2NhdG9yXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWFkZXIuc2V0SW5kZXgob2Zmc2V0KTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tTaWduYXR1cmUoc2lnLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0xPQ0FUT1IpO1xuICAgICAgICAgICAgdGhpcy5yZWFkQmxvY2taaXA2NEVuZE9mQ2VudHJhbExvY2F0b3IoKTtcblxuICAgICAgICAgICAgLy8gbm93IHRoZSB6aXA2NCBFT0NEIHJlY29yZFxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzU2lnbmF0dXJlKHRoaXMucmVsYXRpdmVPZmZzZXRFbmRPZlppcDY0Q2VudHJhbERpciwgc2lnLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0VORCkpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oXCJaSVA2NCBlbmQgb2YgY2VudHJhbCBkaXJlY3Rvcnkgbm90IHdoZXJlIGV4cGVjdGVkLlwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlT2Zmc2V0RW5kT2ZaaXA2NENlbnRyYWxEaXIgPSB0aGlzLnJlYWRlci5sYXN0SW5kZXhPZlNpZ25hdHVyZShzaWcuWklQNjRfQ0VOVFJBTF9ESVJFQ1RPUllfRU5EKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWxhdGl2ZU9mZnNldEVuZE9mWmlwNjRDZW50cmFsRGlyIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwOiBjYW4ndCBmaW5kIHRoZSBaSVA2NCBlbmQgb2YgY2VudHJhbCBkaXJlY3RvcnlcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWFkZXIuc2V0SW5kZXgodGhpcy5yZWxhdGl2ZU9mZnNldEVuZE9mWmlwNjRDZW50cmFsRGlyKTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tTaWduYXR1cmUoc2lnLlpJUDY0X0NFTlRSQUxfRElSRUNUT1JZX0VORCk7XG4gICAgICAgICAgICB0aGlzLnJlYWRCbG9ja1ppcDY0RW5kT2ZDZW50cmFsKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXhwZWN0ZWRFbmRPZkNlbnRyYWxEaXJPZmZzZXQgPSB0aGlzLmNlbnRyYWxEaXJPZmZzZXQgKyB0aGlzLmNlbnRyYWxEaXJTaXplO1xuICAgICAgICBpZiAodGhpcy56aXA2NCkge1xuICAgICAgICAgICAgZXhwZWN0ZWRFbmRPZkNlbnRyYWxEaXJPZmZzZXQgKz0gMjA7IC8vIGVuZCBvZiBjZW50cmFsIGRpciA2NCBsb2NhdG9yXG4gICAgICAgICAgICBleHBlY3RlZEVuZE9mQ2VudHJhbERpck9mZnNldCArPSAxMiAvKiBzaG91bGQgbm90IGluY2x1ZGUgdGhlIGxlYWRpbmcgMTIgYnl0ZXMgKi8gKyB0aGlzLnppcDY0RW5kT2ZDZW50cmFsU2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBleHRyYUJ5dGVzID0gZW5kT2ZDZW50cmFsRGlyT2Zmc2V0IC0gZXhwZWN0ZWRFbmRPZkNlbnRyYWxEaXJPZmZzZXQ7XG5cbiAgICAgICAgaWYgKGV4dHJhQnl0ZXMgPiAwKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oZXh0cmFCeXRlcywgXCJleHRyYSBieXRlcyBhdCBiZWdpbm5pbmcgb3Igd2l0aGluIHppcGZpbGVcIik7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1NpZ25hdHVyZShlbmRPZkNlbnRyYWxEaXJPZmZzZXQsIHNpZy5DRU5UUkFMX0ZJTEVfSEVBREVSKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBvZmZzZXRzIHNlZW0gd3JvbmcsIGJ1dCB3ZSBoYXZlIHNvbWV0aGluZyBhdCB0aGUgc3BlY2lmaWVkIG9mZnNldC5cbiAgICAgICAgICAgICAgICAvLyBTb+KApiB3ZSBrZWVwIGl0LlxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0aGUgb2Zmc2V0IGlzIHdyb25nLCB1cGRhdGUgdGhlIFwiemVyb1wiIG9mIHRoZSByZWFkZXJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGhhcHBlbnMgaWYgZGF0YSBoYXMgYmVlbiBwcmVwZW5kZWQgKGNyeCBmaWxlcyBmb3IgZXhhbXBsZSlcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWRlci56ZXJvID0gZXh0cmFCeXRlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChleHRyYUJ5dGVzIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29ycnVwdGVkIHppcDogbWlzc2luZyBcIiArIE1hdGguYWJzKGV4dHJhQnl0ZXMpICsgXCIgYnl0ZXMuXCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBwcmVwYXJlUmVhZGVyOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHRoaXMucmVhZGVyID0gcmVhZGVyRm9yKGRhdGEpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZCBhIHppcCBmaWxlIGFuZCBjcmVhdGUgWmlwRW50cmllcy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheUJ1ZmZlcnxVaW50OEFycmF5fEJ1ZmZlcn0gZGF0YSB0aGUgYmluYXJ5IHN0cmluZyByZXByZXNlbnRpbmcgYSB6aXAgZmlsZS5cbiAgICAgKi9cbiAgICBsb2FkOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHRoaXMucHJlcGFyZVJlYWRlcihkYXRhKTtcbiAgICAgICAgdGhpcy5yZWFkRW5kT2ZDZW50cmFsKCk7XG4gICAgICAgIHRoaXMucmVhZENlbnRyYWxEaXIoKTtcbiAgICAgICAgdGhpcy5yZWFkTG9jYWxGaWxlcygpO1xuICAgIH1cbn07XG4vLyB9fX0gZW5kIG9mIFppcEVudHJpZXNcbm1vZHVsZS5leHBvcnRzID0gWmlwRW50cmllcztcbiIsIid1c2Ugc3RyaWN0JztcbnZhciByZWFkZXJGb3IgPSByZXF1aXJlKCcuL3JlYWRlci9yZWFkZXJGb3InKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBDb21wcmVzc2VkT2JqZWN0ID0gcmVxdWlyZSgnLi9jb21wcmVzc2VkT2JqZWN0Jyk7XG52YXIgY3JjMzJmbiA9IHJlcXVpcmUoJy4vY3JjMzInKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgnLi91dGY4Jyk7XG52YXIgY29tcHJlc3Npb25zID0gcmVxdWlyZSgnLi9jb21wcmVzc2lvbnMnKTtcbnZhciBzdXBwb3J0ID0gcmVxdWlyZSgnLi9zdXBwb3J0Jyk7XG5cbnZhciBNQURFX0JZX0RPUyA9IDB4MDA7XG52YXIgTUFERV9CWV9VTklYID0gMHgwMztcblxuLyoqXG4gKiBGaW5kIGEgY29tcHJlc3Npb24gcmVnaXN0ZXJlZCBpbiBKU1ppcC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wcmVzc2lvbk1ldGhvZCB0aGUgbWV0aG9kIG1hZ2ljIHRvIGZpbmQuXG4gKiBAcmV0dXJuIHtPYmplY3R8bnVsbH0gdGhlIEpTWmlwIGNvbXByZXNzaW9uIG9iamVjdCwgbnVsbCBpZiBub25lIGZvdW5kLlxuICovXG52YXIgZmluZENvbXByZXNzaW9uID0gZnVuY3Rpb24oY29tcHJlc3Npb25NZXRob2QpIHtcbiAgICBmb3IgKHZhciBtZXRob2QgaW4gY29tcHJlc3Npb25zKSB7XG4gICAgICAgIGlmICghY29tcHJlc3Npb25zLmhhc093blByb3BlcnR5KG1ldGhvZCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wcmVzc2lvbnNbbWV0aG9kXS5tYWdpYyA9PT0gY29tcHJlc3Npb25NZXRob2QpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wcmVzc2lvbnNbbWV0aG9kXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbi8vIGNsYXNzIFppcEVudHJ5IHt7e1xuLyoqXG4gKiBBbiBlbnRyeSBpbiB0aGUgemlwIGZpbGUuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2YgdGhlIGN1cnJlbnQgZmlsZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBsb2FkT3B0aW9ucyBPcHRpb25zIGZvciBsb2FkaW5nIHRoZSBzdHJlYW0uXG4gKi9cbmZ1bmN0aW9uIFppcEVudHJ5KG9wdGlvbnMsIGxvYWRPcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmxvYWRPcHRpb25zID0gbG9hZE9wdGlvbnM7XG59XG5aaXBFbnRyeS5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogc2F5IGlmIHRoZSBmaWxlIGlzIGVuY3J5cHRlZC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBmaWxlIGlzIGVuY3J5cHRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGlzRW5jcnlwdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gYml0IDEgaXMgc2V0XG4gICAgICAgIHJldHVybiAodGhpcy5iaXRGbGFnICYgMHgwMDAxKSA9PT0gMHgwMDAxO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogc2F5IGlmIHRoZSBmaWxlIGhhcyB1dGYtOCBmaWxlbmFtZS9jb21tZW50LlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIGZpbGVuYW1lL2NvbW1lbnQgaXMgaW4gdXRmLTgsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICB1c2VVVEY4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gYml0IDExIGlzIHNldFxuICAgICAgICByZXR1cm4gKHRoaXMuYml0RmxhZyAmIDB4MDgwMCkgPT09IDB4MDgwMDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGxvY2FsIHBhcnQgb2YgYSB6aXAgZmlsZSBhbmQgYWRkIHRoZSBpbmZvIGluIHRoaXMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RGF0YVJlYWRlcn0gcmVhZGVyIHRoZSByZWFkZXIgdG8gdXNlLlxuICAgICAqL1xuICAgIHJlYWRMb2NhbFBhcnQ6IGZ1bmN0aW9uKHJlYWRlcikge1xuICAgICAgICB2YXIgY29tcHJlc3Npb24sIGxvY2FsRXh0cmFGaWVsZHNMZW5ndGg7XG5cbiAgICAgICAgLy8gd2UgYWxyZWFkeSBrbm93IGV2ZXJ5dGhpbmcgZnJvbSB0aGUgY2VudHJhbCBkaXIgIVxuICAgICAgICAvLyBJZiB0aGUgY2VudHJhbCBkaXIgZGF0YSBhcmUgZmFsc2UsIHdlIGFyZSBkb29tZWQuXG4gICAgICAgIC8vIE9uIHRoZSBicmlnaHQgc2lkZSwgdGhlIGxvY2FsIHBhcnQgaXMgc2NhcnkgIDogemlwNjQsIGRhdGEgZGVzY3JpcHRvcnMsIGJvdGgsIGV0Yy5cbiAgICAgICAgLy8gVGhlIGxlc3MgZGF0YSB3ZSBnZXQgaGVyZSwgdGhlIG1vcmUgcmVsaWFibGUgdGhpcyBzaG91bGQgYmUuXG4gICAgICAgIC8vIExldCdzIHNraXAgdGhlIHdob2xlIGhlYWRlciBhbmQgZGFzaCB0byB0aGUgZGF0YSAhXG4gICAgICAgIHJlYWRlci5za2lwKDIyKTtcbiAgICAgICAgLy8gaW4gc29tZSB6aXAgY3JlYXRlZCBvbiB3aW5kb3dzLCB0aGUgZmlsZW5hbWUgc3RvcmVkIGluIHRoZSBjZW50cmFsIGRpciBjb250YWlucyBcXCBpbnN0ZWFkIG9mIC8uXG4gICAgICAgIC8vIFN0cmFuZ2VseSwgdGhlIGZpbGVuYW1lIGhlcmUgaXMgT0suXG4gICAgICAgIC8vIEkgd291bGQgbG92ZSB0byB0cmVhdCB0aGVzZSB6aXAgZmlsZXMgYXMgY29ycnVwdGVkIChzZWUgaHR0cDovL3d3dy5pbmZvLXppcC5vcmcvRkFRLmh0bWwjYmFja3NsYXNoZXNcbiAgICAgICAgLy8gb3IgQVBQTk9URSM0LjQuMTcuMSwgXCJBbGwgc2xhc2hlcyBNVVNUIGJlIGZvcndhcmQgc2xhc2hlcyAnLydcIikgYnV0IHRoZXJlIGFyZSBhIGxvdCBvZiBiYWQgemlwIGdlbmVyYXRvcnMuLi5cbiAgICAgICAgLy8gU2VhcmNoIFwidW56aXAgbWlzbWF0Y2hpbmcgXCJsb2NhbFwiIGZpbGVuYW1lIGNvbnRpbnVpbmcgd2l0aCBcImNlbnRyYWxcIiBmaWxlbmFtZSB2ZXJzaW9uXCIgb25cbiAgICAgICAgLy8gdGhlIGludGVybmV0LlxuICAgICAgICAvL1xuICAgICAgICAvLyBJIHRoaW5rIEkgc2VlIHRoZSBsb2dpYyBoZXJlIDogdGhlIGNlbnRyYWwgZGlyZWN0b3J5IGlzIHVzZWQgdG8gZGlzcGxheVxuICAgICAgICAvLyBjb250ZW50IGFuZCB0aGUgbG9jYWwgZGlyZWN0b3J5IGlzIHVzZWQgdG8gZXh0cmFjdCB0aGUgZmlsZXMuIE1peGluZyAvIGFuZCBcXFxuICAgICAgICAvLyBtYXkgYmUgdXNlZCB0byBkaXNwbGF5IFxcIHRvIHdpbmRvd3MgdXNlcnMgYW5kIHVzZSAvIHdoZW4gZXh0cmFjdGluZyB0aGUgZmlsZXMuXG4gICAgICAgIC8vIFVuZm9ydHVuYXRlbHksIHRoaXMgbGVhZCBhbHNvIHRvIHNvbWUgaXNzdWVzIDogaHR0cDovL3NlY2xpc3RzLm9yZy9mdWxsZGlzY2xvc3VyZS8yMDA5L1NlcC8zOTRcbiAgICAgICAgdGhpcy5maWxlTmFtZUxlbmd0aCA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICBsb2NhbEV4dHJhRmllbGRzTGVuZ3RoID0gcmVhZGVyLnJlYWRJbnQoMik7IC8vIGNhbid0IGJlIHN1cmUgdGhpcyB3aWxsIGJlIHRoZSBzYW1lIGFzIHRoZSBjZW50cmFsIGRpclxuICAgICAgICAvLyB0aGUgZmlsZU5hbWUgaXMgc3RvcmVkIGFzIGJpbmFyeSBkYXRhLCB0aGUgaGFuZGxlVVRGOCBtZXRob2Qgd2lsbCB0YWtlIGNhcmUgb2YgdGhlIGVuY29kaW5nLlxuICAgICAgICB0aGlzLmZpbGVOYW1lID0gcmVhZGVyLnJlYWREYXRhKHRoaXMuZmlsZU5hbWVMZW5ndGgpO1xuICAgICAgICByZWFkZXIuc2tpcChsb2NhbEV4dHJhRmllbGRzTGVuZ3RoKTtcblxuICAgICAgICBpZiAodGhpcy5jb21wcmVzc2VkU2l6ZSA9PT0gLTEgfHwgdGhpcy51bmNvbXByZXNzZWRTaXplID09PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQnVnIG9yIGNvcnJ1cHRlZCB6aXAgOiBkaWRuJ3QgZ2V0IGVub3VnaCBpbmZvcm1hdGlvbiBmcm9tIHRoZSBjZW50cmFsIGRpcmVjdG9yeSBcIiArIFwiKGNvbXByZXNzZWRTaXplID09PSAtMSB8fCB1bmNvbXByZXNzZWRTaXplID09PSAtMSlcIik7XG4gICAgICAgIH1cblxuICAgICAgICBjb21wcmVzc2lvbiA9IGZpbmRDb21wcmVzc2lvbih0aGlzLmNvbXByZXNzaW9uTWV0aG9kKTtcbiAgICAgICAgaWYgKGNvbXByZXNzaW9uID09PSBudWxsKSB7IC8vIG5vIGNvbXByZXNzaW9uIGZvdW5kXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3JydXB0ZWQgemlwIDogY29tcHJlc3Npb24gXCIgKyB1dGlscy5wcmV0dHkodGhpcy5jb21wcmVzc2lvbk1ldGhvZCkgKyBcIiB1bmtub3duIChpbm5lciBmaWxlIDogXCIgKyB1dGlscy50cmFuc2Zvcm1UbyhcInN0cmluZ1wiLCB0aGlzLmZpbGVOYW1lKSArIFwiKVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlY29tcHJlc3NlZCA9IG5ldyBDb21wcmVzc2VkT2JqZWN0KHRoaXMuY29tcHJlc3NlZFNpemUsIHRoaXMudW5jb21wcmVzc2VkU2l6ZSwgdGhpcy5jcmMzMiwgY29tcHJlc3Npb24sIHJlYWRlci5yZWFkRGF0YSh0aGlzLmNvbXByZXNzZWRTaXplKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIGNlbnRyYWwgcGFydCBvZiBhIHppcCBmaWxlIGFuZCBhZGQgdGhlIGluZm8gaW4gdGhpcyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtEYXRhUmVhZGVyfSByZWFkZXIgdGhlIHJlYWRlciB0byB1c2UuXG4gICAgICovXG4gICAgcmVhZENlbnRyYWxQYXJ0OiBmdW5jdGlvbihyZWFkZXIpIHtcbiAgICAgICAgdGhpcy52ZXJzaW9uTWFkZUJ5ID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHJlYWRlci5za2lwKDIpO1xuICAgICAgICAvLyB0aGlzLnZlcnNpb25OZWVkZWQgPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5iaXRGbGFnID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuY29tcHJlc3Npb25NZXRob2QgPSByZWFkZXIucmVhZFN0cmluZygyKTtcbiAgICAgICAgdGhpcy5kYXRlID0gcmVhZGVyLnJlYWREYXRlKCk7XG4gICAgICAgIHRoaXMuY3JjMzIgPSByZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgdGhpcy5jb21wcmVzc2VkU2l6ZSA9IHJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB0aGlzLnVuY29tcHJlc3NlZFNpemUgPSByZWFkZXIucmVhZEludCg0KTtcbiAgICAgICAgdmFyIGZpbGVOYW1lTGVuZ3RoID0gcmVhZGVyLnJlYWRJbnQoMik7XG4gICAgICAgIHRoaXMuZXh0cmFGaWVsZHNMZW5ndGggPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5maWxlQ29tbWVudExlbmd0aCA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmRpc2tOdW1iZXJTdGFydCA9IHJlYWRlci5yZWFkSW50KDIpO1xuICAgICAgICB0aGlzLmludGVybmFsRmlsZUF0dHJpYnV0ZXMgPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgdGhpcy5leHRlcm5hbEZpbGVBdHRyaWJ1dGVzID0gcmVhZGVyLnJlYWRJbnQoNCk7XG4gICAgICAgIHRoaXMubG9jYWxIZWFkZXJPZmZzZXQgPSByZWFkZXIucmVhZEludCg0KTtcblxuICAgICAgICBpZiAodGhpcy5pc0VuY3J5cHRlZCgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFbmNyeXB0ZWQgemlwIGFyZSBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2lsbCBiZSByZWFkIGluIHRoZSBsb2NhbCBwYXJ0LCBzZWUgdGhlIGNvbW1lbnRzIHRoZXJlXG4gICAgICAgIHJlYWRlci5za2lwKGZpbGVOYW1lTGVuZ3RoKTtcbiAgICAgICAgdGhpcy5yZWFkRXh0cmFGaWVsZHMocmVhZGVyKTtcbiAgICAgICAgdGhpcy5wYXJzZVpJUDY0RXh0cmFGaWVsZChyZWFkZXIpO1xuICAgICAgICB0aGlzLmZpbGVDb21tZW50ID0gcmVhZGVyLnJlYWREYXRhKHRoaXMuZmlsZUNvbW1lbnRMZW5ndGgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSB0aGUgZXh0ZXJuYWwgZmlsZSBhdHRyaWJ1dGVzIGFuZCBnZXQgdGhlIHVuaXgvZG9zIHBlcm1pc3Npb25zLlxuICAgICAqL1xuICAgIHByb2Nlc3NBdHRyaWJ1dGVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudW5peFBlcm1pc3Npb25zID0gbnVsbDtcbiAgICAgICAgdGhpcy5kb3NQZXJtaXNzaW9ucyA9IG51bGw7XG4gICAgICAgIHZhciBtYWRlQnkgPSB0aGlzLnZlcnNpb25NYWRlQnkgPj4gODtcblxuICAgICAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIHRoZSBET1MgZGlyZWN0b3J5IGZsYWcgc2V0LlxuICAgICAgICAvLyBXZSBsb29rIGZvciBpdCBpbiB0aGUgRE9TIGFuZCBVTklYIHBlcm1pc3Npb25zXG4gICAgICAgIC8vIGJ1dCBzb21lIHVua25vd24gcGxhdGZvcm0gY291bGQgc2V0IGl0IGFzIGEgY29tcGF0aWJpbGl0eSBmbGFnLlxuICAgICAgICB0aGlzLmRpciA9IHRoaXMuZXh0ZXJuYWxGaWxlQXR0cmlidXRlcyAmIDB4MDAxMCA/IHRydWUgOiBmYWxzZTtcblxuICAgICAgICBpZihtYWRlQnkgPT09IE1BREVfQllfRE9TKSB7XG4gICAgICAgICAgICAvLyBmaXJzdCA2IGJpdHMgKDAgdG8gNSlcbiAgICAgICAgICAgIHRoaXMuZG9zUGVybWlzc2lvbnMgPSB0aGlzLmV4dGVybmFsRmlsZUF0dHJpYnV0ZXMgJiAweDNGO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYobWFkZUJ5ID09PSBNQURFX0JZX1VOSVgpIHtcbiAgICAgICAgICAgIHRoaXMudW5peFBlcm1pc3Npb25zID0gKHRoaXMuZXh0ZXJuYWxGaWxlQXR0cmlidXRlcyA+PiAxNikgJiAweEZGRkY7XG4gICAgICAgICAgICAvLyB0aGUgb2N0YWwgcGVybWlzc2lvbnMgYXJlIGluICh0aGlzLnVuaXhQZXJtaXNzaW9ucyAmIDB4MDFGRikudG9TdHJpbmcoOCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmYWlsIHNhZmUgOiBpZiB0aGUgbmFtZSBlbmRzIHdpdGggYSAvIGl0IHByb2JhYmx5IG1lYW5zIGEgZm9sZGVyXG4gICAgICAgIGlmICghdGhpcy5kaXIgJiYgdGhpcy5maWxlTmFtZVN0ci5zbGljZSgtMSkgPT09ICcvJykge1xuICAgICAgICAgICAgdGhpcy5kaXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBhcnNlIHRoZSBaSVA2NCBleHRyYSBmaWVsZCBhbmQgbWVyZ2UgdGhlIGluZm8gaW4gdGhlIGN1cnJlbnQgWmlwRW50cnkuXG4gICAgICogQHBhcmFtIHtEYXRhUmVhZGVyfSByZWFkZXIgdGhlIHJlYWRlciB0byB1c2UuXG4gICAgICovXG4gICAgcGFyc2VaSVA2NEV4dHJhRmllbGQ6IGZ1bmN0aW9uKHJlYWRlcikge1xuXG4gICAgICAgIGlmICghdGhpcy5leHRyYUZpZWxkc1sweDAwMDFdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzaG91bGQgYmUgc29tZXRoaW5nLCBwcmVwYXJpbmcgdGhlIGV4dHJhIHJlYWRlclxuICAgICAgICB2YXIgZXh0cmFSZWFkZXIgPSByZWFkZXJGb3IodGhpcy5leHRyYUZpZWxkc1sweDAwMDFdLnZhbHVlKTtcblxuICAgICAgICAvLyBJIHJlYWxseSBob3BlIHRoYXQgdGhlc2UgNjRiaXRzIGludGVnZXIgY2FuIGZpdCBpbiAzMiBiaXRzIGludGVnZXIsIGJlY2F1c2UganNcbiAgICAgICAgLy8gd29uJ3QgbGV0IHVzIGhhdmUgbW9yZS5cbiAgICAgICAgaWYgKHRoaXMudW5jb21wcmVzc2VkU2l6ZSA9PT0gdXRpbHMuTUFYX1ZBTFVFXzMyQklUUykge1xuICAgICAgICAgICAgdGhpcy51bmNvbXByZXNzZWRTaXplID0gZXh0cmFSZWFkZXIucmVhZEludCg4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb21wcmVzc2VkU2l6ZSA9PT0gdXRpbHMuTUFYX1ZBTFVFXzMyQklUUykge1xuICAgICAgICAgICAgdGhpcy5jb21wcmVzc2VkU2l6ZSA9IGV4dHJhUmVhZGVyLnJlYWRJbnQoOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubG9jYWxIZWFkZXJPZmZzZXQgPT09IHV0aWxzLk1BWF9WQUxVRV8zMkJJVFMpIHtcbiAgICAgICAgICAgIHRoaXMubG9jYWxIZWFkZXJPZmZzZXQgPSBleHRyYVJlYWRlci5yZWFkSW50KDgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRpc2tOdW1iZXJTdGFydCA9PT0gdXRpbHMuTUFYX1ZBTFVFXzMyQklUUykge1xuICAgICAgICAgICAgdGhpcy5kaXNrTnVtYmVyU3RhcnQgPSBleHRyYVJlYWRlci5yZWFkSW50KDQpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBSZWFkIHRoZSBjZW50cmFsIHBhcnQgb2YgYSB6aXAgZmlsZSBhbmQgYWRkIHRoZSBpbmZvIGluIHRoaXMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7RGF0YVJlYWRlcn0gcmVhZGVyIHRoZSByZWFkZXIgdG8gdXNlLlxuICAgICAqL1xuICAgIHJlYWRFeHRyYUZpZWxkczogZnVuY3Rpb24ocmVhZGVyKSB7XG4gICAgICAgIHZhciBlbmQgPSByZWFkZXIuaW5kZXggKyB0aGlzLmV4dHJhRmllbGRzTGVuZ3RoLFxuICAgICAgICAgICAgZXh0cmFGaWVsZElkLFxuICAgICAgICAgICAgZXh0cmFGaWVsZExlbmd0aCxcbiAgICAgICAgICAgIGV4dHJhRmllbGRWYWx1ZTtcblxuICAgICAgICBpZiAoIXRoaXMuZXh0cmFGaWVsZHMpIHtcbiAgICAgICAgICAgIHRoaXMuZXh0cmFGaWVsZHMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlIChyZWFkZXIuaW5kZXggKyA0IDwgZW5kKSB7XG4gICAgICAgICAgICBleHRyYUZpZWxkSWQgPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgICAgIGV4dHJhRmllbGRMZW5ndGggPSByZWFkZXIucmVhZEludCgyKTtcbiAgICAgICAgICAgIGV4dHJhRmllbGRWYWx1ZSA9IHJlYWRlci5yZWFkRGF0YShleHRyYUZpZWxkTGVuZ3RoKTtcblxuICAgICAgICAgICAgdGhpcy5leHRyYUZpZWxkc1tleHRyYUZpZWxkSWRdID0ge1xuICAgICAgICAgICAgICAgIGlkOiBleHRyYUZpZWxkSWQsXG4gICAgICAgICAgICAgICAgbGVuZ3RoOiBleHRyYUZpZWxkTGVuZ3RoLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBleHRyYUZpZWxkVmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZWFkZXIuc2V0SW5kZXgoZW5kKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEFwcGx5IGFuIFVURjggdHJhbnNmb3JtYXRpb24gaWYgbmVlZGVkLlxuICAgICAqL1xuICAgIGhhbmRsZVVURjg6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGVjb2RlUGFyYW1UeXBlID0gc3VwcG9ydC51aW50OGFycmF5ID8gXCJ1aW50OGFycmF5XCIgOiBcImFycmF5XCI7XG4gICAgICAgIGlmICh0aGlzLnVzZVVURjgoKSkge1xuICAgICAgICAgICAgdGhpcy5maWxlTmFtZVN0ciA9IHV0ZjgudXRmOGRlY29kZSh0aGlzLmZpbGVOYW1lKTtcbiAgICAgICAgICAgIHRoaXMuZmlsZUNvbW1lbnRTdHIgPSB1dGY4LnV0ZjhkZWNvZGUodGhpcy5maWxlQ29tbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdXBhdGggPSB0aGlzLmZpbmRFeHRyYUZpZWxkVW5pY29kZVBhdGgoKTtcbiAgICAgICAgICAgIGlmICh1cGF0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsZU5hbWVTdHIgPSB1cGF0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQVNDSUkgdGV4dCBvciB1bnN1cHBvcnRlZCBjb2RlIHBhZ2VcbiAgICAgICAgICAgICAgICB2YXIgZmlsZU5hbWVCeXRlQXJyYXkgPSAgdXRpbHMudHJhbnNmb3JtVG8oZGVjb2RlUGFyYW1UeXBlLCB0aGlzLmZpbGVOYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGVOYW1lU3RyID0gdGhpcy5sb2FkT3B0aW9ucy5kZWNvZGVGaWxlTmFtZShmaWxlTmFtZUJ5dGVBcnJheSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB1Y29tbWVudCA9IHRoaXMuZmluZEV4dHJhRmllbGRVbmljb2RlQ29tbWVudCgpO1xuICAgICAgICAgICAgaWYgKHVjb21tZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maWxlQ29tbWVudFN0ciA9IHVjb21tZW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBBU0NJSSB0ZXh0IG9yIHVuc3VwcG9ydGVkIGNvZGUgcGFnZVxuICAgICAgICAgICAgICAgIHZhciBjb21tZW50Qnl0ZUFycmF5ID0gIHV0aWxzLnRyYW5zZm9ybVRvKGRlY29kZVBhcmFtVHlwZSwgdGhpcy5maWxlQ29tbWVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5maWxlQ29tbWVudFN0ciA9IHRoaXMubG9hZE9wdGlvbnMuZGVjb2RlRmlsZU5hbWUoY29tbWVudEJ5dGVBcnJheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgdW5pY29kZSBwYXRoIGRlY2xhcmVkIGluIHRoZSBleHRyYSBmaWVsZCwgaWYgYW55LlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gdGhlIHVuaWNvZGUgcGF0aCwgbnVsbCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZmluZEV4dHJhRmllbGRVbmljb2RlUGF0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB1cGF0aEZpZWxkID0gdGhpcy5leHRyYUZpZWxkc1sweDcwNzVdO1xuICAgICAgICBpZiAodXBhdGhGaWVsZCkge1xuICAgICAgICAgICAgdmFyIGV4dHJhUmVhZGVyID0gcmVhZGVyRm9yKHVwYXRoRmllbGQudmFsdWUpO1xuXG4gICAgICAgICAgICAvLyB3cm9uZyB2ZXJzaW9uXG4gICAgICAgICAgICBpZiAoZXh0cmFSZWFkZXIucmVhZEludCgxKSAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0aGUgY3JjIG9mIHRoZSBmaWxlbmFtZSBjaGFuZ2VkLCB0aGlzIGZpZWxkIGlzIG91dCBvZiBkYXRlLlxuICAgICAgICAgICAgaWYgKGNyYzMyZm4odGhpcy5maWxlTmFtZSkgIT09IGV4dHJhUmVhZGVyLnJlYWRJbnQoNCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHV0ZjgudXRmOGRlY29kZShleHRyYVJlYWRlci5yZWFkRGF0YSh1cGF0aEZpZWxkLmxlbmd0aCAtIDUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmluZCB0aGUgdW5pY29kZSBjb21tZW50IGRlY2xhcmVkIGluIHRoZSBleHRyYSBmaWVsZCwgaWYgYW55LlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gdGhlIHVuaWNvZGUgY29tbWVudCwgbnVsbCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgZmluZEV4dHJhRmllbGRVbmljb2RlQ29tbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB1Y29tbWVudEZpZWxkID0gdGhpcy5leHRyYUZpZWxkc1sweDYzNzVdO1xuICAgICAgICBpZiAodWNvbW1lbnRGaWVsZCkge1xuICAgICAgICAgICAgdmFyIGV4dHJhUmVhZGVyID0gcmVhZGVyRm9yKHVjb21tZW50RmllbGQudmFsdWUpO1xuXG4gICAgICAgICAgICAvLyB3cm9uZyB2ZXJzaW9uXG4gICAgICAgICAgICBpZiAoZXh0cmFSZWFkZXIucmVhZEludCgxKSAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0aGUgY3JjIG9mIHRoZSBjb21tZW50IGNoYW5nZWQsIHRoaXMgZmllbGQgaXMgb3V0IG9mIGRhdGUuXG4gICAgICAgICAgICBpZiAoY3JjMzJmbih0aGlzLmZpbGVDb21tZW50KSAhPT0gZXh0cmFSZWFkZXIucmVhZEludCg0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdXRmOC51dGY4ZGVjb2RlKGV4dHJhUmVhZGVyLnJlYWREYXRhKHVjb21tZW50RmllbGQubGVuZ3RoIC0gNSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IFppcEVudHJ5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3RyZWFtSGVscGVyID0gcmVxdWlyZSgnLi9zdHJlYW0vU3RyZWFtSGVscGVyJyk7XG52YXIgRGF0YVdvcmtlciA9IHJlcXVpcmUoJy4vc3RyZWFtL0RhdGFXb3JrZXInKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgnLi91dGY4Jyk7XG52YXIgQ29tcHJlc3NlZE9iamVjdCA9IHJlcXVpcmUoJy4vY29tcHJlc3NlZE9iamVjdCcpO1xudmFyIEdlbmVyaWNXb3JrZXIgPSByZXF1aXJlKCcuL3N0cmVhbS9HZW5lcmljV29ya2VyJyk7XG5cbi8qKlxuICogQSBzaW1wbGUgb2JqZWN0IHJlcHJlc2VudGluZyBhIGZpbGUgaW4gdGhlIHppcCBmaWxlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgZmlsZVxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXlCdWZmZXJ8VWludDhBcnJheXxCdWZmZXJ9IGRhdGEgdGhlIGRhdGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRoZSBvcHRpb25zIG9mIHRoZSBmaWxlXG4gKi9cbnZhciBaaXBPYmplY3QgPSBmdW5jdGlvbihuYW1lLCBkYXRhLCBvcHRpb25zKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmRpciA9IG9wdGlvbnMuZGlyO1xuICAgIHRoaXMuZGF0ZSA9IG9wdGlvbnMuZGF0ZTtcbiAgICB0aGlzLmNvbW1lbnQgPSBvcHRpb25zLmNvbW1lbnQ7XG4gICAgdGhpcy51bml4UGVybWlzc2lvbnMgPSBvcHRpb25zLnVuaXhQZXJtaXNzaW9ucztcbiAgICB0aGlzLmRvc1Blcm1pc3Npb25zID0gb3B0aW9ucy5kb3NQZXJtaXNzaW9ucztcblxuICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgIHRoaXMuX2RhdGFCaW5hcnkgPSBvcHRpb25zLmJpbmFyeTtcbiAgICAvLyBrZWVwIG9ubHkgdGhlIGNvbXByZXNzaW9uXG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICBjb21wcmVzc2lvbiA6IG9wdGlvbnMuY29tcHJlc3Npb24sXG4gICAgICAgIGNvbXByZXNzaW9uT3B0aW9ucyA6IG9wdGlvbnMuY29tcHJlc3Npb25PcHRpb25zXG4gICAgfTtcbn07XG5cblppcE9iamVjdC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGludGVybmFsIHN0cmVhbSBmb3IgdGhlIGNvbnRlbnQgb2YgdGhpcyBvYmplY3QuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIHR5cGUgb2YgZWFjaCBjaHVuay5cbiAgICAgKiBAcmV0dXJuIFN0cmVhbUhlbHBlciB0aGUgc3RyZWFtLlxuICAgICAqL1xuICAgIGludGVybmFsU3RyZWFtOiBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbCwgb3V0cHV0VHlwZSA9IFwic3RyaW5nXCI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBvdXRwdXQgdHlwZSBzcGVjaWZpZWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0cHV0VHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHZhciBhc2tVbmljb2RlU3RyaW5nID0gb3V0cHV0VHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBvdXRwdXRUeXBlID09PSBcInRleHRcIjtcbiAgICAgICAgICAgIGlmIChvdXRwdXRUeXBlID09PSBcImJpbmFyeXN0cmluZ1wiIHx8IG91dHB1dFR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0VHlwZSA9IFwic3RyaW5nXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9kZWNvbXByZXNzV29ya2VyKCk7XG5cbiAgICAgICAgICAgIHZhciBpc1VuaWNvZGVTdHJpbmcgPSAhdGhpcy5fZGF0YUJpbmFyeTtcblxuICAgICAgICAgICAgaWYgKGlzVW5pY29kZVN0cmluZyAmJiAhYXNrVW5pY29kZVN0cmluZykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5waXBlKG5ldyB1dGY4LlV0ZjhFbmNvZGVXb3JrZXIoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzVW5pY29kZVN0cmluZyAmJiBhc2tVbmljb2RlU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnBpcGUobmV3IHV0ZjguVXRmOERlY29kZVdvcmtlcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEdlbmVyaWNXb3JrZXIoXCJlcnJvclwiKTtcbiAgICAgICAgICAgIHJlc3VsdC5lcnJvcihlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtSGVscGVyKHJlc3VsdCwgb3V0cHV0VHlwZSwgXCJcIik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgdGhlIGNvbnRlbnQgaW4gdGhlIGFza2VkIHR5cGUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIHR5cGUgb2YgdGhlIHJlc3VsdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvblVwZGF0ZSBhIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBpbnRlcm5hbCB1cGRhdGUuXG4gICAgICogQHJldHVybiBQcm9taXNlIHRoZSBwcm9taXNlIG9mIHRoZSByZXN1bHQuXG4gICAgICovXG4gICAgYXN5bmM6IGZ1bmN0aW9uICh0eXBlLCBvblVwZGF0ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbFN0cmVhbSh0eXBlKS5hY2N1bXVsYXRlKG9uVXBkYXRlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJlcGFyZSB0aGUgY29udGVudCBhcyBhIG5vZGVqcyBzdHJlYW0uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgdGhlIHR5cGUgb2YgZWFjaCBjaHVuay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvblVwZGF0ZSBhIGZ1bmN0aW9uIHRvIGNhbGwgb24gZWFjaCBpbnRlcm5hbCB1cGRhdGUuXG4gICAgICogQHJldHVybiBTdHJlYW0gdGhlIHN0cmVhbS5cbiAgICAgKi9cbiAgICBub2RlU3RyZWFtOiBmdW5jdGlvbiAodHlwZSwgb25VcGRhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxTdHJlYW0odHlwZSB8fCBcIm5vZGVidWZmZXJcIikudG9Ob2RlanNTdHJlYW0ob25VcGRhdGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSB3b3JrZXIgZm9yIHRoZSBjb21wcmVzc2VkIGNvbnRlbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29tcHJlc3Npb24gdGhlIGNvbXByZXNzaW9uIG9iamVjdCB0byB1c2UuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbXByZXNzaW9uT3B0aW9ucyB0aGUgb3B0aW9ucyB0byB1c2Ugd2hlbiBjb21wcmVzc2luZy5cbiAgICAgKiBAcmV0dXJuIFdvcmtlciB0aGUgd29ya2VyLlxuICAgICAqL1xuICAgIF9jb21wcmVzc1dvcmtlcjogZnVuY3Rpb24gKGNvbXByZXNzaW9uLCBjb21wcmVzc2lvbk9wdGlvbnMpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGhpcy5fZGF0YSBpbnN0YW5jZW9mIENvbXByZXNzZWRPYmplY3QgJiZcbiAgICAgICAgICAgIHRoaXMuX2RhdGEuY29tcHJlc3Npb24ubWFnaWMgPT09IGNvbXByZXNzaW9uLm1hZ2ljXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGEuZ2V0Q29tcHJlc3NlZFdvcmtlcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2RlY29tcHJlc3NXb3JrZXIoKTtcbiAgICAgICAgICAgIGlmKCF0aGlzLl9kYXRhQmluYXJ5KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnBpcGUobmV3IHV0ZjguVXRmOEVuY29kZVdvcmtlcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBDb21wcmVzc2VkT2JqZWN0LmNyZWF0ZVdvcmtlckZyb20ocmVzdWx0LCBjb21wcmVzc2lvbiwgY29tcHJlc3Npb25PcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgd29ya2VyIGZvciB0aGUgZGVjb21wcmVzc2VkIGNvbnRlbnQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcmV0dXJuIFdvcmtlciB0aGUgd29ya2VyLlxuICAgICAqL1xuICAgIF9kZWNvbXByZXNzV29ya2VyIDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fZGF0YSBpbnN0YW5jZW9mIENvbXByZXNzZWRPYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLmdldENvbnRlbnRXb3JrZXIoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9kYXRhIGluc3RhbmNlb2YgR2VuZXJpY1dvcmtlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGFXb3JrZXIodGhpcy5fZGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgcmVtb3ZlZE1ldGhvZHMgPSBbXCJhc1RleHRcIiwgXCJhc0JpbmFyeVwiLCBcImFzTm9kZUJ1ZmZlclwiLCBcImFzVWludDhBcnJheVwiLCBcImFzQXJyYXlCdWZmZXJcIl07XG52YXIgcmVtb3ZlZEZuID0gZnVuY3Rpb24gKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgbWV0aG9kIGhhcyBiZWVuIHJlbW92ZWQgaW4gSlNaaXAgMy4wLCBwbGVhc2UgY2hlY2sgdGhlIHVwZ3JhZGUgZ3VpZGUuXCIpO1xufTtcblxuZm9yKHZhciBpID0gMDsgaSA8IHJlbW92ZWRNZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgWmlwT2JqZWN0LnByb3RvdHlwZVtyZW1vdmVkTWV0aG9kc1tpXV0gPSByZW1vdmVkRm47XG59XG5tb2R1bGUuZXhwb3J0cyA9IFppcE9iamVjdDtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBpbW1lZGlhdGUgPSByZXF1aXJlKCdpbW1lZGlhdGUnKTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIElOVEVSTkFMKCkge31cblxudmFyIGhhbmRsZXJzID0ge307XG5cbnZhciBSRUpFQ1RFRCA9IFsnUkVKRUNURUQnXTtcbnZhciBGVUxGSUxMRUQgPSBbJ0ZVTEZJTExFRCddO1xudmFyIFBFTkRJTkcgPSBbJ1BFTkRJTkcnXTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuXG5mdW5jdGlvbiBQcm9taXNlKHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgcmVzb2x2ZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZXNvbHZlciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuICB0aGlzLnN0YXRlID0gUEVORElORztcbiAgdGhpcy5xdWV1ZSA9IFtdO1xuICB0aGlzLm91dGNvbWUgPSB2b2lkIDA7XG4gIGlmIChyZXNvbHZlciAhPT0gSU5URVJOQUwpIHtcbiAgICBzYWZlbHlSZXNvbHZlVGhlbmFibGUodGhpcywgcmVzb2x2ZXIpO1xuICB9XG59XG5cblByb21pc2UucHJvdG90eXBlW1wiZmluYWxseVwiXSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdmFyIHAgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdGhpcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZSh2YWx1ZSkge1xuICAgIGZ1bmN0aW9uIHllcyAoKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBwLnJlc29sdmUoY2FsbGJhY2soKSkudGhlbih5ZXMpO1xuICB9XG4gIGZ1bmN0aW9uIHJlamVjdChyZWFzb24pIHtcbiAgICBmdW5jdGlvbiBubyAoKSB7XG4gICAgICB0aHJvdyByZWFzb247XG4gICAgfVxuICAgIHJldHVybiBwLnJlc29sdmUoY2FsbGJhY2soKSkudGhlbihubyk7XG4gIH1cbn07XG5Qcm9taXNlLnByb3RvdHlwZVtcImNhdGNoXCJdID0gZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGVkKTtcbn07XG5Qcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gIGlmICh0eXBlb2Ygb25GdWxmaWxsZWQgIT09ICdmdW5jdGlvbicgJiYgdGhpcy5zdGF0ZSA9PT0gRlVMRklMTEVEIHx8XG4gICAgdHlwZW9mIG9uUmVqZWN0ZWQgIT09ICdmdW5jdGlvbicgJiYgdGhpcy5zdGF0ZSA9PT0gUkVKRUNURUQpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB2YXIgcHJvbWlzZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKElOVEVSTkFMKTtcbiAgaWYgKHRoaXMuc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICB2YXIgcmVzb2x2ZXIgPSB0aGlzLnN0YXRlID09PSBGVUxGSUxMRUQgPyBvbkZ1bGZpbGxlZCA6IG9uUmVqZWN0ZWQ7XG4gICAgdW53cmFwKHByb21pc2UsIHJlc29sdmVyLCB0aGlzLm91dGNvbWUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucXVldWUucHVzaChuZXcgUXVldWVJdGVtKHByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSk7XG4gIH1cblxuICByZXR1cm4gcHJvbWlzZTtcbn07XG5mdW5jdGlvbiBRdWV1ZUl0ZW0ocHJvbWlzZSwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgaWYgKHR5cGVvZiBvbkZ1bGZpbGxlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMub25GdWxmaWxsZWQgPSBvbkZ1bGZpbGxlZDtcbiAgICB0aGlzLmNhbGxGdWxmaWxsZWQgPSB0aGlzLm90aGVyQ2FsbEZ1bGZpbGxlZDtcbiAgfVxuICBpZiAodHlwZW9mIG9uUmVqZWN0ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLm9uUmVqZWN0ZWQgPSBvblJlamVjdGVkO1xuICAgIHRoaXMuY2FsbFJlamVjdGVkID0gdGhpcy5vdGhlckNhbGxSZWplY3RlZDtcbiAgfVxufVxuUXVldWVJdGVtLnByb3RvdHlwZS5jYWxsRnVsZmlsbGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGhhbmRsZXJzLnJlc29sdmUodGhpcy5wcm9taXNlLCB2YWx1ZSk7XG59O1xuUXVldWVJdGVtLnByb3RvdHlwZS5vdGhlckNhbGxGdWxmaWxsZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgdW53cmFwKHRoaXMucHJvbWlzZSwgdGhpcy5vbkZ1bGZpbGxlZCwgdmFsdWUpO1xufTtcblF1ZXVlSXRlbS5wcm90b3R5cGUuY2FsbFJlamVjdGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGhhbmRsZXJzLnJlamVjdCh0aGlzLnByb21pc2UsIHZhbHVlKTtcbn07XG5RdWV1ZUl0ZW0ucHJvdG90eXBlLm90aGVyQ2FsbFJlamVjdGVkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHVud3JhcCh0aGlzLnByb21pc2UsIHRoaXMub25SZWplY3RlZCwgdmFsdWUpO1xufTtcblxuZnVuY3Rpb24gdW53cmFwKHByb21pc2UsIGZ1bmMsIHZhbHVlKSB7XG4gIGltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJldHVyblZhbHVlO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm5WYWx1ZSA9IGZ1bmModmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBoYW5kbGVycy5yZWplY3QocHJvbWlzZSwgZSk7XG4gICAgfVxuICAgIGlmIChyZXR1cm5WYWx1ZSA9PT0gcHJvbWlzZSkge1xuICAgICAgaGFuZGxlcnMucmVqZWN0KHByb21pc2UsIG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCByZXNvbHZlIHByb21pc2Ugd2l0aCBpdHNlbGYnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhhbmRsZXJzLnJlc29sdmUocHJvbWlzZSwgcmV0dXJuVmFsdWUpO1xuICAgIH1cbiAgfSk7XG59XG5cbmhhbmRsZXJzLnJlc29sdmUgPSBmdW5jdGlvbiAoc2VsZiwgdmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKGdldFRoZW4sIHZhbHVlKTtcbiAgaWYgKHJlc3VsdC5zdGF0dXMgPT09ICdlcnJvcicpIHtcbiAgICByZXR1cm4gaGFuZGxlcnMucmVqZWN0KHNlbGYsIHJlc3VsdC52YWx1ZSk7XG4gIH1cbiAgdmFyIHRoZW5hYmxlID0gcmVzdWx0LnZhbHVlO1xuXG4gIGlmICh0aGVuYWJsZSkge1xuICAgIHNhZmVseVJlc29sdmVUaGVuYWJsZShzZWxmLCB0aGVuYWJsZSk7XG4gIH0gZWxzZSB7XG4gICAgc2VsZi5zdGF0ZSA9IEZVTEZJTExFRDtcbiAgICBzZWxmLm91dGNvbWUgPSB2YWx1ZTtcbiAgICB2YXIgaSA9IC0xO1xuICAgIHZhciBsZW4gPSBzZWxmLnF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICBzZWxmLnF1ZXVlW2ldLmNhbGxGdWxmaWxsZWQodmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2VsZjtcbn07XG5oYW5kbGVycy5yZWplY3QgPSBmdW5jdGlvbiAoc2VsZiwgZXJyb3IpIHtcbiAgc2VsZi5zdGF0ZSA9IFJFSkVDVEVEO1xuICBzZWxmLm91dGNvbWUgPSBlcnJvcjtcbiAgdmFyIGkgPSAtMTtcbiAgdmFyIGxlbiA9IHNlbGYucXVldWUubGVuZ3RoO1xuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgc2VsZi5xdWV1ZVtpXS5jYWxsUmVqZWN0ZWQoZXJyb3IpO1xuICB9XG4gIHJldHVybiBzZWxmO1xufTtcblxuZnVuY3Rpb24gZ2V0VGhlbihvYmopIHtcbiAgLy8gTWFrZSBzdXJlIHdlIG9ubHkgYWNjZXNzIHRoZSBhY2Nlc3NvciBvbmNlIGFzIHJlcXVpcmVkIGJ5IHRoZSBzcGVjXG4gIHZhciB0aGVuID0gb2JqICYmIG9iai50aGVuO1xuICBpZiAob2JqICYmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSAmJiB0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmdW5jdGlvbiBhcHB5VGhlbigpIHtcbiAgICAgIHRoZW4uYXBwbHkob2JqLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gc2FmZWx5UmVzb2x2ZVRoZW5hYmxlKHNlbGYsIHRoZW5hYmxlKSB7XG4gIC8vIEVpdGhlciBmdWxmaWxsLCByZWplY3Qgb3IgcmVqZWN0IHdpdGggZXJyb3JcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBvbkVycm9yKHZhbHVlKSB7XG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIGhhbmRsZXJzLnJlamVjdChzZWxmLCB2YWx1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBvblN1Y2Nlc3ModmFsdWUpIHtcbiAgICBpZiAoY2FsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxlZCA9IHRydWU7XG4gICAgaGFuZGxlcnMucmVzb2x2ZShzZWxmLCB2YWx1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiB0cnlUb1Vud3JhcCgpIHtcbiAgICB0aGVuYWJsZShvblN1Y2Nlc3MsIG9uRXJyb3IpO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IHRyeUNhdGNoKHRyeVRvVW53cmFwKTtcbiAgaWYgKHJlc3VsdC5zdGF0dXMgPT09ICdlcnJvcicpIHtcbiAgICBvbkVycm9yKHJlc3VsdC52YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ5Q2F0Y2goZnVuYywgdmFsdWUpIHtcbiAgdmFyIG91dCA9IHt9O1xuICB0cnkge1xuICAgIG91dC52YWx1ZSA9IGZ1bmModmFsdWUpO1xuICAgIG91dC5zdGF0dXMgPSAnc3VjY2Vzcyc7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBvdXQuc3RhdHVzID0gJ2Vycm9yJztcbiAgICBvdXQudmFsdWUgPSBlO1xuICB9XG4gIHJldHVybiBvdXQ7XG59XG5cblByb21pc2UucmVzb2x2ZSA9IHJlc29sdmU7XG5mdW5jdGlvbiByZXNvbHZlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIHRoaXMpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGhhbmRsZXJzLnJlc29sdmUobmV3IHRoaXMoSU5URVJOQUwpLCB2YWx1ZSk7XG59XG5cblByb21pc2UucmVqZWN0ID0gcmVqZWN0O1xuZnVuY3Rpb24gcmVqZWN0KHJlYXNvbikge1xuICB2YXIgcHJvbWlzZSA9IG5ldyB0aGlzKElOVEVSTkFMKTtcbiAgcmV0dXJuIGhhbmRsZXJzLnJlamVjdChwcm9taXNlLCByZWFzb24pO1xufVxuXG5Qcm9taXNlLmFsbCA9IGFsbDtcbmZ1bmN0aW9uIGFsbChpdGVyYWJsZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlcmFibGUpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgcmV0dXJuIHRoaXMucmVqZWN0KG5ldyBUeXBlRXJyb3IoJ211c3QgYmUgYW4gYXJyYXknKSk7XG4gIH1cblxuICB2YXIgbGVuID0gaXRlcmFibGUubGVuZ3RoO1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIGlmICghbGVuKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzb2x2ZShbXSk7XG4gIH1cblxuICB2YXIgdmFsdWVzID0gbmV3IEFycmF5KGxlbik7XG4gIHZhciByZXNvbHZlZCA9IDA7XG4gIHZhciBpID0gLTE7XG4gIHZhciBwcm9taXNlID0gbmV3IHRoaXMoSU5URVJOQUwpO1xuXG4gIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICBhbGxSZXNvbHZlcihpdGVyYWJsZVtpXSwgaSk7XG4gIH1cbiAgcmV0dXJuIHByb21pc2U7XG4gIGZ1bmN0aW9uIGFsbFJlc29sdmVyKHZhbHVlLCBpKSB7XG4gICAgc2VsZi5yZXNvbHZlKHZhbHVlKS50aGVuKHJlc29sdmVGcm9tQWxsLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIGhhbmRsZXJzLnJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gcmVzb2x2ZUZyb21BbGwob3V0VmFsdWUpIHtcbiAgICAgIHZhbHVlc1tpXSA9IG91dFZhbHVlO1xuICAgICAgaWYgKCsrcmVzb2x2ZWQgPT09IGxlbiAmJiAhY2FsbGVkKSB7XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIGhhbmRsZXJzLnJlc29sdmUocHJvbWlzZSwgdmFsdWVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuUHJvbWlzZS5yYWNlID0gcmFjZTtcbmZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGl0ZXJhYmxlKSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgIHJldHVybiB0aGlzLnJlamVjdChuZXcgVHlwZUVycm9yKCdtdXN0IGJlIGFuIGFycmF5JykpO1xuICB9XG5cbiAgdmFyIGxlbiA9IGl0ZXJhYmxlLmxlbmd0aDtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICBpZiAoIWxlbikge1xuICAgIHJldHVybiB0aGlzLnJlc29sdmUoW10pO1xuICB9XG5cbiAgdmFyIGkgPSAtMTtcbiAgdmFyIHByb21pc2UgPSBuZXcgdGhpcyhJTlRFUk5BTCk7XG5cbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIHJlc29sdmVyKGl0ZXJhYmxlW2ldKTtcbiAgfVxuICByZXR1cm4gcHJvbWlzZTtcbiAgZnVuY3Rpb24gcmVzb2x2ZXIodmFsdWUpIHtcbiAgICBzZWxmLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgICBoYW5kbGVycy5yZXNvbHZlKHByb21pc2UsIHJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgIGhhbmRsZXJzLnJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8vIFRvcCBsZXZlbCBmaWxlIGlzIGp1c3QgYSBtaXhpbiBvZiBzdWJtb2R1bGVzICYgY29uc3RhbnRzXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhc3NpZ24gICAgPSByZXF1aXJlKCcuL2xpYi91dGlscy9jb21tb24nKS5hc3NpZ247XG5cbnZhciBkZWZsYXRlICAgPSByZXF1aXJlKCcuL2xpYi9kZWZsYXRlJyk7XG52YXIgaW5mbGF0ZSAgID0gcmVxdWlyZSgnLi9saWIvaW5mbGF0ZScpO1xudmFyIGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vbGliL3psaWIvY29uc3RhbnRzJyk7XG5cbnZhciBwYWtvID0ge307XG5cbmFzc2lnbihwYWtvLCBkZWZsYXRlLCBpbmZsYXRlLCBjb25zdGFudHMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBha287XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIHpsaWJfZGVmbGF0ZSA9IHJlcXVpcmUoJy4vemxpYi9kZWZsYXRlJyk7XG52YXIgdXRpbHMgICAgICAgID0gcmVxdWlyZSgnLi91dGlscy9jb21tb24nKTtcbnZhciBzdHJpbmdzICAgICAgPSByZXF1aXJlKCcuL3V0aWxzL3N0cmluZ3MnKTtcbnZhciBtc2cgICAgICAgICAgPSByZXF1aXJlKCcuL3psaWIvbWVzc2FnZXMnKTtcbnZhciBaU3RyZWFtICAgICAgPSByZXF1aXJlKCcuL3psaWIvenN0cmVhbScpO1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxudmFyIFpfTk9fRkxVU0ggICAgICA9IDA7XG52YXIgWl9GSU5JU0ggICAgICAgID0gNDtcblxudmFyIFpfT0sgICAgICAgICAgICA9IDA7XG52YXIgWl9TVFJFQU1fRU5EICAgID0gMTtcbnZhciBaX1NZTkNfRkxVU0ggICAgPSAyO1xuXG52YXIgWl9ERUZBVUxUX0NPTVBSRVNTSU9OID0gLTE7XG5cbnZhciBaX0RFRkFVTFRfU1RSQVRFR1kgICAgPSAwO1xuXG52YXIgWl9ERUZMQVRFRCAgPSA4O1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qKlxuICogY2xhc3MgRGVmbGF0ZVxuICpcbiAqIEdlbmVyaWMgSlMtc3R5bGUgd3JhcHBlciBmb3IgemxpYiBjYWxscy4gSWYgeW91IGRvbid0IG5lZWRcbiAqIHN0cmVhbWluZyBiZWhhdmlvdXIgLSB1c2UgbW9yZSBzaW1wbGUgZnVuY3Rpb25zOiBbW2RlZmxhdGVdXSxcbiAqIFtbZGVmbGF0ZVJhd11dIGFuZCBbW2d6aXBdXS5cbiAqKi9cblxuLyogaW50ZXJuYWxcbiAqIERlZmxhdGUuY2h1bmtzIC0+IEFycmF5XG4gKlxuICogQ2h1bmtzIG9mIG91dHB1dCBkYXRhLCBpZiBbW0RlZmxhdGUjb25EYXRhXV0gbm90IG92ZXJyaWRkZW4uXG4gKiovXG5cbi8qKlxuICogRGVmbGF0ZS5yZXN1bHQgLT4gVWludDhBcnJheXxBcnJheVxuICpcbiAqIENvbXByZXNzZWQgcmVzdWx0LCBnZW5lcmF0ZWQgYnkgZGVmYXVsdCBbW0RlZmxhdGUjb25EYXRhXV1cbiAqIGFuZCBbW0RlZmxhdGUjb25FbmRdXSBoYW5kbGVycy4gRmlsbGVkIGFmdGVyIHlvdSBwdXNoIGxhc3QgY2h1bmtcbiAqIChjYWxsIFtbRGVmbGF0ZSNwdXNoXV0gd2l0aCBgWl9GSU5JU0hgIC8gYHRydWVgIHBhcmFtKSAgb3IgaWYgeW91XG4gKiBwdXNoIGEgY2h1bmsgd2l0aCBleHBsaWNpdCBmbHVzaCAoY2FsbCBbW0RlZmxhdGUjcHVzaF1dIHdpdGhcbiAqIGBaX1NZTkNfRkxVU0hgIHBhcmFtKS5cbiAqKi9cblxuLyoqXG4gKiBEZWZsYXRlLmVyciAtPiBOdW1iZXJcbiAqXG4gKiBFcnJvciBjb2RlIGFmdGVyIGRlZmxhdGUgZmluaXNoZWQuIDAgKFpfT0spIG9uIHN1Y2Nlc3MuXG4gKiBZb3Ugd2lsbCBub3QgbmVlZCBpdCBpbiByZWFsIGxpZmUsIGJlY2F1c2UgZGVmbGF0ZSBlcnJvcnNcbiAqIGFyZSBwb3NzaWJsZSBvbmx5IG9uIHdyb25nIG9wdGlvbnMgb3IgYmFkIGBvbkRhdGFgIC8gYG9uRW5kYFxuICogY3VzdG9tIGhhbmRsZXJzLlxuICoqL1xuXG4vKipcbiAqIERlZmxhdGUubXNnIC0+IFN0cmluZ1xuICpcbiAqIEVycm9yIG1lc3NhZ2UsIGlmIFtbRGVmbGF0ZS5lcnJdXSAhPSAwXG4gKiovXG5cblxuLyoqXG4gKiBuZXcgRGVmbGF0ZShvcHRpb25zKVxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDcmVhdGVzIG5ldyBkZWZsYXRvciBpbnN0YW5jZSB3aXRoIHNwZWNpZmllZCBwYXJhbXMuIFRocm93cyBleGNlcHRpb25cbiAqIG9uIGJhZCBwYXJhbXMuIFN1cHBvcnRlZCBvcHRpb25zOlxuICpcbiAqIC0gYGxldmVsYFxuICogLSBgd2luZG93Qml0c2BcbiAqIC0gYG1lbUxldmVsYFxuICogLSBgc3RyYXRlZ3lgXG4gKiAtIGBkaWN0aW9uYXJ5YFxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIEFkZGl0aW9uYWwgb3B0aW9ucywgZm9yIGludGVybmFsIG5lZWRzOlxuICpcbiAqIC0gYGNodW5rU2l6ZWAgLSBzaXplIG9mIGdlbmVyYXRlZCBkYXRhIGNodW5rcyAoMTZLIGJ5IGRlZmF1bHQpXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIGRvIHJhdyBkZWZsYXRlXG4gKiAtIGBnemlwYCAoQm9vbGVhbikgLSBjcmVhdGUgZ3ppcCB3cmFwcGVyXG4gKiAtIGB0b2AgKFN0cmluZykgLSBpZiBlcXVhbCB0byAnc3RyaW5nJywgdGhlbiByZXN1bHQgd2lsbCBiZSBcImJpbmFyeSBzdHJpbmdcIlxuICogICAgKGVhY2ggY2hhciBjb2RlIFswLi4yNTVdKVxuICogLSBgaGVhZGVyYCAoT2JqZWN0KSAtIGN1c3RvbSBoZWFkZXIgZm9yIGd6aXBcbiAqICAgLSBgdGV4dGAgKEJvb2xlYW4pIC0gdHJ1ZSBpZiBjb21wcmVzc2VkIGRhdGEgYmVsaWV2ZWQgdG8gYmUgdGV4dFxuICogICAtIGB0aW1lYCAoTnVtYmVyKSAtIG1vZGlmaWNhdGlvbiB0aW1lLCB1bml4IHRpbWVzdGFtcFxuICogICAtIGBvc2AgKE51bWJlcikgLSBvcGVyYXRpb24gc3lzdGVtIGNvZGVcbiAqICAgLSBgZXh0cmFgIChBcnJheSkgLSBhcnJheSBvZiBieXRlcyB3aXRoIGV4dHJhIGRhdGEgKG1heCA2NTUzNilcbiAqICAgLSBgbmFtZWAgKFN0cmluZykgLSBmaWxlIG5hbWUgKGJpbmFyeSBzdHJpbmcpXG4gKiAgIC0gYGNvbW1lbnRgIChTdHJpbmcpIC0gY29tbWVudCAoYmluYXJ5IHN0cmluZylcbiAqICAgLSBgaGNyY2AgKEJvb2xlYW4pIC0gdHJ1ZSBpZiBoZWFkZXIgY3JjIHNob3VsZCBiZSBhZGRlZFxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBjaHVuazEgPSBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiAgICwgY2h1bmsyID0gVWludDhBcnJheShbMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTldKTtcbiAqXG4gKiB2YXIgZGVmbGF0ZSA9IG5ldyBwYWtvLkRlZmxhdGUoeyBsZXZlbDogM30pO1xuICpcbiAqIGRlZmxhdGUucHVzaChjaHVuazEsIGZhbHNlKTtcbiAqIGRlZmxhdGUucHVzaChjaHVuazIsIHRydWUpOyAgLy8gdHJ1ZSAtPiBsYXN0IGNodW5rXG4gKlxuICogaWYgKGRlZmxhdGUuZXJyKSB7IHRocm93IG5ldyBFcnJvcihkZWZsYXRlLmVycik7IH1cbiAqXG4gKiBjb25zb2xlLmxvZyhkZWZsYXRlLnJlc3VsdCk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIERlZmxhdGUob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRGVmbGF0ZSkpIHJldHVybiBuZXcgRGVmbGF0ZShvcHRpb25zKTtcblxuICB0aGlzLm9wdGlvbnMgPSB1dGlscy5hc3NpZ24oe1xuICAgIGxldmVsOiBaX0RFRkFVTFRfQ09NUFJFU1NJT04sXG4gICAgbWV0aG9kOiBaX0RFRkxBVEVELFxuICAgIGNodW5rU2l6ZTogMTYzODQsXG4gICAgd2luZG93Qml0czogMTUsXG4gICAgbWVtTGV2ZWw6IDgsXG4gICAgc3RyYXRlZ3k6IFpfREVGQVVMVF9TVFJBVEVHWSxcbiAgICB0bzogJydcbiAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgdmFyIG9wdCA9IHRoaXMub3B0aW9ucztcblxuICBpZiAob3B0LnJhdyAmJiAob3B0LndpbmRvd0JpdHMgPiAwKSkge1xuICAgIG9wdC53aW5kb3dCaXRzID0gLW9wdC53aW5kb3dCaXRzO1xuICB9XG5cbiAgZWxzZSBpZiAob3B0Lmd6aXAgJiYgKG9wdC53aW5kb3dCaXRzID4gMCkgJiYgKG9wdC53aW5kb3dCaXRzIDwgMTYpKSB7XG4gICAgb3B0LndpbmRvd0JpdHMgKz0gMTY7XG4gIH1cblxuICB0aGlzLmVyciAgICA9IDA7ICAgICAgLy8gZXJyb3IgY29kZSwgaWYgaGFwcGVucyAoMCA9IFpfT0spXG4gIHRoaXMubXNnICAgID0gJyc7ICAgICAvLyBlcnJvciBtZXNzYWdlXG4gIHRoaXMuZW5kZWQgID0gZmFsc2U7ICAvLyB1c2VkIHRvIGF2b2lkIG11bHRpcGxlIG9uRW5kKCkgY2FsbHNcbiAgdGhpcy5jaHVua3MgPSBbXTsgICAgIC8vIGNodW5rcyBvZiBjb21wcmVzc2VkIGRhdGFcblxuICB0aGlzLnN0cm0gPSBuZXcgWlN0cmVhbSgpO1xuICB0aGlzLnN0cm0uYXZhaWxfb3V0ID0gMDtcblxuICB2YXIgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVJbml0MihcbiAgICB0aGlzLnN0cm0sXG4gICAgb3B0LmxldmVsLFxuICAgIG9wdC5tZXRob2QsXG4gICAgb3B0LndpbmRvd0JpdHMsXG4gICAgb3B0Lm1lbUxldmVsLFxuICAgIG9wdC5zdHJhdGVneVxuICApO1xuXG4gIGlmIChzdGF0dXMgIT09IFpfT0spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pO1xuICB9XG5cbiAgaWYgKG9wdC5oZWFkZXIpIHtcbiAgICB6bGliX2RlZmxhdGUuZGVmbGF0ZVNldEhlYWRlcih0aGlzLnN0cm0sIG9wdC5oZWFkZXIpO1xuICB9XG5cbiAgaWYgKG9wdC5kaWN0aW9uYXJ5KSB7XG4gICAgdmFyIGRpY3Q7XG4gICAgLy8gQ29udmVydCBkYXRhIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2Ygb3B0LmRpY3Rpb25hcnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBJZiB3ZSBuZWVkIHRvIGNvbXByZXNzIHRleHQsIGNoYW5nZSBlbmNvZGluZyB0byB1dGY4LlxuICAgICAgZGljdCA9IHN0cmluZ3Muc3RyaW5nMmJ1ZihvcHQuZGljdGlvbmFyeSk7XG4gICAgfSBlbHNlIGlmICh0b1N0cmluZy5jYWxsKG9wdC5kaWN0aW9uYXJ5KSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgICAgZGljdCA9IG5ldyBVaW50OEFycmF5KG9wdC5kaWN0aW9uYXJ5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGljdCA9IG9wdC5kaWN0aW9uYXJ5O1xuICAgIH1cblxuICAgIHN0YXR1cyA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIGRpY3QpO1xuXG4gICAgaWYgKHN0YXR1cyAhPT0gWl9PSykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kaWN0X3NldCA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWZsYXRlI3B1c2goZGF0YVssIG1vZGVdKSAtPiBCb29sZWFuXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8QXJyYXlCdWZmZXJ8U3RyaW5nKTogaW5wdXQgZGF0YS4gU3RyaW5ncyB3aWxsIGJlXG4gKiAgIGNvbnZlcnRlZCB0byB1dGY4IGJ5dGUgc2VxdWVuY2UuXG4gKiAtIG1vZGUgKE51bWJlcnxCb29sZWFuKTogMC4uNiBmb3IgY29ycmVzcG9uZGluZyBaX05PX0ZMVVNILi5aX1RSRUUgbW9kZXMuXG4gKiAgIFNlZSBjb25zdGFudHMuIFNraXBwZWQgb3IgYGZhbHNlYCBtZWFucyBaX05PX0ZMVVNILCBgdHJ1ZWAgbWVhbnMgWl9GSU5JU0guXG4gKlxuICogU2VuZHMgaW5wdXQgZGF0YSB0byBkZWZsYXRlIHBpcGUsIGdlbmVyYXRpbmcgW1tEZWZsYXRlI29uRGF0YV1dIGNhbGxzIHdpdGhcbiAqIG5ldyBjb21wcmVzc2VkIGNodW5rcy4gUmV0dXJucyBgdHJ1ZWAgb24gc3VjY2Vzcy4gVGhlIGxhc3QgZGF0YSBibG9jayBtdXN0IGhhdmVcbiAqIG1vZGUgWl9GSU5JU0ggKG9yIGB0cnVlYCkuIFRoYXQgd2lsbCBmbHVzaCBpbnRlcm5hbCBwZW5kaW5nIGJ1ZmZlcnMgYW5kIGNhbGxcbiAqIFtbRGVmbGF0ZSNvbkVuZF1dLiBGb3IgaW50ZXJpbSBleHBsaWNpdCBmbHVzaGVzICh3aXRob3V0IGVuZGluZyB0aGUgc3RyZWFtKSB5b3VcbiAqIGNhbiB1c2UgbW9kZSBaX1NZTkNfRkxVU0gsIGtlZXBpbmcgdGhlIGNvbXByZXNzaW9uIGNvbnRleHQuXG4gKlxuICogT24gZmFpbCBjYWxsIFtbRGVmbGF0ZSNvbkVuZF1dIHdpdGggZXJyb3IgY29kZSBhbmQgcmV0dXJuIGZhbHNlLlxuICpcbiAqIFdlIHN0cm9uZ2x5IHJlY29tbWVuZCB0byB1c2UgYFVpbnQ4QXJyYXlgIG9uIGlucHV0IGZvciBiZXN0IHNwZWVkIChvdXRwdXRcbiAqIGFycmF5IGZvcm1hdCBpcyBkZXRlY3RlZCBhdXRvbWF0aWNhbGx5KS4gQWxzbywgZG9uJ3Qgc2tpcCBsYXN0IHBhcmFtIGFuZCBhbHdheXNcbiAqIHVzZSB0aGUgc2FtZSB0eXBlIGluIHlvdXIgY29kZSAoYm9vbGVhbiBvciBudW1iZXIpLiBUaGF0IHdpbGwgaW1wcm92ZSBKUyBzcGVlZC5cbiAqXG4gKiBGb3IgcmVndWxhciBgQXJyYXlgLXMgbWFrZSBzdXJlIGFsbCBlbGVtZW50cyBhcmUgWzAuLjI1NV0uXG4gKlxuICogIyMjIyMgRXhhbXBsZVxuICpcbiAqIGBgYGphdmFzY3JpcHRcbiAqIHB1c2goY2h1bmssIGZhbHNlKTsgLy8gcHVzaCBvbmUgb2YgZGF0YSBjaHVua3NcbiAqIC4uLlxuICogcHVzaChjaHVuaywgdHJ1ZSk7ICAvLyBwdXNoIGxhc3QgY2h1bmtcbiAqIGBgYFxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChkYXRhLCBtb2RlKSB7XG4gIHZhciBzdHJtID0gdGhpcy5zdHJtO1xuICB2YXIgY2h1bmtTaXplID0gdGhpcy5vcHRpb25zLmNodW5rU2l6ZTtcbiAgdmFyIHN0YXR1cywgX21vZGU7XG5cbiAgaWYgKHRoaXMuZW5kZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgX21vZGUgPSAobW9kZSA9PT0gfn5tb2RlKSA/IG1vZGUgOiAoKG1vZGUgPT09IHRydWUpID8gWl9GSU5JU0ggOiBaX05PX0ZMVVNIKTtcblxuICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBJZiB3ZSBuZWVkIHRvIGNvbXByZXNzIHRleHQsIGNoYW5nZSBlbmNvZGluZyB0byB1dGY4LlxuICAgIHN0cm0uaW5wdXQgPSBzdHJpbmdzLnN0cmluZzJidWYoZGF0YSk7XG4gIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgIHN0cm0uaW5wdXQgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJtLmlucHV0ID0gZGF0YTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uYXZhaWxfaW4gPSBzdHJtLmlucHV0Lmxlbmd0aDtcblxuICBkbyB7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICBzdHJtLm91dHB1dCA9IG5ldyB1dGlscy5CdWY4KGNodW5rU2l6ZSk7XG4gICAgICBzdHJtLm5leHRfb3V0ID0gMDtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplO1xuICAgIH1cbiAgICBzdGF0dXMgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZShzdHJtLCBfbW9kZSk7ICAgIC8qIG5vIGJhZCByZXR1cm4gdmFsdWUgKi9cblxuICAgIGlmIChzdGF0dXMgIT09IFpfU1RSRUFNX0VORCAmJiBzdGF0dXMgIT09IFpfT0spIHtcbiAgICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDAgfHwgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgKF9tb2RlID09PSBaX0ZJTklTSCB8fCBfbW9kZSA9PT0gWl9TWU5DX0ZMVVNIKSkpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMub25EYXRhKHN0cmluZ3MuYnVmMmJpbnN0cmluZyh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9uRGF0YSh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gd2hpbGUgKChzdHJtLmF2YWlsX2luID4gMCB8fCBzdHJtLmF2YWlsX291dCA9PT0gMCkgJiYgc3RhdHVzICE9PSBaX1NUUkVBTV9FTkQpO1xuXG4gIC8vIEZpbmFsaXplIG9uIHRoZSBsYXN0IGNodW5rLlxuICBpZiAoX21vZGUgPT09IFpfRklOSVNIKSB7XG4gICAgc3RhdHVzID0gemxpYl9kZWZsYXRlLmRlZmxhdGVFbmQodGhpcy5zdHJtKTtcbiAgICB0aGlzLm9uRW5kKHN0YXR1cyk7XG4gICAgdGhpcy5lbmRlZCA9IHRydWU7XG4gICAgcmV0dXJuIHN0YXR1cyA9PT0gWl9PSztcbiAgfVxuXG4gIC8vIGNhbGxiYWNrIGludGVyaW0gcmVzdWx0cyBpZiBaX1NZTkNfRkxVU0guXG4gIGlmIChfbW9kZSA9PT0gWl9TWU5DX0ZMVVNIKSB7XG4gICAgdGhpcy5vbkVuZChaX09LKTtcbiAgICBzdHJtLmF2YWlsX291dCA9IDA7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuLyoqXG4gKiBEZWZsYXRlI29uRGF0YShjaHVuaykgLT4gVm9pZFxuICogLSBjaHVuayAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBvdXRwdXQgZGF0YS4gVHlwZSBvZiBhcnJheSBkZXBlbmRzXG4gKiAgIG9uIGpzIGVuZ2luZSBzdXBwb3J0LiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLCBlYWNoIGNodW5rXG4gKiAgIHdpbGwgYmUgc3RyaW5nLlxuICpcbiAqIEJ5IGRlZmF1bHQsIHN0b3JlcyBkYXRhIGJsb2NrcyBpbiBgY2h1bmtzW11gIHByb3BlcnR5IGFuZCBnbHVlXG4gKiB0aG9zZSBpbiBgb25FbmRgLiBPdmVycmlkZSB0aGlzIGhhbmRsZXIsIGlmIHlvdSBuZWVkIGFub3RoZXIgYmVoYXZpb3VyLlxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xufTtcblxuXG4vKipcbiAqIERlZmxhdGUjb25FbmQoc3RhdHVzKSAtPiBWb2lkXG4gKiAtIHN0YXR1cyAoTnVtYmVyKTogZGVmbGF0ZSBzdGF0dXMuIDAgKFpfT0spIG9uIHN1Y2Nlc3MsXG4gKiAgIG90aGVyIGlmIG5vdC5cbiAqXG4gKiBDYWxsZWQgb25jZSBhZnRlciB5b3UgdGVsbCBkZWZsYXRlIHRoYXQgdGhlIGlucHV0IHN0cmVhbSBpc1xuICogY29tcGxldGUgKFpfRklOSVNIKSBvciBzaG91bGQgYmUgZmx1c2hlZCAoWl9TWU5DX0ZMVVNIKVxuICogb3IgaWYgYW4gZXJyb3IgaGFwcGVuZWQuIEJ5IGRlZmF1bHQgLSBqb2luIGNvbGxlY3RlZCBjaHVua3MsXG4gKiBmcmVlIG1lbW9yeSBhbmQgZmlsbCBgcmVzdWx0c2AgLyBgZXJyYCBwcm9wZXJ0aWVzLlxuICoqL1xuRGVmbGF0ZS5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gIC8vIE9uIHN1Y2Nlc3MgLSBqb2luXG4gIGlmIChzdGF0dXMgPT09IFpfT0spIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpcy5yZXN1bHQgPSB0aGlzLmNodW5rcy5qb2luKCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXN1bHQgPSB1dGlscy5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5jaHVua3MgPSBbXTtcbiAgdGhpcy5lcnIgPSBzdGF0dXM7XG4gIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZztcbn07XG5cblxuLyoqXG4gKiBkZWZsYXRlKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGRlZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBDb21wcmVzcyBgZGF0YWAgd2l0aCBkZWZsYXRlIGFsZ29yaXRobSBhbmQgYG9wdGlvbnNgLlxuICpcbiAqIFN1cHBvcnRlZCBvcHRpb25zIGFyZTpcbiAqXG4gKiAtIGxldmVsXG4gKiAtIHdpbmRvd0JpdHNcbiAqIC0gbWVtTGV2ZWxcbiAqIC0gc3RyYXRlZ3lcbiAqIC0gZGljdGlvbmFyeVxuICpcbiAqIFtodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWRdKGh0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZClcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHRoZXNlLlxuICpcbiAqIFN1Z2FyIChvcHRpb25zKTpcbiAqXG4gKiAtIGByYXdgIChCb29sZWFuKSAtIHNheSB0aGF0IHdlIHdvcmsgd2l0aCByYXcgc3RyZWFtLCBpZiB5b3UgZG9uJ3Qgd2lzaCB0byBzcGVjaWZ5XG4gKiAgIG5lZ2F0aXZlIHdpbmRvd0JpdHMgaW1wbGljaXRseS5cbiAqIC0gYHRvYCAoU3RyaW5nKSAtIGlmIGVxdWFsIHRvICdzdHJpbmcnLCB0aGVuIHJlc3VsdCB3aWxsIGJlIFwiYmluYXJ5IHN0cmluZ1wiXG4gKiAgICAoZWFjaCBjaGFyIGNvZGUgWzAuLjI1NV0pXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGRhdGEgPSBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pO1xuICpcbiAqIGNvbnNvbGUubG9nKHBha28uZGVmbGF0ZShkYXRhKSk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIGRlZmxhdG9yID0gbmV3IERlZmxhdGUob3B0aW9ucyk7XG5cbiAgZGVmbGF0b3IucHVzaChpbnB1dCwgdHJ1ZSk7XG5cbiAgLy8gVGhhdCB3aWxsIG5ldmVyIGhhcHBlbnMsIGlmIHlvdSBkb24ndCBjaGVhdCB3aXRoIG9wdGlvbnMgOilcbiAgaWYgKGRlZmxhdG9yLmVycikgeyB0aHJvdyBkZWZsYXRvci5tc2cgfHwgbXNnW2RlZmxhdG9yLmVycl07IH1cblxuICByZXR1cm4gZGVmbGF0b3IucmVzdWx0O1xufVxuXG5cbi8qKlxuICogZGVmbGF0ZVJhdyhkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tkZWZsYXRlXV0sIGJ1dCBjcmVhdGVzIHJhdyBkYXRhLCB3aXRob3V0IHdyYXBwZXJcbiAqIChoZWFkZXIgYW5kIGFkbGVyMzIgY3JjKS5cbiAqKi9cbmZ1bmN0aW9uIGRlZmxhdGVSYXcoaW5wdXQsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIG9wdGlvbnMucmF3ID0gdHJ1ZTtcbiAgcmV0dXJuIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbi8qKlxuICogZ3ppcChkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBkZWZsYXRlIG9wdGlvbnMuXG4gKlxuICogVGhlIHNhbWUgYXMgW1tkZWZsYXRlXV0sIGJ1dCBjcmVhdGUgZ3ppcCB3cmFwcGVyIGluc3RlYWQgb2ZcbiAqIGRlZmxhdGUgb25lLlxuICoqL1xuZnVuY3Rpb24gZ3ppcChpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5nemlwID0gdHJ1ZTtcbiAgcmV0dXJuIGRlZmxhdGUoaW5wdXQsIG9wdGlvbnMpO1xufVxuXG5cbmV4cG9ydHMuRGVmbGF0ZSA9IERlZmxhdGU7XG5leHBvcnRzLmRlZmxhdGUgPSBkZWZsYXRlO1xuZXhwb3J0cy5kZWZsYXRlUmF3ID0gZGVmbGF0ZVJhdztcbmV4cG9ydHMuZ3ppcCA9IGd6aXA7XG4iLCIndXNlIHN0cmljdCc7XG5cblxudmFyIHpsaWJfaW5mbGF0ZSA9IHJlcXVpcmUoJy4vemxpYi9pbmZsYXRlJyk7XG52YXIgdXRpbHMgICAgICAgID0gcmVxdWlyZSgnLi91dGlscy9jb21tb24nKTtcbnZhciBzdHJpbmdzICAgICAgPSByZXF1aXJlKCcuL3V0aWxzL3N0cmluZ3MnKTtcbnZhciBjICAgICAgICAgICAgPSByZXF1aXJlKCcuL3psaWIvY29uc3RhbnRzJyk7XG52YXIgbXNnICAgICAgICAgID0gcmVxdWlyZSgnLi96bGliL21lc3NhZ2VzJyk7XG52YXIgWlN0cmVhbSAgICAgID0gcmVxdWlyZSgnLi96bGliL3pzdHJlYW0nKTtcbnZhciBHWmhlYWRlciAgICAgPSByZXF1aXJlKCcuL3psaWIvZ3poZWFkZXInKTtcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBjbGFzcyBJbmZsYXRlXG4gKlxuICogR2VuZXJpYyBKUy1zdHlsZSB3cmFwcGVyIGZvciB6bGliIGNhbGxzLiBJZiB5b3UgZG9uJ3QgbmVlZFxuICogc3RyZWFtaW5nIGJlaGF2aW91ciAtIHVzZSBtb3JlIHNpbXBsZSBmdW5jdGlvbnM6IFtbaW5mbGF0ZV1dXG4gKiBhbmQgW1tpbmZsYXRlUmF3XV0uXG4gKiovXG5cbi8qIGludGVybmFsXG4gKiBpbmZsYXRlLmNodW5rcyAtPiBBcnJheVxuICpcbiAqIENodW5rcyBvZiBvdXRwdXQgZGF0YSwgaWYgW1tJbmZsYXRlI29uRGF0YV1dIG5vdCBvdmVycmlkZGVuLlxuICoqL1xuXG4vKipcbiAqIEluZmxhdGUucmVzdWx0IC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKlxuICogVW5jb21wcmVzc2VkIHJlc3VsdCwgZ2VuZXJhdGVkIGJ5IGRlZmF1bHQgW1tJbmZsYXRlI29uRGF0YV1dXG4gKiBhbmQgW1tJbmZsYXRlI29uRW5kXV0gaGFuZGxlcnMuIEZpbGxlZCBhZnRlciB5b3UgcHVzaCBsYXN0IGNodW5rXG4gKiAoY2FsbCBbW0luZmxhdGUjcHVzaF1dIHdpdGggYFpfRklOSVNIYCAvIGB0cnVlYCBwYXJhbSkgb3IgaWYgeW91XG4gKiBwdXNoIGEgY2h1bmsgd2l0aCBleHBsaWNpdCBmbHVzaCAoY2FsbCBbW0luZmxhdGUjcHVzaF1dIHdpdGhcbiAqIGBaX1NZTkNfRkxVU0hgIHBhcmFtKS5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLmVyciAtPiBOdW1iZXJcbiAqXG4gKiBFcnJvciBjb2RlIGFmdGVyIGluZmxhdGUgZmluaXNoZWQuIDAgKFpfT0spIG9uIHN1Y2Nlc3MuXG4gKiBTaG91bGQgYmUgY2hlY2tlZCBpZiBicm9rZW4gZGF0YSBwb3NzaWJsZS5cbiAqKi9cblxuLyoqXG4gKiBJbmZsYXRlLm1zZyAtPiBTdHJpbmdcbiAqXG4gKiBFcnJvciBtZXNzYWdlLCBpZiBbW0luZmxhdGUuZXJyXV0gIT0gMFxuICoqL1xuXG5cbi8qKlxuICogbmV3IEluZmxhdGUob3B0aW9ucylcbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogQ3JlYXRlcyBuZXcgaW5mbGF0b3IgaW5zdGFuY2Ugd2l0aCBzcGVjaWZpZWQgcGFyYW1zLiBUaHJvd3MgZXhjZXB0aW9uXG4gKiBvbiBiYWQgcGFyYW1zLiBTdXBwb3J0ZWQgb3B0aW9uczpcbiAqXG4gKiAtIGB3aW5kb3dCaXRzYFxuICogLSBgZGljdGlvbmFyeWBcbiAqXG4gKiBbaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkXShodHRwOi8vemxpYi5uZXQvbWFudWFsLmh0bWwjQWR2YW5jZWQpXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvbiB0aGVzZS5cbiAqXG4gKiBBZGRpdGlvbmFsIG9wdGlvbnMsIGZvciBpbnRlcm5hbCBuZWVkczpcbiAqXG4gKiAtIGBjaHVua1NpemVgIC0gc2l6ZSBvZiBnZW5lcmF0ZWQgZGF0YSBjaHVua3MgKDE2SyBieSBkZWZhdWx0KVxuICogLSBgcmF3YCAoQm9vbGVhbikgLSBkbyByYXcgaW5mbGF0ZVxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgY29udmVydGVkXG4gKiAgIGZyb20gdXRmOCB0byB1dGYxNiAoamF2YXNjcmlwdCkgc3RyaW5nLiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLFxuICogICBjaHVuayBsZW5ndGggY2FuIGRpZmZlciBmcm9tIGBjaHVua1NpemVgLCBkZXBlbmRpbmcgb24gY29udGVudC5cbiAqXG4gKiBCeSBkZWZhdWx0LCB3aGVuIG5vIG9wdGlvbnMgc2V0LCBhdXRvZGV0ZWN0IGRlZmxhdGUvZ3ppcCBkYXRhIGZvcm1hdCB2aWFcbiAqIHdyYXBwZXIgaGVhZGVyLlxuICpcbiAqICMjIyMjIEV4YW1wbGU6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIHBha28gPSByZXF1aXJlKCdwYWtvJylcbiAqICAgLCBjaHVuazEgPSBVaW50OEFycmF5KFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiAgICwgY2h1bmsyID0gVWludDhBcnJheShbMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTldKTtcbiAqXG4gKiB2YXIgaW5mbGF0ZSA9IG5ldyBwYWtvLkluZmxhdGUoeyBsZXZlbDogM30pO1xuICpcbiAqIGluZmxhdGUucHVzaChjaHVuazEsIGZhbHNlKTtcbiAqIGluZmxhdGUucHVzaChjaHVuazIsIHRydWUpOyAgLy8gdHJ1ZSAtPiBsYXN0IGNodW5rXG4gKlxuICogaWYgKGluZmxhdGUuZXJyKSB7IHRocm93IG5ldyBFcnJvcihpbmZsYXRlLmVycik7IH1cbiAqXG4gKiBjb25zb2xlLmxvZyhpbmZsYXRlLnJlc3VsdCk7XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIEluZmxhdGUob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSW5mbGF0ZSkpIHJldHVybiBuZXcgSW5mbGF0ZShvcHRpb25zKTtcblxuICB0aGlzLm9wdGlvbnMgPSB1dGlscy5hc3NpZ24oe1xuICAgIGNodW5rU2l6ZTogMTYzODQsXG4gICAgd2luZG93Qml0czogMCxcbiAgICB0bzogJydcbiAgfSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgdmFyIG9wdCA9IHRoaXMub3B0aW9ucztcblxuICAvLyBGb3JjZSB3aW5kb3cgc2l6ZSBmb3IgYHJhd2AgZGF0YSwgaWYgbm90IHNldCBkaXJlY3RseSxcbiAgLy8gYmVjYXVzZSB3ZSBoYXZlIG5vIGhlYWRlciBmb3IgYXV0b2RldGVjdC5cbiAgaWYgKG9wdC5yYXcgJiYgKG9wdC53aW5kb3dCaXRzID49IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSkge1xuICAgIG9wdC53aW5kb3dCaXRzID0gLW9wdC53aW5kb3dCaXRzO1xuICAgIGlmIChvcHQud2luZG93Qml0cyA9PT0gMCkgeyBvcHQud2luZG93Qml0cyA9IC0xNTsgfVxuICB9XG5cbiAgLy8gSWYgYHdpbmRvd0JpdHNgIG5vdCBkZWZpbmVkIChhbmQgbW9kZSBub3QgcmF3KSAtIHNldCBhdXRvZGV0ZWN0IGZsYWcgZm9yIGd6aXAvZGVmbGF0ZVxuICBpZiAoKG9wdC53aW5kb3dCaXRzID49IDApICYmIChvcHQud2luZG93Qml0cyA8IDE2KSAmJlxuICAgICAgIShvcHRpb25zICYmIG9wdGlvbnMud2luZG93Qml0cykpIHtcbiAgICBvcHQud2luZG93Qml0cyArPSAzMjtcbiAgfVxuXG4gIC8vIEd6aXAgaGVhZGVyIGhhcyBubyBpbmZvIGFib3V0IHdpbmRvd3Mgc2l6ZSwgd2UgY2FuIGRvIGF1dG9kZXRlY3Qgb25seVxuICAvLyBmb3IgZGVmbGF0ZS4gU28sIGlmIHdpbmRvdyBzaXplIG5vdCBzZXQsIGZvcmNlIGl0IHRvIG1heCB3aGVuIGd6aXAgcG9zc2libGVcbiAgaWYgKChvcHQud2luZG93Qml0cyA+IDE1KSAmJiAob3B0LndpbmRvd0JpdHMgPCA0OCkpIHtcbiAgICAvLyBiaXQgMyAoMTYpIC0+IGd6aXBwZWQgZGF0YVxuICAgIC8vIGJpdCA0ICgzMikgLT4gYXV0b2RldGVjdCBnemlwL2RlZmxhdGVcbiAgICBpZiAoKG9wdC53aW5kb3dCaXRzICYgMTUpID09PSAwKSB7XG4gICAgICBvcHQud2luZG93Qml0cyB8PSAxNTtcbiAgICB9XG4gIH1cblxuICB0aGlzLmVyciAgICA9IDA7ICAgICAgLy8gZXJyb3IgY29kZSwgaWYgaGFwcGVucyAoMCA9IFpfT0spXG4gIHRoaXMubXNnICAgID0gJyc7ICAgICAvLyBlcnJvciBtZXNzYWdlXG4gIHRoaXMuZW5kZWQgID0gZmFsc2U7ICAvLyB1c2VkIHRvIGF2b2lkIG11bHRpcGxlIG9uRW5kKCkgY2FsbHNcbiAgdGhpcy5jaHVua3MgPSBbXTsgICAgIC8vIGNodW5rcyBvZiBjb21wcmVzc2VkIGRhdGFcblxuICB0aGlzLnN0cm0gICA9IG5ldyBaU3RyZWFtKCk7XG4gIHRoaXMuc3RybS5hdmFpbF9vdXQgPSAwO1xuXG4gIHZhciBzdGF0dXMgID0gemxpYl9pbmZsYXRlLmluZmxhdGVJbml0MihcbiAgICB0aGlzLnN0cm0sXG4gICAgb3B0LndpbmRvd0JpdHNcbiAgKTtcblxuICBpZiAoc3RhdHVzICE9PSBjLlpfT0spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnW3N0YXR1c10pO1xuICB9XG5cbiAgdGhpcy5oZWFkZXIgPSBuZXcgR1poZWFkZXIoKTtcblxuICB6bGliX2luZmxhdGUuaW5mbGF0ZUdldEhlYWRlcih0aGlzLnN0cm0sIHRoaXMuaGVhZGVyKTtcblxuICAvLyBTZXR1cCBkaWN0aW9uYXJ5XG4gIGlmIChvcHQuZGljdGlvbmFyeSkge1xuICAgIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIG9wdC5kaWN0aW9uYXJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgb3B0LmRpY3Rpb25hcnkgPSBzdHJpbmdzLnN0cmluZzJidWYob3B0LmRpY3Rpb25hcnkpO1xuICAgIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChvcHQuZGljdGlvbmFyeSkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXScpIHtcbiAgICAgIG9wdC5kaWN0aW9uYXJ5ID0gbmV3IFVpbnQ4QXJyYXkob3B0LmRpY3Rpb25hcnkpO1xuICAgIH1cbiAgICBpZiAob3B0LnJhdykgeyAvL0luIHJhdyBtb2RlIHdlIG5lZWQgdG8gc2V0IHRoZSBkaWN0aW9uYXJ5IGVhcmx5XG4gICAgICBzdGF0dXMgPSB6bGliX2luZmxhdGUuaW5mbGF0ZVNldERpY3Rpb25hcnkodGhpcy5zdHJtLCBvcHQuZGljdGlvbmFyeSk7XG4gICAgICBpZiAoc3RhdHVzICE9PSBjLlpfT0spIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZ1tzdGF0dXNdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbmZsYXRlI3B1c2goZGF0YVssIG1vZGVdKSAtPiBCb29sZWFuXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8QXJyYXlCdWZmZXJ8U3RyaW5nKTogaW5wdXQgZGF0YVxuICogLSBtb2RlIChOdW1iZXJ8Qm9vbGVhbik6IDAuLjYgZm9yIGNvcnJlc3BvbmRpbmcgWl9OT19GTFVTSC4uWl9UUkVFIG1vZGVzLlxuICogICBTZWUgY29uc3RhbnRzLiBTa2lwcGVkIG9yIGBmYWxzZWAgbWVhbnMgWl9OT19GTFVTSCwgYHRydWVgIG1lYW5zIFpfRklOSVNILlxuICpcbiAqIFNlbmRzIGlucHV0IGRhdGEgdG8gaW5mbGF0ZSBwaXBlLCBnZW5lcmF0aW5nIFtbSW5mbGF0ZSNvbkRhdGFdXSBjYWxscyB3aXRoXG4gKiBuZXcgb3V0cHV0IGNodW5rcy4gUmV0dXJucyBgdHJ1ZWAgb24gc3VjY2Vzcy4gVGhlIGxhc3QgZGF0YSBibG9jayBtdXN0IGhhdmVcbiAqIG1vZGUgWl9GSU5JU0ggKG9yIGB0cnVlYCkuIFRoYXQgd2lsbCBmbHVzaCBpbnRlcm5hbCBwZW5kaW5nIGJ1ZmZlcnMgYW5kIGNhbGxcbiAqIFtbSW5mbGF0ZSNvbkVuZF1dLiBGb3IgaW50ZXJpbSBleHBsaWNpdCBmbHVzaGVzICh3aXRob3V0IGVuZGluZyB0aGUgc3RyZWFtKSB5b3VcbiAqIGNhbiB1c2UgbW9kZSBaX1NZTkNfRkxVU0gsIGtlZXBpbmcgdGhlIGRlY29tcHJlc3Npb24gY29udGV4dC5cbiAqXG4gKiBPbiBmYWlsIGNhbGwgW1tJbmZsYXRlI29uRW5kXV0gd2l0aCBlcnJvciBjb2RlIGFuZCByZXR1cm4gZmFsc2UuXG4gKlxuICogV2Ugc3Ryb25nbHkgcmVjb21tZW5kIHRvIHVzZSBgVWludDhBcnJheWAgb24gaW5wdXQgZm9yIGJlc3Qgc3BlZWQgKG91dHB1dFxuICogZm9ybWF0IGlzIGRldGVjdGVkIGF1dG9tYXRpY2FsbHkpLiBBbHNvLCBkb24ndCBza2lwIGxhc3QgcGFyYW0gYW5kIGFsd2F5c1xuICogdXNlIHRoZSBzYW1lIHR5cGUgaW4geW91ciBjb2RlIChib29sZWFuIG9yIG51bWJlcikuIFRoYXQgd2lsbCBpbXByb3ZlIEpTIHNwZWVkLlxuICpcbiAqIEZvciByZWd1bGFyIGBBcnJheWAtcyBtYWtlIHN1cmUgYWxsIGVsZW1lbnRzIGFyZSBbMC4uMjU1XS5cbiAqXG4gKiAjIyMjIyBFeGFtcGxlXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogcHVzaChjaHVuaywgZmFsc2UpOyAvLyBwdXNoIG9uZSBvZiBkYXRhIGNodW5rc1xuICogLi4uXG4gKiBwdXNoKGNodW5rLCB0cnVlKTsgIC8vIHB1c2ggbGFzdCBjaHVua1xuICogYGBgXG4gKiovXG5JbmZsYXRlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGRhdGEsIG1vZGUpIHtcbiAgdmFyIHN0cm0gPSB0aGlzLnN0cm07XG4gIHZhciBjaHVua1NpemUgPSB0aGlzLm9wdGlvbnMuY2h1bmtTaXplO1xuICB2YXIgZGljdGlvbmFyeSA9IHRoaXMub3B0aW9ucy5kaWN0aW9uYXJ5O1xuICB2YXIgc3RhdHVzLCBfbW9kZTtcbiAgdmFyIG5leHRfb3V0X3V0ZjgsIHRhaWwsIHV0ZjhzdHI7XG5cbiAgLy8gRmxhZyB0byBwcm9wZXJseSBwcm9jZXNzIFpfQlVGX0VSUk9SIG9uIHRlc3RpbmcgaW5mbGF0ZSBjYWxsXG4gIC8vIHdoZW4gd2UgY2hlY2sgdGhhdCBhbGwgb3V0cHV0IGRhdGEgd2FzIGZsdXNoZWQuXG4gIHZhciBhbGxvd0J1ZkVycm9yID0gZmFsc2U7XG5cbiAgaWYgKHRoaXMuZW5kZWQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gIF9tb2RlID0gKG1vZGUgPT09IH5+bW9kZSkgPyBtb2RlIDogKChtb2RlID09PSB0cnVlKSA/IGMuWl9GSU5JU0ggOiBjLlpfTk9fRkxVU0gpO1xuXG4gIC8vIENvbnZlcnQgZGF0YSBpZiBuZWVkZWRcbiAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgIC8vIE9ubHkgYmluYXJ5IHN0cmluZ3MgY2FuIGJlIGRlY29tcHJlc3NlZCBvbiBwcmFjdGljZVxuICAgIHN0cm0uaW5wdXQgPSBzdHJpbmdzLmJpbnN0cmluZzJidWYoZGF0YSk7XG4gIH0gZWxzZSBpZiAodG9TdHJpbmcuY2FsbChkYXRhKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgIHN0cm0uaW5wdXQgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJtLmlucHV0ID0gZGF0YTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uYXZhaWxfaW4gPSBzdHJtLmlucHV0Lmxlbmd0aDtcblxuICBkbyB7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICBzdHJtLm91dHB1dCA9IG5ldyB1dGlscy5CdWY4KGNodW5rU2l6ZSk7XG4gICAgICBzdHJtLm5leHRfb3V0ID0gMDtcbiAgICAgIHN0cm0uYXZhaWxfb3V0ID0gY2h1bmtTaXplO1xuICAgIH1cblxuICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlKHN0cm0sIGMuWl9OT19GTFVTSCk7ICAgIC8qIG5vIGJhZCByZXR1cm4gdmFsdWUgKi9cblxuICAgIGlmIChzdGF0dXMgPT09IGMuWl9ORUVEX0RJQ1QgJiYgZGljdGlvbmFyeSkge1xuICAgICAgc3RhdHVzID0gemxpYl9pbmZsYXRlLmluZmxhdGVTZXREaWN0aW9uYXJ5KHRoaXMuc3RybSwgZGljdGlvbmFyeSk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyA9PT0gYy5aX0JVRl9FUlJPUiAmJiBhbGxvd0J1ZkVycm9yID09PSB0cnVlKSB7XG4gICAgICBzdGF0dXMgPSBjLlpfT0s7XG4gICAgICBhbGxvd0J1ZkVycm9yID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyAhPT0gYy5aX1NUUkVBTV9FTkQgJiYgc3RhdHVzICE9PSBjLlpfT0spIHtcbiAgICAgIHRoaXMub25FbmQoc3RhdHVzKTtcbiAgICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzdHJtLm5leHRfb3V0KSB7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDAgfHwgc3RhdHVzID09PSBjLlpfU1RSRUFNX0VORCB8fCAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiAoX21vZGUgPT09IGMuWl9GSU5JU0ggfHwgX21vZGUgPT09IGMuWl9TWU5DX0ZMVVNIKSkpIHtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRvID09PSAnc3RyaW5nJykge1xuXG4gICAgICAgICAgbmV4dF9vdXRfdXRmOCA9IHN0cmluZ3MudXRmOGJvcmRlcihzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCk7XG5cbiAgICAgICAgICB0YWlsID0gc3RybS5uZXh0X291dCAtIG5leHRfb3V0X3V0Zjg7XG4gICAgICAgICAgdXRmOHN0ciA9IHN0cmluZ3MuYnVmMnN0cmluZyhzdHJtLm91dHB1dCwgbmV4dF9vdXRfdXRmOCk7XG5cbiAgICAgICAgICAvLyBtb3ZlIHRhaWxcbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gdGFpbDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGNodW5rU2l6ZSAtIHRhaWw7XG4gICAgICAgICAgaWYgKHRhaWwpIHsgdXRpbHMuYXJyYXlTZXQoc3RybS5vdXRwdXQsIHN0cm0ub3V0cHV0LCBuZXh0X291dF91dGY4LCB0YWlsLCAwKTsgfVxuXG4gICAgICAgICAgdGhpcy5vbkRhdGEodXRmOHN0cik7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9uRGF0YSh1dGlscy5zaHJpbmtCdWYoc3RybS5vdXRwdXQsIHN0cm0ubmV4dF9vdXQpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdoZW4gbm8gbW9yZSBpbnB1dCBkYXRhLCB3ZSBzaG91bGQgY2hlY2sgdGhhdCBpbnRlcm5hbCBpbmZsYXRlIGJ1ZmZlcnNcbiAgICAvLyBhcmUgZmx1c2hlZC4gVGhlIG9ubHkgd2F5IHRvIGRvIGl0IHdoZW4gYXZhaWxfb3V0ID0gMCAtIHJ1biBvbmUgbW9yZVxuICAgIC8vIGluZmxhdGUgcGFzcy4gQnV0IGlmIG91dHB1dCBkYXRhIG5vdCBleGlzdHMsIGluZmxhdGUgcmV0dXJuIFpfQlVGX0VSUk9SLlxuICAgIC8vIEhlcmUgd2Ugc2V0IGZsYWcgdG8gcHJvY2VzcyB0aGlzIGVycm9yIHByb3Blcmx5LlxuICAgIC8vXG4gICAgLy8gTk9URS4gRGVmbGF0ZSBkb2VzIG5vdCByZXR1cm4gZXJyb3IgaW4gdGhpcyBjYXNlIGFuZCBkb2VzIG5vdCBuZWVkcyBzdWNoXG4gICAgLy8gbG9naWMuXG4gICAgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIGFsbG93QnVmRXJyb3IgPSB0cnVlO1xuICAgIH1cblxuICB9IHdoaWxlICgoc3RybS5hdmFpbF9pbiA+IDAgfHwgc3RybS5hdmFpbF9vdXQgPT09IDApICYmIHN0YXR1cyAhPT0gYy5aX1NUUkVBTV9FTkQpO1xuXG4gIGlmIChzdGF0dXMgPT09IGMuWl9TVFJFQU1fRU5EKSB7XG4gICAgX21vZGUgPSBjLlpfRklOSVNIO1xuICB9XG5cbiAgLy8gRmluYWxpemUgb24gdGhlIGxhc3QgY2h1bmsuXG4gIGlmIChfbW9kZSA9PT0gYy5aX0ZJTklTSCkge1xuICAgIHN0YXR1cyA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlRW5kKHRoaXMuc3RybSk7XG4gICAgdGhpcy5vbkVuZChzdGF0dXMpO1xuICAgIHRoaXMuZW5kZWQgPSB0cnVlO1xuICAgIHJldHVybiBzdGF0dXMgPT09IGMuWl9PSztcbiAgfVxuXG4gIC8vIGNhbGxiYWNrIGludGVyaW0gcmVzdWx0cyBpZiBaX1NZTkNfRkxVU0guXG4gIGlmIChfbW9kZSA9PT0gYy5aX1NZTkNfRkxVU0gpIHtcbiAgICB0aGlzLm9uRW5kKGMuWl9PSyk7XG4gICAgc3RybS5hdmFpbF9vdXQgPSAwO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5cbi8qKlxuICogSW5mbGF0ZSNvbkRhdGEoY2h1bmspIC0+IFZvaWRcbiAqIC0gY2h1bmsgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogb3V0cHV0IGRhdGEuIFR5cGUgb2YgYXJyYXkgZGVwZW5kc1xuICogICBvbiBqcyBlbmdpbmUgc3VwcG9ydC4gV2hlbiBzdHJpbmcgb3V0cHV0IHJlcXVlc3RlZCwgZWFjaCBjaHVua1xuICogICB3aWxsIGJlIHN0cmluZy5cbiAqXG4gKiBCeSBkZWZhdWx0LCBzdG9yZXMgZGF0YSBibG9ja3MgaW4gYGNodW5rc1tdYCBwcm9wZXJ0eSBhbmQgZ2x1ZVxuICogdGhvc2UgaW4gYG9uRW5kYC4gT3ZlcnJpZGUgdGhpcyBoYW5kbGVyLCBpZiB5b3UgbmVlZCBhbm90aGVyIGJlaGF2aW91ci5cbiAqKi9cbkluZmxhdGUucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICB0aGlzLmNodW5rcy5wdXNoKGNodW5rKTtcbn07XG5cblxuLyoqXG4gKiBJbmZsYXRlI29uRW5kKHN0YXR1cykgLT4gVm9pZFxuICogLSBzdGF0dXMgKE51bWJlcik6IGluZmxhdGUgc3RhdHVzLiAwIChaX09LKSBvbiBzdWNjZXNzLFxuICogICBvdGhlciBpZiBub3QuXG4gKlxuICogQ2FsbGVkIGVpdGhlciBhZnRlciB5b3UgdGVsbCBpbmZsYXRlIHRoYXQgdGhlIGlucHV0IHN0cmVhbSBpc1xuICogY29tcGxldGUgKFpfRklOSVNIKSBvciBzaG91bGQgYmUgZmx1c2hlZCAoWl9TWU5DX0ZMVVNIKVxuICogb3IgaWYgYW4gZXJyb3IgaGFwcGVuZWQuIEJ5IGRlZmF1bHQgLSBqb2luIGNvbGxlY3RlZCBjaHVua3MsXG4gKiBmcmVlIG1lbW9yeSBhbmQgZmlsbCBgcmVzdWx0c2AgLyBgZXJyYCBwcm9wZXJ0aWVzLlxuICoqL1xuSW5mbGF0ZS5wcm90b3R5cGUub25FbmQgPSBmdW5jdGlvbiAoc3RhdHVzKSB7XG4gIC8vIE9uIHN1Y2Nlc3MgLSBqb2luXG4gIGlmIChzdGF0dXMgPT09IGMuWl9PSykge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBHbHVlICYgY29udmVydCBoZXJlLCB1bnRpbCB3ZSB0ZWFjaCBwYWtvIHRvIHNlbmRcbiAgICAgIC8vIHV0ZjggYWxpZ25lZCBzdHJpbmdzIHRvIG9uRGF0YVxuICAgICAgdGhpcy5yZXN1bHQgPSB0aGlzLmNodW5rcy5qb2luKCcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXN1bHQgPSB1dGlscy5mbGF0dGVuQ2h1bmtzKHRoaXMuY2h1bmtzKTtcbiAgICB9XG4gIH1cbiAgdGhpcy5jaHVua3MgPSBbXTtcbiAgdGhpcy5lcnIgPSBzdGF0dXM7XG4gIHRoaXMubXNnID0gdGhpcy5zdHJtLm1zZztcbn07XG5cblxuLyoqXG4gKiBpbmZsYXRlKGRhdGFbLCBvcHRpb25zXSkgLT4gVWludDhBcnJheXxBcnJheXxTdHJpbmdcbiAqIC0gZGF0YSAoVWludDhBcnJheXxBcnJheXxTdHJpbmcpOiBpbnB1dCBkYXRhIHRvIGRlY29tcHJlc3MuXG4gKiAtIG9wdGlvbnMgKE9iamVjdCk6IHpsaWIgaW5mbGF0ZSBvcHRpb25zLlxuICpcbiAqIERlY29tcHJlc3MgYGRhdGFgIHdpdGggaW5mbGF0ZS91bmd6aXAgYW5kIGBvcHRpb25zYC4gQXV0b2RldGVjdFxuICogZm9ybWF0IHZpYSB3cmFwcGVyIGhlYWRlciBieSBkZWZhdWx0LiBUaGF0J3Mgd2h5IHdlIGRvbid0IHByb3ZpZGVcbiAqIHNlcGFyYXRlIGB1bmd6aXBgIG1ldGhvZC5cbiAqXG4gKiBTdXBwb3J0ZWQgb3B0aW9ucyBhcmU6XG4gKlxuICogLSB3aW5kb3dCaXRzXG4gKlxuICogW2h0dHA6Ly96bGliLm5ldC9tYW51YWwuaHRtbCNBZHZhbmNlZF0oaHR0cDovL3psaWIubmV0L21hbnVhbC5odG1sI0FkdmFuY2VkKVxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogU3VnYXIgKG9wdGlvbnMpOlxuICpcbiAqIC0gYHJhd2AgKEJvb2xlYW4pIC0gc2F5IHRoYXQgd2Ugd29yayB3aXRoIHJhdyBzdHJlYW0sIGlmIHlvdSBkb24ndCB3aXNoIHRvIHNwZWNpZnlcbiAqICAgbmVnYXRpdmUgd2luZG93Qml0cyBpbXBsaWNpdGx5LlxuICogLSBgdG9gIChTdHJpbmcpIC0gaWYgZXF1YWwgdG8gJ3N0cmluZycsIHRoZW4gcmVzdWx0IHdpbGwgYmUgY29udmVydGVkXG4gKiAgIGZyb20gdXRmOCB0byB1dGYxNiAoamF2YXNjcmlwdCkgc3RyaW5nLiBXaGVuIHN0cmluZyBvdXRwdXQgcmVxdWVzdGVkLFxuICogICBjaHVuayBsZW5ndGggY2FuIGRpZmZlciBmcm9tIGBjaHVua1NpemVgLCBkZXBlbmRpbmcgb24gY29udGVudC5cbiAqXG4gKlxuICogIyMjIyMgRXhhbXBsZTpcbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiB2YXIgcGFrbyA9IHJlcXVpcmUoJ3Bha28nKVxuICogICAsIGlucHV0ID0gcGFrby5kZWZsYXRlKFsxLDIsMyw0LDUsNiw3LDgsOV0pXG4gKiAgICwgb3V0cHV0O1xuICpcbiAqIHRyeSB7XG4gKiAgIG91dHB1dCA9IHBha28uaW5mbGF0ZShpbnB1dCk7XG4gKiB9IGNhdGNoIChlcnIpXG4gKiAgIGNvbnNvbGUubG9nKGVycik7XG4gKiB9XG4gKiBgYGBcbiAqKi9cbmZ1bmN0aW9uIGluZmxhdGUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgdmFyIGluZmxhdG9yID0gbmV3IEluZmxhdGUob3B0aW9ucyk7XG5cbiAgaW5mbGF0b3IucHVzaChpbnB1dCwgdHJ1ZSk7XG5cbiAgLy8gVGhhdCB3aWxsIG5ldmVyIGhhcHBlbnMsIGlmIHlvdSBkb24ndCBjaGVhdCB3aXRoIG9wdGlvbnMgOilcbiAgaWYgKGluZmxhdG9yLmVycikgeyB0aHJvdyBpbmZsYXRvci5tc2cgfHwgbXNnW2luZmxhdG9yLmVycl07IH1cblxuICByZXR1cm4gaW5mbGF0b3IucmVzdWx0O1xufVxuXG5cbi8qKlxuICogaW5mbGF0ZVJhdyhkYXRhWywgb3B0aW9uc10pIC0+IFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nXG4gKiAtIGRhdGEgKFVpbnQ4QXJyYXl8QXJyYXl8U3RyaW5nKTogaW5wdXQgZGF0YSB0byBkZWNvbXByZXNzLlxuICogLSBvcHRpb25zIChPYmplY3QpOiB6bGliIGluZmxhdGUgb3B0aW9ucy5cbiAqXG4gKiBUaGUgc2FtZSBhcyBbW2luZmxhdGVdXSwgYnV0IGNyZWF0ZXMgcmF3IGRhdGEsIHdpdGhvdXQgd3JhcHBlclxuICogKGhlYWRlciBhbmQgYWRsZXIzMiBjcmMpLlxuICoqL1xuZnVuY3Rpb24gaW5mbGF0ZVJhdyhpbnB1dCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgb3B0aW9ucy5yYXcgPSB0cnVlO1xuICByZXR1cm4gaW5mbGF0ZShpbnB1dCwgb3B0aW9ucyk7XG59XG5cblxuLyoqXG4gKiB1bmd6aXAoZGF0YVssIG9wdGlvbnNdKSAtPiBVaW50OEFycmF5fEFycmF5fFN0cmluZ1xuICogLSBkYXRhIChVaW50OEFycmF5fEFycmF5fFN0cmluZyk6IGlucHV0IGRhdGEgdG8gZGVjb21wcmVzcy5cbiAqIC0gb3B0aW9ucyAoT2JqZWN0KTogemxpYiBpbmZsYXRlIG9wdGlvbnMuXG4gKlxuICogSnVzdCBzaG9ydGN1dCB0byBbW2luZmxhdGVdXSwgYmVjYXVzZSBpdCBhdXRvZGV0ZWN0cyBmb3JtYXRcbiAqIGJ5IGhlYWRlci5jb250ZW50LiBEb25lIGZvciBjb252ZW5pZW5jZS5cbiAqKi9cblxuXG5leHBvcnRzLkluZmxhdGUgPSBJbmZsYXRlO1xuZXhwb3J0cy5pbmZsYXRlID0gaW5mbGF0ZTtcbmV4cG9ydHMuaW5mbGF0ZVJhdyA9IGluZmxhdGVSYXc7XG5leHBvcnRzLnVuZ3ppcCAgPSBpbmZsYXRlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBUWVBFRF9PSyA9ICAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2YgVWludDE2QXJyYXkgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2YgSW50MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcpO1xuXG5mdW5jdGlvbiBfaGFzKG9iaiwga2V5KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufVxuXG5leHBvcnRzLmFzc2lnbiA9IGZ1bmN0aW9uIChvYmogLypmcm9tMSwgZnJvbTIsIGZyb20zLCAuLi4qLykge1xuICB2YXIgc291cmNlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHdoaWxlIChzb3VyY2VzLmxlbmd0aCkge1xuICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzLnNoaWZ0KCk7XG4gICAgaWYgKCFzb3VyY2UpIHsgY29udGludWU7IH1cblxuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzb3VyY2UgKyAnbXVzdCBiZSBub24tb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcCBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChfaGFzKHNvdXJjZSwgcCkpIHtcbiAgICAgICAgb2JqW3BdID0gc291cmNlW3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG5cbi8vIHJlZHVjZSBidWZmZXIgc2l6ZSwgYXZvaWRpbmcgbWVtIGNvcHlcbmV4cG9ydHMuc2hyaW5rQnVmID0gZnVuY3Rpb24gKGJ1Ziwgc2l6ZSkge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gc2l6ZSkgeyByZXR1cm4gYnVmOyB9XG4gIGlmIChidWYuc3ViYXJyYXkpIHsgcmV0dXJuIGJ1Zi5zdWJhcnJheSgwLCBzaXplKTsgfVxuICBidWYubGVuZ3RoID0gc2l6ZTtcbiAgcmV0dXJuIGJ1Zjtcbn07XG5cblxudmFyIGZuVHlwZWQgPSB7XG4gIGFycmF5U2V0OiBmdW5jdGlvbiAoZGVzdCwgc3JjLCBzcmNfb2ZmcywgbGVuLCBkZXN0X29mZnMpIHtcbiAgICBpZiAoc3JjLnN1YmFycmF5ICYmIGRlc3Quc3ViYXJyYXkpIHtcbiAgICAgIGRlc3Quc2V0KHNyYy5zdWJhcnJheShzcmNfb2Zmcywgc3JjX29mZnMgKyBsZW4pLCBkZXN0X29mZnMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBGYWxsYmFjayB0byBvcmRpbmFyeSBhcnJheVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RbZGVzdF9vZmZzICsgaV0gPSBzcmNbc3JjX29mZnMgKyBpXTtcbiAgICB9XG4gIH0sXG4gIC8vIEpvaW4gYXJyYXkgb2YgY2h1bmtzIHRvIHNpbmdsZSBhcnJheS5cbiAgZmxhdHRlbkNodW5rczogZnVuY3Rpb24gKGNodW5rcykge1xuICAgIHZhciBpLCBsLCBsZW4sIHBvcywgY2h1bmssIHJlc3VsdDtcblxuICAgIC8vIGNhbGN1bGF0ZSBkYXRhIGxlbmd0aFxuICAgIGxlbiA9IDA7XG4gICAgZm9yIChpID0gMCwgbCA9IGNodW5rcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGxlbiArPSBjaHVua3NbaV0ubGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIGpvaW4gY2h1bmtzXG4gICAgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICBwb3MgPSAwO1xuICAgIGZvciAoaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjaHVuayA9IGNodW5rc1tpXTtcbiAgICAgIHJlc3VsdC5zZXQoY2h1bmssIHBvcyk7XG4gICAgICBwb3MgKz0gY2h1bmsubGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbnZhciBmblVudHlwZWQgPSB7XG4gIGFycmF5U2V0OiBmdW5jdGlvbiAoZGVzdCwgc3JjLCBzcmNfb2ZmcywgbGVuLCBkZXN0X29mZnMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0W2Rlc3Rfb2ZmcyArIGldID0gc3JjW3NyY19vZmZzICsgaV07XG4gICAgfVxuICB9LFxuICAvLyBKb2luIGFycmF5IG9mIGNodW5rcyB0byBzaW5nbGUgYXJyYXkuXG4gIGZsYXR0ZW5DaHVua3M6IGZ1bmN0aW9uIChjaHVua3MpIHtcbiAgICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCBjaHVua3MpO1xuICB9XG59O1xuXG5cbi8vIEVuYWJsZS9EaXNhYmxlIHR5cGVkIGFycmF5cyB1c2UsIGZvciB0ZXN0aW5nXG4vL1xuZXhwb3J0cy5zZXRUeXBlZCA9IGZ1bmN0aW9uIChvbikge1xuICBpZiAob24pIHtcbiAgICBleHBvcnRzLkJ1ZjggID0gVWludDhBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjE2ID0gVWludDE2QXJyYXk7XG4gICAgZXhwb3J0cy5CdWYzMiA9IEludDMyQXJyYXk7XG4gICAgZXhwb3J0cy5hc3NpZ24oZXhwb3J0cywgZm5UeXBlZCk7XG4gIH0gZWxzZSB7XG4gICAgZXhwb3J0cy5CdWY4ICA9IEFycmF5O1xuICAgIGV4cG9ydHMuQnVmMTYgPSBBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjMyID0gQXJyYXk7XG4gICAgZXhwb3J0cy5hc3NpZ24oZXhwb3J0cywgZm5VbnR5cGVkKTtcbiAgfVxufTtcblxuZXhwb3J0cy5zZXRUeXBlZChUWVBFRF9PSyk7XG4iLCIvLyBTdHJpbmcgZW5jb2RlL2RlY29kZSBoZWxwZXJzXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi9jb21tb24nKTtcblxuXG4vLyBRdWljayBjaGVjayBpZiB3ZSBjYW4gdXNlIGZhc3QgYXJyYXkgdG8gYmluIHN0cmluZyBjb252ZXJzaW9uXG4vL1xuLy8gLSBhcHBseShBcnJheSkgY2FuIGZhaWwgb24gQW5kcm9pZCAyLjJcbi8vIC0gYXBwbHkoVWludDhBcnJheSkgY2FuIGZhaWwgb24gaU9TIDUuMSBTYWZhcmlcbi8vXG52YXIgU1RSX0FQUExZX09LID0gdHJ1ZTtcbnZhciBTVFJfQVBQTFlfVUlBX09LID0gdHJ1ZTtcblxudHJ5IHsgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBbIDAgXSk7IH0gY2F0Y2ggKF9fKSB7IFNUUl9BUFBMWV9PSyA9IGZhbHNlOyB9XG50cnkgeyBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KDEpKTsgfSBjYXRjaCAoX18pIHsgU1RSX0FQUExZX1VJQV9PSyA9IGZhbHNlOyB9XG5cblxuLy8gVGFibGUgd2l0aCB1dGY4IGxlbmd0aHMgKGNhbGN1bGF0ZWQgYnkgZmlyc3QgYnl0ZSBvZiBzZXF1ZW5jZSlcbi8vIE5vdGUsIHRoYXQgNSAmIDYtYnl0ZSB2YWx1ZXMgYW5kIHNvbWUgNC1ieXRlIHZhbHVlcyBjYW4gbm90IGJlIHJlcHJlc2VudGVkIGluIEpTLFxuLy8gYmVjYXVzZSBtYXggcG9zc2libGUgY29kZXBvaW50IGlzIDB4MTBmZmZmXG52YXIgX3V0ZjhsZW4gPSBuZXcgdXRpbHMuQnVmOCgyNTYpO1xuZm9yICh2YXIgcSA9IDA7IHEgPCAyNTY7IHErKykge1xuICBfdXRmOGxlbltxXSA9IChxID49IDI1MiA/IDYgOiBxID49IDI0OCA/IDUgOiBxID49IDI0MCA/IDQgOiBxID49IDIyNCA/IDMgOiBxID49IDE5MiA/IDIgOiAxKTtcbn1cbl91dGY4bGVuWzI1NF0gPSBfdXRmOGxlblsyNTRdID0gMTsgLy8gSW52YWxpZCBzZXF1ZW5jZSBzdGFydFxuXG5cbi8vIGNvbnZlcnQgc3RyaW5nIHRvIGFycmF5ICh0eXBlZCwgd2hlbiBwb3NzaWJsZSlcbmV4cG9ydHMuc3RyaW5nMmJ1ZiA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgdmFyIGJ1ZiwgYywgYzIsIG1fcG9zLCBpLCBzdHJfbGVuID0gc3RyLmxlbmd0aCwgYnVmX2xlbiA9IDA7XG5cbiAgLy8gY291bnQgYmluYXJ5IHNpemVcbiAgZm9yIChtX3BvcyA9IDA7IG1fcG9zIDwgc3RyX2xlbjsgbV9wb3MrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChtX3Bvcyk7XG4gICAgaWYgKChjICYgMHhmYzAwKSA9PT0gMHhkODAwICYmIChtX3BvcyArIDEgPCBzdHJfbGVuKSkge1xuICAgICAgYzIgPSBzdHIuY2hhckNvZGVBdChtX3BvcyArIDEpO1xuICAgICAgaWYgKChjMiAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkge1xuICAgICAgICBjID0gMHgxMDAwMCArICgoYyAtIDB4ZDgwMCkgPDwgMTApICsgKGMyIC0gMHhkYzAwKTtcbiAgICAgICAgbV9wb3MrKztcbiAgICAgIH1cbiAgICB9XG4gICAgYnVmX2xlbiArPSBjIDwgMHg4MCA/IDEgOiBjIDwgMHg4MDAgPyAyIDogYyA8IDB4MTAwMDAgPyAzIDogNDtcbiAgfVxuXG4gIC8vIGFsbG9jYXRlIGJ1ZmZlclxuICBidWYgPSBuZXcgdXRpbHMuQnVmOChidWZfbGVuKTtcblxuICAvLyBjb252ZXJ0XG4gIGZvciAoaSA9IDAsIG1fcG9zID0gMDsgaSA8IGJ1Zl9sZW47IG1fcG9zKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQobV9wb3MpO1xuICAgIGlmICgoYyAmIDB4ZmMwMCkgPT09IDB4ZDgwMCAmJiAobV9wb3MgKyAxIDwgc3RyX2xlbikpIHtcbiAgICAgIGMyID0gc3RyLmNoYXJDb2RlQXQobV9wb3MgKyAxKTtcbiAgICAgIGlmICgoYzIgJiAweGZjMDApID09PSAweGRjMDApIHtcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoKGMgLSAweGQ4MDApIDw8IDEwKSArIChjMiAtIDB4ZGMwMCk7XG4gICAgICAgIG1fcG9zKys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjIDwgMHg4MCkge1xuICAgICAgLyogb25lIGJ5dGUgKi9cbiAgICAgIGJ1ZltpKytdID0gYztcbiAgICB9IGVsc2UgaWYgKGMgPCAweDgwMCkge1xuICAgICAgLyogdHdvIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4QzAgfCAoYyA+Pj4gNik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH0gZWxzZSBpZiAoYyA8IDB4MTAwMDApIHtcbiAgICAgIC8qIHRocmVlIGJ5dGVzICovXG4gICAgICBidWZbaSsrXSA9IDB4RTAgfCAoYyA+Pj4gMTIpO1xuICAgICAgYnVmW2krK10gPSAweDgwIHwgKGMgPj4+IDYgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjICYgMHgzZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIGZvdXIgYnl0ZXMgKi9cbiAgICAgIGJ1ZltpKytdID0gMHhmMCB8IChjID4+PiAxOCk7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyA+Pj4gMTIgJiAweDNmKTtcbiAgICAgIGJ1ZltpKytdID0gMHg4MCB8IChjID4+PiA2ICYgMHgzZik7XG4gICAgICBidWZbaSsrXSA9IDB4ODAgfCAoYyAmIDB4M2YpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWY7XG59O1xuXG4vLyBIZWxwZXIgKHVzZWQgaW4gMiBwbGFjZXMpXG5mdW5jdGlvbiBidWYyYmluc3RyaW5nKGJ1ZiwgbGVuKSB7XG4gIC8vIE9uIENocm9tZSwgdGhlIGFyZ3VtZW50cyBpbiBhIGZ1bmN0aW9uIGNhbGwgdGhhdCBhcmUgYWxsb3dlZCBpcyBgNjU1MzRgLlxuICAvLyBJZiB0aGUgbGVuZ3RoIG9mIHRoZSBidWZmZXIgaXMgc21hbGxlciB0aGFuIHRoYXQsIHdlIGNhbiB1c2UgdGhpcyBvcHRpbWl6YXRpb24sXG4gIC8vIG90aGVyd2lzZSB3ZSB3aWxsIHRha2UgYSBzbG93ZXIgcGF0aC5cbiAgaWYgKGxlbiA8IDY1NTM0KSB7XG4gICAgaWYgKChidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX1VJQV9PSykgfHwgKCFidWYuc3ViYXJyYXkgJiYgU1RSX0FQUExZX09LKSkge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgdXRpbHMuc2hyaW5rQnVmKGJ1ZiwgbGVuKSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHJlc3VsdCA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcmVzdWx0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbi8vIENvbnZlcnQgYnl0ZSBhcnJheSB0byBiaW5hcnkgc3RyaW5nXG5leHBvcnRzLmJ1ZjJiaW5zdHJpbmcgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIHJldHVybiBidWYyYmluc3RyaW5nKGJ1ZiwgYnVmLmxlbmd0aCk7XG59O1xuXG5cbi8vIENvbnZlcnQgYmluYXJ5IHN0cmluZyAodHlwZWQsIHdoZW4gcG9zc2libGUpXG5leHBvcnRzLmJpbnN0cmluZzJidWYgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHZhciBidWYgPSBuZXcgdXRpbHMuQnVmOChzdHIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGJ1Zi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGJ1ZltpXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBidWY7XG59O1xuXG5cbi8vIGNvbnZlcnQgYXJyYXkgdG8gc3RyaW5nXG5leHBvcnRzLmJ1ZjJzdHJpbmcgPSBmdW5jdGlvbiAoYnVmLCBtYXgpIHtcbiAgdmFyIGksIG91dCwgYywgY19sZW47XG4gIHZhciBsZW4gPSBtYXggfHwgYnVmLmxlbmd0aDtcblxuICAvLyBSZXNlcnZlIG1heCBwb3NzaWJsZSBsZW5ndGggKDIgd29yZHMgcGVyIGNoYXIpXG4gIC8vIE5COiBieSB1bmtub3duIHJlYXNvbnMsIEFycmF5IGlzIHNpZ25pZmljYW50bHkgZmFzdGVyIGZvclxuICAvLyAgICAgU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseSB0aGFuIFVpbnQxNkFycmF5LlxuICB2YXIgdXRmMTZidWYgPSBuZXcgQXJyYXkobGVuICogMik7XG5cbiAgZm9yIChvdXQgPSAwLCBpID0gMDsgaSA8IGxlbjspIHtcbiAgICBjID0gYnVmW2krK107XG4gICAgLy8gcXVpY2sgcHJvY2VzcyBhc2NpaVxuICAgIGlmIChjIDwgMHg4MCkgeyB1dGYxNmJ1ZltvdXQrK10gPSBjOyBjb250aW51ZTsgfVxuXG4gICAgY19sZW4gPSBfdXRmOGxlbltjXTtcbiAgICAvLyBza2lwIDUgJiA2IGJ5dGUgY29kZXNcbiAgICBpZiAoY19sZW4gPiA0KSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgaSArPSBjX2xlbiAtIDE7IGNvbnRpbnVlOyB9XG5cbiAgICAvLyBhcHBseSBtYXNrIG9uIGZpcnN0IGJ5dGVcbiAgICBjICY9IGNfbGVuID09PSAyID8gMHgxZiA6IGNfbGVuID09PSAzID8gMHgwZiA6IDB4MDc7XG4gICAgLy8gam9pbiB0aGUgcmVzdFxuICAgIHdoaWxlIChjX2xlbiA+IDEgJiYgaSA8IGxlbikge1xuICAgICAgYyA9IChjIDw8IDYpIHwgKGJ1ZltpKytdICYgMHgzZik7XG4gICAgICBjX2xlbi0tO1xuICAgIH1cblxuICAgIC8vIHRlcm1pbmF0ZWQgYnkgZW5kIG9mIHN0cmluZz9cbiAgICBpZiAoY19sZW4gPiAxKSB7IHV0ZjE2YnVmW291dCsrXSA9IDB4ZmZmZDsgY29udGludWU7IH1cblxuICAgIGlmIChjIDwgMHgxMDAwMCkge1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gYztcbiAgICB9IGVsc2Uge1xuICAgICAgYyAtPSAweDEwMDAwO1xuICAgICAgdXRmMTZidWZbb3V0KytdID0gMHhkODAwIHwgKChjID4+IDEwKSAmIDB4M2ZmKTtcbiAgICAgIHV0ZjE2YnVmW291dCsrXSA9IDB4ZGMwMCB8IChjICYgMHgzZmYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWYyYmluc3RyaW5nKHV0ZjE2YnVmLCBvdXQpO1xufTtcblxuXG4vLyBDYWxjdWxhdGUgbWF4IHBvc3NpYmxlIHBvc2l0aW9uIGluIHV0ZjggYnVmZmVyLFxuLy8gdGhhdCB3aWxsIG5vdCBicmVhayBzZXF1ZW5jZS4gSWYgdGhhdCdzIG5vdCBwb3NzaWJsZVxuLy8gLSAodmVyeSBzbWFsbCBsaW1pdHMpIHJldHVybiBtYXggc2l6ZSBhcyBpcy5cbi8vXG4vLyBidWZbXSAtIHV0ZjggYnl0ZXMgYXJyYXlcbi8vIG1heCAgIC0gbGVuZ3RoIGxpbWl0IChtYW5kYXRvcnkpO1xuZXhwb3J0cy51dGY4Ym9yZGVyID0gZnVuY3Rpb24gKGJ1ZiwgbWF4KSB7XG4gIHZhciBwb3M7XG5cbiAgbWF4ID0gbWF4IHx8IGJ1Zi5sZW5ndGg7XG4gIGlmIChtYXggPiBidWYubGVuZ3RoKSB7IG1heCA9IGJ1Zi5sZW5ndGg7IH1cblxuICAvLyBnbyBiYWNrIGZyb20gbGFzdCBwb3NpdGlvbiwgdW50aWwgc3RhcnQgb2Ygc2VxdWVuY2UgZm91bmRcbiAgcG9zID0gbWF4IC0gMTtcbiAgd2hpbGUgKHBvcyA+PSAwICYmIChidWZbcG9zXSAmIDB4QzApID09PSAweDgwKSB7IHBvcy0tOyB9XG5cbiAgLy8gVmVyeSBzbWFsbCBhbmQgYnJva2VuIHNlcXVlbmNlLFxuICAvLyByZXR1cm4gbWF4LCBiZWNhdXNlIHdlIHNob3VsZCByZXR1cm4gc29tZXRoaW5nIGFueXdheS5cbiAgaWYgKHBvcyA8IDApIHsgcmV0dXJuIG1heDsgfVxuXG4gIC8vIElmIHdlIGNhbWUgdG8gc3RhcnQgb2YgYnVmZmVyIC0gdGhhdCBtZWFucyBidWZmZXIgaXMgdG9vIHNtYWxsLFxuICAvLyByZXR1cm4gbWF4IHRvby5cbiAgaWYgKHBvcyA9PT0gMCkgeyByZXR1cm4gbWF4OyB9XG5cbiAgcmV0dXJuIChwb3MgKyBfdXRmOGxlbltidWZbcG9zXV0gPiBtYXgpID8gcG9zIDogbWF4O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gTm90ZTogYWRsZXIzMiB0YWtlcyAxMiUgZm9yIGxldmVsIDAgYW5kIDIlIGZvciBsZXZlbCA2LlxuLy8gSXQgaXNuJ3Qgd29ydGggaXQgdG8gbWFrZSBhZGRpdGlvbmFsIG9wdGltaXphdGlvbnMgYXMgaW4gb3JpZ2luYWwuXG4vLyBTbWFsbCBzaXplIGlzIHByZWZlcmFibGUuXG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuZnVuY3Rpb24gYWRsZXIzMihhZGxlciwgYnVmLCBsZW4sIHBvcykge1xuICB2YXIgczEgPSAoYWRsZXIgJiAweGZmZmYpIHwwLFxuICAgICAgczIgPSAoKGFkbGVyID4+PiAxNikgJiAweGZmZmYpIHwwLFxuICAgICAgbiA9IDA7XG5cbiAgd2hpbGUgKGxlbiAhPT0gMCkge1xuICAgIC8vIFNldCBsaW1pdCB+IHR3aWNlIGxlc3MgdGhhbiA1NTUyLCB0byBrZWVwXG4gICAgLy8gczIgaW4gMzEtYml0cywgYmVjYXVzZSB3ZSBmb3JjZSBzaWduZWQgaW50cy5cbiAgICAvLyBpbiBvdGhlciBjYXNlICU9IHdpbGwgZmFpbC5cbiAgICBuID0gbGVuID4gMjAwMCA/IDIwMDAgOiBsZW47XG4gICAgbGVuIC09IG47XG5cbiAgICBkbyB7XG4gICAgICBzMSA9IChzMSArIGJ1Zltwb3MrK10pIHwwO1xuICAgICAgczIgPSAoczIgKyBzMSkgfDA7XG4gICAgfSB3aGlsZSAoLS1uKTtcblxuICAgIHMxICU9IDY1NTIxO1xuICAgIHMyICU9IDY1NTIxO1xuICB9XG5cbiAgcmV0dXJuIChzMSB8IChzMiA8PCAxNikpIHwwO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gYWRsZXIzMjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAvKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovXG4gIFpfTk9fRkxVU0g6ICAgICAgICAgMCxcbiAgWl9QQVJUSUFMX0ZMVVNIOiAgICAxLFxuICBaX1NZTkNfRkxVU0g6ICAgICAgIDIsXG4gIFpfRlVMTF9GTFVTSDogICAgICAgMyxcbiAgWl9GSU5JU0g6ICAgICAgICAgICA0LFxuICBaX0JMT0NLOiAgICAgICAgICAgIDUsXG4gIFpfVFJFRVM6ICAgICAgICAgICAgNixcblxuICAvKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICAqL1xuICBaX09LOiAgICAgICAgICAgICAgIDAsXG4gIFpfU1RSRUFNX0VORDogICAgICAgMSxcbiAgWl9ORUVEX0RJQ1Q6ICAgICAgICAyLFxuICBaX0VSUk5POiAgICAgICAgICAgLTEsXG4gIFpfU1RSRUFNX0VSUk9SOiAgICAtMixcbiAgWl9EQVRBX0VSUk9SOiAgICAgIC0zLFxuICAvL1pfTUVNX0VSUk9SOiAgICAgLTQsXG4gIFpfQlVGX0VSUk9SOiAgICAgICAtNSxcbiAgLy9aX1ZFUlNJT05fRVJST1I6IC02LFxuXG4gIC8qIGNvbXByZXNzaW9uIGxldmVscyAqL1xuICBaX05PX0NPTVBSRVNTSU9OOiAgICAgICAgIDAsXG4gIFpfQkVTVF9TUEVFRDogICAgICAgICAgICAgMSxcbiAgWl9CRVNUX0NPTVBSRVNTSU9OOiAgICAgICA5LFxuICBaX0RFRkFVTFRfQ09NUFJFU1NJT046ICAgLTEsXG5cblxuICBaX0ZJTFRFUkVEOiAgICAgICAgICAgICAgIDEsXG4gIFpfSFVGRk1BTl9PTkxZOiAgICAgICAgICAgMixcbiAgWl9STEU6ICAgICAgICAgICAgICAgICAgICAzLFxuICBaX0ZJWEVEOiAgICAgICAgICAgICAgICAgIDQsXG4gIFpfREVGQVVMVF9TVFJBVEVHWTogICAgICAgMCxcblxuICAvKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG4gIFpfQklOQVJZOiAgICAgICAgICAgICAgICAgMCxcbiAgWl9URVhUOiAgICAgICAgICAgICAgICAgICAxLFxuICAvL1pfQVNDSUk6ICAgICAgICAgICAgICAgIDEsIC8vID0gWl9URVhUIChkZXByZWNhdGVkKVxuICBaX1VOS05PV046ICAgICAgICAgICAgICAgIDIsXG5cbiAgLyogVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kICovXG4gIFpfREVGTEFURUQ6ICAgICAgICAgICAgICAgOFxuICAvL1pfTlVMTDogICAgICAgICAgICAgICAgIG51bGwgLy8gVXNlIC0xIG9yIG51bGwgaW5saW5lLCBkZXBlbmRpbmcgb24gdmFyIHR5cGVcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIE5vdGU6IHdlIGNhbid0IGdldCBzaWduaWZpY2FudCBzcGVlZCBib29zdCBoZXJlLlxuLy8gU28gd3JpdGUgY29kZSB0byBtaW5pbWl6ZSBzaXplIC0gbm8gcHJlZ2VuZXJhdGVkIHRhYmxlc1xuLy8gYW5kIGFycmF5IHRvb2xzIGRlcGVuZGVuY2llcy5cblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG4vLyBVc2Ugb3JkaW5hcnkgYXJyYXksIHNpbmNlIHVudHlwZWQgbWFrZXMgbm8gYm9vc3QgaGVyZVxuZnVuY3Rpb24gbWFrZVRhYmxlKCkge1xuICB2YXIgYywgdGFibGUgPSBbXTtcblxuICBmb3IgKHZhciBuID0gMDsgbiA8IDI1NjsgbisrKSB7XG4gICAgYyA9IG47XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCA4OyBrKyspIHtcbiAgICAgIGMgPSAoKGMgJiAxKSA/ICgweEVEQjg4MzIwIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG4gICAgfVxuICAgIHRhYmxlW25dID0gYztcbiAgfVxuXG4gIHJldHVybiB0YWJsZTtcbn1cblxuLy8gQ3JlYXRlIHRhYmxlIG9uIGxvYWQuIEp1c3QgMjU1IHNpZ25lZCBsb25ncy4gTm90IGEgcHJvYmxlbS5cbnZhciBjcmNUYWJsZSA9IG1ha2VUYWJsZSgpO1xuXG5cbmZ1bmN0aW9uIGNyYzMyKGNyYywgYnVmLCBsZW4sIHBvcykge1xuICB2YXIgdCA9IGNyY1RhYmxlLFxuICAgICAgZW5kID0gcG9zICsgbGVuO1xuXG4gIGNyYyBePSAtMTtcblxuICBmb3IgKHZhciBpID0gcG9zOyBpIDwgZW5kOyBpKyspIHtcbiAgICBjcmMgPSAoY3JjID4+PiA4KSBeIHRbKGNyYyBeIGJ1ZltpXSkgJiAweEZGXTtcbiAgfVxuXG4gIHJldHVybiAoY3JjIF4gKC0xKSk7IC8vID4+PiAwO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gY3JjMzI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxudmFyIHV0aWxzICAgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcbnZhciB0cmVlcyAgID0gcmVxdWlyZSgnLi90cmVlcycpO1xudmFyIGFkbGVyMzIgPSByZXF1aXJlKCcuL2FkbGVyMzInKTtcbnZhciBjcmMzMiAgID0gcmVxdWlyZSgnLi9jcmMzMicpO1xudmFyIG1zZyAgICAgPSByZXF1aXJlKCcuL21lc3NhZ2VzJyk7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qIEFsbG93ZWQgZmx1c2ggdmFsdWVzOyBzZWUgZGVmbGF0ZSgpIGFuZCBpbmZsYXRlKCkgYmVsb3cgZm9yIGRldGFpbHMgKi9cbnZhciBaX05PX0ZMVVNIICAgICAgPSAwO1xudmFyIFpfUEFSVElBTF9GTFVTSCA9IDE7XG4vL3ZhciBaX1NZTkNfRkxVU0ggICAgPSAyO1xudmFyIFpfRlVMTF9GTFVTSCAgICA9IDM7XG52YXIgWl9GSU5JU0ggICAgICAgID0gNDtcbnZhciBaX0JMT0NLICAgICAgICAgPSA1O1xuLy92YXIgWl9UUkVFUyAgICAgICAgID0gNjtcblxuXG4vKiBSZXR1cm4gY29kZXMgZm9yIHRoZSBjb21wcmVzc2lvbi9kZWNvbXByZXNzaW9uIGZ1bmN0aW9ucy4gTmVnYXRpdmUgdmFsdWVzXG4gKiBhcmUgZXJyb3JzLCBwb3NpdGl2ZSB2YWx1ZXMgYXJlIHVzZWQgZm9yIHNwZWNpYWwgYnV0IG5vcm1hbCBldmVudHMuXG4gKi9cbnZhciBaX09LICAgICAgICAgICAgPSAwO1xudmFyIFpfU1RSRUFNX0VORCAgICA9IDE7XG4vL3ZhciBaX05FRURfRElDVCAgICAgPSAyO1xuLy92YXIgWl9FUlJOTyAgICAgICAgID0gLTE7XG52YXIgWl9TVFJFQU1fRVJST1IgID0gLTI7XG52YXIgWl9EQVRBX0VSUk9SICAgID0gLTM7XG4vL3ZhciBaX01FTV9FUlJPUiAgICAgPSAtNDtcbnZhciBaX0JVRl9FUlJPUiAgICAgPSAtNTtcbi8vdmFyIFpfVkVSU0lPTl9FUlJPUiA9IC02O1xuXG5cbi8qIGNvbXByZXNzaW9uIGxldmVscyAqL1xuLy92YXIgWl9OT19DT01QUkVTU0lPTiAgICAgID0gMDtcbi8vdmFyIFpfQkVTVF9TUEVFRCAgICAgICAgICA9IDE7XG4vL3ZhciBaX0JFU1RfQ09NUFJFU1NJT04gICAgPSA5O1xudmFyIFpfREVGQVVMVF9DT01QUkVTU0lPTiA9IC0xO1xuXG5cbnZhciBaX0ZJTFRFUkVEICAgICAgICAgICAgPSAxO1xudmFyIFpfSFVGRk1BTl9PTkxZICAgICAgICA9IDI7XG52YXIgWl9STEUgICAgICAgICAgICAgICAgID0gMztcbnZhciBaX0ZJWEVEICAgICAgICAgICAgICAgPSA0O1xudmFyIFpfREVGQVVMVF9TVFJBVEVHWSAgICA9IDA7XG5cbi8qIFBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgZGF0YV90eXBlIGZpZWxkICh0aG91Z2ggc2VlIGluZmxhdGUoKSkgKi9cbi8vdmFyIFpfQklOQVJZICAgICAgICAgICAgICA9IDA7XG4vL3ZhciBaX1RFWFQgICAgICAgICAgICAgICAgPSAxO1xuLy92YXIgWl9BU0NJSSAgICAgICAgICAgICAgID0gMTsgLy8gPSBaX1RFWFRcbnZhciBaX1VOS05PV04gICAgICAgICAgICAgPSAyO1xuXG5cbi8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xudmFyIFpfREVGTEFURUQgID0gODtcblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG52YXIgTUFYX01FTV9MRVZFTCA9IDk7XG4vKiBNYXhpbXVtIHZhbHVlIGZvciBtZW1MZXZlbCBpbiBkZWZsYXRlSW5pdDIgKi9cbnZhciBNQVhfV0JJVFMgPSAxNTtcbi8qIDMySyBMWjc3IHdpbmRvdyAqL1xudmFyIERFRl9NRU1fTEVWRUwgPSA4O1xuXG5cbnZhciBMRU5HVEhfQ09ERVMgID0gMjk7XG4vKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGVzLCBub3QgY291bnRpbmcgdGhlIHNwZWNpYWwgRU5EX0JMT0NLIGNvZGUgKi9cbnZhciBMSVRFUkFMUyAgICAgID0gMjU2O1xuLyogbnVtYmVyIG9mIGxpdGVyYWwgYnl0ZXMgMC4uMjU1ICovXG52YXIgTF9DT0RFUyAgICAgICA9IExJVEVSQUxTICsgMSArIExFTkdUSF9DT0RFUztcbi8qIG51bWJlciBvZiBMaXRlcmFsIG9yIExlbmd0aCBjb2RlcywgaW5jbHVkaW5nIHRoZSBFTkRfQkxPQ0sgY29kZSAqL1xudmFyIERfQ09ERVMgICAgICAgPSAzMDtcbi8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlcyAqL1xudmFyIEJMX0NPREVTICAgICAgPSAxOTtcbi8qIG51bWJlciBvZiBjb2RlcyB1c2VkIHRvIHRyYW5zZmVyIHRoZSBiaXQgbGVuZ3RocyAqL1xudmFyIEhFQVBfU0laRSAgICAgPSAyICogTF9DT0RFUyArIDE7XG4vKiBtYXhpbXVtIGhlYXAgc2l6ZSAqL1xudmFyIE1BWF9CSVRTICA9IDE1O1xuLyogQWxsIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQklUUyBiaXRzICovXG5cbnZhciBNSU5fTUFUQ0ggPSAzO1xudmFyIE1BWF9NQVRDSCA9IDI1ODtcbnZhciBNSU5fTE9PS0FIRUFEID0gKE1BWF9NQVRDSCArIE1JTl9NQVRDSCArIDEpO1xuXG52YXIgUFJFU0VUX0RJQ1QgPSAweDIwO1xuXG52YXIgSU5JVF9TVEFURSA9IDQyO1xudmFyIEVYVFJBX1NUQVRFID0gNjk7XG52YXIgTkFNRV9TVEFURSA9IDczO1xudmFyIENPTU1FTlRfU1RBVEUgPSA5MTtcbnZhciBIQ1JDX1NUQVRFID0gMTAzO1xudmFyIEJVU1lfU1RBVEUgPSAxMTM7XG52YXIgRklOSVNIX1NUQVRFID0gNjY2O1xuXG52YXIgQlNfTkVFRF9NT1JFICAgICAgPSAxOyAvKiBibG9jayBub3QgY29tcGxldGVkLCBuZWVkIG1vcmUgaW5wdXQgb3IgbW9yZSBvdXRwdXQgKi9cbnZhciBCU19CTE9DS19ET05FICAgICA9IDI7IC8qIGJsb2NrIGZsdXNoIHBlcmZvcm1lZCAqL1xudmFyIEJTX0ZJTklTSF9TVEFSVEVEID0gMzsgLyogZmluaXNoIHN0YXJ0ZWQsIG5lZWQgb25seSBtb3JlIG91dHB1dCBhdCBuZXh0IGRlZmxhdGUgKi9cbnZhciBCU19GSU5JU0hfRE9ORSAgICA9IDQ7IC8qIGZpbmlzaCBkb25lLCBhY2NlcHQgbm8gbW9yZSBpbnB1dCBvciBvdXRwdXQgKi9cblxudmFyIE9TX0NPREUgPSAweDAzOyAvLyBVbml4IDopIC4gRG9uJ3QgZGV0ZWN0LCB1c2UgdGhpcyBkZWZhdWx0LlxuXG5mdW5jdGlvbiBlcnIoc3RybSwgZXJyb3JDb2RlKSB7XG4gIHN0cm0ubXNnID0gbXNnW2Vycm9yQ29kZV07XG4gIHJldHVybiBlcnJvckNvZGU7XG59XG5cbmZ1bmN0aW9uIHJhbmsoZikge1xuICByZXR1cm4gKChmKSA8PCAxKSAtICgoZikgPiA0ID8gOSA6IDApO1xufVxuXG5mdW5jdGlvbiB6ZXJvKGJ1ZikgeyB2YXIgbGVuID0gYnVmLmxlbmd0aDsgd2hpbGUgKC0tbGVuID49IDApIHsgYnVmW2xlbl0gPSAwOyB9IH1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCBhcyBtdWNoIHBlbmRpbmcgb3V0cHV0IGFzIHBvc3NpYmxlLiBBbGwgZGVmbGF0ZSgpIG91dHB1dCBnb2VzXG4gKiB0aHJvdWdoIHRoaXMgZnVuY3Rpb24gc28gc29tZSBhcHBsaWNhdGlvbnMgbWF5IHdpc2ggdG8gbW9kaWZ5IGl0XG4gKiB0byBhdm9pZCBhbGxvY2F0aW5nIGEgbGFyZ2Ugc3RybS0+b3V0cHV0IGJ1ZmZlciBhbmQgY29weWluZyBpbnRvIGl0LlxuICogKFNlZSBhbHNvIHJlYWRfYnVmKCkpLlxuICovXG5mdW5jdGlvbiBmbHVzaF9wZW5kaW5nKHN0cm0pIHtcbiAgdmFyIHMgPSBzdHJtLnN0YXRlO1xuXG4gIC8vX3RyX2ZsdXNoX2JpdHMocyk7XG4gIHZhciBsZW4gPSBzLnBlbmRpbmc7XG4gIGlmIChsZW4gPiBzdHJtLmF2YWlsX291dCkge1xuICAgIGxlbiA9IHN0cm0uYXZhaWxfb3V0O1xuICB9XG4gIGlmIChsZW4gPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgdXRpbHMuYXJyYXlTZXQoc3RybS5vdXRwdXQsIHMucGVuZGluZ19idWYsIHMucGVuZGluZ19vdXQsIGxlbiwgc3RybS5uZXh0X291dCk7XG4gIHN0cm0ubmV4dF9vdXQgKz0gbGVuO1xuICBzLnBlbmRpbmdfb3V0ICs9IGxlbjtcbiAgc3RybS50b3RhbF9vdXQgKz0gbGVuO1xuICBzdHJtLmF2YWlsX291dCAtPSBsZW47XG4gIHMucGVuZGluZyAtPSBsZW47XG4gIGlmIChzLnBlbmRpbmcgPT09IDApIHtcbiAgICBzLnBlbmRpbmdfb3V0ID0gMDtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGZsdXNoX2Jsb2NrX29ubHkocywgbGFzdCkge1xuICB0cmVlcy5fdHJfZmx1c2hfYmxvY2socywgKHMuYmxvY2tfc3RhcnQgPj0gMCA/IHMuYmxvY2tfc3RhcnQgOiAtMSksIHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0LCBsYXN0KTtcbiAgcy5ibG9ja19zdGFydCA9IHMuc3Ryc3RhcnQ7XG4gIGZsdXNoX3BlbmRpbmcocy5zdHJtKTtcbn1cblxuXG5mdW5jdGlvbiBwdXRfYnl0ZShzLCBiKSB7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBQdXQgYSBzaG9ydCBpbiB0aGUgcGVuZGluZyBidWZmZXIuIFRoZSAxNi1iaXQgdmFsdWUgaXMgcHV0IGluIE1TQiBvcmRlci5cbiAqIElOIGFzc2VydGlvbjogdGhlIHN0cmVhbSBzdGF0ZSBpcyBjb3JyZWN0IGFuZCB0aGVyZSBpcyBlbm91Z2ggcm9vbSBpblxuICogcGVuZGluZ19idWYuXG4gKi9cbmZ1bmN0aW9uIHB1dFNob3J0TVNCKHMsIGIpIHtcbi8vICBwdXRfYnl0ZShzLCAoQnl0ZSkoYiA+PiA4KSk7XG4vLyAgcHV0X2J5dGUocywgKEJ5dGUpKGIgJiAweGZmKSk7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKGIgPj4+IDgpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBiICYgMHhmZjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJlYWQgYSBuZXcgYnVmZmVyIGZyb20gdGhlIGN1cnJlbnQgaW5wdXQgc3RyZWFtLCB1cGRhdGUgdGhlIGFkbGVyMzJcbiAqIGFuZCB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgcmVhZC4gIEFsbCBkZWZsYXRlKCkgaW5wdXQgZ29lcyB0aHJvdWdoXG4gKiB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdCB0byBhdm9pZFxuICogYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPmlucHV0IGJ1ZmZlciBhbmQgY29weWluZyBmcm9tIGl0LlxuICogKFNlZSBhbHNvIGZsdXNoX3BlbmRpbmcoKSkuXG4gKi9cbmZ1bmN0aW9uIHJlYWRfYnVmKHN0cm0sIGJ1Ziwgc3RhcnQsIHNpemUpIHtcbiAgdmFyIGxlbiA9IHN0cm0uYXZhaWxfaW47XG5cbiAgaWYgKGxlbiA+IHNpemUpIHsgbGVuID0gc2l6ZTsgfVxuICBpZiAobGVuID09PSAwKSB7IHJldHVybiAwOyB9XG5cbiAgc3RybS5hdmFpbF9pbiAtPSBsZW47XG5cbiAgLy8gem1lbWNweShidWYsIHN0cm0tPm5leHRfaW4sIGxlbik7XG4gIHV0aWxzLmFycmF5U2V0KGJ1Ziwgc3RybS5pbnB1dCwgc3RybS5uZXh0X2luLCBsZW4sIHN0YXJ0KTtcbiAgaWYgKHN0cm0uc3RhdGUud3JhcCA9PT0gMSkge1xuICAgIHN0cm0uYWRsZXIgPSBhZGxlcjMyKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7XG4gIH1cblxuICBlbHNlIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDIpIHtcbiAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgYnVmLCBsZW4sIHN0YXJ0KTtcbiAgfVxuXG4gIHN0cm0ubmV4dF9pbiArPSBsZW47XG4gIHN0cm0udG90YWxfaW4gKz0gbGVuO1xuXG4gIHJldHVybiBsZW47XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZXQgbWF0Y2hfc3RhcnQgdG8gdGhlIGxvbmdlc3QgbWF0Y2ggc3RhcnRpbmcgYXQgdGhlIGdpdmVuIHN0cmluZyBhbmRcbiAqIHJldHVybiBpdHMgbGVuZ3RoLiBNYXRjaGVzIHNob3J0ZXIgb3IgZXF1YWwgdG8gcHJldl9sZW5ndGggYXJlIGRpc2NhcmRlZCxcbiAqIGluIHdoaWNoIGNhc2UgdGhlIHJlc3VsdCBpcyBlcXVhbCB0byBwcmV2X2xlbmd0aCBhbmQgbWF0Y2hfc3RhcnQgaXNcbiAqIGdhcmJhZ2UuXG4gKiBJTiBhc3NlcnRpb25zOiBjdXJfbWF0Y2ggaXMgdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gZm9yIHRoZSBjdXJyZW50XG4gKiAgIHN0cmluZyAoc3Ryc3RhcnQpIGFuZCBpdHMgZGlzdGFuY2UgaXMgPD0gTUFYX0RJU1QsIGFuZCBwcmV2X2xlbmd0aCA+PSAxXG4gKiBPVVQgYXNzZXJ0aW9uOiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIG5vdCBncmVhdGVyIHRoYW4gcy0+bG9va2FoZWFkLlxuICovXG5mdW5jdGlvbiBsb25nZXN0X21hdGNoKHMsIGN1cl9tYXRjaCkge1xuICB2YXIgY2hhaW5fbGVuZ3RoID0gcy5tYXhfY2hhaW5fbGVuZ3RoOyAgICAgIC8qIG1heCBoYXNoIGNoYWluIGxlbmd0aCAqL1xuICB2YXIgc2NhbiA9IHMuc3Ryc3RhcnQ7IC8qIGN1cnJlbnQgc3RyaW5nICovXG4gIHZhciBtYXRjaDsgICAgICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoZWQgc3RyaW5nICovXG4gIHZhciBsZW47ICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgbWF0Y2ggKi9cbiAgdmFyIGJlc3RfbGVuID0gcy5wcmV2X2xlbmd0aDsgICAgICAgICAgICAgIC8qIGJlc3QgbWF0Y2ggbGVuZ3RoIHNvIGZhciAqL1xuICB2YXIgbmljZV9tYXRjaCA9IHMubmljZV9tYXRjaDsgICAgICAgICAgICAgLyogc3RvcCBpZiBtYXRjaCBsb25nIGVub3VnaCAqL1xuICB2YXIgbGltaXQgPSAocy5zdHJzdGFydCA+IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSA/XG4gICAgICBzLnN0cnN0YXJ0IC0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkgOiAwLypOSUwqLztcblxuICB2YXIgX3dpbiA9IHMud2luZG93OyAvLyBzaG9ydGN1dFxuXG4gIHZhciB3bWFzayA9IHMud19tYXNrO1xuICB2YXIgcHJldiAgPSBzLnByZXY7XG5cbiAgLyogU3RvcCB3aGVuIGN1cl9tYXRjaCBiZWNvbWVzIDw9IGxpbWl0LiBUbyBzaW1wbGlmeSB0aGUgY29kZSxcbiAgICogd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZyBvZiB3aW5kb3cgaW5kZXggMC5cbiAgICovXG5cbiAgdmFyIHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7XG4gIHZhciBzY2FuX2VuZDEgID0gX3dpbltzY2FuICsgYmVzdF9sZW4gLSAxXTtcbiAgdmFyIHNjYW5fZW5kICAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbl07XG5cbiAgLyogVGhlIGNvZGUgaXMgb3B0aW1pemVkIGZvciBIQVNIX0JJVFMgPj0gOCBhbmQgTUFYX01BVENILTIgbXVsdGlwbGUgb2YgMTYuXG4gICAqIEl0IGlzIGVhc3kgdG8gZ2V0IHJpZCBvZiB0aGlzIG9wdGltaXphdGlvbiBpZiBuZWNlc3NhcnkuXG4gICAqL1xuICAvLyBBc3NlcnQocy0+aGFzaF9iaXRzID49IDggJiYgTUFYX01BVENIID09IDI1OCwgXCJDb2RlIHRvbyBjbGV2ZXJcIik7XG5cbiAgLyogRG8gbm90IHdhc3RlIHRvbyBtdWNoIHRpbWUgaWYgd2UgYWxyZWFkeSBoYXZlIGEgZ29vZCBtYXRjaDogKi9cbiAgaWYgKHMucHJldl9sZW5ndGggPj0gcy5nb29kX21hdGNoKSB7XG4gICAgY2hhaW5fbGVuZ3RoID4+PSAyO1xuICB9XG4gIC8qIERvIG5vdCBsb29rIGZvciBtYXRjaGVzIGJleW9uZCB0aGUgZW5kIG9mIHRoZSBpbnB1dC4gVGhpcyBpcyBuZWNlc3NhcnlcbiAgICogdG8gbWFrZSBkZWZsYXRlIGRldGVybWluaXN0aWMuXG4gICAqL1xuICBpZiAobmljZV9tYXRjaCA+IHMubG9va2FoZWFkKSB7IG5pY2VfbWF0Y2ggPSBzLmxvb2thaGVhZDsgfVxuXG4gIC8vIEFzc2VydCgodWxnKXMtPnN0cnN0YXJ0IDw9IHMtPndpbmRvd19zaXplLU1JTl9MT09LQUhFQUQsIFwibmVlZCBsb29rYWhlYWRcIik7XG5cbiAgZG8ge1xuICAgIC8vIEFzc2VydChjdXJfbWF0Y2ggPCBzLT5zdHJzdGFydCwgXCJubyBmdXR1cmVcIik7XG4gICAgbWF0Y2ggPSBjdXJfbWF0Y2g7XG5cbiAgICAvKiBTa2lwIHRvIG5leHQgbWF0Y2ggaWYgdGhlIG1hdGNoIGxlbmd0aCBjYW5ub3QgaW5jcmVhc2VcbiAgICAgKiBvciBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIGxlc3MgdGhhbiAyLiAgTm90ZSB0aGF0IHRoZSBjaGVja3MgYmVsb3dcbiAgICAgKiBmb3IgaW5zdWZmaWNpZW50IGxvb2thaGVhZCBvbmx5IG9jY3VyIG9jY2FzaW9uYWxseSBmb3IgcGVyZm9ybWFuY2VcbiAgICAgKiByZWFzb25zLiAgVGhlcmVmb3JlIHVuaW5pdGlhbGl6ZWQgbWVtb3J5IHdpbGwgYmUgYWNjZXNzZWQsIGFuZFxuICAgICAqIGNvbmRpdGlvbmFsIGp1bXBzIHdpbGwgYmUgbWFkZSB0aGF0IGRlcGVuZCBvbiB0aG9zZSB2YWx1ZXMuXG4gICAgICogSG93ZXZlciB0aGUgbGVuZ3RoIG9mIHRoZSBtYXRjaCBpcyBsaW1pdGVkIHRvIHRoZSBsb29rYWhlYWQsIHNvXG4gICAgICogdGhlIG91dHB1dCBvZiBkZWZsYXRlIGlzIG5vdCBhZmZlY3RlZCBieSB0aGUgdW5pbml0aWFsaXplZCB2YWx1ZXMuXG4gICAgICovXG5cbiAgICBpZiAoX3dpblttYXRjaCArIGJlc3RfbGVuXSAgICAgIT09IHNjYW5fZW5kICB8fFxuICAgICAgICBfd2luW21hdGNoICsgYmVzdF9sZW4gLSAxXSAhPT0gc2Nhbl9lbmQxIHx8XG4gICAgICAgIF93aW5bbWF0Y2hdICAgICAgICAgICAgICAgICE9PSBfd2luW3NjYW5dIHx8XG4gICAgICAgIF93aW5bKyttYXRjaF0gICAgICAgICAgICAgICE9PSBfd2luW3NjYW4gKyAxXSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLyogVGhlIGNoZWNrIGF0IGJlc3RfbGVuLTEgY2FuIGJlIHJlbW92ZWQgYmVjYXVzZSBpdCB3aWxsIGJlIG1hZGVcbiAgICAgKiBhZ2FpbiBsYXRlci4gKFRoaXMgaGV1cmlzdGljIGlzIG5vdCBhbHdheXMgYSB3aW4uKVxuICAgICAqIEl0IGlzIG5vdCBuZWNlc3NhcnkgdG8gY29tcGFyZSBzY2FuWzJdIGFuZCBtYXRjaFsyXSBzaW5jZSB0aGV5XG4gICAgICogYXJlIGFsd2F5cyBlcXVhbCB3aGVuIHRoZSBvdGhlciBieXRlcyBtYXRjaCwgZ2l2ZW4gdGhhdFxuICAgICAqIHRoZSBoYXNoIGtleXMgYXJlIGVxdWFsIGFuZCB0aGF0IEhBU0hfQklUUyA+PSA4LlxuICAgICAqL1xuICAgIHNjYW4gKz0gMjtcbiAgICBtYXRjaCsrO1xuICAgIC8vIEFzc2VydCgqc2NhbiA9PSAqbWF0Y2gsIFwibWF0Y2hbMl0/XCIpO1xuXG4gICAgLyogV2UgY2hlY2sgZm9yIGluc3VmZmljaWVudCBsb29rYWhlYWQgb25seSBldmVyeSA4dGggY29tcGFyaXNvbjtcbiAgICAgKiB0aGUgMjU2dGggY2hlY2sgd2lsbCBiZSBtYWRlIGF0IHN0cnN0YXJ0KzI1OC5cbiAgICAgKi9cbiAgICBkbyB7XG4gICAgICAvKmpzaGludCBub2VtcHR5OmZhbHNlKi9cbiAgICB9IHdoaWxlIChfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgc2NhbiA8IHN0cmVuZCk7XG5cbiAgICAvLyBBc3NlcnQoc2NhbiA8PSBzLT53aW5kb3crKHVuc2lnbmVkKShzLT53aW5kb3dfc2l6ZS0xKSwgXCJ3aWxkIHNjYW5cIik7XG5cbiAgICBsZW4gPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7XG4gICAgc2NhbiA9IHN0cmVuZCAtIE1BWF9NQVRDSDtcblxuICAgIGlmIChsZW4gPiBiZXN0X2xlbikge1xuICAgICAgcy5tYXRjaF9zdGFydCA9IGN1cl9tYXRjaDtcbiAgICAgIGJlc3RfbGVuID0gbGVuO1xuICAgICAgaWYgKGxlbiA+PSBuaWNlX21hdGNoKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc2Nhbl9lbmQxICA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07XG4gICAgICBzY2FuX2VuZCAgID0gX3dpbltzY2FuICsgYmVzdF9sZW5dO1xuICAgIH1cbiAgfSB3aGlsZSAoKGN1cl9tYXRjaCA9IHByZXZbY3VyX21hdGNoICYgd21hc2tdKSA+IGxpbWl0ICYmIC0tY2hhaW5fbGVuZ3RoICE9PSAwKTtcblxuICBpZiAoYmVzdF9sZW4gPD0gcy5sb29rYWhlYWQpIHtcbiAgICByZXR1cm4gYmVzdF9sZW47XG4gIH1cbiAgcmV0dXJuIHMubG9va2FoZWFkO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmlsbCB0aGUgd2luZG93IHdoZW4gdGhlIGxvb2thaGVhZCBiZWNvbWVzIGluc3VmZmljaWVudC5cbiAqIFVwZGF0ZXMgc3Ryc3RhcnQgYW5kIGxvb2thaGVhZC5cbiAqXG4gKiBJTiBhc3NlcnRpb246IGxvb2thaGVhZCA8IE1JTl9MT09LQUhFQURcbiAqIE9VVCBhc3NlcnRpb25zOiBzdHJzdGFydCA8PSB3aW5kb3dfc2l6ZS1NSU5fTE9PS0FIRUFEXG4gKiAgICBBdCBsZWFzdCBvbmUgYnl0ZSBoYXMgYmVlbiByZWFkLCBvciBhdmFpbF9pbiA9PSAwOyByZWFkcyBhcmVcbiAqICAgIHBlcmZvcm1lZCBmb3IgYXQgbGVhc3QgdHdvIGJ5dGVzIChyZXF1aXJlZCBmb3IgdGhlIHppcCB0cmFuc2xhdGVfZW9sXG4gKiAgICBvcHRpb24gLS0gbm90IHN1cHBvcnRlZCBoZXJlKS5cbiAqL1xuZnVuY3Rpb24gZmlsbF93aW5kb3cocykge1xuICB2YXIgX3dfc2l6ZSA9IHMud19zaXplO1xuICB2YXIgcCwgbiwgbSwgbW9yZSwgc3RyO1xuXG4gIC8vQXNzZXJ0KHMtPmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQsIFwiYWxyZWFkeSBlbm91Z2ggbG9va2FoZWFkXCIpO1xuXG4gIGRvIHtcbiAgICBtb3JlID0gcy53aW5kb3dfc2l6ZSAtIHMubG9va2FoZWFkIC0gcy5zdHJzdGFydDtcblxuICAgIC8vIEpTIGludHMgaGF2ZSAzMiBiaXQsIGJsb2NrIGJlbG93IG5vdCBuZWVkZWRcbiAgICAvKiBEZWFsIHdpdGggIUAjJCUgNjRLIGxpbWl0OiAqL1xuICAgIC8vaWYgKHNpemVvZihpbnQpIDw9IDIpIHtcbiAgICAvLyAgICBpZiAobW9yZSA9PSAwICYmIHMtPnN0cnN0YXJ0ID09IDAgJiYgcy0+bG9va2FoZWFkID09IDApIHtcbiAgICAvLyAgICAgICAgbW9yZSA9IHdzaXplO1xuICAgIC8vXG4gICAgLy8gIH0gZWxzZSBpZiAobW9yZSA9PSAodW5zaWduZWQpKC0xKSkge1xuICAgIC8vICAgICAgICAvKiBWZXJ5IHVubGlrZWx5LCBidXQgcG9zc2libGUgb24gMTYgYml0IG1hY2hpbmUgaWZcbiAgICAvLyAgICAgICAgICogc3Ryc3RhcnQgPT0gMCAmJiBsb29rYWhlYWQgPT0gMSAoaW5wdXQgZG9uZSBhIGJ5dGUgYXQgdGltZSlcbiAgICAvLyAgICAgICAgICovXG4gICAgLy8gICAgICAgIG1vcmUtLTtcbiAgICAvLyAgICB9XG4gICAgLy99XG5cblxuICAgIC8qIElmIHRoZSB3aW5kb3cgaXMgYWxtb3N0IGZ1bGwgYW5kIHRoZXJlIGlzIGluc3VmZmljaWVudCBsb29rYWhlYWQsXG4gICAgICogbW92ZSB0aGUgdXBwZXIgaGFsZiB0byB0aGUgbG93ZXIgb25lIHRvIG1ha2Ugcm9vbSBpbiB0aGUgdXBwZXIgaGFsZi5cbiAgICAgKi9cbiAgICBpZiAocy5zdHJzdGFydCA+PSBfd19zaXplICsgKF93X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkge1xuXG4gICAgICB1dGlscy5hcnJheVNldChzLndpbmRvdywgcy53aW5kb3csIF93X3NpemUsIF93X3NpemUsIDApO1xuICAgICAgcy5tYXRjaF9zdGFydCAtPSBfd19zaXplO1xuICAgICAgcy5zdHJzdGFydCAtPSBfd19zaXplO1xuICAgICAgLyogd2Ugbm93IGhhdmUgc3Ryc3RhcnQgPj0gTUFYX0RJU1QgKi9cbiAgICAgIHMuYmxvY2tfc3RhcnQgLT0gX3dfc2l6ZTtcblxuICAgICAgLyogU2xpZGUgdGhlIGhhc2ggdGFibGUgKGNvdWxkIGJlIGF2b2lkZWQgd2l0aCAzMiBiaXQgdmFsdWVzXG4gICAgICAgYXQgdGhlIGV4cGVuc2Ugb2YgbWVtb3J5IHVzYWdlKS4gV2Ugc2xpZGUgZXZlbiB3aGVuIGxldmVsID09IDBcbiAgICAgICB0byBrZWVwIHRoZSBoYXNoIHRhYmxlIGNvbnNpc3RlbnQgaWYgd2Ugc3dpdGNoIGJhY2sgdG8gbGV2ZWwgPiAwXG4gICAgICAgbGF0ZXIuIChVc2luZyBsZXZlbCAwIHBlcm1hbmVudGx5IGlzIG5vdCBhbiBvcHRpbWFsIHVzYWdlIG9mXG4gICAgICAgemxpYiwgc28gd2UgZG9uJ3QgY2FyZSBhYm91dCB0aGlzIHBhdGhvbG9naWNhbCBjYXNlLilcbiAgICAgICAqL1xuXG4gICAgICBuID0gcy5oYXNoX3NpemU7XG4gICAgICBwID0gbjtcbiAgICAgIGRvIHtcbiAgICAgICAgbSA9IHMuaGVhZFstLXBdO1xuICAgICAgICBzLmhlYWRbcF0gPSAobSA+PSBfd19zaXplID8gbSAtIF93X3NpemUgOiAwKTtcbiAgICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICAgIG4gPSBfd19zaXplO1xuICAgICAgcCA9IG47XG4gICAgICBkbyB7XG4gICAgICAgIG0gPSBzLnByZXZbLS1wXTtcbiAgICAgICAgcy5wcmV2W3BdID0gKG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMCk7XG4gICAgICAgIC8qIElmIG4gaXMgbm90IG9uIGFueSBoYXNoIGNoYWluLCBwcmV2W25dIGlzIGdhcmJhZ2UgYnV0XG4gICAgICAgICAqIGl0cyB2YWx1ZSB3aWxsIG5ldmVyIGJlIHVzZWQuXG4gICAgICAgICAqL1xuICAgICAgfSB3aGlsZSAoLS1uKTtcblxuICAgICAgbW9yZSArPSBfd19zaXplO1xuICAgIH1cbiAgICBpZiAocy5zdHJtLmF2YWlsX2luID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvKiBJZiB0aGVyZSB3YXMgbm8gc2xpZGluZzpcbiAgICAgKiAgICBzdHJzdGFydCA8PSBXU0laRStNQVhfRElTVC0xICYmIGxvb2thaGVhZCA8PSBNSU5fTE9PS0FIRUFEIC0gMSAmJlxuICAgICAqICAgIG1vcmUgPT0gd2luZG93X3NpemUgLSBsb29rYWhlYWQgLSBzdHJzdGFydFxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAoTUlOX0xPT0tBSEVBRC0xICsgV1NJWkUgKyBNQVhfRElTVC0xKVxuICAgICAqID0+IG1vcmUgPj0gd2luZG93X3NpemUgLSAyKldTSVpFICsgMlxuICAgICAqIEluIHRoZSBCSUdfTUVNIG9yIE1NQVAgY2FzZSAobm90IHlldCBzdXBwb3J0ZWQpLFxuICAgICAqICAgd2luZG93X3NpemUgPT0gaW5wdXRfc2l6ZSArIE1JTl9MT09LQUhFQUQgICYmXG4gICAgICogICBzdHJzdGFydCArIHMtPmxvb2thaGVhZCA8PSBpbnB1dF9zaXplID0+IG1vcmUgPj0gTUlOX0xPT0tBSEVBRC5cbiAgICAgKiBPdGhlcndpc2UsIHdpbmRvd19zaXplID09IDIqV1NJWkUgc28gbW9yZSA+PSAyLlxuICAgICAqIElmIHRoZXJlIHdhcyBzbGlkaW5nLCBtb3JlID49IFdTSVpFLiBTbyBpbiBhbGwgY2FzZXMsIG1vcmUgPj0gMi5cbiAgICAgKi9cbiAgICAvL0Fzc2VydChtb3JlID49IDIsIFwibW9yZSA8IDJcIik7XG4gICAgbiA9IHJlYWRfYnVmKHMuc3RybSwgcy53aW5kb3csIHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCwgbW9yZSk7XG4gICAgcy5sb29rYWhlYWQgKz0gbjtcblxuICAgIC8qIEluaXRpYWxpemUgdGhlIGhhc2ggdmFsdWUgbm93IHRoYXQgd2UgaGF2ZSBzb21lIGlucHV0OiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0ID49IE1JTl9NQVRDSCkge1xuICAgICAgc3RyID0gcy5zdHJzdGFydCAtIHMuaW5zZXJ0O1xuICAgICAgcy5pbnNfaCA9IHMud2luZG93W3N0cl07XG5cbiAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgMV0pOyAqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbc3RyICsgMV0pICYgcy5oYXNoX21hc2s7XG4vLyNpZiBNSU5fTUFUQ0ggIT0gM1xuLy8gICAgICAgIENhbGwgdXBkYXRlX2hhc2goKSBNSU5fTUFUQ0gtMyBtb3JlIHRpbWVzXG4vLyNlbmRpZlxuICAgICAgd2hpbGUgKHMuaW5zZXJ0KSB7XG4gICAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgTUlOX01BVENILTFdKTsgKi9cbiAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbc3RyICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG5cbiAgICAgICAgcy5wcmV2W3N0ciAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyO1xuICAgICAgICBzdHIrKztcbiAgICAgICAgcy5pbnNlcnQtLTtcbiAgICAgICAgaWYgKHMubG9va2FoZWFkICsgcy5pbnNlcnQgPCBNSU5fTUFUQ0gpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvKiBJZiB0aGUgd2hvbGUgaW5wdXQgaGFzIGxlc3MgdGhhbiBNSU5fTUFUQ0ggYnl0ZXMsIGluc19oIGlzIGdhcmJhZ2UsXG4gICAgICogYnV0IHRoaXMgaXMgbm90IGltcG9ydGFudCBzaW5jZSBvbmx5IGxpdGVyYWwgYnl0ZXMgd2lsbCBiZSBlbWl0dGVkLlxuICAgICAqL1xuXG4gIH0gd2hpbGUgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBzLnN0cm0uYXZhaWxfaW4gIT09IDApO1xuXG4gIC8qIElmIHRoZSBXSU5fSU5JVCBieXRlcyBhZnRlciB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGRhdGEgaGF2ZSBuZXZlciBiZWVuXG4gICAqIHdyaXR0ZW4sIHRoZW4gemVybyB0aG9zZSBieXRlcyBpbiBvcmRlciB0byBhdm9pZCBtZW1vcnkgY2hlY2sgcmVwb3J0cyBvZlxuICAgKiB0aGUgdXNlIG9mIHVuaW5pdGlhbGl6ZWQgKG9yIHVuaW5pdGlhbGlzZWQgYXMgSnVsaWFuIHdyaXRlcykgYnl0ZXMgYnlcbiAgICogdGhlIGxvbmdlc3QgbWF0Y2ggcm91dGluZXMuICBVcGRhdGUgdGhlIGhpZ2ggd2F0ZXIgbWFyayBmb3IgdGhlIG5leHRcbiAgICogdGltZSB0aHJvdWdoIGhlcmUuICBXSU5fSU5JVCBpcyBzZXQgdG8gTUFYX01BVENIIHNpbmNlIHRoZSBsb25nZXN0IG1hdGNoXG4gICAqIHJvdXRpbmVzIGFsbG93IHNjYW5uaW5nIHRvIHN0cnN0YXJ0ICsgTUFYX01BVENILCBpZ25vcmluZyBsb29rYWhlYWQuXG4gICAqL1xuLy8gIGlmIChzLmhpZ2hfd2F0ZXIgPCBzLndpbmRvd19zaXplKSB7XG4vLyAgICB2YXIgY3VyciA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZDtcbi8vICAgIHZhciBpbml0ID0gMDtcbi8vXG4vLyAgICBpZiAocy5oaWdoX3dhdGVyIDwgY3Vycikge1xuLy8gICAgICAvKiBQcmV2aW91cyBoaWdoIHdhdGVyIG1hcmsgYmVsb3cgY3VycmVudCBkYXRhIC0tIHplcm8gV0lOX0lOSVRcbi8vICAgICAgICogYnl0ZXMgb3IgdXAgdG8gZW5kIG9mIHdpbmRvdywgd2hpY2hldmVyIGlzIGxlc3MuXG4vLyAgICAgICAqL1xuLy8gICAgICBpbml0ID0gcy53aW5kb3dfc2l6ZSAtIGN1cnI7XG4vLyAgICAgIGlmIChpbml0ID4gV0lOX0lOSVQpXG4vLyAgICAgICAgaW5pdCA9IFdJTl9JTklUO1xuLy8gICAgICB6bWVtemVybyhzLT53aW5kb3cgKyBjdXJyLCAodW5zaWduZWQpaW5pdCk7XG4vLyAgICAgIHMtPmhpZ2hfd2F0ZXIgPSBjdXJyICsgaW5pdDtcbi8vICAgIH1cbi8vICAgIGVsc2UgaWYgKHMtPmhpZ2hfd2F0ZXIgPCAodWxnKWN1cnIgKyBXSU5fSU5JVCkge1xuLy8gICAgICAvKiBIaWdoIHdhdGVyIG1hcmsgYXQgb3IgYWJvdmUgY3VycmVudCBkYXRhLCBidXQgYmVsb3cgY3VycmVudCBkYXRhXG4vLyAgICAgICAqIHBsdXMgV0lOX0lOSVQgLS0gemVybyBvdXQgdG8gY3VycmVudCBkYXRhIHBsdXMgV0lOX0lOSVQsIG9yIHVwXG4vLyAgICAgICAqIHRvIGVuZCBvZiB3aW5kb3csIHdoaWNoZXZlciBpcyBsZXNzLlxuLy8gICAgICAgKi9cbi8vICAgICAgaW5pdCA9ICh1bGcpY3VyciArIFdJTl9JTklUIC0gcy0+aGlnaF93YXRlcjtcbi8vICAgICAgaWYgKGluaXQgPiBzLT53aW5kb3dfc2l6ZSAtIHMtPmhpZ2hfd2F0ZXIpXG4vLyAgICAgICAgaW5pdCA9IHMtPndpbmRvd19zaXplIC0gcy0+aGlnaF93YXRlcjtcbi8vICAgICAgem1lbXplcm8ocy0+d2luZG93ICsgcy0+aGlnaF93YXRlciwgKHVuc2lnbmVkKWluaXQpO1xuLy8gICAgICBzLT5oaWdoX3dhdGVyICs9IGluaXQ7XG4vLyAgICB9XG4vLyAgfVxuLy9cbi8vICBBc3NlcnQoKHVsZylzLT5zdHJzdGFydCA8PSBzLT53aW5kb3dfc2l6ZSAtIE1JTl9MT09LQUhFQUQsXG4vLyAgICBcIm5vdCBlbm91Z2ggcm9vbSBmb3Igc2VhcmNoXCIpO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHkgd2l0aG91dCBjb21wcmVzc2lvbiBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGlucHV0IHN0cmVhbSwgcmV0dXJuXG4gKiB0aGUgY3VycmVudCBibG9jayBzdGF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgaW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IHNpbmNlXG4gKiB1bmNvbXByZXNzaWJsZSBkYXRhIGlzIHByb2JhYmx5IG5vdCB1c2VmdWwuIFRoaXMgZnVuY3Rpb24gaXMgdXNlZFxuICogb25seSBmb3IgdGhlIGxldmVsPTAgY29tcHJlc3Npb24gb3B0aW9uLlxuICogTk9URTogdGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgb3B0aW1pemVkIHRvIGF2b2lkIGV4dHJhIGNvcHlpbmcgZnJvbVxuICogd2luZG93IHRvIHBlbmRpbmdfYnVmLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3N0b3JlZChzLCBmbHVzaCkge1xuICAvKiBTdG9yZWQgYmxvY2tzIGFyZSBsaW1pdGVkIHRvIDB4ZmZmZiBieXRlcywgcGVuZGluZ19idWYgaXMgbGltaXRlZFxuICAgKiB0byBwZW5kaW5nX2J1Zl9zaXplLCBhbmQgZWFjaCBzdG9yZWQgYmxvY2sgaGFzIGEgNSBieXRlIGhlYWRlcjpcbiAgICovXG4gIHZhciBtYXhfYmxvY2tfc2l6ZSA9IDB4ZmZmZjtcblxuICBpZiAobWF4X2Jsb2NrX3NpemUgPiBzLnBlbmRpbmdfYnVmX3NpemUgLSA1KSB7XG4gICAgbWF4X2Jsb2NrX3NpemUgPSBzLnBlbmRpbmdfYnVmX3NpemUgLSA1O1xuICB9XG5cbiAgLyogQ29weSBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gaW5wdXQgdG8gb3V0cHV0OiAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogRmlsbCB0aGUgd2luZG93IGFzIG11Y2ggYXMgcG9zc2libGU6ICovXG4gICAgaWYgKHMubG9va2FoZWFkIDw9IDEpIHtcblxuICAgICAgLy9Bc3NlcnQocy0+c3Ryc3RhcnQgPCBzLT53X3NpemUrTUFYX0RJU1QocykgfHxcbiAgICAgIC8vICBzLT5ibG9ja19zdGFydCA+PSAobG9uZylzLT53X3NpemUsIFwic2xpZGUgdG9vIGxhdGVcIik7XG4vLyAgICAgIGlmICghKHMuc3Ryc3RhcnQgPCBzLndfc2l6ZSArIChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIHx8XG4vLyAgICAgICAgcy5ibG9ja19zdGFydCA+PSBzLndfc2l6ZSkpIHtcbi8vICAgICAgICB0aHJvdyAgbmV3IEVycm9yKFwic2xpZGUgdG9vIGxhdGVcIik7XG4vLyAgICAgIH1cblxuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDAgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cblxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICB9XG4gICAgLy9Bc3NlcnQocy0+YmxvY2tfc3RhcnQgPj0gMEwsIFwiYmxvY2sgZ29uZVwiKTtcbi8vICAgIGlmIChzLmJsb2NrX3N0YXJ0IDwgMCkgdGhyb3cgbmV3IEVycm9yKFwiYmxvY2sgZ29uZVwiKTtcblxuICAgIHMuc3Ryc3RhcnQgKz0gcy5sb29rYWhlYWQ7XG4gICAgcy5sb29rYWhlYWQgPSAwO1xuXG4gICAgLyogRW1pdCBhIHN0b3JlZCBibG9jayBpZiBwZW5kaW5nX2J1ZiB3aWxsIGJlIGZ1bGw6ICovXG4gICAgdmFyIG1heF9zdGFydCA9IHMuYmxvY2tfc3RhcnQgKyBtYXhfYmxvY2tfc2l6ZTtcblxuICAgIGlmIChzLnN0cnN0YXJ0ID09PSAwIHx8IHMuc3Ryc3RhcnQgPj0gbWF4X3N0YXJ0KSB7XG4gICAgICAvKiBzdHJzdGFydCA9PSAwIGlzIHBvc3NpYmxlIHdoZW4gd3JhcGFyb3VuZCBvbiAxNi1iaXQgbWFjaGluZSAqL1xuICAgICAgcy5sb29rYWhlYWQgPSBzLnN0cnN0YXJ0IC0gbWF4X3N0YXJ0O1xuICAgICAgcy5zdHJzdGFydCA9IG1heF9zdGFydDtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG5cblxuICAgIH1cbiAgICAvKiBGbHVzaCBpZiB3ZSBtYXkgaGF2ZSB0byBzbGlkZSwgb3RoZXJ3aXNlIGJsb2NrX3N0YXJ0IG1heSBiZWNvbWVcbiAgICAgKiBuZWdhdGl2ZSBhbmQgdGhlIGRhdGEgd2lsbCBiZSBnb25lOlxuICAgICAqL1xuICAgIGlmIChzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCA+PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cblxuICBzLmluc2VydCA9IDA7XG5cbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG5cbiAgaWYgKHMuc3Ryc3RhcnQgPiBzLmJsb2NrX3N0YXJ0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG5cbiAgcmV0dXJuIEJTX05FRURfTU9SRTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wcmVzcyBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGlucHV0IHN0cmVhbSwgcmV0dXJuIHRoZSBjdXJyZW50XG4gKiBibG9jayBzdGF0ZS5cbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgcGVyZm9ybSBsYXp5IGV2YWx1YXRpb24gb2YgbWF0Y2hlcyBhbmQgaW5zZXJ0c1xuICogbmV3IHN0cmluZ3MgaW4gdGhlIGRpY3Rpb25hcnkgb25seSBmb3IgdW5tYXRjaGVkIHN0cmluZ3Mgb3IgZm9yIHNob3J0XG4gKiBtYXRjaGVzLiBJdCBpcyB1c2VkIG9ubHkgZm9yIHRoZSBmYXN0IGNvbXByZXNzaW9uIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfZmFzdChzLCBmbHVzaCkge1xuICB2YXIgaGFzaF9oZWFkOyAgICAgICAgLyogaGVhZCBvZiB0aGUgaGFzaCBjaGFpbiAqL1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXG4gICAgICogc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBicmVhazsgLyogZmx1c2ggdGhlIGN1cnJlbnQgYmxvY2sgKi9cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiBJbnNlcnQgdGhlIHN0cmluZyB3aW5kb3dbc3Ryc3RhcnQgLi4gc3Ryc3RhcnQrMl0gaW4gdGhlXG4gICAgICogZGljdGlvbmFyeSwgYW5kIHNldCBoYXNoX2hlYWQgdG8gdGhlIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW46XG4gICAgICovXG4gICAgaGFzaF9oZWFkID0gMC8qTklMKi87XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcbiAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgIC8qKiovXG4gICAgfVxuXG4gICAgLyogRmluZCB0aGUgbG9uZ2VzdCBtYXRjaCwgZGlzY2FyZGluZyB0aG9zZSA8PSBwcmV2X2xlbmd0aC5cbiAgICAgKiBBdCB0aGlzIHBvaW50IHdlIGhhdmUgYWx3YXlzIG1hdGNoX2xlbmd0aCA8IE1JTl9NQVRDSFxuICAgICAqL1xuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmICgocy5zdHJzdGFydCAtIGhhc2hfaGVhZCkgPD0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpKSB7XG4gICAgICAvKiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgd2UgcHJldmVudCBtYXRjaGVzIHdpdGggdGhlIHN0cmluZ1xuICAgICAgICogb2Ygd2luZG93IGluZGV4IDAgKGluIHBhcnRpY3VsYXIgd2UgaGF2ZSB0byBhdm9pZCBhIG1hdGNoXG4gICAgICAgKiBvZiB0aGUgc3RyaW5nIHdpdGggaXRzZWxmIGF0IHRoZSBzdGFydCBvZiB0aGUgaW5wdXQgZmlsZSkuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gbG9uZ2VzdF9tYXRjaChzLCBoYXNoX2hlYWQpO1xuICAgICAgLyogbG9uZ2VzdF9tYXRjaCgpIHNldHMgbWF0Y2hfc3RhcnQgKi9cbiAgICB9XG4gICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkge1xuICAgICAgLy8gY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydCwgcy5tYXRjaF9zdGFydCwgcy5tYXRjaF9sZW5ndGgpOyAvLyBmb3IgZGVidWcgb25seVxuXG4gICAgICAvKioqIF90cl90YWxseV9kaXN0KHMsIHMuc3Ryc3RhcnQgLSBzLm1hdGNoX3N0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDtcblxuICAgICAgLyogSW5zZXJ0IG5ldyBzdHJpbmdzIGluIHRoZSBoYXNoIHRhYmxlIG9ubHkgaWYgdGhlIG1hdGNoIGxlbmd0aFxuICAgICAgICogaXMgbm90IHRvbyBsYXJnZS4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICAgICAqL1xuICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoIDw9IHMubWF4X2xhenlfbWF0Y2gvKm1heF9pbnNlcnRfbGVuZ3RoKi8gJiYgcy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoLS07IC8qIHN0cmluZyBhdCBzdHJzdGFydCBhbHJlYWR5IGluIHRhYmxlICovXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICAgIC8qIHN0cnN0YXJ0IG5ldmVyIGV4Y2VlZHMgV1NJWkUtTUFYX01BVENILCBzbyB0aGVyZSBhcmVcbiAgICAgICAgICAgKiBhbHdheXMgTUlOX01BVENIIGJ5dGVzIGFoZWFkLlxuICAgICAgICAgICAqL1xuICAgICAgICB9IHdoaWxlICgtLXMubWF0Y2hfbGVuZ3RoICE9PSAwKTtcbiAgICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgfSBlbHNlXG4gICAgICB7XG4gICAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICAgICAgcy5pbnNfaCA9IHMud2luZG93W3Muc3Ryc3RhcnRdO1xuICAgICAgICAvKiBVUERBVEVfSEFTSChzLCBzLmluc19oLCBzLndpbmRvd1tzLnN0cnN0YXJ0KzFdKTsgKi9cbiAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIDFdKSAmIHMuaGFzaF9tYXNrO1xuXG4vLyNpZiBNSU5fTUFUQ0ggIT0gM1xuLy8gICAgICAgICAgICAgICAgQ2FsbCBVUERBVEVfSEFTSCgpIE1JTl9NQVRDSC0zIG1vcmUgdGltZXNcbi8vI2VuZGlmXG4gICAgICAgIC8qIElmIGxvb2thaGVhZCA8IE1JTl9NQVRDSCwgaW5zX2ggaXMgZ2FyYmFnZSwgYnV0IGl0IGRvZXMgbm90XG4gICAgICAgICAqIG1hdHRlciBzaW5jZSBpdCB3aWxsIGJlIHJlY29tcHV0ZWQgYXQgbmV4dCBkZWZsYXRlIGNhbGwuXG4gICAgICAgICAqL1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBObyBtYXRjaCwgb3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMud2luZG93W3Muc3Ryc3RhcnRdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG5cbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgfVxuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gKChzLnN0cnN0YXJ0IDwgKE1JTl9NQVRDSCAtIDEpKSA/IHMuc3Ryc3RhcnQgOiBNSU5fTUFUQ0ggLSAxKTtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNhbWUgYXMgYWJvdmUsIGJ1dCBhY2hpZXZlcyBiZXR0ZXIgY29tcHJlc3Npb24uIFdlIHVzZSBhIGxhenlcbiAqIGV2YWx1YXRpb24gZm9yIG1hdGNoZXM6IGEgbWF0Y2ggaXMgZmluYWxseSBhZG9wdGVkIG9ubHkgaWYgdGhlcmUgaXNcbiAqIG5vIGJldHRlciBtYXRjaCBhdCB0aGUgbmV4dCB3aW5kb3cgcG9zaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfc2xvdyhzLCBmbHVzaCkge1xuICB2YXIgaGFzaF9oZWFkOyAgICAgICAgICAvKiBoZWFkIG9mIGhhc2ggY2hhaW4gKi9cbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIHZhciBtYXhfaW5zZXJ0O1xuXG4gIC8qIFByb2Nlc3MgdGhlIGlucHV0IGJsb2NrLiAqL1xuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgYWx3YXlzIGhhdmUgZW5vdWdoIGxvb2thaGVhZCwgZXhjZXB0XG4gICAgICogYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgZmlsZS4gV2UgbmVlZCBNQVhfTUFUQ0ggYnl0ZXNcbiAgICAgKiBmb3IgdGhlIG5leHQgbWF0Y2gsIHBsdXMgTUlOX01BVENIIGJ5dGVzIHRvIGluc2VydCB0aGVcbiAgICAgKiBzdHJpbmcgZm9sbG93aW5nIHRoZSBuZXh0IG1hdGNoLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7IGJyZWFrOyB9IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAvKk5JTCovO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAvKioqL1xuICAgIH1cblxuICAgIC8qIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXG4gICAgICovXG4gICAgcy5wcmV2X2xlbmd0aCA9IHMubWF0Y2hfbGVuZ3RoO1xuICAgIHMucHJldl9tYXRjaCA9IHMubWF0Y2hfc3RhcnQ7XG4gICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuXG4gICAgaWYgKGhhc2hfaGVhZCAhPT0gMC8qTklMKi8gJiYgcy5wcmV2X2xlbmd0aCA8IHMubWF4X2xhenlfbWF0Y2ggJiZcbiAgICAgICAgcy5zdHJzdGFydCAtIGhhc2hfaGVhZCA8PSAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKS8qTUFYX0RJU1QocykqLykge1xuICAgICAgLyogVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmdcbiAgICAgICAqIG9mIHdpbmRvdyBpbmRleCAwIChpbiBwYXJ0aWN1bGFyIHdlIGhhdmUgdG8gYXZvaWQgYSBtYXRjaFxuICAgICAgICogb2YgdGhlIHN0cmluZyB3aXRoIGl0c2VsZiBhdCB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IGZpbGUpLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTtcbiAgICAgIC8qIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0ICovXG5cbiAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSA1ICYmXG4gICAgICAgICAocy5zdHJhdGVneSA9PT0gWl9GSUxURVJFRCB8fCAocy5tYXRjaF9sZW5ndGggPT09IE1JTl9NQVRDSCAmJiBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCA+IDQwOTYvKlRPT19GQVIqLykpKSB7XG5cbiAgICAgICAgLyogSWYgcHJldl9tYXRjaCBpcyBhbHNvIE1JTl9NQVRDSCwgbWF0Y2hfc3RhcnQgaXMgZ2FyYmFnZVxuICAgICAgICAgKiBidXQgd2Ugd2lsbCBpZ25vcmUgdGhlIGN1cnJlbnQgbWF0Y2ggYW55d2F5LlxuICAgICAgICAgKi9cbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICAgICAgfVxuICAgIH1cbiAgICAvKiBJZiB0aGVyZSB3YXMgYSBtYXRjaCBhdCB0aGUgcHJldmlvdXMgc3RlcCBhbmQgdGhlIGN1cnJlbnRcbiAgICAgKiBtYXRjaCBpcyBub3QgYmV0dGVyLCBvdXRwdXQgdGhlIHByZXZpb3VzIG1hdGNoOlxuICAgICAqL1xuICAgIGlmIChzLnByZXZfbGVuZ3RoID49IE1JTl9NQVRDSCAmJiBzLm1hdGNoX2xlbmd0aCA8PSBzLnByZXZfbGVuZ3RoKSB7XG4gICAgICBtYXhfaW5zZXJ0ID0gcy5zdHJzdGFydCArIHMubG9va2FoZWFkIC0gTUlOX01BVENIO1xuICAgICAgLyogRG8gbm90IGluc2VydCBzdHJpbmdzIGluIGhhc2ggdGFibGUgYmV5b25kIHRoaXMuICovXG5cbiAgICAgIC8vY2hlY2tfbWF0Y2gocywgcy5zdHJzdGFydC0xLCBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGgpO1xuXG4gICAgICAvKioqX3RyX3RhbGx5X2Rpc3Qocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsXG4gICAgICAgICAgICAgICAgICAgICBzLnByZXZfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCBzLnN0cnN0YXJ0IC0gMSAtIHMucHJldl9tYXRjaCwgcy5wcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCk7XG4gICAgICAvKiBJbnNlcnQgaW4gaGFzaCB0YWJsZSBhbGwgc3RyaW5ncyB1cCB0byB0aGUgZW5kIG9mIHRoZSBtYXRjaC5cbiAgICAgICAqIHN0cnN0YXJ0LTEgYW5kIHN0cnN0YXJ0IGFyZSBhbHJlYWR5IGluc2VydGVkLiBJZiB0aGVyZSBpcyBub3RcbiAgICAgICAqIGVub3VnaCBsb29rYWhlYWQsIHRoZSBsYXN0IHR3byBzdHJpbmdzIGFyZSBub3QgaW5zZXJ0ZWQgaW5cbiAgICAgICAqIHRoZSBoYXNoIHRhYmxlLlxuICAgICAgICovXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLnByZXZfbGVuZ3RoIC0gMTtcbiAgICAgIHMucHJldl9sZW5ndGggLT0gMjtcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKCsrcy5zdHJzdGFydCA8PSBtYXhfaW5zZXJ0KSB7XG4gICAgICAgICAgLyoqKiBJTlNFUlRfU1RSSU5HKHMsIHMuc3Ryc3RhcnQsIGhhc2hfaGVhZCk7ICoqKi9cbiAgICAgICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgICAgcy5oZWFkW3MuaW5zX2hdID0gcy5zdHJzdGFydDtcbiAgICAgICAgICAvKioqL1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlICgtLXMucHJldl9sZW5ndGggIT09IDApO1xuICAgICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICAgICAgcy5zdHJzdGFydCsrO1xuXG4gICAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgICAgfVxuICAgICAgICAvKioqL1xuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkge1xuICAgICAgLyogSWYgdGhlcmUgd2FzIG5vIG1hdGNoIGF0IHRoZSBwcmV2aW91cyBwb3NpdGlvbiwgb3V0cHV0IGFcbiAgICAgICAqIHNpbmdsZSBsaXRlcmFsLiBJZiB0aGVyZSB3YXMgYSBtYXRjaCBidXQgdGhlIGN1cnJlbnQgbWF0Y2hcbiAgICAgICAqIGlzIGxvbmdlciwgdHJ1bmNhdGUgdGhlIHByZXZpb3VzIG1hdGNoIHRvIGEgc2luZ2xlIGxpdGVyYWwuXG4gICAgICAgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0LTFdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydC0xXSwgYmZsdXNoKTsgKioqL1xuICAgICAgYmZsdXNoID0gdHJlZXMuX3RyX3RhbGx5KHMsIDAsIHMud2luZG93W3Muc3Ryc3RhcnQgLSAxXSk7XG5cbiAgICAgIGlmIChiZmx1c2gpIHtcbiAgICAgICAgLyoqKiBGTFVTSF9CTE9DS19PTkxZKHMsIDApICoqKi9cbiAgICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICAgIC8qKiovXG4gICAgICB9XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLyogVGhlcmUgaXMgbm8gcHJldmlvdXMgbWF0Y2ggdG8gY29tcGFyZSB3aXRoLCB3YWl0IGZvclxuICAgICAgICogdGhlIG5leHQgc3RlcCB0byBkZWNpZGUuXG4gICAgICAgKi9cbiAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChmbHVzaCAhPSBaX05PX0ZMVVNILCBcIm5vIGZsdXNoP1wiKTtcbiAgaWYgKHMubWF0Y2hfYXZhaWxhYmxlKSB7XG4gICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnQtMV0pKTtcbiAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydC0xXSwgYmZsdXNoKTsgKioqL1xuICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pO1xuXG4gICAgcy5tYXRjaF9hdmFpbGFibGUgPSAwO1xuICB9XG4gIHMuaW5zZXJ0ID0gcy5zdHJzdGFydCA8IE1JTl9NQVRDSCAtIDEgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIIC0gMTtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG5cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGb3IgWl9STEUsIHNpbXBseSBsb29rIGZvciBydW5zIG9mIGJ5dGVzLCBnZW5lcmF0ZSBtYXRjaGVzIG9ubHkgb2YgZGlzdGFuY2VcbiAqIG9uZS4gIERvIG5vdCBtYWludGFpbiBhIGhhc2ggdGFibGUuICAoSXQgd2lsbCBiZSByZWdlbmVyYXRlZCBpZiB0aGlzIHJ1biBvZlxuICogZGVmbGF0ZSBzd2l0Y2hlcyBhd2F5IGZyb20gWl9STEUuKVxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3JsZShzLCBmbHVzaCkge1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuICB2YXIgcHJldjsgICAgICAgICAgICAgIC8qIGJ5dGUgYXQgZGlzdGFuY2Ugb25lIHRvIG1hdGNoICovXG4gIHZhciBzY2FuLCBzdHJlbmQ7ICAgICAgLyogc2NhbiBnb2VzIHVwIHRvIHN0cmVuZCBmb3IgbGVuZ3RoIG9mIHJ1biAqL1xuXG4gIHZhciBfd2luID0gcy53aW5kb3c7XG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBsb25nZXN0IHJ1biwgcGx1cyBvbmUgZm9yIHRoZSB1bnJvbGxlZCBsb29wLlxuICAgICAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0gpIHtcbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkIDw9IE1BWF9NQVRDSCAmJiBmbHVzaCA9PT0gWl9OT19GTFVTSCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7IGJyZWFrOyB9IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuXG4gICAgLyogU2VlIGhvdyBtYW55IHRpbWVzIHRoZSBwcmV2aW91cyBieXRlIHJlcGVhdHMgKi9cbiAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgaWYgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCAmJiBzLnN0cnN0YXJ0ID4gMCkge1xuICAgICAgc2NhbiA9IHMuc3Ryc3RhcnQgLSAxO1xuICAgICAgcHJldiA9IF93aW5bc2Nhbl07XG4gICAgICBpZiAocHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0pIHtcbiAgICAgICAgc3RyZW5kID0gcy5zdHJzdGFydCArIE1BWF9NQVRDSDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIC8qanNoaW50IG5vZW1wdHk6ZmFsc2UqL1xuICAgICAgICB9IHdoaWxlIChwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHNjYW4gPCBzdHJlbmQpO1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IE1BWF9NQVRDSCAtIChzdHJlbmQgLSBzY2FuKTtcbiAgICAgICAgaWYgKHMubWF0Y2hfbGVuZ3RoID4gcy5sb29rYWhlYWQpIHtcbiAgICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IHMubG9va2FoZWFkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvL0Fzc2VydChzY2FuIDw9IHMtPndpbmRvdysodUludCkocy0+d2luZG93X3NpemUtMSksIFwid2lsZCBzY2FuXCIpO1xuICAgIH1cblxuICAgIC8qIEVtaXQgbWF0Y2ggaWYgaGF2ZSBydW4gb2YgTUlOX01BVENIIG9yIGxvbmdlciwgZWxzZSBlbWl0IGxpdGVyYWwgKi9cbiAgICBpZiAocy5tYXRjaF9sZW5ndGggPj0gTUlOX01BVENIKSB7XG4gICAgICAvL2NoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQsIHMuc3Ryc3RhcnQgLSAxLCBzLm1hdGNoX2xlbmd0aCk7XG5cbiAgICAgIC8qKiogX3RyX3RhbGx5X2Rpc3QocywgMSwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gsIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAxLCBzLm1hdGNoX2xlbmd0aCAtIE1JTl9NQVRDSCk7XG5cbiAgICAgIHMubG9va2FoZWFkIC09IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgcy5zdHJzdGFydCArPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgLyogTm8gbWF0Y2gsIG91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLT53aW5kb3dbcy0+c3Ryc3RhcnRdKSk7XG4gICAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG5cbiAgICAgIHMubG9va2FoZWFkLS07XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgfVxuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gMDtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZvciBaX0hVRkZNQU5fT05MWSwgZG8gbm90IGxvb2sgZm9yIG1hdGNoZXMuICBEbyBub3QgbWFpbnRhaW4gYSBoYXNoIHRhYmxlLlxuICogKEl0IHdpbGwgYmUgcmVnZW5lcmF0ZWQgaWYgdGhpcyBydW4gb2YgZGVmbGF0ZSBzd2l0Y2hlcyBhd2F5IGZyb20gSHVmZm1hbi4pXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVfaHVmZihzLCBmbHVzaCkge1xuICB2YXIgYmZsdXNoOyAgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICBmb3IgKDs7KSB7XG4gICAgLyogTWFrZSBzdXJlIHRoYXQgd2UgaGF2ZSBhIGxpdGVyYWwgdG8gd3JpdGUuICovXG4gICAgaWYgKHMubG9va2FoZWFkID09PSAwKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrOyAgICAgIC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogT3V0cHV0IGEgbGl0ZXJhbCBieXRlICovXG4gICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0XSkpO1xuICAgIC8qKiogX3RyX3RhbGx5X2xpdChzLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSwgYmZsdXNoKTsgKioqL1xuICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSk7XG4gICAgcy5sb29rYWhlYWQtLTtcbiAgICBzLnN0cnN0YXJ0Kys7XG4gICAgaWYgKGJmbHVzaCkge1xuICAgICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgICAgfVxuICAgICAgLyoqKi9cbiAgICB9XG4gIH1cbiAgcy5pbnNlcnQgPSAwO1xuICBpZiAoZmx1c2ggPT09IFpfRklOSVNIKSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAxKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgdHJ1ZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19GSU5JU0hfU1RBUlRFRDtcbiAgICB9XG4gICAgLyoqKi9cbiAgICByZXR1cm4gQlNfRklOSVNIX0RPTkU7XG4gIH1cbiAgaWYgKHMubGFzdF9saXQpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCBmYWxzZSk7XG4gICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgfVxuICAgIC8qKiovXG4gIH1cbiAgcmV0dXJuIEJTX0JMT0NLX0RPTkU7XG59XG5cbi8qIFZhbHVlcyBmb3IgbWF4X2xhenlfbWF0Y2gsIGdvb2RfbWF0Y2ggYW5kIG1heF9jaGFpbl9sZW5ndGgsIGRlcGVuZGluZyBvblxuICogdGhlIGRlc2lyZWQgcGFjayBsZXZlbCAoMC4uOSkuIFRoZSB2YWx1ZXMgZ2l2ZW4gYmVsb3cgaGF2ZSBiZWVuIHR1bmVkIHRvXG4gKiBleGNsdWRlIHdvcnN0IGNhc2UgcGVyZm9ybWFuY2UgZm9yIHBhdGhvbG9naWNhbCBmaWxlcy4gQmV0dGVyIHZhbHVlcyBtYXkgYmVcbiAqIGZvdW5kIGZvciBzcGVjaWZpYyBmaWxlcy5cbiAqL1xuZnVuY3Rpb24gQ29uZmlnKGdvb2RfbGVuZ3RoLCBtYXhfbGF6eSwgbmljZV9sZW5ndGgsIG1heF9jaGFpbiwgZnVuYykge1xuICB0aGlzLmdvb2RfbGVuZ3RoID0gZ29vZF9sZW5ndGg7XG4gIHRoaXMubWF4X2xhenkgPSBtYXhfbGF6eTtcbiAgdGhpcy5uaWNlX2xlbmd0aCA9IG5pY2VfbGVuZ3RoO1xuICB0aGlzLm1heF9jaGFpbiA9IG1heF9jaGFpbjtcbiAgdGhpcy5mdW5jID0gZnVuYztcbn1cblxudmFyIGNvbmZpZ3VyYXRpb25fdGFibGU7XG5cbmNvbmZpZ3VyYXRpb25fdGFibGUgPSBbXG4gIC8qICAgICAgZ29vZCBsYXp5IG5pY2UgY2hhaW4gKi9cbiAgbmV3IENvbmZpZygwLCAwLCAwLCAwLCBkZWZsYXRlX3N0b3JlZCksICAgICAgICAgIC8qIDAgc3RvcmUgb25seSAqL1xuICBuZXcgQ29uZmlnKDQsIDQsIDgsIDQsIGRlZmxhdGVfZmFzdCksICAgICAgICAgICAgLyogMSBtYXggc3BlZWQsIG5vIGxhenkgbWF0Y2hlcyAqL1xuICBuZXcgQ29uZmlnKDQsIDUsIDE2LCA4LCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAgLyogMiAqL1xuICBuZXcgQ29uZmlnKDQsIDYsIDMyLCAzMiwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgLyogMyAqL1xuXG4gIG5ldyBDb25maWcoNCwgNCwgMTYsIDE2LCBkZWZsYXRlX3Nsb3cpLCAgICAgICAgICAvKiA0IGxhenkgbWF0Y2hlcyAqL1xuICBuZXcgQ29uZmlnKDgsIDE2LCAzMiwgMzIsIGRlZmxhdGVfc2xvdyksICAgICAgICAgLyogNSAqL1xuICBuZXcgQ29uZmlnKDgsIDE2LCAxMjgsIDEyOCwgZGVmbGF0ZV9zbG93KSwgICAgICAgLyogNiAqL1xuICBuZXcgQ29uZmlnKDgsIDMyLCAxMjgsIDI1NiwgZGVmbGF0ZV9zbG93KSwgICAgICAgLyogNyAqL1xuICBuZXcgQ29uZmlnKDMyLCAxMjgsIDI1OCwgMTAyNCwgZGVmbGF0ZV9zbG93KSwgICAgLyogOCAqL1xuICBuZXcgQ29uZmlnKDMyLCAyNTgsIDI1OCwgNDA5NiwgZGVmbGF0ZV9zbG93KSAgICAgLyogOSBtYXggY29tcHJlc3Npb24gKi9cbl07XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBJbml0aWFsaXplIHRoZSBcImxvbmdlc3QgbWF0Y2hcIiByb3V0aW5lcyBmb3IgYSBuZXcgemxpYiBzdHJlYW1cbiAqL1xuZnVuY3Rpb24gbG1faW5pdChzKSB7XG4gIHMud2luZG93X3NpemUgPSAyICogcy53X3NpemU7XG5cbiAgLyoqKiBDTEVBUl9IQVNIKHMpOyAqKiovXG4gIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcblxuICAvKiBTZXQgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzOlxuICAgKi9cbiAgcy5tYXhfbGF6eV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2xhenk7XG4gIHMuZ29vZF9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZ29vZF9sZW5ndGg7XG4gIHMubmljZV9tYXRjaCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubmljZV9sZW5ndGg7XG4gIHMubWF4X2NoYWluX2xlbmd0aCA9IGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0ubWF4X2NoYWluO1xuXG4gIHMuc3Ryc3RhcnQgPSAwO1xuICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgcy5sb29rYWhlYWQgPSAwO1xuICBzLmluc2VydCA9IDA7XG4gIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgcy5pbnNfaCA9IDA7XG59XG5cblxuZnVuY3Rpb24gRGVmbGF0ZVN0YXRlKCkge1xuICB0aGlzLnN0cm0gPSBudWxsOyAgICAgICAgICAgIC8qIHBvaW50ZXIgYmFjayB0byB0aGlzIHpsaWIgc3RyZWFtICovXG4gIHRoaXMuc3RhdHVzID0gMDsgICAgICAgICAgICAvKiBhcyB0aGUgbmFtZSBpbXBsaWVzICovXG4gIHRoaXMucGVuZGluZ19idWYgPSBudWxsOyAgICAgIC8qIG91dHB1dCBzdGlsbCBwZW5kaW5nICovXG4gIHRoaXMucGVuZGluZ19idWZfc2l6ZSA9IDA7ICAvKiBzaXplIG9mIHBlbmRpbmdfYnVmICovXG4gIHRoaXMucGVuZGluZ19vdXQgPSAwOyAgICAgICAvKiBuZXh0IHBlbmRpbmcgYnl0ZSB0byBvdXRwdXQgdG8gdGhlIHN0cmVhbSAqL1xuICB0aGlzLnBlbmRpbmcgPSAwOyAgICAgICAgICAgLyogbmIgb2YgYnl0ZXMgaW4gdGhlIHBlbmRpbmcgYnVmZmVyICovXG4gIHRoaXMud3JhcCA9IDA7ICAgICAgICAgICAgICAvKiBiaXQgMCB0cnVlIGZvciB6bGliLCBiaXQgMSB0cnVlIGZvciBnemlwICovXG4gIHRoaXMuZ3poZWFkID0gbnVsbDsgICAgICAgICAvKiBnemlwIGhlYWRlciBpbmZvcm1hdGlvbiB0byB3cml0ZSAqL1xuICB0aGlzLmd6aW5kZXggPSAwOyAgICAgICAgICAgLyogd2hlcmUgaW4gZXh0cmEsIG5hbWUsIG9yIGNvbW1lbnQgKi9cbiAgdGhpcy5tZXRob2QgPSBaX0RFRkxBVEVEOyAvKiBjYW4gb25seSBiZSBERUZMQVRFRCAqL1xuICB0aGlzLmxhc3RfZmx1c2ggPSAtMTsgICAvKiB2YWx1ZSBvZiBmbHVzaCBwYXJhbSBmb3IgcHJldmlvdXMgZGVmbGF0ZSBjYWxsICovXG5cbiAgdGhpcy53X3NpemUgPSAwOyAgLyogTFo3NyB3aW5kb3cgc2l6ZSAoMzJLIGJ5IGRlZmF1bHQpICovXG4gIHRoaXMud19iaXRzID0gMDsgIC8qIGxvZzIod19zaXplKSAgKDguLjE2KSAqL1xuICB0aGlzLndfbWFzayA9IDA7ICAvKiB3X3NpemUgLSAxICovXG5cbiAgdGhpcy53aW5kb3cgPSBudWxsO1xuICAvKiBTbGlkaW5nIHdpbmRvdy4gSW5wdXQgYnl0ZXMgYXJlIHJlYWQgaW50byB0aGUgc2Vjb25kIGhhbGYgb2YgdGhlIHdpbmRvdyxcbiAgICogYW5kIG1vdmUgdG8gdGhlIGZpcnN0IGhhbGYgbGF0ZXIgdG8ga2VlcCBhIGRpY3Rpb25hcnkgb2YgYXQgbGVhc3Qgd1NpemVcbiAgICogYnl0ZXMuIFdpdGggdGhpcyBvcmdhbml6YXRpb24sIG1hdGNoZXMgYXJlIGxpbWl0ZWQgdG8gYSBkaXN0YW5jZSBvZlxuICAgKiB3U2l6ZS1NQVhfTUFUQ0ggYnl0ZXMsIGJ1dCB0aGlzIGVuc3VyZXMgdGhhdCBJTyBpcyBhbHdheXNcbiAgICogcGVyZm9ybWVkIHdpdGggYSBsZW5ndGggbXVsdGlwbGUgb2YgdGhlIGJsb2NrIHNpemUuXG4gICAqL1xuXG4gIHRoaXMud2luZG93X3NpemUgPSAwO1xuICAvKiBBY3R1YWwgc2l6ZSBvZiB3aW5kb3c6IDIqd1NpemUsIGV4Y2VwdCB3aGVuIHRoZSB1c2VyIGlucHV0IGJ1ZmZlclxuICAgKiBpcyBkaXJlY3RseSB1c2VkIGFzIHNsaWRpbmcgd2luZG93LlxuICAgKi9cblxuICB0aGlzLnByZXYgPSBudWxsO1xuICAvKiBMaW5rIHRvIG9sZGVyIHN0cmluZyB3aXRoIHNhbWUgaGFzaCBpbmRleC4gVG8gbGltaXQgdGhlIHNpemUgb2YgdGhpc1xuICAgKiBhcnJheSB0byA2NEssIHRoaXMgbGluayBpcyBtYWludGFpbmVkIG9ubHkgZm9yIHRoZSBsYXN0IDMySyBzdHJpbmdzLlxuICAgKiBBbiBpbmRleCBpbiB0aGlzIGFycmF5IGlzIHRodXMgYSB3aW5kb3cgaW5kZXggbW9kdWxvIDMySy5cbiAgICovXG5cbiAgdGhpcy5oZWFkID0gbnVsbDsgICAvKiBIZWFkcyBvZiB0aGUgaGFzaCBjaGFpbnMgb3IgTklMLiAqL1xuXG4gIHRoaXMuaW5zX2ggPSAwOyAgICAgICAvKiBoYXNoIGluZGV4IG9mIHN0cmluZyB0byBiZSBpbnNlcnRlZCAqL1xuICB0aGlzLmhhc2hfc2l6ZSA9IDA7ICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIGhhc2ggdGFibGUgKi9cbiAgdGhpcy5oYXNoX2JpdHMgPSAwOyAgIC8qIGxvZzIoaGFzaF9zaXplKSAqL1xuICB0aGlzLmhhc2hfbWFzayA9IDA7ICAgLyogaGFzaF9zaXplLTEgKi9cblxuICB0aGlzLmhhc2hfc2hpZnQgPSAwO1xuICAvKiBOdW1iZXIgb2YgYml0cyBieSB3aGljaCBpbnNfaCBtdXN0IGJlIHNoaWZ0ZWQgYXQgZWFjaCBpbnB1dFxuICAgKiBzdGVwLiBJdCBtdXN0IGJlIHN1Y2ggdGhhdCBhZnRlciBNSU5fTUFUQ0ggc3RlcHMsIHRoZSBvbGRlc3RcbiAgICogYnl0ZSBubyBsb25nZXIgdGFrZXMgcGFydCBpbiB0aGUgaGFzaCBrZXksIHRoYXQgaXM6XG4gICAqICAgaGFzaF9zaGlmdCAqIE1JTl9NQVRDSCA+PSBoYXNoX2JpdHNcbiAgICovXG5cbiAgdGhpcy5ibG9ja19zdGFydCA9IDA7XG4gIC8qIFdpbmRvdyBwb3NpdGlvbiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjdXJyZW50IG91dHB1dCBibG9jay4gR2V0c1xuICAgKiBuZWdhdGl2ZSB3aGVuIHRoZSB3aW5kb3cgaXMgbW92ZWQgYmFja3dhcmRzLlxuICAgKi9cblxuICB0aGlzLm1hdGNoX2xlbmd0aCA9IDA7ICAgICAgLyogbGVuZ3RoIG9mIGJlc3QgbWF0Y2ggKi9cbiAgdGhpcy5wcmV2X21hdGNoID0gMDsgICAgICAgIC8qIHByZXZpb3VzIG1hdGNoICovXG4gIHRoaXMubWF0Y2hfYXZhaWxhYmxlID0gMDsgICAvKiBzZXQgaWYgcHJldmlvdXMgbWF0Y2ggZXhpc3RzICovXG4gIHRoaXMuc3Ryc3RhcnQgPSAwOyAgICAgICAgICAvKiBzdGFydCBvZiBzdHJpbmcgdG8gaW5zZXJ0ICovXG4gIHRoaXMubWF0Y2hfc3RhcnQgPSAwOyAgICAgICAvKiBzdGFydCBvZiBtYXRjaGluZyBzdHJpbmcgKi9cbiAgdGhpcy5sb29rYWhlYWQgPSAwOyAgICAgICAgIC8qIG51bWJlciBvZiB2YWxpZCBieXRlcyBhaGVhZCBpbiB3aW5kb3cgKi9cblxuICB0aGlzLnByZXZfbGVuZ3RoID0gMDtcbiAgLyogTGVuZ3RoIG9mIHRoZSBiZXN0IG1hdGNoIGF0IHByZXZpb3VzIHN0ZXAuIE1hdGNoZXMgbm90IGdyZWF0ZXIgdGhhbiB0aGlzXG4gICAqIGFyZSBkaXNjYXJkZWQuIFRoaXMgaXMgdXNlZCBpbiB0aGUgbGF6eSBtYXRjaCBldmFsdWF0aW9uLlxuICAgKi9cblxuICB0aGlzLm1heF9jaGFpbl9sZW5ndGggPSAwO1xuICAvKiBUbyBzcGVlZCB1cCBkZWZsYXRpb24sIGhhc2ggY2hhaW5zIGFyZSBuZXZlciBzZWFyY2hlZCBiZXlvbmQgdGhpc1xuICAgKiBsZW5ndGguICBBIGhpZ2hlciBsaW1pdCBpbXByb3ZlcyBjb21wcmVzc2lvbiByYXRpbyBidXQgZGVncmFkZXMgdGhlXG4gICAqIHNwZWVkLlxuICAgKi9cblxuICB0aGlzLm1heF9sYXp5X21hdGNoID0gMDtcbiAgLyogQXR0ZW1wdCB0byBmaW5kIGEgYmV0dGVyIG1hdGNoIG9ubHkgd2hlbiB0aGUgY3VycmVudCBtYXRjaCBpcyBzdHJpY3RseVxuICAgKiBzbWFsbGVyIHRoYW4gdGhpcyB2YWx1ZS4gVGhpcyBtZWNoYW5pc20gaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvblxuICAgKiBsZXZlbHMgPj0gNC5cbiAgICovXG4gIC8vIFRoYXQncyBhbGlhcyB0byBtYXhfbGF6eV9tYXRjaCwgZG9uJ3QgdXNlIGRpcmVjdGx5XG4gIC8vdGhpcy5tYXhfaW5zZXJ0X2xlbmd0aCA9IDA7XG4gIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGggaXMgbm90XG4gICAqIGdyZWF0ZXIgdGhhbiB0aGlzIGxlbmd0aC4gVGhpcyBzYXZlcyB0aW1lIGJ1dCBkZWdyYWRlcyBjb21wcmVzc2lvbi5cbiAgICogbWF4X2luc2VydF9sZW5ndGggaXMgdXNlZCBvbmx5IGZvciBjb21wcmVzc2lvbiBsZXZlbHMgPD0gMy5cbiAgICovXG5cbiAgdGhpcy5sZXZlbCA9IDA7ICAgICAvKiBjb21wcmVzc2lvbiBsZXZlbCAoMS4uOSkgKi9cbiAgdGhpcy5zdHJhdGVneSA9IDA7ICAvKiBmYXZvciBvciBmb3JjZSBIdWZmbWFuIGNvZGluZyovXG5cbiAgdGhpcy5nb29kX21hdGNoID0gMDtcbiAgLyogVXNlIGEgZmFzdGVyIHNlYXJjaCB3aGVuIHRoZSBwcmV2aW91cyBtYXRjaCBpcyBsb25nZXIgdGhhbiB0aGlzICovXG5cbiAgdGhpcy5uaWNlX21hdGNoID0gMDsgLyogU3RvcCBzZWFyY2hpbmcgd2hlbiBjdXJyZW50IG1hdGNoIGV4Y2VlZHMgdGhpcyAqL1xuXG4gICAgICAgICAgICAgIC8qIHVzZWQgYnkgdHJlZXMuYzogKi9cblxuICAvKiBEaWRuJ3QgdXNlIGN0X2RhdGEgdHlwZWRlZiBiZWxvdyB0byBzdXBwcmVzcyBjb21waWxlciB3YXJuaW5nICovXG5cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBkeW5fbHRyZWVbSEVBUF9TSVpFXTsgICAvKiBsaXRlcmFsIGFuZCBsZW5ndGggdHJlZSAqL1xuICAvLyBzdHJ1Y3QgY3RfZGF0YV9zIGR5bl9kdHJlZVsyKkRfQ09ERVMrMV07IC8qIGRpc3RhbmNlIHRyZWUgKi9cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBibF90cmVlWzIqQkxfQ09ERVMrMV07ICAvKiBIdWZmbWFuIHRyZWUgZm9yIGJpdCBsZW5ndGhzICovXG5cbiAgLy8gVXNlIGZsYXQgYXJyYXkgb2YgRE9VQkxFIHNpemUsIHdpdGggaW50ZXJsZWF2ZWQgZmF0YSxcbiAgLy8gYmVjYXVzZSBKUyBkb2VzIG5vdCBzdXBwb3J0IGVmZmVjdGl2ZVxuICB0aGlzLmR5bl9sdHJlZSAgPSBuZXcgdXRpbHMuQnVmMTYoSEVBUF9TSVpFICogMik7XG4gIHRoaXMuZHluX2R0cmVlICA9IG5ldyB1dGlscy5CdWYxNigoMiAqIERfQ09ERVMgKyAxKSAqIDIpO1xuICB0aGlzLmJsX3RyZWUgICAgPSBuZXcgdXRpbHMuQnVmMTYoKDIgKiBCTF9DT0RFUyArIDEpICogMik7XG4gIHplcm8odGhpcy5keW5fbHRyZWUpO1xuICB6ZXJvKHRoaXMuZHluX2R0cmVlKTtcbiAgemVybyh0aGlzLmJsX3RyZWUpO1xuXG4gIHRoaXMubF9kZXNjICAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBsaXRlcmFsIHRyZWUgKi9cbiAgdGhpcy5kX2Rlc2MgICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGRpc3RhbmNlIHRyZWUgKi9cbiAgdGhpcy5ibF9kZXNjICA9IG51bGw7ICAgICAgICAgLyogZGVzYy4gZm9yIGJpdCBsZW5ndGggdHJlZSAqL1xuXG4gIC8vdXNoIGJsX2NvdW50W01BWF9CSVRTKzFdO1xuICB0aGlzLmJsX2NvdW50ID0gbmV3IHV0aWxzLkJ1ZjE2KE1BWF9CSVRTICsgMSk7XG4gIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggZm9yIGFuIG9wdGltYWwgdHJlZSAqL1xuXG4gIC8vaW50IGhlYXBbMipMX0NPREVTKzFdOyAgICAgIC8qIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlcyAqL1xuICB0aGlzLmhlYXAgPSBuZXcgdXRpbHMuQnVmMTYoMiAqIExfQ09ERVMgKyAxKTsgIC8qIGhlYXAgdXNlZCB0byBidWlsZCB0aGUgSHVmZm1hbiB0cmVlcyAqL1xuICB6ZXJvKHRoaXMuaGVhcCk7XG5cbiAgdGhpcy5oZWFwX2xlbiA9IDA7ICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBoZWFwICovXG4gIHRoaXMuaGVhcF9tYXggPSAwOyAgICAgICAgICAgICAgIC8qIGVsZW1lbnQgb2YgbGFyZ2VzdCBmcmVxdWVuY3kgKi9cbiAgLyogVGhlIHNvbnMgb2YgaGVhcFtuXSBhcmUgaGVhcFsyKm5dIGFuZCBoZWFwWzIqbisxXS4gaGVhcFswXSBpcyBub3QgdXNlZC5cbiAgICogVGhlIHNhbWUgaGVhcCBhcnJheSBpcyB1c2VkIHRvIGJ1aWxkIGFsbCB0cmVlcy5cbiAgICovXG5cbiAgdGhpcy5kZXB0aCA9IG5ldyB1dGlscy5CdWYxNigyICogTF9DT0RFUyArIDEpOyAvL3VjaCBkZXB0aFsyKkxfQ09ERVMrMV07XG4gIHplcm8odGhpcy5kZXB0aCk7XG4gIC8qIERlcHRoIG9mIGVhY2ggc3VidHJlZSB1c2VkIGFzIHRpZSBicmVha2VyIGZvciB0cmVlcyBvZiBlcXVhbCBmcmVxdWVuY3lcbiAgICovXG5cbiAgdGhpcy5sX2J1ZiA9IDA7ICAgICAgICAgIC8qIGJ1ZmZlciBpbmRleCBmb3IgbGl0ZXJhbHMgb3IgbGVuZ3RocyAqL1xuXG4gIHRoaXMubGl0X2J1ZnNpemUgPSAwO1xuICAvKiBTaXplIG9mIG1hdGNoIGJ1ZmZlciBmb3IgbGl0ZXJhbHMvbGVuZ3Rocy4gIFRoZXJlIGFyZSA0IHJlYXNvbnMgZm9yXG4gICAqIGxpbWl0aW5nIGxpdF9idWZzaXplIHRvIDY0SzpcbiAgICogICAtIGZyZXF1ZW5jaWVzIGNhbiBiZSBrZXB0IGluIDE2IGJpdCBjb3VudGVyc1xuICAgKiAgIC0gaWYgY29tcHJlc3Npb24gaXMgbm90IHN1Y2Nlc3NmdWwgZm9yIHRoZSBmaXJzdCBibG9jaywgYWxsIGlucHV0XG4gICAqICAgICBkYXRhIGlzIHN0aWxsIGluIHRoZSB3aW5kb3cgc28gd2UgY2FuIHN0aWxsIGVtaXQgYSBzdG9yZWQgYmxvY2sgZXZlblxuICAgKiAgICAgd2hlbiBpbnB1dCBjb21lcyBmcm9tIHN0YW5kYXJkIGlucHV0LiAgKFRoaXMgY2FuIGFsc28gYmUgZG9uZSBmb3JcbiAgICogICAgIGFsbCBibG9ja3MgaWYgbGl0X2J1ZnNpemUgaXMgbm90IGdyZWF0ZXIgdGhhbiAzMksuKVxuICAgKiAgIC0gaWYgY29tcHJlc3Npb24gaXMgbm90IHN1Y2Nlc3NmdWwgZm9yIGEgZmlsZSBzbWFsbGVyIHRoYW4gNjRLLCB3ZSBjYW5cbiAgICogICAgIGV2ZW4gZW1pdCBhIHN0b3JlZCBmaWxlIGluc3RlYWQgb2YgYSBzdG9yZWQgYmxvY2sgKHNhdmluZyA1IGJ5dGVzKS5cbiAgICogICAgIFRoaXMgaXMgYXBwbGljYWJsZSBvbmx5IGZvciB6aXAgKG5vdCBnemlwIG9yIHpsaWIpLlxuICAgKiAgIC0gY3JlYXRpbmcgbmV3IEh1ZmZtYW4gdHJlZXMgbGVzcyBmcmVxdWVudGx5IG1heSBub3QgcHJvdmlkZSBmYXN0XG4gICAqICAgICBhZGFwdGF0aW9uIHRvIGNoYW5nZXMgaW4gdGhlIGlucHV0IGRhdGEgc3RhdGlzdGljcy4gKFRha2UgZm9yXG4gICAqICAgICBleGFtcGxlIGEgYmluYXJ5IGZpbGUgd2l0aCBwb29ybHkgY29tcHJlc3NpYmxlIGNvZGUgZm9sbG93ZWQgYnlcbiAgICogICAgIGEgaGlnaGx5IGNvbXByZXNzaWJsZSBzdHJpbmcgdGFibGUuKSBTbWFsbGVyIGJ1ZmZlciBzaXplcyBnaXZlXG4gICAqICAgICBmYXN0IGFkYXB0YXRpb24gYnV0IGhhdmUgb2YgY291cnNlIHRoZSBvdmVyaGVhZCBvZiB0cmFuc21pdHRpbmdcbiAgICogICAgIHRyZWVzIG1vcmUgZnJlcXVlbnRseS5cbiAgICogICAtIEkgY2FuJ3QgY291bnQgYWJvdmUgNFxuICAgKi9cblxuICB0aGlzLmxhc3RfbGl0ID0gMDsgICAgICAvKiBydW5uaW5nIGluZGV4IGluIGxfYnVmICovXG5cbiAgdGhpcy5kX2J1ZiA9IDA7XG4gIC8qIEJ1ZmZlciBpbmRleCBmb3IgZGlzdGFuY2VzLiBUbyBzaW1wbGlmeSB0aGUgY29kZSwgZF9idWYgYW5kIGxfYnVmIGhhdmVcbiAgICogdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzLiBUbyB1c2UgZGlmZmVyZW50IGxlbmd0aHMsIGFuIGV4dHJhIGZsYWdcbiAgICogYXJyYXkgd291bGQgYmUgbmVjZXNzYXJ5LlxuICAgKi9cblxuICB0aGlzLm9wdF9sZW4gPSAwOyAgICAgICAvKiBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBvcHRpbWFsIHRyZWVzICovXG4gIHRoaXMuc3RhdGljX2xlbiA9IDA7ICAgIC8qIGJpdCBsZW5ndGggb2YgY3VycmVudCBibG9jayB3aXRoIHN0YXRpYyB0cmVlcyAqL1xuICB0aGlzLm1hdGNoZXMgPSAwOyAgICAgICAvKiBudW1iZXIgb2Ygc3RyaW5nIG1hdGNoZXMgaW4gY3VycmVudCBibG9jayAqL1xuICB0aGlzLmluc2VydCA9IDA7ICAgICAgICAvKiBieXRlcyBhdCBlbmQgb2Ygd2luZG93IGxlZnQgdG8gaW5zZXJ0ICovXG5cblxuICB0aGlzLmJpX2J1ZiA9IDA7XG4gIC8qIE91dHB1dCBidWZmZXIuIGJpdHMgYXJlIGluc2VydGVkIHN0YXJ0aW5nIGF0IHRoZSBib3R0b20gKGxlYXN0XG4gICAqIHNpZ25pZmljYW50IGJpdHMpLlxuICAgKi9cbiAgdGhpcy5iaV92YWxpZCA9IDA7XG4gIC8qIE51bWJlciBvZiB2YWxpZCBiaXRzIGluIGJpX2J1Zi4gIEFsbCBiaXRzIGFib3ZlIHRoZSBsYXN0IHZhbGlkIGJpdFxuICAgKiBhcmUgYWx3YXlzIHplcm8uXG4gICAqL1xuXG4gIC8vIFVzZWQgZm9yIHdpbmRvdyBtZW1vcnkgaW5pdC4gV2Ugc2FmZWx5IGlnbm9yZSBpdCBmb3IgSlMuIFRoYXQgbWFrZXNcbiAgLy8gc2Vuc2Ugb25seSBmb3IgcG9pbnRlcnMgYW5kIG1lbW9yeSBjaGVjayB0b29scy5cbiAgLy90aGlzLmhpZ2hfd2F0ZXIgPSAwO1xuICAvKiBIaWdoIHdhdGVyIG1hcmsgb2Zmc2V0IGluIHdpbmRvdyBmb3IgaW5pdGlhbGl6ZWQgYnl0ZXMgLS0gYnl0ZXMgYWJvdmVcbiAgICogdGhpcyBhcmUgc2V0IHRvIHplcm8gaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGNoZWNrIHdhcm5pbmdzIHdoZW5cbiAgICogbG9uZ2VzdCBtYXRjaCByb3V0aW5lcyBhY2Nlc3MgYnl0ZXMgcGFzdCB0aGUgaW5wdXQuICBUaGlzIGlzIHRoZW5cbiAgICogdXBkYXRlZCB0byB0aGUgbmV3IGhpZ2ggd2F0ZXIgbWFyay5cbiAgICovXG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZVJlc2V0S2VlcChzdHJtKSB7XG4gIHZhciBzO1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gMDtcbiAgc3RybS5kYXRhX3R5cGUgPSBaX1VOS05PV047XG5cbiAgcyA9IHN0cm0uc3RhdGU7XG4gIHMucGVuZGluZyA9IDA7XG4gIHMucGVuZGluZ19vdXQgPSAwO1xuXG4gIGlmIChzLndyYXAgPCAwKSB7XG4gICAgcy53cmFwID0gLXMud3JhcDtcbiAgICAvKiB3YXMgbWFkZSBuZWdhdGl2ZSBieSBkZWZsYXRlKC4uLiwgWl9GSU5JU0gpOyAqL1xuICB9XG4gIHMuc3RhdHVzID0gKHMud3JhcCA/IElOSVRfU1RBVEUgOiBCVVNZX1NUQVRFKTtcbiAgc3RybS5hZGxlciA9IChzLndyYXAgPT09IDIpID9cbiAgICAwICAvLyBjcmMzMigwLCBaX05VTEwsIDApXG4gIDpcbiAgICAxOyAvLyBhZGxlcjMyKDAsIFpfTlVMTCwgMClcbiAgcy5sYXN0X2ZsdXNoID0gWl9OT19GTFVTSDtcbiAgdHJlZXMuX3RyX2luaXQocyk7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVSZXNldChzdHJtKSB7XG4gIHZhciByZXQgPSBkZWZsYXRlUmVzZXRLZWVwKHN0cm0pO1xuICBpZiAocmV0ID09PSBaX09LKSB7XG4gICAgbG1faW5pdChzdHJtLnN0YXRlKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVTZXRIZWFkZXIoc3RybSwgaGVhZCkge1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIGlmIChzdHJtLnN0YXRlLndyYXAgIT09IDIpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0cm0uc3RhdGUuZ3poZWFkID0gaGVhZDtcbiAgcmV0dXJuIFpfT0s7XG59XG5cblxuZnVuY3Rpb24gZGVmbGF0ZUluaXQyKHN0cm0sIGxldmVsLCBtZXRob2QsIHdpbmRvd0JpdHMsIG1lbUxldmVsLCBzdHJhdGVneSkge1xuICBpZiAoIXN0cm0pIHsgLy8gPT09IFpfTlVMTFxuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuICB2YXIgd3JhcCA9IDE7XG5cbiAgaWYgKGxldmVsID09PSBaX0RFRkFVTFRfQ09NUFJFU1NJT04pIHtcbiAgICBsZXZlbCA9IDY7XG4gIH1cblxuICBpZiAod2luZG93Qml0cyA8IDApIHsgLyogc3VwcHJlc3MgemxpYiB3cmFwcGVyICovXG4gICAgd3JhcCA9IDA7XG4gICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzO1xuICB9XG5cbiAgZWxzZSBpZiAod2luZG93Qml0cyA+IDE1KSB7XG4gICAgd3JhcCA9IDI7ICAgICAgICAgICAvKiB3cml0ZSBnemlwIHdyYXBwZXIgaW5zdGVhZCAqL1xuICAgIHdpbmRvd0JpdHMgLT0gMTY7XG4gIH1cblxuXG4gIGlmIChtZW1MZXZlbCA8IDEgfHwgbWVtTGV2ZWwgPiBNQVhfTUVNX0xFVkVMIHx8IG1ldGhvZCAhPT0gWl9ERUZMQVRFRCB8fFxuICAgIHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSB8fCBsZXZlbCA8IDAgfHwgbGV2ZWwgPiA5IHx8XG4gICAgc3RyYXRlZ3kgPCAwIHx8IHN0cmF0ZWd5ID4gWl9GSVhFRCkge1xuICAgIHJldHVybiBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cblxuICBpZiAod2luZG93Qml0cyA9PT0gOCkge1xuICAgIHdpbmRvd0JpdHMgPSA5O1xuICB9XG4gIC8qIHVudGlsIDI1Ni1ieXRlIHdpbmRvdyBidWcgZml4ZWQgKi9cblxuICB2YXIgcyA9IG5ldyBEZWZsYXRlU3RhdGUoKTtcblxuICBzdHJtLnN0YXRlID0gcztcbiAgcy5zdHJtID0gc3RybTtcblxuICBzLndyYXAgPSB3cmFwO1xuICBzLmd6aGVhZCA9IG51bGw7XG4gIHMud19iaXRzID0gd2luZG93Qml0cztcbiAgcy53X3NpemUgPSAxIDw8IHMud19iaXRzO1xuICBzLndfbWFzayA9IHMud19zaXplIC0gMTtcblxuICBzLmhhc2hfYml0cyA9IG1lbUxldmVsICsgNztcbiAgcy5oYXNoX3NpemUgPSAxIDw8IHMuaGFzaF9iaXRzO1xuICBzLmhhc2hfbWFzayA9IHMuaGFzaF9zaXplIC0gMTtcbiAgcy5oYXNoX3NoaWZ0ID0gfn4oKHMuaGFzaF9iaXRzICsgTUlOX01BVENIIC0gMSkgLyBNSU5fTUFUQ0gpO1xuXG4gIHMud2luZG93ID0gbmV3IHV0aWxzLkJ1Zjgocy53X3NpemUgKiAyKTtcbiAgcy5oZWFkID0gbmV3IHV0aWxzLkJ1ZjE2KHMuaGFzaF9zaXplKTtcbiAgcy5wcmV2ID0gbmV3IHV0aWxzLkJ1ZjE2KHMud19zaXplKTtcblxuICAvLyBEb24ndCBuZWVkIG1lbSBpbml0IG1hZ2ljIGZvciBKUy5cbiAgLy9zLmhpZ2hfd2F0ZXIgPSAwOyAgLyogbm90aGluZyB3cml0dGVuIHRvIHMtPndpbmRvdyB5ZXQgKi9cblxuICBzLmxpdF9idWZzaXplID0gMSA8PCAobWVtTGV2ZWwgKyA2KTsgLyogMTZLIGVsZW1lbnRzIGJ5IGRlZmF1bHQgKi9cblxuICBzLnBlbmRpbmdfYnVmX3NpemUgPSBzLmxpdF9idWZzaXplICogNDtcblxuICAvL292ZXJsYXkgPSAodXNoZiAqKSBaQUxMT0Moc3RybSwgcy0+bGl0X2J1ZnNpemUsIHNpemVvZih1c2gpKzIpO1xuICAvL3MtPnBlbmRpbmdfYnVmID0gKHVjaGYgKikgb3ZlcmxheTtcbiAgcy5wZW5kaW5nX2J1ZiA9IG5ldyB1dGlscy5CdWY4KHMucGVuZGluZ19idWZfc2l6ZSk7XG5cbiAgLy8gSXQgaXMgb2Zmc2V0IGZyb20gYHMucGVuZGluZ19idWZgIChzaXplIGlzIGBzLmxpdF9idWZzaXplICogMmApXG4gIC8vcy0+ZF9idWYgPSBvdmVybGF5ICsgcy0+bGl0X2J1ZnNpemUvc2l6ZW9mKHVzaCk7XG4gIHMuZF9idWYgPSAxICogcy5saXRfYnVmc2l6ZTtcblxuICAvL3MtPmxfYnVmID0gcy0+cGVuZGluZ19idWYgKyAoMStzaXplb2YodXNoKSkqcy0+bGl0X2J1ZnNpemU7XG4gIHMubF9idWYgPSAoMSArIDIpICogcy5saXRfYnVmc2l6ZTtcblxuICBzLmxldmVsID0gbGV2ZWw7XG4gIHMuc3RyYXRlZ3kgPSBzdHJhdGVneTtcbiAgcy5tZXRob2QgPSBtZXRob2Q7XG5cbiAgcmV0dXJuIGRlZmxhdGVSZXNldChzdHJtKTtcbn1cblxuZnVuY3Rpb24gZGVmbGF0ZUluaXQoc3RybSwgbGV2ZWwpIHtcbiAgcmV0dXJuIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgWl9ERUZMQVRFRCwgTUFYX1dCSVRTLCBERUZfTUVNX0xFVkVMLCBaX0RFRkFVTFRfU1RSQVRFR1kpO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGUoc3RybSwgZmx1c2gpIHtcbiAgdmFyIG9sZF9mbHVzaCwgcztcbiAgdmFyIGJlZywgdmFsOyAvLyBmb3IgZ3ppcCBoZWFkZXIgd3JpdGUgb25seVxuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fFxuICAgIGZsdXNoID4gWl9CTE9DSyB8fCBmbHVzaCA8IDApIHtcbiAgICByZXR1cm4gc3RybSA/IGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUikgOiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHMgPSBzdHJtLnN0YXRlO1xuXG4gIGlmICghc3RybS5vdXRwdXQgfHxcbiAgICAgICghc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB8fFxuICAgICAgKHMuc3RhdHVzID09PSBGSU5JU0hfU1RBVEUgJiYgZmx1c2ggIT09IFpfRklOSVNIKSkge1xuICAgIHJldHVybiBlcnIoc3RybSwgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSA/IFpfQlVGX0VSUk9SIDogWl9TVFJFQU1fRVJST1IpO1xuICB9XG5cbiAgcy5zdHJtID0gc3RybTsgLyoganVzdCBpbiBjYXNlICovXG4gIG9sZF9mbHVzaCA9IHMubGFzdF9mbHVzaDtcbiAgcy5sYXN0X2ZsdXNoID0gZmx1c2g7XG5cbiAgLyogV3JpdGUgdGhlIGhlYWRlciAqL1xuICBpZiAocy5zdGF0dXMgPT09IElOSVRfU1RBVEUpIHtcblxuICAgIGlmIChzLndyYXAgPT09IDIpIHsgLy8gR1pJUCBoZWFkZXJcbiAgICAgIHN0cm0uYWRsZXIgPSAwOyAgLy9jcmMzMigwTCwgWl9OVUxMLCAwKTtcbiAgICAgIHB1dF9ieXRlKHMsIDMxKTtcbiAgICAgIHB1dF9ieXRlKHMsIDEzOSk7XG4gICAgICBwdXRfYnl0ZShzLCA4KTtcbiAgICAgIGlmICghcy5nemhlYWQpIHsgLy8gcy0+Z3poZWFkID09IFpfTlVMTFxuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMubGV2ZWwgPT09IDkgPyAyIDpcbiAgICAgICAgICAgICAgICAgICAgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgP1xuICAgICAgICAgICAgICAgICAgICAgNCA6IDApKTtcbiAgICAgICAgcHV0X2J5dGUocywgT1NfQ09ERSk7XG4gICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGV4dCA/IDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzLmd6aGVhZC5oY3JjID8gMiA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKCFzLmd6aGVhZC5leHRyYSA/IDAgOiA0KSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQubmFtZSA/IDAgOiA4KSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQuY29tbWVudCA/IDAgOiAxNilcbiAgICAgICAgKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQudGltZSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQudGltZSA+PiAxNikgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gMjQpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMubGV2ZWwgPT09IDkgPyAyIDpcbiAgICAgICAgICAgICAgICAgICAgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIgP1xuICAgICAgICAgICAgICAgICAgICAgNCA6IDApKTtcbiAgICAgICAgcHV0X2J5dGUocywgcy5nemhlYWQub3MgJiAweGZmKTtcbiAgICAgICAgaWYgKHMuZ3poZWFkLmV4dHJhICYmIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCkge1xuICAgICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhLmxlbmd0aCAmIDB4ZmYpO1xuICAgICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC5leHRyYS5sZW5ndGggPj4gOCkgJiAweGZmKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocy5nemhlYWQuaGNyYykge1xuICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcsIDApO1xuICAgICAgICB9XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gRVhUUkFfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgLy8gREVGTEFURSBoZWFkZXJcbiAgICB7XG4gICAgICB2YXIgaGVhZGVyID0gKFpfREVGTEFURUQgKyAoKHMud19iaXRzIC0gOCkgPDwgNCkpIDw8IDg7XG4gICAgICB2YXIgbGV2ZWxfZmxhZ3MgPSAtMTtcblxuICAgICAgaWYgKHMuc3RyYXRlZ3kgPj0gWl9IVUZGTUFOX09OTFkgfHwgcy5sZXZlbCA8IDIpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAwO1xuICAgICAgfSBlbHNlIGlmIChzLmxldmVsIDwgNikge1xuICAgICAgICBsZXZlbF9mbGFncyA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHMubGV2ZWwgPT09IDYpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAzO1xuICAgICAgfVxuICAgICAgaGVhZGVyIHw9IChsZXZlbF9mbGFncyA8PCA2KTtcbiAgICAgIGlmIChzLnN0cnN0YXJ0ICE9PSAwKSB7IGhlYWRlciB8PSBQUkVTRVRfRElDVDsgfVxuICAgICAgaGVhZGVyICs9IDMxIC0gKGhlYWRlciAlIDMxKTtcblxuICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgcHV0U2hvcnRNU0IocywgaGVhZGVyKTtcblxuICAgICAgLyogU2F2ZSB0aGUgYWRsZXIzMiBvZiB0aGUgcHJlc2V0IGRpY3Rpb25hcnk6ICovXG4gICAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkge1xuICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyID4+PiAxNik7XG4gICAgICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgJiAweGZmZmYpO1xuICAgICAgfVxuICAgICAgc3RybS5hZGxlciA9IDE7IC8vIGFkbGVyMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgfVxuICB9XG5cbi8vI2lmZGVmIEdaSVBcbiAgaWYgKHMuc3RhdHVzID09PSBFWFRSQV9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5leHRyYS8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG5cbiAgICAgIHdoaWxlIChzLmd6aW5kZXggPCAocy5nemhlYWQuZXh0cmEubGVuZ3RoICYgMHhmZmZmKSkge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLmV4dHJhW3MuZ3ppbmRleF0gJiAweGZmKTtcbiAgICAgICAgcy5nemluZGV4Kys7XG4gICAgICB9XG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmd6aW5kZXggPT09IHMuZ3poZWFkLmV4dHJhLmxlbmd0aCkge1xuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IE5BTUVfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBOQU1FX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IE5BTUVfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQubmFtZS8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG4gICAgICAvL2ludCB2YWw7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIHZhbCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSlMgc3BlY2lmaWM6IGxpdHRsZSBtYWdpYyB0byBhZGQgemVybyB0ZXJtaW5hdG9yIHRvIGVuZCBvZiBzdHJpbmdcbiAgICAgICAgaWYgKHMuZ3ppbmRleCA8IHMuZ3poZWFkLm5hbWUubGVuZ3RoKSB7XG4gICAgICAgICAgdmFsID0gcy5nemhlYWQubmFtZS5jaGFyQ29kZUF0KHMuZ3ppbmRleCsrKSAmIDB4ZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCB2YWwpO1xuICAgICAgfSB3aGlsZSAodmFsICE9PSAwKTtcblxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsID09PSAwKSB7XG4gICAgICAgIHMuZ3ppbmRleCA9IDA7XG4gICAgICAgIHMuc3RhdHVzID0gQ09NTUVOVF9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IENPTU1FTlRfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gQ09NTUVOVF9TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5jb21tZW50LyogIT0gWl9OVUxMKi8pIHtcbiAgICAgIGJlZyA9IHMucGVuZGluZzsgIC8qIHN0YXJ0IG9mIGJ5dGVzIHRvIHVwZGF0ZSBjcmMgKi9cbiAgICAgIC8vaW50IHZhbDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICAgICAgYmVnID0gcy5wZW5kaW5nO1xuICAgICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgICAgdmFsID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBKUyBzcGVjaWZpYzogbGl0dGxlIG1hZ2ljIHRvIGFkZCB6ZXJvIHRlcm1pbmF0b3IgdG8gZW5kIG9mIHN0cmluZ1xuICAgICAgICBpZiAocy5nemluZGV4IDwgcy5nemhlYWQuY29tbWVudC5sZW5ndGgpIHtcbiAgICAgICAgICB2YWwgPSBzLmd6aGVhZC5jb21tZW50LmNoYXJDb2RlQXQocy5nemluZGV4KyspICYgMHhmZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHB1dF9ieXRlKHMsIHZhbCk7XG4gICAgICB9IHdoaWxlICh2YWwgIT09IDApO1xuXG4gICAgICBpZiAocy5nemhlYWQuaGNyYyAmJiBzLnBlbmRpbmcgPiBiZWcpIHtcbiAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgIH1cbiAgICAgIGlmICh2YWwgPT09IDApIHtcbiAgICAgICAgcy5zdGF0dXMgPSBIQ1JDX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gSENSQ19TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBIQ1JDX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLmhjcmMpIHtcbiAgICAgIGlmIChzLnBlbmRpbmcgKyAyID4gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICB9XG4gICAgICBpZiAocy5wZW5kaW5nICsgMiA8PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiA4KSAmIDB4ZmYpO1xuICAgICAgICBzdHJtLmFkbGVyID0gMDsgLy9jcmMzMigwTCwgWl9OVUxMLCAwKTtcbiAgICAgICAgcy5zdGF0dXMgPSBCVVNZX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICB9XG4gIH1cbi8vI2VuZGlmXG5cbiAgLyogRmx1c2ggYXMgbXVjaCBwZW5kaW5nIG91dHB1dCBhcyBwb3NzaWJsZSAqL1xuICBpZiAocy5wZW5kaW5nICE9PSAwKSB7XG4gICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgIC8qIFNpbmNlIGF2YWlsX291dCBpcyAwLCBkZWZsYXRlIHdpbGwgYmUgY2FsbGVkIGFnYWluIHdpdGhcbiAgICAgICAqIG1vcmUgb3V0cHV0IHNwYWNlLCBidXQgcG9zc2libHkgd2l0aCBib3RoIHBlbmRpbmcgYW5kXG4gICAgICAgKiBhdmFpbF9pbiBlcXVhbCB0byB6ZXJvLiBUaGVyZSB3b24ndCBiZSBhbnl0aGluZyB0byBkbyxcbiAgICAgICAqIGJ1dCB0aGlzIGlzIG5vdCBhbiBlcnJvciBzaXR1YXRpb24gc28gbWFrZSBzdXJlIHdlXG4gICAgICAgKiByZXR1cm4gT0sgaW5zdGVhZCBvZiBCVUZfRVJST1IgYXQgbmV4dCBjYWxsIG9mIGRlZmxhdGU6XG4gICAgICAgKi9cbiAgICAgIHMubGFzdF9mbHVzaCA9IC0xO1xuICAgICAgcmV0dXJuIFpfT0s7XG4gICAgfVxuXG4gICAgLyogTWFrZSBzdXJlIHRoZXJlIGlzIHNvbWV0aGluZyB0byBkbyBhbmQgYXZvaWQgZHVwbGljYXRlIGNvbnNlY3V0aXZlXG4gICAgICogZmx1c2hlcy4gRm9yIHJlcGVhdGVkIGFuZCB1c2VsZXNzIGNhbGxzIHdpdGggWl9GSU5JU0gsIHdlIGtlZXBcbiAgICAgKiByZXR1cm5pbmcgWl9TVFJFQU1fRU5EIGluc3RlYWQgb2YgWl9CVUZfRVJST1IuXG4gICAgICovXG4gIH0gZWxzZSBpZiAoc3RybS5hdmFpbF9pbiA9PT0gMCAmJiByYW5rKGZsdXNoKSA8PSByYW5rKG9sZF9mbHVzaCkgJiZcbiAgICBmbHVzaCAhPT0gWl9GSU5JU0gpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfQlVGX0VSUk9SKTtcbiAgfVxuXG4gIC8qIFVzZXIgbXVzdCBub3QgcHJvdmlkZSBtb3JlIGlucHV0IGFmdGVyIHRoZSBmaXJzdCBGSU5JU0g6ICovXG4gIGlmIChzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIHN0cm0uYXZhaWxfaW4gIT09IDApIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfQlVGX0VSUk9SKTtcbiAgfVxuXG4gIC8qIFN0YXJ0IGEgbmV3IGJsb2NrIG9yIGNvbnRpbnVlIHRoZSBjdXJyZW50IG9uZS5cbiAgICovXG4gIGlmIChzdHJtLmF2YWlsX2luICE9PSAwIHx8IHMubG9va2FoZWFkICE9PSAwIHx8XG4gICAgKGZsdXNoICE9PSBaX05PX0ZMVVNIICYmIHMuc3RhdHVzICE9PSBGSU5JU0hfU1RBVEUpKSB7XG4gICAgdmFyIGJzdGF0ZSA9IChzLnN0cmF0ZWd5ID09PSBaX0hVRkZNQU5fT05MWSkgPyBkZWZsYXRlX2h1ZmYocywgZmx1c2gpIDpcbiAgICAgIChzLnN0cmF0ZWd5ID09PSBaX1JMRSA/IGRlZmxhdGVfcmxlKHMsIGZsdXNoKSA6XG4gICAgICAgIGNvbmZpZ3VyYXRpb25fdGFibGVbcy5sZXZlbF0uZnVuYyhzLCBmbHVzaCkpO1xuXG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfRklOSVNIX1NUQVJURUQgfHwgYnN0YXRlID09PSBCU19GSU5JU0hfRE9ORSkge1xuICAgICAgcy5zdGF0dXMgPSBGSU5JU0hfU1RBVEU7XG4gICAgfVxuICAgIGlmIChic3RhdGUgPT09IEJTX05FRURfTU9SRSB8fCBic3RhdGUgPT09IEJTX0ZJTklTSF9TVEFSVEVEKSB7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7XG4gICAgICAgIC8qIGF2b2lkIEJVRl9FUlJPUiBuZXh0IGNhbGwsIHNlZSBhYm92ZSAqL1xuICAgICAgfVxuICAgICAgcmV0dXJuIFpfT0s7XG4gICAgICAvKiBJZiBmbHVzaCAhPSBaX05PX0ZMVVNIICYmIGF2YWlsX291dCA9PSAwLCB0aGUgbmV4dCBjYWxsXG4gICAgICAgKiBvZiBkZWZsYXRlIHNob3VsZCB1c2UgdGhlIHNhbWUgZmx1c2ggcGFyYW1ldGVyIHRvIG1ha2Ugc3VyZVxuICAgICAgICogdGhhdCB0aGUgZmx1c2ggaXMgY29tcGxldGUuIFNvIHdlIGRvbid0IGhhdmUgdG8gb3V0cHV0IGFuXG4gICAgICAgKiBlbXB0eSBibG9jayBoZXJlLCB0aGlzIHdpbGwgYmUgZG9uZSBhdCBuZXh0IGNhbGwuIFRoaXMgYWxzb1xuICAgICAgICogZW5zdXJlcyB0aGF0IGZvciBhIHZlcnkgc21hbGwgb3V0cHV0IGJ1ZmZlciwgd2UgZW1pdCBhdCBtb3N0XG4gICAgICAgKiBvbmUgZW1wdHkgYmxvY2suXG4gICAgICAgKi9cbiAgICB9XG4gICAgaWYgKGJzdGF0ZSA9PT0gQlNfQkxPQ0tfRE9ORSkge1xuICAgICAgaWYgKGZsdXNoID09PSBaX1BBUlRJQUxfRkxVU0gpIHtcbiAgICAgICAgdHJlZXMuX3RyX2FsaWduKHMpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoZmx1c2ggIT09IFpfQkxPQ0spIHsgLyogRlVMTF9GTFVTSCBvciBTWU5DX0ZMVVNIICovXG5cbiAgICAgICAgdHJlZXMuX3RyX3N0b3JlZF9ibG9jayhzLCAwLCAwLCBmYWxzZSk7XG4gICAgICAgIC8qIEZvciBhIGZ1bGwgZmx1c2gsIHRoaXMgZW1wdHkgYmxvY2sgd2lsbCBiZSByZWNvZ25pemVkXG4gICAgICAgICAqIGFzIGEgc3BlY2lhbCBtYXJrZXIgYnkgaW5mbGF0ZV9zeW5jKCkuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfRlVMTF9GTFVTSCkge1xuICAgICAgICAgIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqLyAgICAgICAgICAgICAvKiBmb3JnZXQgaGlzdG9yeSAqL1xuICAgICAgICAgIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcblxuICAgICAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICAgICAgcy5zdHJzdGFydCA9IDA7XG4gICAgICAgICAgICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgICAgICAgICAgIHMuaW5zZXJ0ID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgICBpZiAoc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcy5sYXN0X2ZsdXNoID0gLTE7IC8qIGF2b2lkIEJVRl9FUlJPUiBhdCBuZXh0IGNhbGwsIHNlZSBhYm92ZSAqL1xuICAgICAgICByZXR1cm4gWl9PSztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQoc3RybS0+YXZhaWxfb3V0ID4gMCwgXCJidWcyXCIpO1xuICAvL2lmIChzdHJtLmF2YWlsX291dCA8PSAwKSB7IHRocm93IG5ldyBFcnJvcihcImJ1ZzJcIik7fVxuXG4gIGlmIChmbHVzaCAhPT0gWl9GSU5JU0gpIHsgcmV0dXJuIFpfT0s7IH1cbiAgaWYgKHMud3JhcCA8PSAwKSB7IHJldHVybiBaX1NUUkVBTV9FTkQ7IH1cblxuICAvKiBXcml0ZSB0aGUgdHJhaWxlciAqL1xuICBpZiAocy53cmFwID09PSAyKSB7XG4gICAgcHV0X2J5dGUocywgc3RybS5hZGxlciAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDgpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gMTYpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gMjQpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgc3RybS50b3RhbF9pbiAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDgpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gMTYpICYgMHhmZik7XG4gICAgcHV0X2J5dGUocywgKHN0cm0udG90YWxfaW4gPj4gMjQpICYgMHhmZik7XG4gIH1cbiAgZWxzZVxuICB7XG4gICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpO1xuICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgJiAweGZmZmYpO1xuICB9XG5cbiAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgLyogSWYgYXZhaWxfb3V0IGlzIHplcm8sIHRoZSBhcHBsaWNhdGlvbiB3aWxsIGNhbGwgZGVmbGF0ZSBhZ2FpblxuICAgKiB0byBmbHVzaCB0aGUgcmVzdC5cbiAgICovXG4gIGlmIChzLndyYXAgPiAwKSB7IHMud3JhcCA9IC1zLndyYXA7IH1cbiAgLyogd3JpdGUgdGhlIHRyYWlsZXIgb25seSBvbmNlISAqL1xuICByZXR1cm4gcy5wZW5kaW5nICE9PSAwID8gWl9PSyA6IFpfU1RSRUFNX0VORDtcbn1cblxuZnVuY3Rpb24gZGVmbGF0ZUVuZChzdHJtKSB7XG4gIHZhciBzdGF0dXM7XG5cbiAgaWYgKCFzdHJtLyo9PSBaX05VTEwqLyB8fCAhc3RybS5zdGF0ZS8qPT0gWl9OVUxMKi8pIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzdGF0dXMgPSBzdHJtLnN0YXRlLnN0YXR1cztcbiAgaWYgKHN0YXR1cyAhPT0gSU5JVF9TVEFURSAmJlxuICAgIHN0YXR1cyAhPT0gRVhUUkFfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IE5BTUVfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IENPTU1FTlRfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEhDUkNfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEJVU1lfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEZJTklTSF9TVEFURVxuICApIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHN0cm0uc3RhdGUgPSBudWxsO1xuXG4gIHJldHVybiBzdGF0dXMgPT09IEJVU1lfU1RBVEUgPyBlcnIoc3RybSwgWl9EQVRBX0VSUk9SKSA6IFpfT0s7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZXMgdGhlIGNvbXByZXNzaW9uIGRpY3Rpb25hcnkgZnJvbSB0aGUgZ2l2ZW4gYnl0ZVxuICogc2VxdWVuY2Ugd2l0aG91dCBwcm9kdWNpbmcgYW55IGNvbXByZXNzZWQgb3V0cHV0LlxuICovXG5mdW5jdGlvbiBkZWZsYXRlU2V0RGljdGlvbmFyeShzdHJtLCBkaWN0aW9uYXJ5KSB7XG4gIHZhciBkaWN0TGVuZ3RoID0gZGljdGlvbmFyeS5sZW5ndGg7XG5cbiAgdmFyIHM7XG4gIHZhciBzdHIsIG47XG4gIHZhciB3cmFwO1xuICB2YXIgYXZhaWw7XG4gIHZhciBuZXh0O1xuICB2YXIgaW5wdXQ7XG4gIHZhciB0bXBEaWN0O1xuXG4gIGlmICghc3RybS8qPT0gWl9OVUxMKi8gfHwgIXN0cm0uc3RhdGUvKj09IFpfTlVMTCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgcyA9IHN0cm0uc3RhdGU7XG4gIHdyYXAgPSBzLndyYXA7XG5cbiAgaWYgKHdyYXAgPT09IDIgfHwgKHdyYXAgPT09IDEgJiYgcy5zdGF0dXMgIT09IElOSVRfU1RBVEUpIHx8IHMubG9va2FoZWFkKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgLyogd2hlbiB1c2luZyB6bGliIHdyYXBwZXJzLCBjb21wdXRlIEFkbGVyLTMyIGZvciBwcm92aWRlZCBkaWN0aW9uYXJ5ICovXG4gIGlmICh3cmFwID09PSAxKSB7XG4gICAgLyogYWRsZXIzMihzdHJtLT5hZGxlciwgZGljdGlvbmFyeSwgZGljdExlbmd0aCk7ICovXG4gICAgc3RybS5hZGxlciA9IGFkbGVyMzIoc3RybS5hZGxlciwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgMCk7XG4gIH1cblxuICBzLndyYXAgPSAwOyAgIC8qIGF2b2lkIGNvbXB1dGluZyBBZGxlci0zMiBpbiByZWFkX2J1ZiAqL1xuXG4gIC8qIGlmIGRpY3Rpb25hcnkgd291bGQgZmlsbCB3aW5kb3csIGp1c3QgcmVwbGFjZSB0aGUgaGlzdG9yeSAqL1xuICBpZiAoZGljdExlbmd0aCA+PSBzLndfc2l6ZSkge1xuICAgIGlmICh3cmFwID09PSAwKSB7ICAgICAgICAgICAgLyogYWxyZWFkeSBlbXB0eSBvdGhlcndpc2UgKi9cbiAgICAgIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqL1xuICAgICAgemVybyhzLmhlYWQpOyAvLyBGaWxsIHdpdGggTklMICg9IDApO1xuICAgICAgcy5zdHJzdGFydCA9IDA7XG4gICAgICBzLmJsb2NrX3N0YXJ0ID0gMDtcbiAgICAgIHMuaW5zZXJ0ID0gMDtcbiAgICB9XG4gICAgLyogdXNlIHRoZSB0YWlsICovXG4gICAgLy8gZGljdGlvbmFyeSA9IGRpY3Rpb25hcnkuc2xpY2UoZGljdExlbmd0aCAtIHMud19zaXplKTtcbiAgICB0bXBEaWN0ID0gbmV3IHV0aWxzLkJ1Zjgocy53X3NpemUpO1xuICAgIHV0aWxzLmFycmF5U2V0KHRtcERpY3QsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGggLSBzLndfc2l6ZSwgcy53X3NpemUsIDApO1xuICAgIGRpY3Rpb25hcnkgPSB0bXBEaWN0O1xuICAgIGRpY3RMZW5ndGggPSBzLndfc2l6ZTtcbiAgfVxuICAvKiBpbnNlcnQgZGljdGlvbmFyeSBpbnRvIHdpbmRvdyBhbmQgaGFzaCAqL1xuICBhdmFpbCA9IHN0cm0uYXZhaWxfaW47XG4gIG5leHQgPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgc3RybS5hdmFpbF9pbiA9IGRpY3RMZW5ndGg7XG4gIHN0cm0ubmV4dF9pbiA9IDA7XG4gIHN0cm0uaW5wdXQgPSBkaWN0aW9uYXJ5O1xuICBmaWxsX3dpbmRvdyhzKTtcbiAgd2hpbGUgKHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgIHN0ciA9IHMuc3Ryc3RhcnQ7XG4gICAgbiA9IHMubG9va2FoZWFkIC0gKE1JTl9NQVRDSCAtIDEpO1xuICAgIGRvIHtcbiAgICAgIC8qIFVQREFURV9IQVNIKHMsIHMtPmluc19oLCBzLT53aW5kb3dbc3RyICsgTUlOX01BVENILTFdKTsgKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuXG4gICAgICBzLnByZXZbc3RyICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuXG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzdHI7XG4gICAgICBzdHIrKztcbiAgICB9IHdoaWxlICgtLW4pO1xuICAgIHMuc3Ryc3RhcnQgPSBzdHI7XG4gICAgcy5sb29rYWhlYWQgPSBNSU5fTUFUQ0ggLSAxO1xuICAgIGZpbGxfd2luZG93KHMpO1xuICB9XG4gIHMuc3Ryc3RhcnQgKz0gcy5sb29rYWhlYWQ7XG4gIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0O1xuICBzLmluc2VydCA9IHMubG9va2FoZWFkO1xuICBzLmxvb2thaGVhZCA9IDA7XG4gIHMubWF0Y2hfbGVuZ3RoID0gcy5wcmV2X2xlbmd0aCA9IE1JTl9NQVRDSCAtIDE7XG4gIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgc3RybS5pbnB1dCA9IGlucHV0O1xuICBzdHJtLmF2YWlsX2luID0gYXZhaWw7XG4gIHMud3JhcCA9IHdyYXA7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmV4cG9ydHMuZGVmbGF0ZUluaXQgPSBkZWZsYXRlSW5pdDtcbmV4cG9ydHMuZGVmbGF0ZUluaXQyID0gZGVmbGF0ZUluaXQyO1xuZXhwb3J0cy5kZWZsYXRlUmVzZXQgPSBkZWZsYXRlUmVzZXQ7XG5leHBvcnRzLmRlZmxhdGVSZXNldEtlZXAgPSBkZWZsYXRlUmVzZXRLZWVwO1xuZXhwb3J0cy5kZWZsYXRlU2V0SGVhZGVyID0gZGVmbGF0ZVNldEhlYWRlcjtcbmV4cG9ydHMuZGVmbGF0ZSA9IGRlZmxhdGU7XG5leHBvcnRzLmRlZmxhdGVFbmQgPSBkZWZsYXRlRW5kO1xuZXhwb3J0cy5kZWZsYXRlU2V0RGljdGlvbmFyeSA9IGRlZmxhdGVTZXREaWN0aW9uYXJ5O1xuZXhwb3J0cy5kZWZsYXRlSW5mbyA9ICdwYWtvIGRlZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpJztcblxuLyogTm90IGltcGxlbWVudGVkXG5leHBvcnRzLmRlZmxhdGVCb3VuZCA9IGRlZmxhdGVCb3VuZDtcbmV4cG9ydHMuZGVmbGF0ZUNvcHkgPSBkZWZsYXRlQ29weTtcbmV4cG9ydHMuZGVmbGF0ZVBhcmFtcyA9IGRlZmxhdGVQYXJhbXM7XG5leHBvcnRzLmRlZmxhdGVQZW5kaW5nID0gZGVmbGF0ZVBlbmRpbmc7XG5leHBvcnRzLmRlZmxhdGVQcmltZSA9IGRlZmxhdGVQcmltZTtcbmV4cG9ydHMuZGVmbGF0ZVR1bmUgPSBkZWZsYXRlVHVuZTtcbiovXG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuZnVuY3Rpb24gR1poZWFkZXIoKSB7XG4gIC8qIHRydWUgaWYgY29tcHJlc3NlZCBkYXRhIGJlbGlldmVkIHRvIGJlIHRleHQgKi9cbiAgdGhpcy50ZXh0ICAgICAgID0gMDtcbiAgLyogbW9kaWZpY2F0aW9uIHRpbWUgKi9cbiAgdGhpcy50aW1lICAgICAgID0gMDtcbiAgLyogZXh0cmEgZmxhZ3MgKG5vdCB1c2VkIHdoZW4gd3JpdGluZyBhIGd6aXAgZmlsZSkgKi9cbiAgdGhpcy54ZmxhZ3MgICAgID0gMDtcbiAgLyogb3BlcmF0aW5nIHN5c3RlbSAqL1xuICB0aGlzLm9zICAgICAgICAgPSAwO1xuICAvKiBwb2ludGVyIHRvIGV4dHJhIGZpZWxkIG9yIFpfTlVMTCBpZiBub25lICovXG4gIHRoaXMuZXh0cmEgICAgICA9IG51bGw7XG4gIC8qIGV4dHJhIGZpZWxkIGxlbmd0aCAodmFsaWQgaWYgZXh0cmEgIT0gWl9OVUxMKSAqL1xuICB0aGlzLmV4dHJhX2xlbiAgPSAwOyAvLyBBY3R1YWxseSwgd2UgZG9uJ3QgbmVlZCBpdCBpbiBKUyxcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gYnV0IGxlYXZlIGZvciBmZXcgY29kZSBtb2RpZmljYXRpb25zXG5cbiAgLy9cbiAgLy8gU2V0dXAgbGltaXRzIGlzIG5vdCBuZWNlc3NhcnkgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeVxuICAvLyBmb3IgaW5mbGF0ZSB1c2UgY29uc3RhbnQgbGltaXQgaW4gNjU1MzYgYnl0ZXNcbiAgLy9cblxuICAvKiBzcGFjZSBhdCBleHRyYSAob25seSB3aGVuIHJlYWRpbmcgaGVhZGVyKSAqL1xuICAvLyB0aGlzLmV4dHJhX21heCAgPSAwO1xuICAvKiBwb2ludGVyIHRvIHplcm8tdGVybWluYXRlZCBmaWxlIG5hbWUgb3IgWl9OVUxMICovXG4gIHRoaXMubmFtZSAgICAgICA9ICcnO1xuICAvKiBzcGFjZSBhdCBuYW1lIChvbmx5IHdoZW4gcmVhZGluZyBoZWFkZXIpICovXG4gIC8vIHRoaXMubmFtZV9tYXggICA9IDA7XG4gIC8qIHBvaW50ZXIgdG8gemVyby10ZXJtaW5hdGVkIGNvbW1lbnQgb3IgWl9OVUxMICovXG4gIHRoaXMuY29tbWVudCAgICA9ICcnO1xuICAvKiBzcGFjZSBhdCBjb21tZW50IChvbmx5IHdoZW4gcmVhZGluZyBoZWFkZXIpICovXG4gIC8vIHRoaXMuY29tbV9tYXggICA9IDA7XG4gIC8qIHRydWUgaWYgdGhlcmUgd2FzIG9yIHdpbGwgYmUgYSBoZWFkZXIgY3JjICovXG4gIHRoaXMuaGNyYyAgICAgICA9IDA7XG4gIC8qIHRydWUgd2hlbiBkb25lIHJlYWRpbmcgZ3ppcCBoZWFkZXIgKG5vdCB1c2VkIHdoZW4gd3JpdGluZyBhIGd6aXAgZmlsZSkgKi9cbiAgdGhpcy5kb25lICAgICAgID0gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR1poZWFkZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuLy8gU2VlIHN0YXRlIGRlZnMgZnJvbSBpbmZsYXRlLmpzXG52YXIgQkFEID0gMzA7ICAgICAgIC8qIGdvdCBhIGRhdGEgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciBUWVBFID0gMTI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgdHlwZSBiaXRzLCBpbmNsdWRpbmcgbGFzdC1mbGFnIGJpdCAqL1xuXG4vKlxuICAgRGVjb2RlIGxpdGVyYWwsIGxlbmd0aCwgYW5kIGRpc3RhbmNlIGNvZGVzIGFuZCB3cml0ZSBvdXQgdGhlIHJlc3VsdGluZ1xuICAgbGl0ZXJhbCBhbmQgbWF0Y2ggYnl0ZXMgdW50aWwgZWl0aGVyIG5vdCBlbm91Z2ggaW5wdXQgb3Igb3V0cHV0IGlzXG4gICBhdmFpbGFibGUsIGFuIGVuZC1vZi1ibG9jayBpcyBlbmNvdW50ZXJlZCwgb3IgYSBkYXRhIGVycm9yIGlzIGVuY291bnRlcmVkLlxuICAgV2hlbiBsYXJnZSBlbm91Z2ggaW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIGFyZSBzdXBwbGllZCB0byBpbmZsYXRlKCksIGZvclxuICAgZXhhbXBsZSwgYSAxNksgaW5wdXQgYnVmZmVyIGFuZCBhIDY0SyBvdXRwdXQgYnVmZmVyLCBtb3JlIHRoYW4gOTUlIG9mIHRoZVxuICAgaW5mbGF0ZSBleGVjdXRpb24gdGltZSBpcyBzcGVudCBpbiB0aGlzIHJvdXRpbmUuXG5cbiAgIEVudHJ5IGFzc3VtcHRpb25zOlxuXG4gICAgICAgIHN0YXRlLm1vZGUgPT09IExFTlxuICAgICAgICBzdHJtLmF2YWlsX2luID49IDZcbiAgICAgICAgc3RybS5hdmFpbF9vdXQgPj0gMjU4XG4gICAgICAgIHN0YXJ0ID49IHN0cm0uYXZhaWxfb3V0XG4gICAgICAgIHN0YXRlLmJpdHMgPCA4XG5cbiAgIE9uIHJldHVybiwgc3RhdGUubW9kZSBpcyBvbmUgb2Y6XG5cbiAgICAgICAgTEVOIC0tIHJhbiBvdXQgb2YgZW5vdWdoIG91dHB1dCBzcGFjZSBvciBlbm91Z2ggYXZhaWxhYmxlIGlucHV0XG4gICAgICAgIFRZUEUgLS0gcmVhY2hlZCBlbmQgb2YgYmxvY2sgY29kZSwgaW5mbGF0ZSgpIHRvIGludGVycHJldCBuZXh0IGJsb2NrXG4gICAgICAgIEJBRCAtLSBlcnJvciBpbiBibG9jayBkYXRhXG5cbiAgIE5vdGVzOlxuXG4gICAgLSBUaGUgbWF4aW11bSBpbnB1dCBiaXRzIHVzZWQgYnkgYSBsZW5ndGgvZGlzdGFuY2UgcGFpciBpcyAxNSBiaXRzIGZvciB0aGVcbiAgICAgIGxlbmd0aCBjb2RlLCA1IGJpdHMgZm9yIHRoZSBsZW5ndGggZXh0cmEsIDE1IGJpdHMgZm9yIHRoZSBkaXN0YW5jZSBjb2RlLFxuICAgICAgYW5kIDEzIGJpdHMgZm9yIHRoZSBkaXN0YW5jZSBleHRyYS4gIFRoaXMgdG90YWxzIDQ4IGJpdHMsIG9yIHNpeCBieXRlcy5cbiAgICAgIFRoZXJlZm9yZSBpZiBzdHJtLmF2YWlsX2luID49IDYsIHRoZW4gdGhlcmUgaXMgZW5vdWdoIGlucHV0IHRvIGF2b2lkXG4gICAgICBjaGVja2luZyBmb3IgYXZhaWxhYmxlIGlucHV0IHdoaWxlIGRlY29kaW5nLlxuXG4gICAgLSBUaGUgbWF4aW11bSBieXRlcyB0aGF0IGEgc2luZ2xlIGxlbmd0aC9kaXN0YW5jZSBwYWlyIGNhbiBvdXRwdXQgaXMgMjU4XG4gICAgICBieXRlcywgd2hpY2ggaXMgdGhlIG1heGltdW0gbGVuZ3RoIHRoYXQgY2FuIGJlIGNvZGVkLiAgaW5mbGF0ZV9mYXN0KClcbiAgICAgIHJlcXVpcmVzIHN0cm0uYXZhaWxfb3V0ID49IDI1OCBmb3IgZWFjaCBsb29wIHRvIGF2b2lkIGNoZWNraW5nIGZvclxuICAgICAgb3V0cHV0IHNwYWNlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluZmxhdGVfZmFzdChzdHJtLCBzdGFydCkge1xuICB2YXIgc3RhdGU7XG4gIHZhciBfaW47ICAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmlucHV0ICovXG4gIHZhciBsYXN0OyAgICAgICAgICAgICAgICAgICAvKiBoYXZlIGVub3VnaCBpbnB1dCB3aGlsZSBpbiA8IGxhc3QgKi9cbiAgdmFyIF9vdXQ7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0ub3V0cHV0ICovXG4gIHZhciBiZWc7ICAgICAgICAgICAgICAgICAgICAvKiBpbmZsYXRlKCkncyBpbml0aWFsIHN0cm0ub3V0cHV0ICovXG4gIHZhciBlbmQ7ICAgICAgICAgICAgICAgICAgICAvKiB3aGlsZSBvdXQgPCBlbmQsIGVub3VnaCBzcGFjZSBhdmFpbGFibGUgKi9cbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gIHZhciBkbWF4OyAgICAgICAgICAgICAgICAgICAvKiBtYXhpbXVtIGRpc3RhbmNlIGZyb20gemxpYiBoZWFkZXIgKi9cbi8vI2VuZGlmXG4gIHZhciB3c2l6ZTsgICAgICAgICAgICAgICAgICAvKiB3aW5kb3cgc2l6ZSBvciB6ZXJvIGlmIG5vdCB1c2luZyB3aW5kb3cgKi9cbiAgdmFyIHdoYXZlOyAgICAgICAgICAgICAgICAgIC8qIHZhbGlkIGJ5dGVzIGluIHRoZSB3aW5kb3cgKi9cbiAgdmFyIHduZXh0OyAgICAgICAgICAgICAgICAgIC8qIHdpbmRvdyB3cml0ZSBpbmRleCAqL1xuICAvLyBVc2UgYHNfd2luZG93YCBpbnN0ZWFkIGB3aW5kb3dgLCBhdm9pZCBjb25mbGljdCB3aXRoIGluc3RydW1lbnRhdGlvbiB0b29sc1xuICB2YXIgc193aW5kb3c7ICAgICAgICAgICAgICAgLyogYWxsb2NhdGVkIHNsaWRpbmcgd2luZG93LCBpZiB3c2l6ZSAhPSAwICovXG4gIHZhciBob2xkOyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmhvbGQgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0uYml0cyAqL1xuICB2YXIgbGNvZGU7ICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5sZW5jb2RlICovXG4gIHZhciBkY29kZTsgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmRpc3Rjb2RlICovXG4gIHZhciBsbWFzazsgICAgICAgICAgICAgICAgICAvKiBtYXNrIGZvciBmaXJzdCBsZXZlbCBvZiBsZW5ndGggY29kZXMgKi9cbiAgdmFyIGRtYXNrOyAgICAgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGZpcnN0IGxldmVsIG9mIGRpc3RhbmNlIGNvZGVzICovXG4gIHZhciBoZXJlOyAgICAgICAgICAgICAgICAgICAvKiByZXRyaWV2ZWQgdGFibGUgZW50cnkgKi9cbiAgdmFyIG9wOyAgICAgICAgICAgICAgICAgICAgIC8qIGNvZGUgYml0cywgb3BlcmF0aW9uLCBleHRyYSBiaXRzLCBvciAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIHdpbmRvdyBwb3NpdGlvbiwgd2luZG93IGJ5dGVzIHRvIGNvcHkgKi9cbiAgdmFyIGxlbjsgICAgICAgICAgICAgICAgICAgIC8qIG1hdGNoIGxlbmd0aCwgdW51c2VkIGJ5dGVzICovXG4gIHZhciBkaXN0OyAgICAgICAgICAgICAgICAgICAvKiBtYXRjaCBkaXN0YW5jZSAqL1xuICB2YXIgZnJvbTsgICAgICAgICAgICAgICAgICAgLyogd2hlcmUgdG8gY29weSBtYXRjaCBmcm9tICovXG4gIHZhciBmcm9tX3NvdXJjZTtcblxuXG4gIHZhciBpbnB1dCwgb3V0cHV0OyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG5cbiAgLyogY29weSBzdGF0ZSB0byBsb2NhbCB2YXJpYWJsZXMgKi9cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICAvL2hlcmUgPSBzdGF0ZS5oZXJlO1xuICBfaW4gPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgbGFzdCA9IF9pbiArIChzdHJtLmF2YWlsX2luIC0gNSk7XG4gIF9vdXQgPSBzdHJtLm5leHRfb3V0O1xuICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgYmVnID0gX291dCAtIChzdGFydCAtIHN0cm0uYXZhaWxfb3V0KTtcbiAgZW5kID0gX291dCArIChzdHJtLmF2YWlsX291dCAtIDI1Nyk7XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICBkbWF4ID0gc3RhdGUuZG1heDtcbi8vI2VuZGlmXG4gIHdzaXplID0gc3RhdGUud3NpemU7XG4gIHdoYXZlID0gc3RhdGUud2hhdmU7XG4gIHduZXh0ID0gc3RhdGUud25leHQ7XG4gIHNfd2luZG93ID0gc3RhdGUud2luZG93O1xuICBob2xkID0gc3RhdGUuaG9sZDtcbiAgYml0cyA9IHN0YXRlLmJpdHM7XG4gIGxjb2RlID0gc3RhdGUubGVuY29kZTtcbiAgZGNvZGUgPSBzdGF0ZS5kaXN0Y29kZTtcbiAgbG1hc2sgPSAoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDE7XG4gIGRtYXNrID0gKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMTtcblxuXG4gIC8qIGRlY29kZSBsaXRlcmFscyBhbmQgbGVuZ3RoL2Rpc3RhbmNlcyB1bnRpbCBlbmQtb2YtYmxvY2sgb3Igbm90IGVub3VnaFxuICAgICBpbnB1dCBkYXRhIG9yIG91dHB1dCBzcGFjZSAqL1xuXG4gIHRvcDpcbiAgZG8ge1xuICAgIGlmIChiaXRzIDwgMTUpIHtcbiAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICBiaXRzICs9IDg7XG4gICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgYml0cyArPSA4O1xuICAgIH1cblxuICAgIGhlcmUgPSBsY29kZVtob2xkICYgbG1hc2tdO1xuXG4gICAgZG9sZW46XG4gICAgZm9yICg7OykgeyAvLyBHb3RvIGVtdWxhdGlvblxuICAgICAgb3AgPSBoZXJlID4+PiAyNC8qaGVyZS5iaXRzKi87XG4gICAgICBob2xkID4+Pj0gb3A7XG4gICAgICBiaXRzIC09IG9wO1xuICAgICAgb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZi8qaGVyZS5vcCovO1xuICAgICAgaWYgKG9wID09PSAwKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBsaXRlcmFsICovXG4gICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBoZXJlLnZhbCA+PSAweDIwICYmIGhlcmUudmFsIDwgMHg3ZiA/XG4gICAgICAgIC8vICAgICAgICBcImluZmxhdGU6ICAgICAgICAgbGl0ZXJhbCAnJWMnXFxuXCIgOlxuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgMHglMDJ4XFxuXCIsIGhlcmUudmFsKSk7XG4gICAgICAgIG91dHB1dFtfb3V0KytdID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9wICYgMTYpIHsgICAgICAgICAgICAgICAgICAgICAvKiBsZW5ndGggYmFzZSAqL1xuICAgICAgICBsZW4gPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgICBvcCAmPSAxNTsgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyAqL1xuICAgICAgICBpZiAob3ApIHtcbiAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZW4gKz0gaG9sZCAmICgoMSA8PCBvcCkgLSAxKTtcbiAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGxlbmd0aCAldVxcblwiLCBsZW4pKTtcbiAgICAgICAgaWYgKGJpdHMgPCAxNSkge1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbX2luKytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIGhlcmUgPSBkY29kZVtob2xkICYgZG1hc2tdO1xuXG4gICAgICAgIGRvZGlzdDpcbiAgICAgICAgZm9yICg7OykgeyAvLyBnb3RvIGVtdWxhdGlvblxuICAgICAgICAgIG9wID0gaGVyZSA+Pj4gMjQvKmhlcmUuYml0cyovO1xuICAgICAgICAgIGhvbGQgPj4+PSBvcDtcbiAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgIG9wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmYvKmhlcmUub3AqLztcblxuICAgICAgICAgIGlmIChvcCAmIDE2KSB7ICAgICAgICAgICAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhc2UgKi9cbiAgICAgICAgICAgIGRpc3QgPSBoZXJlICYgMHhmZmZmLypoZXJlLnZhbCovO1xuICAgICAgICAgICAgb3AgJj0gMTU7ICAgICAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyAqL1xuICAgICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzdCArPSBob2xkICYgKCgxIDw8IG9wKSAtIDEpO1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgICAgICAgICAgIGlmIChkaXN0ID4gZG1heCkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgICBiaXRzIC09IG9wO1xuICAgICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxcblwiLCBkaXN0KSk7XG4gICAgICAgICAgICBvcCA9IF9vdXQgLSBiZWc7ICAgICAgICAgICAgICAgIC8qIG1heCBkaXN0YW5jZSBpbiBvdXRwdXQgKi9cbiAgICAgICAgICAgIGlmIChkaXN0ID4gb3ApIHsgICAgICAgICAgICAgICAgLyogc2VlIGlmIGNvcHkgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgb3AgPSBkaXN0IC0gb3A7ICAgICAgICAgICAgICAgLyogZGlzdGFuY2UgYmFjayBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgaWYgKG9wID4gd2hhdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkge1xuICAgICAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIHRvcDtcbiAgICAgICAgICAgICAgICB9XG5cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYXVsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG4vLyNpZmRlZiBJTkZMQVRFX0FMTE9XX0lOVkFMSURfRElTVEFOQ0VfVE9PRkFSX0FSUlJcbi8vICAgICAgICAgICAgICAgIGlmIChsZW4gPD0gb3AgLSB3aGF2ZSkge1xuLy8gICAgICAgICAgICAgICAgICBkbyB7XG4vLyAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSAwO1xuLy8gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWxlbik7XG4vLyAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHRvcDtcbi8vICAgICAgICAgICAgICAgIH1cbi8vICAgICAgICAgICAgICAgIGxlbiAtPSBvcCAtIHdoYXZlO1xuLy8gICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IDA7XG4vLyAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wID4gd2hhdmUpO1xuLy8gICAgICAgICAgICAgICAgaWYgKG9wID09PSAwKSB7XG4vLyAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDtcbi8vICAgICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4vLyAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbGVuKTtcbi8vICAgICAgICAgICAgICAgICAgY29udGludWUgdG9wO1xuLy8gICAgICAgICAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmcm9tID0gMDsgLy8gd2luZG93IGluZGV4XG4gICAgICAgICAgICAgIGZyb21fc291cmNlID0gc193aW5kb3c7XG4gICAgICAgICAgICAgIGlmICh3bmV4dCA9PT0gMCkgeyAgICAgICAgICAgLyogdmVyeSBjb21tb24gY2FzZSAqL1xuICAgICAgICAgICAgICAgIGZyb20gKz0gd3NpemUgLSBvcDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2UgaWYgKHduZXh0IDwgb3ApIHsgICAgICAvKiB3cmFwIGFyb3VuZCB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHdzaXplICsgd25leHQgLSBvcDtcbiAgICAgICAgICAgICAgICBvcCAtPSB3bmV4dDtcbiAgICAgICAgICAgICAgICBpZiAob3AgPCBsZW4pIHsgICAgICAgICAvKiBzb21lIGZyb20gZW5kIG9mIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSAwO1xuICAgICAgICAgICAgICAgICAgaWYgKHduZXh0IDwgbGVuKSB7ICAvKiBzb21lIGZyb20gc3RhcnQgb2Ygd2luZG93ICovXG4gICAgICAgICAgICAgICAgICAgIG9wID0gd25leHQ7XG4gICAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gc193aW5kb3dbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgICAgICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgLyogY29udGlndW91cyBpbiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHduZXh0IC0gb3A7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3aGlsZSAobGVuID4gMikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAgICAgICAgIC8qIGNvcHkgZGlyZWN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgIGRvIHsgICAgICAgICAgICAgICAgICAgICAgICAvKiBtaW5pbXVtIGxlbmd0aCBpcyB0aHJlZSAqL1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGxlbiAtPSAzO1xuICAgICAgICAgICAgICB9IHdoaWxlIChsZW4gPiAyKTtcbiAgICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA+IDEpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgeyAgICAgICAgICAvKiAybmQgbGV2ZWwgZGlzdGFuY2UgY29kZSAqL1xuICAgICAgICAgICAgaGVyZSA9IGRjb2RlWyhoZXJlICYgMHhmZmZmKS8qaGVyZS52YWwqLyArIChob2xkICYgKCgxIDw8IG9wKSAtIDEpKV07XG4gICAgICAgICAgICBjb250aW51ZSBkb2Rpc3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSBjb2RlJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7IC8vIG5lZWQgdG8gZW11bGF0ZSBnb3RvIHZpYSBcImNvbnRpbnVlXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZiAoKG9wICYgNjQpID09PSAwKSB7ICAgICAgICAgICAgICAvKiAybmQgbGV2ZWwgbGVuZ3RoIGNvZGUgKi9cbiAgICAgICAgaGVyZSA9IGxjb2RlWyhoZXJlICYgMHhmZmZmKS8qaGVyZS52YWwqLyArIChob2xkICYgKCgxIDw8IG9wKSAtIDEpKV07XG4gICAgICAgIGNvbnRpbnVlIGRvbGVuO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob3AgJiAzMikgeyAgICAgICAgICAgICAgICAgICAgIC8qIGVuZC1vZi1ibG9jayAqL1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGVuZCBvZiBibG9ja1xcblwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhayB0b3A7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgfVxuXG4gICAgICBicmVhazsgLy8gbmVlZCB0byBlbXVsYXRlIGdvdG8gdmlhIFwiY29udGludWVcIlxuICAgIH1cbiAgfSB3aGlsZSAoX2luIDwgbGFzdCAmJiBfb3V0IDwgZW5kKTtcblxuICAvKiByZXR1cm4gdW51c2VkIGJ5dGVzIChvbiBlbnRyeSwgYml0cyA8IDgsIHNvIGluIHdvbid0IGdvIHRvbyBmYXIgYmFjaykgKi9cbiAgbGVuID0gYml0cyA+PiAzO1xuICBfaW4gLT0gbGVuO1xuICBiaXRzIC09IGxlbiA8PCAzO1xuICBob2xkICY9ICgxIDw8IGJpdHMpIC0gMTtcblxuICAvKiB1cGRhdGUgc3RhdGUgYW5kIHJldHVybiAqL1xuICBzdHJtLm5leHRfaW4gPSBfaW47XG4gIHN0cm0ubmV4dF9vdXQgPSBfb3V0O1xuICBzdHJtLmF2YWlsX2luID0gKF9pbiA8IGxhc3QgPyA1ICsgKGxhc3QgLSBfaW4pIDogNSAtIChfaW4gLSBsYXN0KSk7XG4gIHN0cm0uYXZhaWxfb3V0ID0gKF9vdXQgPCBlbmQgPyAyNTcgKyAoZW5kIC0gX291dCkgOiAyNTcgLSAoX291dCAtIGVuZCkpO1xuICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgc3RhdGUuYml0cyA9IGJpdHM7XG4gIHJldHVybjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxudmFyIHV0aWxzICAgICAgICAgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcbnZhciBhZGxlcjMyICAgICAgID0gcmVxdWlyZSgnLi9hZGxlcjMyJyk7XG52YXIgY3JjMzIgICAgICAgICA9IHJlcXVpcmUoJy4vY3JjMzInKTtcbnZhciBpbmZsYXRlX2Zhc3QgID0gcmVxdWlyZSgnLi9pbmZmYXN0Jyk7XG52YXIgaW5mbGF0ZV90YWJsZSA9IHJlcXVpcmUoJy4vaW5mdHJlZXMnKTtcblxudmFyIENPREVTID0gMDtcbnZhciBMRU5TID0gMTtcbnZhciBESVNUUyA9IDI7XG5cbi8qIFB1YmxpYyBjb25zdGFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbi8qIEFsbG93ZWQgZmx1c2ggdmFsdWVzOyBzZWUgZGVmbGF0ZSgpIGFuZCBpbmZsYXRlKCkgYmVsb3cgZm9yIGRldGFpbHMgKi9cbi8vdmFyIFpfTk9fRkxVU0ggICAgICA9IDA7XG4vL3ZhciBaX1BBUlRJQUxfRkxVU0ggPSAxO1xuLy92YXIgWl9TWU5DX0ZMVVNIICAgID0gMjtcbi8vdmFyIFpfRlVMTF9GTFVTSCAgICA9IDM7XG52YXIgWl9GSU5JU0ggICAgICAgID0gNDtcbnZhciBaX0JMT0NLICAgICAgICAgPSA1O1xudmFyIFpfVFJFRVMgICAgICAgICA9IDY7XG5cblxuLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICovXG52YXIgWl9PSyAgICAgICAgICAgID0gMDtcbnZhciBaX1NUUkVBTV9FTkQgICAgPSAxO1xudmFyIFpfTkVFRF9ESUNUICAgICA9IDI7XG4vL3ZhciBaX0VSUk5PICAgICAgICAgPSAtMTtcbnZhciBaX1NUUkVBTV9FUlJPUiAgPSAtMjtcbnZhciBaX0RBVEFfRVJST1IgICAgPSAtMztcbnZhciBaX01FTV9FUlJPUiAgICAgPSAtNDtcbnZhciBaX0JVRl9FUlJPUiAgICAgPSAtNTtcbi8vdmFyIFpfVkVSU0lPTl9FUlJPUiA9IC02O1xuXG4vKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi9cbnZhciBaX0RFRkxBVEVEICA9IDg7XG5cblxuLyogU1RBVEVTID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxudmFyICAgIEhFQUQgPSAxOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBtYWdpYyBoZWFkZXIgKi9cbnZhciAgICBGTEFHUyA9IDI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgbWV0aG9kIGFuZCBmbGFncyAoZ3ppcCkgKi9cbnZhciAgICBUSU1FID0gMzsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbW9kaWZpY2F0aW9uIHRpbWUgKGd6aXApICovXG52YXIgICAgT1MgPSA0OyAgICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGZsYWdzIGFuZCBvcGVyYXRpbmcgc3lzdGVtIChnemlwKSAqL1xudmFyICAgIEVYTEVOID0gNTsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBsZW5ndGggKGd6aXApICovXG52YXIgICAgRVhUUkEgPSA2OyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGV4dHJhIGJ5dGVzIChnemlwKSAqL1xudmFyICAgIE5BTUUgPSA3OyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBlbmQgb2YgZmlsZSBuYW1lIChnemlwKSAqL1xudmFyICAgIENPTU1FTlQgPSA4OyAgICAvKiBpOiB3YWl0aW5nIGZvciBlbmQgb2YgY29tbWVudCAoZ3ppcCkgKi9cbnZhciAgICBIQ1JDID0gOTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgaGVhZGVyIGNyYyAoZ3ppcCkgKi9cbnZhciAgICBESUNUSUQgPSAxMDsgICAgLyogaTogd2FpdGluZyBmb3IgZGljdGlvbmFyeSBjaGVjayB2YWx1ZSAqL1xudmFyICAgIERJQ1QgPSAxMTsgICAgICAvKiB3YWl0aW5nIGZvciBpbmZsYXRlU2V0RGljdGlvbmFyeSgpIGNhbGwgKi9cbnZhciAgICAgICAgVFlQRSA9IDEyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIHR5cGUgYml0cywgaW5jbHVkaW5nIGxhc3QtZmxhZyBiaXQgKi9cbnZhciAgICAgICAgVFlQRURPID0gMTM7ICAgIC8qIGk6IHNhbWUsIGJ1dCBza2lwIGNoZWNrIHRvIGV4aXQgaW5mbGF0ZSBvbiBuZXcgYmxvY2sgKi9cbnZhciAgICAgICAgU1RPUkVEID0gMTQ7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIHN0b3JlZCBzaXplIChsZW5ndGggYW5kIGNvbXBsZW1lbnQpICovXG52YXIgICAgICAgIENPUFlfID0gMTU7ICAgICAvKiBpL286IHNhbWUgYXMgQ09QWSBiZWxvdywgYnV0IG9ubHkgZmlyc3QgdGltZSBpbiAqL1xudmFyICAgICAgICBDT1BZID0gMTY7ICAgICAgLyogaS9vOiB3YWl0aW5nIGZvciBpbnB1dCBvciBvdXRwdXQgdG8gY29weSBzdG9yZWQgYmxvY2sgKi9cbnZhciAgICAgICAgVEFCTEUgPSAxNzsgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGR5bmFtaWMgYmxvY2sgdGFibGUgbGVuZ3RocyAqL1xudmFyICAgICAgICBMRU5MRU5TID0gMTg7ICAgLyogaTogd2FpdGluZyBmb3IgY29kZSBsZW5ndGggY29kZSBsZW5ndGhzICovXG52YXIgICAgICAgIENPREVMRU5TID0gMTk7ICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGgvbGl0IGFuZCBkaXN0YW5jZSBjb2RlIGxlbmd0aHMgKi9cbnZhciAgICAgICAgICAgIExFTl8gPSAyMDsgICAgICAvKiBpOiBzYW1lIGFzIExFTiBiZWxvdywgYnV0IG9ubHkgZmlyc3QgdGltZSBpbiAqL1xudmFyICAgICAgICAgICAgTEVOID0gMjE7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGxlbmd0aC9saXQvZW9iIGNvZGUgKi9cbnZhciAgICAgICAgICAgIExFTkVYVCA9IDIyOyAgICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGggZXh0cmEgYml0cyAqL1xudmFyICAgICAgICAgICAgRElTVCA9IDIzOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpc3RhbmNlIGNvZGUgKi9cbnZhciAgICAgICAgICAgIERJU1RFWFQgPSAyNDsgICAvKiBpOiB3YWl0aW5nIGZvciBkaXN0YW5jZSBleHRyYSBiaXRzICovXG52YXIgICAgICAgICAgICBNQVRDSCA9IDI1OyAgICAgLyogbzogd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlIHRvIGNvcHkgc3RyaW5nICovXG52YXIgICAgICAgICAgICBMSVQgPSAyNjsgICAgICAgLyogbzogd2FpdGluZyBmb3Igb3V0cHV0IHNwYWNlIHRvIHdyaXRlIGxpdGVyYWwgKi9cbnZhciAgICBDSEVDSyA9IDI3OyAgICAgLyogaTogd2FpdGluZyBmb3IgMzItYml0IGNoZWNrIHZhbHVlICovXG52YXIgICAgTEVOR1RIID0gMjg7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIDMyLWJpdCBsZW5ndGggKGd6aXApICovXG52YXIgICAgRE9ORSA9IDI5OyAgICAgIC8qIGZpbmlzaGVkIGNoZWNrLCBkb25lIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgICAgQkFEID0gMzA7ICAgICAgIC8qIGdvdCBhIGRhdGEgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciAgICBNRU0gPSAzMTsgICAgICAgLyogZ290IGFuIGluZmxhdGUoKSBtZW1vcnkgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciAgICBTWU5DID0gMzI7ICAgICAgLyogbG9va2luZyBmb3Igc3luY2hyb25pemF0aW9uIGJ5dGVzIHRvIHJlc3RhcnQgaW5mbGF0ZSgpICovXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuXG52YXIgRU5PVUdIX0xFTlMgPSA4NTI7XG52YXIgRU5PVUdIX0RJU1RTID0gNTkyO1xuLy92YXIgRU5PVUdIID0gIChFTk9VR0hfTEVOUytFTk9VR0hfRElTVFMpO1xuXG52YXIgTUFYX1dCSVRTID0gMTU7XG4vKiAzMksgTFo3NyB3aW5kb3cgKi9cbnZhciBERUZfV0JJVFMgPSBNQVhfV0JJVFM7XG5cblxuZnVuY3Rpb24genN3YXAzMihxKSB7XG4gIHJldHVybiAgKCgocSA+Pj4gMjQpICYgMHhmZikgK1xuICAgICAgICAgICgocSA+Pj4gOCkgJiAweGZmMDApICtcbiAgICAgICAgICAoKHEgJiAweGZmMDApIDw8IDgpICtcbiAgICAgICAgICAoKHEgJiAweGZmKSA8PCAyNCkpO1xufVxuXG5cbmZ1bmN0aW9uIEluZmxhdGVTdGF0ZSgpIHtcbiAgdGhpcy5tb2RlID0gMDsgICAgICAgICAgICAgLyogY3VycmVudCBpbmZsYXRlIG1vZGUgKi9cbiAgdGhpcy5sYXN0ID0gZmFsc2U7ICAgICAgICAgIC8qIHRydWUgaWYgcHJvY2Vzc2luZyBsYXN0IGJsb2NrICovXG4gIHRoaXMud3JhcCA9IDA7ICAgICAgICAgICAgICAvKiBiaXQgMCB0cnVlIGZvciB6bGliLCBiaXQgMSB0cnVlIGZvciBnemlwICovXG4gIHRoaXMuaGF2ZWRpY3QgPSBmYWxzZTsgICAgICAvKiB0cnVlIGlmIGRpY3Rpb25hcnkgcHJvdmlkZWQgKi9cbiAgdGhpcy5mbGFncyA9IDA7ICAgICAgICAgICAgIC8qIGd6aXAgaGVhZGVyIG1ldGhvZCBhbmQgZmxhZ3MgKDAgaWYgemxpYikgKi9cbiAgdGhpcy5kbWF4ID0gMDsgICAgICAgICAgICAgIC8qIHpsaWIgaGVhZGVyIG1heCBkaXN0YW5jZSAoSU5GTEFURV9TVFJJQ1QpICovXG4gIHRoaXMuY2hlY2sgPSAwOyAgICAgICAgICAgICAvKiBwcm90ZWN0ZWQgY29weSBvZiBjaGVjayB2YWx1ZSAqL1xuICB0aGlzLnRvdGFsID0gMDsgICAgICAgICAgICAgLyogcHJvdGVjdGVkIGNvcHkgb2Ygb3V0cHV0IGNvdW50ICovXG4gIC8vIFRPRE86IG1heSBiZSB7fVxuICB0aGlzLmhlYWQgPSBudWxsOyAgICAgICAgICAgLyogd2hlcmUgdG8gc2F2ZSBnemlwIGhlYWRlciBpbmZvcm1hdGlvbiAqL1xuXG4gIC8qIHNsaWRpbmcgd2luZG93ICovXG4gIHRoaXMud2JpdHMgPSAwOyAgICAgICAgICAgICAvKiBsb2cgYmFzZSAyIG9mIHJlcXVlc3RlZCB3aW5kb3cgc2l6ZSAqL1xuICB0aGlzLndzaXplID0gMDsgICAgICAgICAgICAgLyogd2luZG93IHNpemUgb3IgemVybyBpZiBub3QgdXNpbmcgd2luZG93ICovXG4gIHRoaXMud2hhdmUgPSAwOyAgICAgICAgICAgICAvKiB2YWxpZCBieXRlcyBpbiB0aGUgd2luZG93ICovXG4gIHRoaXMud25leHQgPSAwOyAgICAgICAgICAgICAvKiB3aW5kb3cgd3JpdGUgaW5kZXggKi9cbiAgdGhpcy53aW5kb3cgPSBudWxsOyAgICAgICAgIC8qIGFsbG9jYXRlZCBzbGlkaW5nIHdpbmRvdywgaWYgbmVlZGVkICovXG5cbiAgLyogYml0IGFjY3VtdWxhdG9yICovXG4gIHRoaXMuaG9sZCA9IDA7ICAgICAgICAgICAgICAvKiBpbnB1dCBiaXQgYWNjdW11bGF0b3IgKi9cbiAgdGhpcy5iaXRzID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBiaXRzIGluIFwiaW5cIiAqL1xuXG4gIC8qIGZvciBzdHJpbmcgYW5kIHN0b3JlZCBibG9jayBjb3B5aW5nICovXG4gIHRoaXMubGVuZ3RoID0gMDsgICAgICAgICAgICAvKiBsaXRlcmFsIG9yIGxlbmd0aCBvZiBkYXRhIHRvIGNvcHkgKi9cbiAgdGhpcy5vZmZzZXQgPSAwOyAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhY2sgdG8gY29weSBzdHJpbmcgZnJvbSAqL1xuXG4gIC8qIGZvciB0YWJsZSBhbmQgY29kZSBkZWNvZGluZyAqL1xuICB0aGlzLmV4dHJhID0gMDsgICAgICAgICAgICAgLyogZXh0cmEgYml0cyBuZWVkZWQgKi9cblxuICAvKiBmaXhlZCBhbmQgZHluYW1pYyBjb2RlIHRhYmxlcyAqL1xuICB0aGlzLmxlbmNvZGUgPSBudWxsOyAgICAgICAgICAvKiBzdGFydGluZyB0YWJsZSBmb3IgbGVuZ3RoL2xpdGVyYWwgY29kZXMgKi9cbiAgdGhpcy5kaXN0Y29kZSA9IG51bGw7ICAgICAgICAgLyogc3RhcnRpbmcgdGFibGUgZm9yIGRpc3RhbmNlIGNvZGVzICovXG4gIHRoaXMubGVuYml0cyA9IDA7ICAgICAgICAgICAvKiBpbmRleCBiaXRzIGZvciBsZW5jb2RlICovXG4gIHRoaXMuZGlzdGJpdHMgPSAwOyAgICAgICAgICAvKiBpbmRleCBiaXRzIGZvciBkaXN0Y29kZSAqL1xuXG4gIC8qIGR5bmFtaWMgdGFibGUgYnVpbGRpbmcgKi9cbiAgdGhpcy5uY29kZSA9IDA7ICAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlIGxlbmd0aCBjb2RlIGxlbmd0aHMgKi9cbiAgdGhpcy5ubGVuID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBsZW5ndGggY29kZSBsZW5ndGhzICovXG4gIHRoaXMubmRpc3QgPSAwOyAgICAgICAgICAgICAvKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZSBsZW5ndGhzICovXG4gIHRoaXMuaGF2ZSA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZSBsZW5ndGhzIGluIGxlbnNbXSAqL1xuICB0aGlzLm5leHQgPSBudWxsOyAgICAgICAgICAgICAgLyogbmV4dCBhdmFpbGFibGUgc3BhY2UgaW4gY29kZXNbXSAqL1xuXG4gIHRoaXMubGVucyA9IG5ldyB1dGlscy5CdWYxNigzMjApOyAvKiB0ZW1wb3Jhcnkgc3RvcmFnZSBmb3IgY29kZSBsZW5ndGhzICovXG4gIHRoaXMud29yayA9IG5ldyB1dGlscy5CdWYxNigyODgpOyAvKiB3b3JrIGFyZWEgZm9yIGNvZGUgdGFibGUgYnVpbGRpbmcgKi9cblxuICAvKlxuICAgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIHBvaW50ZXJzIGluIGpzLCB3ZSB1c2UgbGVuY29kZSBhbmQgZGlzdGNvZGUgZGlyZWN0bHlcbiAgIGFzIGJ1ZmZlcnMgc28gd2UgZG9uJ3QgbmVlZCBjb2Rlc1xuICAqL1xuICAvL3RoaXMuY29kZXMgPSBuZXcgdXRpbHMuQnVmMzIoRU5PVUdIKTsgICAgICAgLyogc3BhY2UgZm9yIGNvZGUgdGFibGVzICovXG4gIHRoaXMubGVuZHluID0gbnVsbDsgICAgICAgICAgICAgIC8qIGR5bmFtaWMgdGFibGUgZm9yIGxlbmd0aC9saXRlcmFsIGNvZGVzIChKUyBzcGVjaWZpYykgKi9cbiAgdGhpcy5kaXN0ZHluID0gbnVsbDsgICAgICAgICAgICAgLyogZHluYW1pYyB0YWJsZSBmb3IgZGlzdGFuY2UgY29kZXMgKEpTIHNwZWNpZmljKSAqL1xuICB0aGlzLnNhbmUgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBpZiBmYWxzZSwgYWxsb3cgaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyICovXG4gIHRoaXMuYmFjayA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIGJpdHMgYmFjayBvZiBsYXN0IHVucHJvY2Vzc2VkIGxlbmd0aC9saXQgKi9cbiAgdGhpcy53YXMgPSAwOyAgICAgICAgICAgICAgICAgICAgLyogaW5pdGlhbCBsZW5ndGggb2YgbWF0Y2ggKi9cbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlc2V0S2VlcChzdHJtKSB7XG4gIHZhciBzdGF0ZTtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgc3RybS50b3RhbF9pbiA9IHN0cm0udG90YWxfb3V0ID0gc3RhdGUudG90YWwgPSAwO1xuICBzdHJtLm1zZyA9ICcnOyAvKlpfTlVMTCovXG4gIGlmIChzdGF0ZS53cmFwKSB7ICAgICAgIC8qIHRvIHN1cHBvcnQgaWxsLWNvbmNlaXZlZCBKYXZhIHRlc3Qgc3VpdGUgKi9cbiAgICBzdHJtLmFkbGVyID0gc3RhdGUud3JhcCAmIDE7XG4gIH1cbiAgc3RhdGUubW9kZSA9IEhFQUQ7XG4gIHN0YXRlLmxhc3QgPSAwO1xuICBzdGF0ZS5oYXZlZGljdCA9IDA7XG4gIHN0YXRlLmRtYXggPSAzMjc2ODtcbiAgc3RhdGUuaGVhZCA9IG51bGwvKlpfTlVMTCovO1xuICBzdGF0ZS5ob2xkID0gMDtcbiAgc3RhdGUuYml0cyA9IDA7XG4gIC8vc3RhdGUubGVuY29kZSA9IHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUubmV4dCA9IHN0YXRlLmNvZGVzO1xuICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSF9MRU5TKTtcbiAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSF9ESVNUUyk7XG5cbiAgc3RhdGUuc2FuZSA9IDE7XG4gIHN0YXRlLmJhY2sgPSAtMTtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiByZXNldFxcblwiKSk7XG4gIHJldHVybiBaX09LO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmVzZXQoc3RybSkge1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIHN0YXRlLndzaXplID0gMDtcbiAgc3RhdGUud2hhdmUgPSAwO1xuICBzdGF0ZS53bmV4dCA9IDA7XG4gIHJldHVybiBpbmZsYXRlUmVzZXRLZWVwKHN0cm0pO1xuXG59XG5cbmZ1bmN0aW9uIGluZmxhdGVSZXNldDIoc3RybSwgd2luZG93Qml0cykge1xuICB2YXIgd3JhcDtcbiAgdmFyIHN0YXRlO1xuXG4gIC8qIGdldCB0aGUgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgLyogZXh0cmFjdCB3cmFwIHJlcXVlc3QgZnJvbSB3aW5kb3dCaXRzIHBhcmFtZXRlciAqL1xuICBpZiAod2luZG93Qml0cyA8IDApIHtcbiAgICB3cmFwID0gMDtcbiAgICB3aW5kb3dCaXRzID0gLXdpbmRvd0JpdHM7XG4gIH1cbiAgZWxzZSB7XG4gICAgd3JhcCA9ICh3aW5kb3dCaXRzID4+IDQpICsgMTtcbiAgICBpZiAod2luZG93Qml0cyA8IDQ4KSB7XG4gICAgICB3aW5kb3dCaXRzICY9IDE1O1xuICAgIH1cbiAgfVxuXG4gIC8qIHNldCBudW1iZXIgb2Ygd2luZG93IGJpdHMsIGZyZWUgd2luZG93IGlmIGRpZmZlcmVudCAqL1xuICBpZiAod2luZG93Qml0cyAmJiAod2luZG93Qml0cyA8IDggfHwgd2luZG93Qml0cyA+IDE1KSkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuICBpZiAoc3RhdGUud2luZG93ICE9PSBudWxsICYmIHN0YXRlLndiaXRzICE9PSB3aW5kb3dCaXRzKSB7XG4gICAgc3RhdGUud2luZG93ID0gbnVsbDtcbiAgfVxuXG4gIC8qIHVwZGF0ZSBzdGF0ZSBhbmQgcmVzZXQgdGhlIHJlc3Qgb2YgaXQgKi9cbiAgc3RhdGUud3JhcCA9IHdyYXA7XG4gIHN0YXRlLndiaXRzID0gd2luZG93Qml0cztcbiAgcmV0dXJuIGluZmxhdGVSZXNldChzdHJtKTtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUluaXQyKHN0cm0sIHdpbmRvd0JpdHMpIHtcbiAgdmFyIHJldDtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3RybSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgLy9zdHJtLm1zZyA9IFpfTlVMTDsgICAgICAgICAgICAgICAgIC8qIGluIGNhc2Ugd2UgcmV0dXJuIGFuIGVycm9yICovXG5cbiAgc3RhdGUgPSBuZXcgSW5mbGF0ZVN0YXRlKCk7XG5cbiAgLy9pZiAoc3RhdGUgPT09IFpfTlVMTCkgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6IGFsbG9jYXRlZFxcblwiKSk7XG4gIHN0cm0uc3RhdGUgPSBzdGF0ZTtcbiAgc3RhdGUud2luZG93ID0gbnVsbC8qWl9OVUxMKi87XG4gIHJldCA9IGluZmxhdGVSZXNldDIoc3RybSwgd2luZG93Qml0cyk7XG4gIGlmIChyZXQgIT09IFpfT0spIHtcbiAgICBzdHJtLnN0YXRlID0gbnVsbC8qWl9OVUxMKi87XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUluaXQoc3RybSkge1xuICByZXR1cm4gaW5mbGF0ZUluaXQyKHN0cm0sIERFRl9XQklUUyk7XG59XG5cblxuLypcbiBSZXR1cm4gc3RhdGUgd2l0aCBsZW5ndGggYW5kIGRpc3RhbmNlIGRlY29kaW5nIHRhYmxlcyBhbmQgaW5kZXggc2l6ZXMgc2V0IHRvXG4gZml4ZWQgY29kZSBkZWNvZGluZy4gIE5vcm1hbGx5IHRoaXMgcmV0dXJucyBmaXhlZCB0YWJsZXMgZnJvbSBpbmZmaXhlZC5oLlxuIElmIEJVSUxERklYRUQgaXMgZGVmaW5lZCwgdGhlbiBpbnN0ZWFkIHRoaXMgcm91dGluZSBidWlsZHMgdGhlIHRhYmxlcyB0aGVcbiBmaXJzdCB0aW1lIGl0J3MgY2FsbGVkLCBhbmQgcmV0dXJucyB0aG9zZSB0YWJsZXMgdGhlIGZpcnN0IHRpbWUgYW5kXG4gdGhlcmVhZnRlci4gIFRoaXMgcmVkdWNlcyB0aGUgc2l6ZSBvZiB0aGUgY29kZSBieSBhYm91dCAySyBieXRlcywgaW5cbiBleGNoYW5nZSBmb3IgYSBsaXR0bGUgZXhlY3V0aW9uIHRpbWUuICBIb3dldmVyLCBCVUlMREZJWEVEIHNob3VsZCBub3QgYmVcbiB1c2VkIGZvciB0aHJlYWRlZCBhcHBsaWNhdGlvbnMsIHNpbmNlIHRoZSByZXdyaXRpbmcgb2YgdGhlIHRhYmxlcyBhbmQgdmlyZ2luXG4gbWF5IG5vdCBiZSB0aHJlYWQtc2FmZS5cbiAqL1xudmFyIHZpcmdpbiA9IHRydWU7XG5cbnZhciBsZW5maXgsIGRpc3RmaXg7IC8vIFdlIGhhdmUgbm8gcG9pbnRlcnMgaW4gSlMsIHNvIGtlZXAgdGFibGVzIHNlcGFyYXRlXG5cbmZ1bmN0aW9uIGZpeGVkdGFibGVzKHN0YXRlKSB7XG4gIC8qIGJ1aWxkIGZpeGVkIGh1ZmZtYW4gdGFibGVzIGlmIGZpcnN0IGNhbGwgKG1heSBub3QgYmUgdGhyZWFkIHNhZmUpICovXG4gIGlmICh2aXJnaW4pIHtcbiAgICB2YXIgc3ltO1xuXG4gICAgbGVuZml4ID0gbmV3IHV0aWxzLkJ1ZjMyKDUxMik7XG4gICAgZGlzdGZpeCA9IG5ldyB1dGlscy5CdWYzMigzMik7XG5cbiAgICAvKiBsaXRlcmFsL2xlbmd0aCB0YWJsZSAqL1xuICAgIHN5bSA9IDA7XG4gICAgd2hpbGUgKHN5bSA8IDE0NCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjU2KSB7IHN0YXRlLmxlbnNbc3ltKytdID0gOTsgfVxuICAgIHdoaWxlIChzeW0gPCAyODApIHsgc3RhdGUubGVuc1tzeW0rK10gPSA3OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI4OCkgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDg7IH1cblxuICAgIGluZmxhdGVfdGFibGUoTEVOUywgIHN0YXRlLmxlbnMsIDAsIDI4OCwgbGVuZml4LCAgIDAsIHN0YXRlLndvcmssIHsgYml0czogOSB9KTtcblxuICAgIC8qIGRpc3RhbmNlIHRhYmxlICovXG4gICAgc3ltID0gMDtcbiAgICB3aGlsZSAoc3ltIDwgMzIpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA1OyB9XG5cbiAgICBpbmZsYXRlX3RhYmxlKERJU1RTLCBzdGF0ZS5sZW5zLCAwLCAzMiwgICBkaXN0Zml4LCAwLCBzdGF0ZS53b3JrLCB7IGJpdHM6IDUgfSk7XG5cbiAgICAvKiBkbyB0aGlzIGp1c3Qgb25jZSAqL1xuICAgIHZpcmdpbiA9IGZhbHNlO1xuICB9XG5cbiAgc3RhdGUubGVuY29kZSA9IGxlbmZpeDtcbiAgc3RhdGUubGVuYml0cyA9IDk7XG4gIHN0YXRlLmRpc3Rjb2RlID0gZGlzdGZpeDtcbiAgc3RhdGUuZGlzdGJpdHMgPSA1O1xufVxuXG5cbi8qXG4gVXBkYXRlIHRoZSB3aW5kb3cgd2l0aCB0aGUgbGFzdCB3c2l6ZSAobm9ybWFsbHkgMzJLKSBieXRlcyB3cml0dGVuIGJlZm9yZVxuIHJldHVybmluZy4gIElmIHdpbmRvdyBkb2VzIG5vdCBleGlzdCB5ZXQsIGNyZWF0ZSBpdC4gIFRoaXMgaXMgb25seSBjYWxsZWRcbiB3aGVuIGEgd2luZG93IGlzIGFscmVhZHkgaW4gdXNlLCBvciB3aGVuIG91dHB1dCBoYXMgYmVlbiB3cml0dGVuIGR1cmluZyB0aGlzXG4gaW5mbGF0ZSBjYWxsLCBidXQgdGhlIGVuZCBvZiB0aGUgZGVmbGF0ZSBzdHJlYW0gaGFzIG5vdCBiZWVuIHJlYWNoZWQgeWV0LlxuIEl0IGlzIGFsc28gY2FsbGVkIHRvIGNyZWF0ZSBhIHdpbmRvdyBmb3IgZGljdGlvbmFyeSBkYXRhIHdoZW4gYSBkaWN0aW9uYXJ5XG4gaXMgbG9hZGVkLlxuXG4gUHJvdmlkaW5nIG91dHB1dCBidWZmZXJzIGxhcmdlciB0aGFuIDMySyB0byBpbmZsYXRlKCkgc2hvdWxkIHByb3ZpZGUgYSBzcGVlZFxuIGFkdmFudGFnZSwgc2luY2Ugb25seSB0aGUgbGFzdCAzMksgb2Ygb3V0cHV0IGlzIGNvcGllZCB0byB0aGUgc2xpZGluZyB3aW5kb3dcbiB1cG9uIHJldHVybiBmcm9tIGluZmxhdGUoKSwgYW5kIHNpbmNlIGFsbCBkaXN0YW5jZXMgYWZ0ZXIgdGhlIGZpcnN0IDMySyBvZlxuIG91dHB1dCB3aWxsIGZhbGwgaW4gdGhlIG91dHB1dCBkYXRhLCBtYWtpbmcgbWF0Y2ggY29waWVzIHNpbXBsZXIgYW5kIGZhc3Rlci5cbiBUaGUgYWR2YW50YWdlIG1heSBiZSBkZXBlbmRlbnQgb24gdGhlIHNpemUgb2YgdGhlIHByb2Nlc3NvcidzIGRhdGEgY2FjaGVzLlxuICovXG5mdW5jdGlvbiB1cGRhdGV3aW5kb3coc3RybSwgc3JjLCBlbmQsIGNvcHkpIHtcbiAgdmFyIGRpc3Q7XG4gIHZhciBzdGF0ZSA9IHN0cm0uc3RhdGU7XG5cbiAgLyogaWYgaXQgaGFzbid0IGJlZW4gZG9uZSBhbHJlYWR5LCBhbGxvY2F0ZSBzcGFjZSBmb3IgdGhlIHdpbmRvdyAqL1xuICBpZiAoc3RhdGUud2luZG93ID09PSBudWxsKSB7XG4gICAgc3RhdGUud3NpemUgPSAxIDw8IHN0YXRlLndiaXRzO1xuICAgIHN0YXRlLnduZXh0ID0gMDtcbiAgICBzdGF0ZS53aGF2ZSA9IDA7XG5cbiAgICBzdGF0ZS53aW5kb3cgPSBuZXcgdXRpbHMuQnVmOChzdGF0ZS53c2l6ZSk7XG4gIH1cblxuICAvKiBjb3B5IHN0YXRlLT53c2l6ZSBvciBsZXNzIG91dHB1dCBieXRlcyBpbnRvIHRoZSBjaXJjdWxhciB3aW5kb3cgKi9cbiAgaWYgKGNvcHkgPj0gc3RhdGUud3NpemUpIHtcbiAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gc3RhdGUud3NpemUsIHN0YXRlLndzaXplLCAwKTtcbiAgICBzdGF0ZS53bmV4dCA9IDA7XG4gICAgc3RhdGUud2hhdmUgPSBzdGF0ZS53c2l6ZTtcbiAgfVxuICBlbHNlIHtcbiAgICBkaXN0ID0gc3RhdGUud3NpemUgLSBzdGF0ZS53bmV4dDtcbiAgICBpZiAoZGlzdCA+IGNvcHkpIHtcbiAgICAgIGRpc3QgPSBjb3B5O1xuICAgIH1cbiAgICAvL3ptZW1jcHkoc3RhdGUtPndpbmRvdyArIHN0YXRlLT53bmV4dCwgZW5kIC0gY29weSwgZGlzdCk7XG4gICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIGNvcHksIGRpc3QsIHN0YXRlLnduZXh0KTtcbiAgICBjb3B5IC09IGRpc3Q7XG4gICAgaWYgKGNvcHkpIHtcbiAgICAgIC8vem1lbWNweShzdGF0ZS0+d2luZG93LCBlbmQgLSBjb3B5LCBjb3B5KTtcbiAgICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBjb3B5LCBjb3B5LCAwKTtcbiAgICAgIHN0YXRlLnduZXh0ID0gY29weTtcbiAgICAgIHN0YXRlLndoYXZlID0gc3RhdGUud3NpemU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgc3RhdGUud25leHQgKz0gZGlzdDtcbiAgICAgIGlmIChzdGF0ZS53bmV4dCA9PT0gc3RhdGUud3NpemUpIHsgc3RhdGUud25leHQgPSAwOyB9XG4gICAgICBpZiAoc3RhdGUud2hhdmUgPCBzdGF0ZS53c2l6ZSkgeyBzdGF0ZS53aGF2ZSArPSBkaXN0OyB9XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlKHN0cm0sIGZsdXNoKSB7XG4gIHZhciBzdGF0ZTtcbiAgdmFyIGlucHV0LCBvdXRwdXQ7ICAgICAgICAgIC8vIGlucHV0L291dHB1dCBidWZmZXJzXG4gIHZhciBuZXh0OyAgICAgICAgICAgICAgICAgICAvKiBuZXh0IGlucHV0IElOREVYICovXG4gIHZhciBwdXQ7ICAgICAgICAgICAgICAgICAgICAvKiBuZXh0IG91dHB1dCBJTkRFWCAqL1xuICB2YXIgaGF2ZSwgbGVmdDsgICAgICAgICAgICAgLyogYXZhaWxhYmxlIGlucHV0IGFuZCBvdXRwdXQgKi9cbiAgdmFyIGhvbGQ7ICAgICAgICAgICAgICAgICAgIC8qIGJpdCBidWZmZXIgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAgICAgICAgIC8qIGJpdHMgaW4gYml0IGJ1ZmZlciAqL1xuICB2YXIgX2luLCBfb3V0OyAgICAgICAgICAgICAgLyogc2F2ZSBzdGFydGluZyBhdmFpbGFibGUgaW5wdXQgYW5kIG91dHB1dCAqL1xuICB2YXIgY29weTsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHN0b3JlZCBvciBtYXRjaCBieXRlcyB0byBjb3B5ICovXG4gIHZhciBmcm9tOyAgICAgICAgICAgICAgICAgICAvKiB3aGVyZSB0byBjb3B5IG1hdGNoIGJ5dGVzIGZyb20gKi9cbiAgdmFyIGZyb21fc291cmNlO1xuICB2YXIgaGVyZSA9IDA7ICAgICAgICAgICAgICAgLyogY3VycmVudCBkZWNvZGluZyB0YWJsZSBlbnRyeSAqL1xuICB2YXIgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDsgLy8gcGFrZWQgXCJoZXJlXCIgZGVub3JtYWxpemVkIChKUyBzcGVjaWZpYylcbiAgLy92YXIgbGFzdDsgICAgICAgICAgICAgICAgICAgLyogcGFyZW50IHRhYmxlIGVudHJ5ICovXG4gIHZhciBsYXN0X2JpdHMsIGxhc3Rfb3AsIGxhc3RfdmFsOyAvLyBwYWtlZCBcImxhc3RcIiBkZW5vcm1hbGl6ZWQgKEpTIHNwZWNpZmljKVxuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIHRvIGNvcHkgZm9yIHJlcGVhdHMsIGJpdHMgdG8gZHJvcCAqL1xuICB2YXIgcmV0OyAgICAgICAgICAgICAgICAgICAgLyogcmV0dXJuIGNvZGUgKi9cbiAgdmFyIGhidWYgPSBuZXcgdXRpbHMuQnVmOCg0KTsgICAgLyogYnVmZmVyIGZvciBnemlwIGhlYWRlciBjcmMgY2FsY3VsYXRpb24gKi9cbiAgdmFyIG9wdHM7XG5cbiAgdmFyIG47IC8vIHRlbXBvcmFyeSB2YXIgZm9yIE5FRURfQklUU1xuXG4gIHZhciBvcmRlciA9IC8qIHBlcm11dGF0aW9uIG9mIGNvZGUgbGVuZ3RocyAqL1xuICAgIFsgMTYsIDE3LCAxOCwgMCwgOCwgNywgOSwgNiwgMTAsIDUsIDExLCA0LCAxMiwgMywgMTMsIDIsIDE0LCAxLCAxNSBdO1xuXG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlIHx8ICFzdHJtLm91dHB1dCB8fFxuICAgICAgKCFzdHJtLmlucHV0ICYmIHN0cm0uYXZhaWxfaW4gIT09IDApKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSkgeyBzdGF0ZS5tb2RlID0gVFlQRURPOyB9ICAgIC8qIHNraXAgY2hlY2sgKi9cblxuXG4gIC8vLS0tIExPQUQoKSAtLS1cbiAgcHV0ID0gc3RybS5uZXh0X291dDtcbiAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gIGxlZnQgPSBzdHJtLmF2YWlsX291dDtcbiAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICBoYXZlID0gc3RybS5hdmFpbF9pbjtcbiAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICAvLy0tLVxuXG4gIF9pbiA9IGhhdmU7XG4gIF9vdXQgPSBsZWZ0O1xuICByZXQgPSBaX09LO1xuXG4gIGluZl9sZWF2ZTogLy8gZ290byBlbXVsYXRpb25cbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoc3RhdGUubW9kZSkge1xuICAgICAgY2FzZSBIRUFEOlxuICAgICAgICBpZiAoc3RhdGUud3JhcCA9PT0gMCkge1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFRE87XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpO1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmICgoc3RhdGUud3JhcCAmIDIpICYmIGhvbGQgPT09IDB4OGIxZikgeyAgLyogZ3ppcCBoZWFkZXIgKi9cbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IDAvKmNyYzMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgIC8vPT09Ly9cblxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBGTEFHUztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5mbGFncyA9IDA7ICAgICAgICAgICAvKiBleHBlY3QgemxpYiBoZWFkZXIgKi9cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShzdGF0ZS53cmFwICYgMSkgfHwgICAvKiBjaGVjayBpZiB6bGliIGhlYWRlciBhbGxvd2VkICovXG4gICAgICAgICAgKCgoaG9sZCAmIDB4ZmYpLypCSVRTKDgpKi8gPDwgOCkgKyAoaG9sZCA+PiA4KSkgJSAzMSkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBoZWFkZXIgY2hlY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChob2xkICYgMHgwZikvKkJJVFMoNCkqLyAhPT0gWl9ERUZMQVRFRCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gY29tcHJlc3Npb24gbWV0aG9kJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDQpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA0O1xuICAgICAgICBiaXRzIC09IDQ7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgbGVuID0gKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICsgODtcbiAgICAgICAgaWYgKHN0YXRlLndiaXRzID09PSAwKSB7XG4gICAgICAgICAgc3RhdGUud2JpdHMgPSBsZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuID4gc3RhdGUud2JpdHMpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIHdpbmRvdyBzaXplJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmRtYXggPSAxIDw8IGxlbjtcbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIHpsaWIgaGVhZGVyIG9rXFxuXCIpKTtcbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gMS8qYWRsZXIzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICBzdGF0ZS5tb2RlID0gaG9sZCAmIDB4MjAwID8gRElDVElEIDogVFlQRTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBGTEFHUzpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLmZsYWdzID0gaG9sZDtcbiAgICAgICAgaWYgKChzdGF0ZS5mbGFncyAmIDB4ZmYpICE9PSBaX0RFRkxBVEVEKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHhlMDAwKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndW5rbm93biBoZWFkZXIgZmxhZ3Mgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC50ZXh0ID0gKChob2xkID4+IDgpICYgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IFRJTUU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVElNRTpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC50aW1lID0gaG9sZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBDUkM0KHN0YXRlLmNoZWNrLCBob2xkKVxuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzJdID0gKGhvbGQgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlszXSA9IChob2xkID4+PiAyNCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDQsIDApO1xuICAgICAgICAgIC8vPT09XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBPUztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBPUzpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC54ZmxhZ3MgPSAoaG9sZCAmIDB4ZmYpO1xuICAgICAgICAgIHN0YXRlLmhlYWQub3MgPSAoaG9sZCA+PiA4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gRVhMRU47XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRVhMRU46XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDQwMCkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZDtcbiAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYV9sZW4gPSBob2xkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmEgPSBudWxsLypaX05VTEwqLztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gRVhUUkE7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRVhUUkE6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDQwMCkge1xuICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgICAgaWYgKGNvcHkgPiBoYXZlKSB7IGNvcHkgPSBoYXZlOyB9XG4gICAgICAgICAgaWYgKGNvcHkpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgICAgIGxlbiA9IHN0YXRlLmhlYWQuZXh0cmFfbGVuIC0gc3RhdGUubGVuZ3RoO1xuICAgICAgICAgICAgICBpZiAoIXN0YXRlLmhlYWQuZXh0cmEpIHtcbiAgICAgICAgICAgICAgICAvLyBVc2UgdW50eXBlZCBhcnJheSBmb3IgbW9yZSBjb252ZW5pZW50IHByb2Nlc3NpbmcgbGF0ZXJcbiAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbmV3IEFycmF5KHN0YXRlLmhlYWQuZXh0cmFfbGVuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB1dGlscy5hcnJheVNldChcbiAgICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICAgICAgLy8gZXh0cmEgZmllbGQgaXMgbGltaXRlZCB0byA2NTUzNiBieXRlc1xuICAgICAgICAgICAgICAgIC8vIC0gbm8gbmVlZCBmb3IgYWRkaXRpb25hbCBzaXplIGNoZWNrXG4gICAgICAgICAgICAgICAgY29weSxcbiAgICAgICAgICAgICAgICAvKmxlbiArIGNvcHkgPiBzdGF0ZS5oZWFkLmV4dHJhX21heCAtIGxlbiA/IHN0YXRlLmhlYWQuZXh0cmFfbWF4IDogY29weSwqL1xuICAgICAgICAgICAgICAgIGxlblxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAvL3ptZW1jcHkoc3RhdGUuaGVhZC5leHRyYSArIGxlbiwgbmV4dCxcbiAgICAgICAgICAgICAgLy8gICAgICAgIGxlbiArIGNvcHkgPiBzdGF0ZS5oZWFkLmV4dHJhX21heCA/XG4gICAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhX21heCAtIGxlbiA6IGNvcHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdGUubGVuZ3RoKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBOQU1FO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIE5BTUU6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDgwMCkge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGNvcHkgPSAwO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIC8vIFRPRE86IDIgb3IgMSBieXRlcz9cbiAgICAgICAgICAgIGxlbiA9IGlucHV0W25leHQgKyBjb3B5KytdO1xuICAgICAgICAgICAgLyogdXNlIGNvbnN0YW50IGxpbWl0IGJlY2F1c2UgaW4ganMgd2Ugc2hvdWxkIG5vdCBwcmVhbGxvY2F0ZSBtZW1vcnkgKi9cbiAgICAgICAgICAgIGlmIChzdGF0ZS5oZWFkICYmIGxlbiAmJlxuICAgICAgICAgICAgICAgIChzdGF0ZS5sZW5ndGggPCA2NTUzNiAvKnN0YXRlLmhlYWQubmFtZV9tYXgqLykpIHtcbiAgICAgICAgICAgICAgc3RhdGUuaGVhZC5uYW1lICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IHdoaWxlIChsZW4gJiYgY29weSA8IGhhdmUpO1xuXG4gICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgaWYgKGxlbikgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5uYW1lID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sZW5ndGggPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQ09NTUVOVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT01NRU5UOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDEwMDApIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBjb3B5ID0gMDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBsZW4gPSBpbnB1dFtuZXh0ICsgY29weSsrXTtcbiAgICAgICAgICAgIC8qIHVzZSBjb25zdGFudCBsaW1pdCBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5ICovXG4gICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCAmJiBsZW4gJiZcbiAgICAgICAgICAgICAgICAoc3RhdGUubGVuZ3RoIDwgNjU1MzYgLypzdGF0ZS5oZWFkLmNvbW1fbWF4Ki8pKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmhlYWQuY29tbWVudCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSB3aGlsZSAobGVuICYmIGNvcHkgPCBoYXZlKTtcbiAgICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGlucHV0LCBjb3B5LCBuZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBpZiAobGVuKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmNvbW1lbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBIQ1JDO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIEhDUkM6XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS5jaGVjayAmIDB4ZmZmZikpIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2hlYWRlciBjcmMgbWlzbWF0Y2gnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQuaGNyYyA9ICgoc3RhdGUuZmxhZ3MgPj4gOSkgJiAxKTtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmRvbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElDVElEOlxuICAgICAgICAvLz09PSBORUVEQklUUygzMik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0genN3YXAzMihob2xkKTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBESUNUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERJQ1Q6XG4gICAgICAgIGlmIChzdGF0ZS5oYXZlZGljdCA9PT0gMCkge1xuICAgICAgICAgIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgICAgICAgICBzdHJtLm5leHRfb3V0ID0gcHV0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICAgICAgICAgIHN0cm0uYXZhaWxfaW4gPSBoYXZlO1xuICAgICAgICAgIHN0YXRlLmhvbGQgPSBob2xkO1xuICAgICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAgICAgICAgIC8vLS0tXG4gICAgICAgICAgcmV0dXJuIFpfTkVFRF9ESUNUO1xuICAgICAgICB9XG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDEvKmFkbGVyMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgVFlQRTpcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX0JMT0NLIHx8IGZsdXNoID09PSBaX1RSRUVTKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIFRZUEVETzpcbiAgICAgICAgaWYgKHN0YXRlLmxhc3QpIHtcbiAgICAgICAgICAvLy0tLSBCWVRFQklUUygpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3O1xuICAgICAgICAgIGJpdHMgLT0gYml0cyAmIDc7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBDSEVDSztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLz09PSBORUVEQklUUygzKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLmxhc3QgPSAoaG9sZCAmIDB4MDEpLypCSVRTKDEpKi87XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDEpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSAxO1xuICAgICAgICBiaXRzIC09IDE7XG4gICAgICAgIC8vLS0tLy9cblxuICAgICAgICBzd2l0Y2ggKChob2xkICYgMHgwMykvKkJJVFMoMikqLykge1xuICAgICAgICAgIGNhc2UgMDogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIHN0b3JlZCBibG9jayAqL1xuICAgICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgc3RvcmVkIGJsb2NrJXNcXG5cIixcbiAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gU1RPUkVEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZml4ZWQgYmxvY2sgKi9cbiAgICAgICAgICAgIGZpeGVkdGFibGVzKHN0YXRlKTtcbiAgICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIGZpeGVkIGNvZGVzIGJsb2NrJXNcXG5cIixcbiAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gTEVOXzsgICAgICAgICAgICAgLyogZGVjb2RlIGNvZGVzICovXG4gICAgICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDI6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBkeW5hbWljIGJsb2NrICovXG4gICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBkeW5hbWljIGNvZGVzIGJsb2NrJXNcXG5cIixcbiAgICAgICAgICAgIC8vICAgICAgICBzdGF0ZS5sYXN0ID8gXCIgKGxhc3QpXCIgOiBcIlwiKSk7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gVEFCTEU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJsb2NrIHR5cGUnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTVE9SRUQ6XG4gICAgICAgIC8vLS0tIEJZVEVCSVRTKCkgLS0tLy8gLyogZ28gdG8gYnl0ZSBib3VuZGFyeSAqL1xuICAgICAgICBob2xkID4+Pj0gYml0cyAmIDc7XG4gICAgICAgIGJpdHMgLT0gYml0cyAmIDc7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmICgoaG9sZCAmIDB4ZmZmZikgIT09ICgoaG9sZCA+Pj4gMTYpIF4gMHhmZmZmKSkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgc3RvcmVkIGJsb2NrIGxlbmd0aHMnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZCAmIDB4ZmZmZjtcbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBzdG9yZWQgbGVuZ3RoICV1XFxuXCIsXG4gICAgICAgIC8vICAgICAgICBzdGF0ZS5sZW5ndGgpKTtcbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT1BZXztcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIENPUFlfOlxuICAgICAgICBzdGF0ZS5tb2RlID0gQ09QWTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT1BZOlxuICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICBpZiAoY29weSkge1xuICAgICAgICAgIGlmIChjb3B5ID4gaGF2ZSkgeyBjb3B5ID0gaGF2ZTsgfVxuICAgICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuICAgICAgICAgIGlmIChjb3B5ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIC8vLS0tIHptZW1jcHkocHV0LCBuZXh0LCBjb3B5KTsgLS0tXG4gICAgICAgICAgdXRpbHMuYXJyYXlTZXQob3V0cHV0LCBpbnB1dCwgbmV4dCwgY29weSwgcHV0KTtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICAgICAgcHV0ICs9IGNvcHk7XG4gICAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBzdG9yZWQgZW5kXFxuXCIpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUQUJMRTpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTQpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE0KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm5sZW4gPSAoaG9sZCAmIDB4MWYpLypCSVRTKDUpKi8gKyAyNTc7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDUpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA1O1xuICAgICAgICBiaXRzIC09IDU7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUubmRpc3QgPSAoaG9sZCAmIDB4MWYpLypCSVRTKDUpKi8gKyAxO1xuICAgICAgICAvLy0tLSBEUk9QQklUUyg1KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNTtcbiAgICAgICAgYml0cyAtPSA1O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLm5jb2RlID0gKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICsgNDtcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNCkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDQ7XG4gICAgICAgIGJpdHMgLT0gNDtcbiAgICAgICAgLy8tLS0vL1xuLy8jaWZuZGVmIFBLWklQX0JVR19XT1JLQVJPVU5EXG4gICAgICAgIGlmIChzdGF0ZS5ubGVuID4gMjg2IHx8IHN0YXRlLm5kaXN0ID4gMzApIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd0b28gbWFueSBsZW5ndGggb3IgZGlzdGFuY2Ugc3ltYm9scyc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICB0YWJsZSBzaXplcyBva1xcblwiKSk7XG4gICAgICAgIHN0YXRlLmhhdmUgPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOTEVOUztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5MRU5TOlxuICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5jb2RlKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMyk7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAzKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IChob2xkICYgMHgwNyk7Ly9CSVRTKDMpO1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKDMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IDM7XG4gICAgICAgICAgYml0cyAtPSAzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IDE5KSB7XG4gICAgICAgICAgc3RhdGUubGVuc1tvcmRlcltzdGF0ZS5oYXZlKytdXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgICAgLy9zdGF0ZS5uZXh0ID0gc3RhdGUuY29kZXM7XG4gICAgICAgIC8vc3RhdGUubGVuY29kZSA9IHN0YXRlLm5leHQ7XG4gICAgICAgIC8vIFN3aXRjaCB0byB1c2UgZHluYW1pYyB0YWJsZVxuICAgICAgICBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubGVuZHluO1xuICAgICAgICBzdGF0ZS5sZW5iaXRzID0gNztcblxuICAgICAgICBvcHRzID0geyBiaXRzOiBzdGF0ZS5sZW5iaXRzIH07XG4gICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoQ09ERVMsIHN0YXRlLmxlbnMsIDAsIDE5LCBzdGF0ZS5sZW5jb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgICAgc3RhdGUubGVuYml0cyA9IG9wdHMuYml0cztcblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBjb2RlIGxlbmd0aHMgc2V0JztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgY29kZSBsZW5ndGhzIG9rXFxuXCIpKTtcbiAgICAgICAgc3RhdGUuaGF2ZSA9IDA7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBDT0RFTEVOUztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT0RFTEVOUzpcbiAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBoZXJlID0gc3RhdGUubGVuY29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmxlbmJpdHMpIC0gMSldOy8qQklUUyhzdGF0ZS5sZW5iaXRzKSovXG4gICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgICAgaWYgKChoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoZXJlX3ZhbCA8IDE2KSB7XG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUrK10gPSBoZXJlX3ZhbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaGVyZV92YWwgPT09IDE2KSB7XG4gICAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDIpO1xuICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgMjtcbiAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgaWYgKHN0YXRlLmhhdmUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0JztcbiAgICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxlbiA9IHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSAtIDFdO1xuICAgICAgICAgICAgICBjb3B5ID0gMyArIChob2xkICYgMHgwMyk7Ly9CSVRTKDIpO1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gMjtcbiAgICAgICAgICAgICAgYml0cyAtPSAyO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChoZXJlX3ZhbCA9PT0gMTcpIHtcbiAgICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgMyk7XG4gICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAzO1xuICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgICBjb3B5ID0gMyArIChob2xkICYgMHgwNyk7Ly9CSVRTKDMpO1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUygzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gMztcbiAgICAgICAgICAgICAgYml0cyAtPSAzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgNyk7XG4gICAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyA3O1xuICAgICAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgICAgICBjb3B5ID0gMTEgKyAoaG9sZCAmIDB4N2YpOy8vQklUUyg3KTtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoNykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDc7XG4gICAgICAgICAgICAgIGJpdHMgLT0gNztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlLmhhdmUgKyBjb3B5ID4gc3RhdGUubmxlbiArIHN0YXRlLm5kaXN0KSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYml0IGxlbmd0aCByZXBlYXQnO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjb3B5LS0pIHtcbiAgICAgICAgICAgICAgc3RhdGUubGVuc1tzdGF0ZS5oYXZlKytdID0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGhhbmRsZSBlcnJvciBicmVha3MgaW4gd2hpbGUgKi9cbiAgICAgICAgaWYgKHN0YXRlLm1vZGUgPT09IEJBRCkgeyBicmVhazsgfVxuXG4gICAgICAgIC8qIGNoZWNrIGZvciBlbmQtb2YtYmxvY2sgY29kZSAoYmV0dGVyIGhhdmUgb25lKSAqL1xuICAgICAgICBpZiAoc3RhdGUubGVuc1syNTZdID09PSAwKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBjb2RlIC0tIG1pc3NpbmcgZW5kLW9mLWJsb2NrJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogYnVpbGQgY29kZSB0YWJsZXMgLS0gbm90ZTogZG8gbm90IGNoYW5nZSB0aGUgbGVuYml0cyBvciBkaXN0Yml0c1xuICAgICAgICAgICB2YWx1ZXMgaGVyZSAoOSBhbmQgNikgd2l0aG91dCByZWFkaW5nIHRoZSBjb21tZW50cyBpbiBpbmZ0cmVlcy5oXG4gICAgICAgICAgIGNvbmNlcm5pbmcgdGhlIEVOT1VHSCBjb25zdGFudHMsIHdoaWNoIGRlcGVuZCBvbiB0aG9zZSB2YWx1ZXMgKi9cbiAgICAgICAgc3RhdGUubGVuYml0cyA9IDk7XG5cbiAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUubGVuYml0cyB9O1xuICAgICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKExFTlMsIHN0YXRlLmxlbnMsIDAsIHN0YXRlLm5sZW4sIHN0YXRlLmxlbmNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgICAvLyBzdGF0ZS5uZXh0X2luZGV4ID0gb3B0cy50YWJsZV9pbmRleDtcbiAgICAgICAgc3RhdGUubGVuYml0cyA9IG9wdHMuYml0cztcbiAgICAgICAgLy8gc3RhdGUubGVuY29kZSA9IHN0YXRlLm5leHQ7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGhzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLmRpc3RiaXRzID0gNjtcbiAgICAgICAgLy9zdGF0ZS5kaXN0Y29kZS5jb3B5KHN0YXRlLmNvZGVzKTtcbiAgICAgICAgLy8gU3dpdGNoIHRvIHVzZSBkeW5hbWljIHRhYmxlXG4gICAgICAgIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUuZGlzdGR5bjtcbiAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUuZGlzdGJpdHMgfTtcbiAgICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShESVNUUywgc3RhdGUubGVucywgc3RhdGUubmxlbiwgc3RhdGUubmRpc3QsIHN0YXRlLmRpc3Rjb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgICAgLy8gc3RhdGUubmV4dF9pbmRleCA9IG9wdHMudGFibGVfaW5kZXg7XG4gICAgICAgIHN0YXRlLmRpc3RiaXRzID0gb3B0cy5iaXRzO1xuICAgICAgICAvLyBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLm5leHQ7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2VzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCAnaW5mbGF0ZTogICAgICAgY29kZXMgb2tcXG4nKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5fO1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOXzpcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTjtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU46XG4gICAgICAgIGlmIChoYXZlID49IDYgJiYgbGVmdCA+PSAyNTgpIHtcbiAgICAgICAgICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gICAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gICAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgICAgICAgICBzdGF0ZS5iaXRzID0gYml0cztcbiAgICAgICAgICAvLy0tLVxuICAgICAgICAgIGluZmxhdGVfZmFzdChzdHJtLCBfb3V0KTtcbiAgICAgICAgICAvLy0tLSBMT0FEKCkgLS0tXG4gICAgICAgICAgcHV0ID0gc3RybS5uZXh0X291dDtcbiAgICAgICAgICBvdXRwdXQgPSBzdHJtLm91dHB1dDtcbiAgICAgICAgICBsZWZ0ID0gc3RybS5hdmFpbF9vdXQ7XG4gICAgICAgICAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgICAgICAgICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gICAgICAgICAgaGF2ZSA9IHN0cm0uYXZhaWxfaW47XG4gICAgICAgICAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gICAgICAgICAgYml0cyA9IHN0YXRlLmJpdHM7XG4gICAgICAgICAgLy8tLS1cblxuICAgICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBUWVBFKSB7XG4gICAgICAgICAgICBzdGF0ZS5iYWNrID0gLTE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmJhY2sgPSAwO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDEpXTsgIC8qQklUUyhzdGF0ZS5sZW5iaXRzKSovXG4gICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgIGlmIChoZXJlX2JpdHMgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVyZV9vcCAmJiAoaGVyZV9vcCAmIDB4ZjApID09PSAwKSB7XG4gICAgICAgICAgbGFzdF9iaXRzID0gaGVyZV9iaXRzO1xuICAgICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wO1xuICAgICAgICAgIGxhc3RfdmFsID0gaGVyZV92YWw7XG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbbGFzdF92YWwgK1xuICAgICAgICAgICAgICAgICAgICAoKGhvbGQgJiAoKDEgPDwgKGxhc3RfYml0cyArIGxhc3Rfb3ApKSAtIDEpKS8qQklUUyhsYXN0LmJpdHMgKyBsYXN0Lm9wKSovID4+IGxhc3RfYml0cyldO1xuICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICAgIGlmICgobGFzdF9iaXRzICsgaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhsYXN0LmJpdHMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0cztcbiAgICAgICAgICBiaXRzIC09IGxhc3RfYml0cztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBsYXN0X2JpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5iYWNrICs9IGhlcmVfYml0cztcbiAgICAgICAgc3RhdGUubGVuZ3RoID0gaGVyZV92YWw7XG4gICAgICAgIGlmIChoZXJlX29wID09PSAwKSB7XG4gICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIGhlcmUudmFsID49IDB4MjAgJiYgaGVyZS52YWwgPCAweDdmID9cbiAgICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgJyVjJ1xcblwiIDpcbiAgICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgMHglMDJ4XFxuXCIsIGhlcmUudmFsKSk7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IExJVDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVyZV9vcCAmIDMyKSB7XG4gICAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBlbmQgb2YgYmxvY2tcXG5cIikpO1xuICAgICAgICAgIHN0YXRlLmJhY2sgPSAtMTtcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVyZV9vcCAmIDY0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmV4dHJhID0gaGVyZV9vcCAmIDE1O1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVORVhUO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTkVYVDpcbiAgICAgICAgaWYgKHN0YXRlLmV4dHJhKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoc3RhdGUuZXh0cmEpO1xuICAgICAgICAgIG4gPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5sZW5ndGggKz0gaG9sZCAmICgoMSA8PCBzdGF0ZS5leHRyYSkgLSAxKS8qQklUUyhzdGF0ZS5leHRyYSkqLztcbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhzdGF0ZS5leHRyYSkgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgYml0cyAtPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGxlbmd0aCAldVxcblwiLCBzdGF0ZS5sZW5ndGgpKTtcbiAgICAgICAgc3RhdGUud2FzID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICBzdGF0ZS5tb2RlID0gRElTVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBESVNUOlxuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaGVyZSA9IHN0YXRlLmRpc3Rjb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUuZGlzdGJpdHMpIC0gMSldOy8qQklUUyhzdGF0ZS5kaXN0Yml0cykqL1xuICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICBpZiAoKGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICBpZiAoKGhlcmVfb3AgJiAweGYwKSA9PT0gMCkge1xuICAgICAgICAgIGxhc3RfYml0cyA9IGhlcmVfYml0cztcbiAgICAgICAgICBsYXN0X29wID0gaGVyZV9vcDtcbiAgICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsO1xuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5kaXN0Y29kZVtsYXN0X3ZhbCArXG4gICAgICAgICAgICAgICAgICAgICgoaG9sZCAmICgoMSA8PCAobGFzdF9iaXRzICsgbGFzdF9vcCkpIC0gMSkpLypCSVRTKGxhc3QuYml0cyArIGxhc3Qub3ApKi8gPj4gbGFzdF9iaXRzKV07XG4gICAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICAgIGhlcmVfdmFsID0gaGVyZSAmIDB4ZmZmZjtcblxuICAgICAgICAgICAgaWYgKChsYXN0X2JpdHMgKyBoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vLS0tIERST1BCSVRTKGxhc3QuYml0cykgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gbGFzdF9iaXRzO1xuICAgICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0cztcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzO1xuICAgICAgICBpZiAoaGVyZV9vcCAmIDY0KSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSBjb2RlJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm9mZnNldCA9IGhlcmVfdmFsO1xuICAgICAgICBzdGF0ZS5leHRyYSA9IChoZXJlX29wKSAmIDE1O1xuICAgICAgICBzdGF0ZS5tb2RlID0gRElTVEVYVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBESVNURVhUOlxuICAgICAgICBpZiAoc3RhdGUuZXh0cmEpIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUyhzdGF0ZS5leHRyYSk7XG4gICAgICAgICAgbiA9IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLm9mZnNldCArPSBob2xkICYgKCgxIDw8IHN0YXRlLmV4dHJhKSAtIDEpLypCSVRTKHN0YXRlLmV4dHJhKSovO1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKHN0YXRlLmV4dHJhKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICBiaXRzIC09IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhO1xuICAgICAgICB9XG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICAgICAgICBpZiAoc3RhdGUub2Zmc2V0ID4gc3RhdGUuZG1heCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICAgIGRpc3RhbmNlICV1XFxuXCIsIHN0YXRlLm9mZnNldCkpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTUFUQ0g7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTUFUQ0g6XG4gICAgICAgIGlmIChsZWZ0ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBjb3B5ID0gX291dCAtIGxlZnQ7XG4gICAgICAgIGlmIChzdGF0ZS5vZmZzZXQgPiBjb3B5KSB7ICAgICAgICAgLyogY29weSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgIGNvcHkgPSBzdGF0ZS5vZmZzZXQgLSBjb3B5O1xuICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUud2hhdmUpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5zYW5lKSB7XG4gICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4vLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmF1bHRzLFxuLy8gZG9uJ3QgZW5hYmxlIGl0IGZvciBiaW5hcnkgY29tcGF0aWJpbGl0eVxuLy8jaWZkZWYgSU5GTEFURV9BTExPV19JTlZBTElEX0RJU1RBTkNFX1RPT0ZBUl9BUlJSXG4vLyAgICAgICAgICBUcmFjZSgoc3RkZXJyLCBcImluZmxhdGUuYyB0b28gZmFyXFxuXCIpKTtcbi8vICAgICAgICAgIGNvcHkgLT0gc3RhdGUud2hhdmU7XG4vLyAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLmxlbmd0aCkgeyBjb3B5ID0gc3RhdGUubGVuZ3RoOyB9XG4vLyAgICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbi8vICAgICAgICAgIGxlZnQgLT0gY29weTtcbi8vICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuLy8gICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICBvdXRwdXRbcHV0KytdID0gMDtcbi8vICAgICAgICAgIH0gd2hpbGUgKC0tY29weSk7XG4vLyAgICAgICAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7IHN0YXRlLm1vZGUgPSBMRU47IH1cbi8vICAgICAgICAgIGJyZWFrO1xuLy8jZW5kaWZcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS53bmV4dCkge1xuICAgICAgICAgICAgY29weSAtPSBzdGF0ZS53bmV4dDtcbiAgICAgICAgICAgIGZyb20gPSBzdGF0ZS53c2l6ZSAtIGNvcHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZnJvbSA9IHN0YXRlLnduZXh0IC0gY29weTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS5sZW5ndGgpIHsgY29weSA9IHN0YXRlLmxlbmd0aDsgfVxuICAgICAgICAgIGZyb21fc291cmNlID0gc3RhdGUud2luZG93O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGNvcHkgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICBmcm9tID0gcHV0IC0gc3RhdGUub2Zmc2V0O1xuICAgICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4gICAgICAgIGxlZnQgLT0gY29weTtcbiAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICBvdXRwdXRbcHV0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgfSB3aGlsZSAoLS1jb3B5KTtcbiAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgeyBzdGF0ZS5tb2RlID0gTEVOOyB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBMSVQ6XG4gICAgICAgIGlmIChsZWZ0ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBvdXRwdXRbcHV0KytdID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICBsZWZ0LS07XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU47XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDSEVDSzpcbiAgICAgICAgaWYgKHN0YXRlLndyYXApIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygzMik7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAvLyBVc2UgJ3wnIGluc3RlYWQgb2YgJysnIHRvIG1ha2Ugc3VyZSB0aGF0IHJlc3VsdCBpcyBzaWduZWRcbiAgICAgICAgICAgIGhvbGQgfD0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgX291dCAtPSBsZWZ0O1xuICAgICAgICAgIHN0cm0udG90YWxfb3V0ICs9IF9vdXQ7XG4gICAgICAgICAgc3RhdGUudG90YWwgKz0gX291dDtcbiAgICAgICAgICBpZiAoX291dCkge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID1cbiAgICAgICAgICAgICAgICAvKlVQREFURShzdGF0ZS5jaGVjaywgcHV0IC0gX291dCwgX291dCk7Ki9cbiAgICAgICAgICAgICAgICAoc3RhdGUuZmxhZ3MgPyBjcmMzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KSA6IGFkbGVyMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgcHV0IC0gX291dCkpO1xuXG4gICAgICAgICAgfVxuICAgICAgICAgIF9vdXQgPSBsZWZ0O1xuICAgICAgICAgIC8vIE5COiBjcmMzMiBzdG9yZWQgYXMgc2lnbmVkIDMyLWJpdCBpbnQsIHpzd2FwMzIgcmV0dXJucyBzaWduZWQgdG9vXG4gICAgICAgICAgaWYgKChzdGF0ZS5mbGFncyA/IGhvbGQgOiB6c3dhcDMyKGhvbGQpKSAhPT0gc3RhdGUuY2hlY2spIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBkYXRhIGNoZWNrJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGNoZWNrIG1hdGNoZXMgdHJhaWxlclxcblwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IExFTkdUSDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5HVEg6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwICYmIHN0YXRlLmZsYWdzKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBpZiAoaG9sZCAhPT0gKHN0YXRlLnRvdGFsICYgMHhmZmZmZmZmZikpIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2luY29ycmVjdCBsZW5ndGggY2hlY2snO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgbGVuZ3RoIG1hdGNoZXMgdHJhaWxlclxcblwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IERPTkU7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRE9ORTpcbiAgICAgICAgcmV0ID0gWl9TVFJFQU1fRU5EO1xuICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICBjYXNlIEJBRDpcbiAgICAgICAgcmV0ID0gWl9EQVRBX0VSUk9SO1xuICAgICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgICBjYXNlIE1FTTpcbiAgICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAgICAgY2FzZSBTWU5DOlxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgfVxuICB9XG5cbiAgLy8gaW5mX2xlYXZlIDwtIGhlcmUgaXMgcmVhbCBwbGFjZSBmb3IgXCJnb3RvIGluZl9sZWF2ZVwiLCBlbXVsYXRlZCB2aWEgXCJicmVhayBpbmZfbGVhdmVcIlxuXG4gIC8qXG4gICAgIFJldHVybiBmcm9tIGluZmxhdGUoKSwgdXBkYXRpbmcgdGhlIHRvdGFsIGNvdW50cyBhbmQgdGhlIGNoZWNrIHZhbHVlLlxuICAgICBJZiB0aGVyZSB3YXMgbm8gcHJvZ3Jlc3MgZHVyaW5nIHRoZSBpbmZsYXRlKCkgY2FsbCwgcmV0dXJuIGEgYnVmZmVyXG4gICAgIGVycm9yLiAgQ2FsbCB1cGRhdGV3aW5kb3coKSB0byBjcmVhdGUgYW5kL29yIHVwZGF0ZSB0aGUgd2luZG93IHN0YXRlLlxuICAgICBOb3RlOiBhIG1lbW9yeSBlcnJvciBmcm9tIGluZmxhdGUoKSBpcyBub24tcmVjb3ZlcmFibGUuXG4gICAqL1xuXG4gIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0O1xuICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAvLy0tLVxuXG4gIGlmIChzdGF0ZS53c2l6ZSB8fCAoX291dCAhPT0gc3RybS5hdmFpbF9vdXQgJiYgc3RhdGUubW9kZSA8IEJBRCAmJlxuICAgICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlIDwgQ0hFQ0sgfHwgZmx1c2ggIT09IFpfRklOSVNIKSkpIHtcbiAgICBpZiAodXBkYXRld2luZG93KHN0cm0sIHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0LCBfb3V0IC0gc3RybS5hdmFpbF9vdXQpKSB7XG4gICAgICBzdGF0ZS5tb2RlID0gTUVNO1xuICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAgIH1cbiAgfVxuICBfaW4gLT0gc3RybS5hdmFpbF9pbjtcbiAgX291dCAtPSBzdHJtLmF2YWlsX291dDtcbiAgc3RybS50b3RhbF9pbiArPSBfaW47XG4gIHN0cm0udG90YWxfb3V0ICs9IF9vdXQ7XG4gIHN0YXRlLnRvdGFsICs9IF9vdXQ7XG4gIGlmIChzdGF0ZS53cmFwICYmIF9vdXQpIHtcbiAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAvKlVQREFURShzdGF0ZS5jaGVjaywgc3RybS5uZXh0X291dCAtIF9vdXQsIF9vdXQpOyovXG4gICAgICAoc3RhdGUuZmxhZ3MgPyBjcmMzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBzdHJtLm5leHRfb3V0IC0gX291dCkgOiBhZGxlcjMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHN0cm0ubmV4dF9vdXQgLSBfb3V0KSk7XG4gIH1cbiAgc3RybS5kYXRhX3R5cGUgPSBzdGF0ZS5iaXRzICsgKHN0YXRlLmxhc3QgPyA2NCA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPT09IFRZUEUgPyAxMjggOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlID09PSBMRU5fIHx8IHN0YXRlLm1vZGUgPT09IENPUFlfID8gMjU2IDogMCk7XG4gIGlmICgoKF9pbiA9PT0gMCAmJiBfb3V0ID09PSAwKSB8fCBmbHVzaCA9PT0gWl9GSU5JU0gpICYmIHJldCA9PT0gWl9PSykge1xuICAgIHJldCA9IFpfQlVGX0VSUk9SO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVFbmQoc3RybSkge1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSAvKnx8IHN0cm0tPnpmcmVlID09IChmcmVlX2Z1bmMpMCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgdmFyIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKHN0YXRlLndpbmRvdykge1xuICAgIHN0YXRlLndpbmRvdyA9IG51bGw7XG4gIH1cbiAgc3RybS5zdGF0ZSA9IG51bGw7XG4gIHJldHVybiBaX09LO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlR2V0SGVhZGVyKHN0cm0sIGhlYWQpIHtcbiAgdmFyIHN0YXRlO1xuXG4gIC8qIGNoZWNrIHN0YXRlICovXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoKHN0YXRlLndyYXAgJiAyKSA9PT0gMCkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cblxuICAvKiBzYXZlIGhlYWRlciBzdHJ1Y3R1cmUgKi9cbiAgc3RhdGUuaGVhZCA9IGhlYWQ7XG4gIGhlYWQuZG9uZSA9IGZhbHNlO1xuICByZXR1cm4gWl9PSztcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVNldERpY3Rpb25hcnkoc3RybSwgZGljdGlvbmFyeSkge1xuICB2YXIgZGljdExlbmd0aCA9IGRpY3Rpb25hcnkubGVuZ3RoO1xuXG4gIHZhciBzdGF0ZTtcbiAgdmFyIGRpY3RpZDtcbiAgdmFyIHJldDtcblxuICAvKiBjaGVjayBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gLyogPT0gWl9OVUxMICovIHx8ICFzdHJtLnN0YXRlIC8qID09IFpfTlVMTCAqLykgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIGlmIChzdGF0ZS53cmFwICE9PSAwICYmIHN0YXRlLm1vZGUgIT09IERJQ1QpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICAvKiBjaGVjayBmb3IgY29ycmVjdCBkaWN0aW9uYXJ5IGlkZW50aWZpZXIgKi9cbiAgaWYgKHN0YXRlLm1vZGUgPT09IERJQ1QpIHtcbiAgICBkaWN0aWQgPSAxOyAvKiBhZGxlcjMyKDAsIG51bGwsIDApKi9cbiAgICAvKiBkaWN0aWQgPSBhZGxlcjMyKGRpY3RpZCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCk7ICovXG4gICAgZGljdGlkID0gYWRsZXIzMihkaWN0aWQsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIDApO1xuICAgIGlmIChkaWN0aWQgIT09IHN0YXRlLmNoZWNrKSB7XG4gICAgICByZXR1cm4gWl9EQVRBX0VSUk9SO1xuICAgIH1cbiAgfVxuICAvKiBjb3B5IGRpY3Rpb25hcnkgdG8gd2luZG93IHVzaW5nIHVwZGF0ZXdpbmRvdygpLCB3aGljaCB3aWxsIGFtZW5kIHRoZVxuICAgZXhpc3RpbmcgZGljdGlvbmFyeSBpZiBhcHByb3ByaWF0ZSAqL1xuICByZXQgPSB1cGRhdGV3aW5kb3coc3RybSwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgZGljdExlbmd0aCk7XG4gIGlmIChyZXQpIHtcbiAgICBzdGF0ZS5tb2RlID0gTUVNO1xuICAgIHJldHVybiBaX01FTV9FUlJPUjtcbiAgfVxuICBzdGF0ZS5oYXZlZGljdCA9IDE7XG4gIC8vIFRyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgZGljdGlvbmFyeSBzZXRcXG5cIikpO1xuICByZXR1cm4gWl9PSztcbn1cblxuZXhwb3J0cy5pbmZsYXRlUmVzZXQgPSBpbmZsYXRlUmVzZXQ7XG5leHBvcnRzLmluZmxhdGVSZXNldDIgPSBpbmZsYXRlUmVzZXQyO1xuZXhwb3J0cy5pbmZsYXRlUmVzZXRLZWVwID0gaW5mbGF0ZVJlc2V0S2VlcDtcbmV4cG9ydHMuaW5mbGF0ZUluaXQgPSBpbmZsYXRlSW5pdDtcbmV4cG9ydHMuaW5mbGF0ZUluaXQyID0gaW5mbGF0ZUluaXQyO1xuZXhwb3J0cy5pbmZsYXRlID0gaW5mbGF0ZTtcbmV4cG9ydHMuaW5mbGF0ZUVuZCA9IGluZmxhdGVFbmQ7XG5leHBvcnRzLmluZmxhdGVHZXRIZWFkZXIgPSBpbmZsYXRlR2V0SGVhZGVyO1xuZXhwb3J0cy5pbmZsYXRlU2V0RGljdGlvbmFyeSA9IGluZmxhdGVTZXREaWN0aW9uYXJ5O1xuZXhwb3J0cy5pbmZsYXRlSW5mbyA9ICdwYWtvIGluZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpJztcblxuLyogTm90IGltcGxlbWVudGVkXG5leHBvcnRzLmluZmxhdGVDb3B5ID0gaW5mbGF0ZUNvcHk7XG5leHBvcnRzLmluZmxhdGVHZXREaWN0aW9uYXJ5ID0gaW5mbGF0ZUdldERpY3Rpb25hcnk7XG5leHBvcnRzLmluZmxhdGVNYXJrID0gaW5mbGF0ZU1hcms7XG5leHBvcnRzLmluZmxhdGVQcmltZSA9IGluZmxhdGVQcmltZTtcbmV4cG9ydHMuaW5mbGF0ZVN5bmMgPSBpbmZsYXRlU3luYztcbmV4cG9ydHMuaW5mbGF0ZVN5bmNQb2ludCA9IGluZmxhdGVTeW5jUG9pbnQ7XG5leHBvcnRzLmluZmxhdGVVbmRlcm1pbmUgPSBpbmZsYXRlVW5kZXJtaW5lO1xuKi9cbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcblxudmFyIE1BWEJJVFMgPSAxNTtcbnZhciBFTk9VR0hfTEVOUyA9IDg1MjtcbnZhciBFTk9VR0hfRElTVFMgPSA1OTI7XG4vL3ZhciBFTk9VR0ggPSAoRU5PVUdIX0xFTlMrRU5PVUdIX0RJU1RTKTtcblxudmFyIENPREVTID0gMDtcbnZhciBMRU5TID0gMTtcbnZhciBESVNUUyA9IDI7XG5cbnZhciBsYmFzZSA9IFsgLyogTGVuZ3RoIGNvZGVzIDI1Ny4uMjg1IGJhc2UgKi9cbiAgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMywgMTUsIDE3LCAxOSwgMjMsIDI3LCAzMSxcbiAgMzUsIDQzLCA1MSwgNTksIDY3LCA4MywgOTksIDExNSwgMTMxLCAxNjMsIDE5NSwgMjI3LCAyNTgsIDAsIDBcbl07XG5cbnZhciBsZXh0ID0gWyAvKiBMZW5ndGggY29kZXMgMjU3Li4yODUgZXh0cmEgKi9cbiAgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE3LCAxNywgMTgsIDE4LCAxOCwgMTgsXG4gIDE5LCAxOSwgMTksIDE5LCAyMCwgMjAsIDIwLCAyMCwgMjEsIDIxLCAyMSwgMjEsIDE2LCA3MiwgNzhcbl07XG5cbnZhciBkYmFzZSA9IFsgLyogRGlzdGFuY2UgY29kZXMgMC4uMjkgYmFzZSAqL1xuICAxLCAyLCAzLCA0LCA1LCA3LCA5LCAxMywgMTcsIDI1LCAzMywgNDksIDY1LCA5NywgMTI5LCAxOTMsXG4gIDI1NywgMzg1LCA1MTMsIDc2OSwgMTAyNSwgMTUzNywgMjA0OSwgMzA3MywgNDA5NywgNjE0NSxcbiAgODE5MywgMTIyODksIDE2Mzg1LCAyNDU3NywgMCwgMFxuXTtcblxudmFyIGRleHQgPSBbIC8qIERpc3RhbmNlIGNvZGVzIDAuLjI5IGV4dHJhICovXG4gIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE4LCAxOCwgMTksIDE5LCAyMCwgMjAsIDIxLCAyMSwgMjIsIDIyLFxuICAyMywgMjMsIDI0LCAyNCwgMjUsIDI1LCAyNiwgMjYsIDI3LCAyNyxcbiAgMjgsIDI4LCAyOSwgMjksIDY0LCA2NFxuXTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmZsYXRlX3RhYmxlKHR5cGUsIGxlbnMsIGxlbnNfaW5kZXgsIGNvZGVzLCB0YWJsZSwgdGFibGVfaW5kZXgsIHdvcmssIG9wdHMpXG57XG4gIHZhciBiaXRzID0gb3B0cy5iaXRzO1xuICAgICAgLy9oZXJlID0gb3B0cy5oZXJlOyAvKiB0YWJsZSBlbnRyeSBmb3IgZHVwbGljYXRpb24gKi9cblxuICB2YXIgbGVuID0gMDsgICAgICAgICAgICAgICAvKiBhIGNvZGUncyBsZW5ndGggaW4gYml0cyAqL1xuICB2YXIgc3ltID0gMDsgICAgICAgICAgICAgICAvKiBpbmRleCBvZiBjb2RlIHN5bWJvbHMgKi9cbiAgdmFyIG1pbiA9IDAsIG1heCA9IDA7ICAgICAgICAgIC8qIG1pbmltdW0gYW5kIG1heGltdW0gY29kZSBsZW5ndGhzICovXG4gIHZhciByb290ID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciByb290IHRhYmxlICovXG4gIHZhciBjdXJyID0gMDsgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBpbmRleCBiaXRzIGZvciBjdXJyZW50IHRhYmxlICovXG4gIHZhciBkcm9wID0gMDsgICAgICAgICAgICAgIC8qIGNvZGUgYml0cyB0byBkcm9wIGZvciBzdWItdGFibGUgKi9cbiAgdmFyIGxlZnQgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgcHJlZml4IGNvZGVzIGF2YWlsYWJsZSAqL1xuICB2YXIgdXNlZCA9IDA7ICAgICAgICAgICAgICAvKiBjb2RlIGVudHJpZXMgaW4gdGFibGUgdXNlZCAqL1xuICB2YXIgaHVmZiA9IDA7ICAgICAgICAgICAgICAvKiBIdWZmbWFuIGNvZGUgKi9cbiAgdmFyIGluY3I7ICAgICAgICAgICAgICAvKiBmb3IgaW5jcmVtZW50aW5nIGNvZGUsIGluZGV4ICovXG4gIHZhciBmaWxsOyAgICAgICAgICAgICAgLyogaW5kZXggZm9yIHJlcGxpY2F0aW5nIGVudHJpZXMgKi9cbiAgdmFyIGxvdzsgICAgICAgICAgICAgICAvKiBsb3cgYml0cyBmb3IgY3VycmVudCByb290IGVudHJ5ICovXG4gIHZhciBtYXNrOyAgICAgICAgICAgICAgLyogbWFzayBmb3IgbG93IHJvb3QgYml0cyAqL1xuICB2YXIgbmV4dDsgICAgICAgICAgICAgLyogbmV4dCBhdmFpbGFibGUgc3BhY2UgaW4gdGFibGUgKi9cbiAgdmFyIGJhc2UgPSBudWxsOyAgICAgLyogYmFzZSB2YWx1ZSB0YWJsZSB0byB1c2UgKi9cbiAgdmFyIGJhc2VfaW5kZXggPSAwO1xuLy8gIHZhciBzaG9leHRyYTsgICAgLyogZXh0cmEgYml0cyB0YWJsZSB0byB1c2UgKi9cbiAgdmFyIGVuZDsgICAgICAgICAgICAgICAgICAgIC8qIHVzZSBiYXNlIGFuZCBleHRyYSBmb3Igc3ltYm9sID4gZW5kICovXG4gIHZhciBjb3VudCA9IG5ldyB1dGlscy5CdWYxNihNQVhCSVRTICsgMSk7IC8vW01BWEJJVFMrMV07ICAgIC8qIG51bWJlciBvZiBjb2RlcyBvZiBlYWNoIGxlbmd0aCAqL1xuICB2YXIgb2ZmcyA9IG5ldyB1dGlscy5CdWYxNihNQVhCSVRTICsgMSk7IC8vW01BWEJJVFMrMV07ICAgICAvKiBvZmZzZXRzIGluIHRhYmxlIGZvciBlYWNoIGxlbmd0aCAqL1xuICB2YXIgZXh0cmEgPSBudWxsO1xuICB2YXIgZXh0cmFfaW5kZXggPSAwO1xuXG4gIHZhciBoZXJlX2JpdHMsIGhlcmVfb3AsIGhlcmVfdmFsO1xuXG4gIC8qXG4gICBQcm9jZXNzIGEgc2V0IG9mIGNvZGUgbGVuZ3RocyB0byBjcmVhdGUgYSBjYW5vbmljYWwgSHVmZm1hbiBjb2RlLiAgVGhlXG4gICBjb2RlIGxlbmd0aHMgYXJlIGxlbnNbMC4uY29kZXMtMV0uICBFYWNoIGxlbmd0aCBjb3JyZXNwb25kcyB0byB0aGVcbiAgIHN5bWJvbHMgMC4uY29kZXMtMS4gIFRoZSBIdWZmbWFuIGNvZGUgaXMgZ2VuZXJhdGVkIGJ5IGZpcnN0IHNvcnRpbmcgdGhlXG4gICBzeW1ib2xzIGJ5IGxlbmd0aCBmcm9tIHNob3J0IHRvIGxvbmcsIGFuZCByZXRhaW5pbmcgdGhlIHN5bWJvbCBvcmRlclxuICAgZm9yIGNvZGVzIHdpdGggZXF1YWwgbGVuZ3Rocy4gIFRoZW4gdGhlIGNvZGUgc3RhcnRzIHdpdGggYWxsIHplcm8gYml0c1xuICAgZm9yIHRoZSBmaXJzdCBjb2RlIG9mIHRoZSBzaG9ydGVzdCBsZW5ndGgsIGFuZCB0aGUgY29kZXMgYXJlIGludGVnZXJcbiAgIGluY3JlbWVudHMgZm9yIHRoZSBzYW1lIGxlbmd0aCwgYW5kIHplcm9zIGFyZSBhcHBlbmRlZCBhcyB0aGUgbGVuZ3RoXG4gICBpbmNyZWFzZXMuICBGb3IgdGhlIGRlZmxhdGUgZm9ybWF0LCB0aGVzZSBiaXRzIGFyZSBzdG9yZWQgYmFja3dhcmRzXG4gICBmcm9tIHRoZWlyIG1vcmUgbmF0dXJhbCBpbnRlZ2VyIGluY3JlbWVudCBvcmRlcmluZywgYW5kIHNvIHdoZW4gdGhlXG4gICBkZWNvZGluZyB0YWJsZXMgYXJlIGJ1aWx0IGluIHRoZSBsYXJnZSBsb29wIGJlbG93LCB0aGUgaW50ZWdlciBjb2Rlc1xuICAgYXJlIGluY3JlbWVudGVkIGJhY2t3YXJkcy5cblxuICAgVGhpcyByb3V0aW5lIGFzc3VtZXMsIGJ1dCBkb2VzIG5vdCBjaGVjaywgdGhhdCBhbGwgb2YgdGhlIGVudHJpZXMgaW5cbiAgIGxlbnNbXSBhcmUgaW4gdGhlIHJhbmdlIDAuLk1BWEJJVFMuICBUaGUgY2FsbGVyIG11c3QgYXNzdXJlIHRoaXMuXG4gICAxLi5NQVhCSVRTIGlzIGludGVycHJldGVkIGFzIHRoYXQgY29kZSBsZW5ndGguICB6ZXJvIG1lYW5zIHRoYXQgdGhhdFxuICAgc3ltYm9sIGRvZXMgbm90IG9jY3VyIGluIHRoaXMgY29kZS5cblxuICAgVGhlIGNvZGVzIGFyZSBzb3J0ZWQgYnkgY29tcHV0aW5nIGEgY291bnQgb2YgY29kZXMgZm9yIGVhY2ggbGVuZ3RoLFxuICAgY3JlYXRpbmcgZnJvbSB0aGF0IGEgdGFibGUgb2Ygc3RhcnRpbmcgaW5kaWNlcyBmb3IgZWFjaCBsZW5ndGggaW4gdGhlXG4gICBzb3J0ZWQgdGFibGUsIGFuZCB0aGVuIGVudGVyaW5nIHRoZSBzeW1ib2xzIGluIG9yZGVyIGluIHRoZSBzb3J0ZWRcbiAgIHRhYmxlLiAgVGhlIHNvcnRlZCB0YWJsZSBpcyB3b3JrW10sIHdpdGggdGhhdCBzcGFjZSBiZWluZyBwcm92aWRlZCBieVxuICAgdGhlIGNhbGxlci5cblxuICAgVGhlIGxlbmd0aCBjb3VudHMgYXJlIHVzZWQgZm9yIG90aGVyIHB1cnBvc2VzIGFzIHdlbGwsIGkuZS4gZmluZGluZ1xuICAgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gbGVuZ3RoIGNvZGVzLCBkZXRlcm1pbmluZyBpZiB0aGVyZSBhcmUgYW55XG4gICBjb2RlcyBhdCBhbGwsIGNoZWNraW5nIGZvciBhIHZhbGlkIHNldCBvZiBsZW5ndGhzLCBhbmQgbG9va2luZyBhaGVhZFxuICAgYXQgbGVuZ3RoIGNvdW50cyB0byBkZXRlcm1pbmUgc3ViLXRhYmxlIHNpemVzIHdoZW4gYnVpbGRpbmcgdGhlXG4gICBkZWNvZGluZyB0YWJsZXMuXG4gICAqL1xuXG4gIC8qIGFjY3VtdWxhdGUgbGVuZ3RocyBmb3IgY29kZXMgKGFzc3VtZXMgbGVuc1tdIGFsbCBpbiAwLi5NQVhCSVRTKSAqL1xuICBmb3IgKGxlbiA9IDA7IGxlbiA8PSBNQVhCSVRTOyBsZW4rKykge1xuICAgIGNvdW50W2xlbl0gPSAwO1xuICB9XG4gIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7XG4gICAgY291bnRbbGVuc1tsZW5zX2luZGV4ICsgc3ltXV0rKztcbiAgfVxuXG4gIC8qIGJvdW5kIGNvZGUgbGVuZ3RocywgZm9yY2Ugcm9vdCB0byBiZSB3aXRoaW4gY29kZSBsZW5ndGhzICovXG4gIHJvb3QgPSBiaXRzO1xuICBmb3IgKG1heCA9IE1BWEJJVFM7IG1heCA+PSAxOyBtYXgtLSkge1xuICAgIGlmIChjb3VudFttYXhdICE9PSAwKSB7IGJyZWFrOyB9XG4gIH1cbiAgaWYgKHJvb3QgPiBtYXgpIHtcbiAgICByb290ID0gbWF4O1xuICB9XG4gIGlmIChtYXggPT09IDApIHsgICAgICAgICAgICAgICAgICAgICAvKiBubyBzeW1ib2xzIHRvIGNvZGUgYXQgYWxsICovXG4gICAgLy90YWJsZS5vcFtvcHRzLnRhYmxlX2luZGV4XSA9IDY0OyAgLy9oZXJlLm9wID0gKHZhciBjaGFyKTY0OyAgICAvKiBpbnZhbGlkIGNvZGUgbWFya2VyICovXG4gICAgLy90YWJsZS5iaXRzW29wdHMudGFibGVfaW5kZXhdID0gMTsgICAvL2hlcmUuYml0cyA9ICh2YXIgY2hhcikxO1xuICAgIC8vdGFibGUudmFsW29wdHMudGFibGVfaW5kZXgrK10gPSAwOyAgIC8vaGVyZS52YWwgPSAodmFyIHNob3J0KTA7XG4gICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAoMSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwgMDtcblxuXG4gICAgLy90YWJsZS5vcFtvcHRzLnRhYmxlX2luZGV4XSA9IDY0O1xuICAgIC8vdGFibGUuYml0c1tvcHRzLnRhYmxlX2luZGV4XSA9IDE7XG4gICAgLy90YWJsZS52YWxbb3B0cy50YWJsZV9pbmRleCsrXSA9IDA7XG4gICAgdGFibGVbdGFibGVfaW5kZXgrK10gPSAoMSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwgMDtcblxuICAgIG9wdHMuYml0cyA9IDE7XG4gICAgcmV0dXJuIDA7ICAgICAvKiBubyBzeW1ib2xzLCBidXQgd2FpdCBmb3IgZGVjb2RpbmcgdG8gcmVwb3J0IGVycm9yICovXG4gIH1cbiAgZm9yIChtaW4gPSAxOyBtaW4gPCBtYXg7IG1pbisrKSB7XG4gICAgaWYgKGNvdW50W21pbl0gIT09IDApIHsgYnJlYWs7IH1cbiAgfVxuICBpZiAocm9vdCA8IG1pbikge1xuICAgIHJvb3QgPSBtaW47XG4gIH1cblxuICAvKiBjaGVjayBmb3IgYW4gb3Zlci1zdWJzY3JpYmVkIG9yIGluY29tcGxldGUgc2V0IG9mIGxlbmd0aHMgKi9cbiAgbGVmdCA9IDE7XG4gIGZvciAobGVuID0gMTsgbGVuIDw9IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgbGVmdCA8PD0gMTtcbiAgICBsZWZ0IC09IGNvdW50W2xlbl07XG4gICAgaWYgKGxlZnQgPCAwKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfSAgICAgICAgLyogb3Zlci1zdWJzY3JpYmVkICovXG4gIH1cbiAgaWYgKGxlZnQgPiAwICYmICh0eXBlID09PSBDT0RFUyB8fCBtYXggIT09IDEpKSB7XG4gICAgcmV0dXJuIC0xOyAgICAgICAgICAgICAgICAgICAgICAvKiBpbmNvbXBsZXRlIHNldCAqL1xuICB9XG5cbiAgLyogZ2VuZXJhdGUgb2Zmc2V0cyBpbnRvIHN5bWJvbCB0YWJsZSBmb3IgZWFjaCBsZW5ndGggZm9yIHNvcnRpbmcgKi9cbiAgb2Zmc1sxXSA9IDA7XG4gIGZvciAobGVuID0gMTsgbGVuIDwgTUFYQklUUzsgbGVuKyspIHtcbiAgICBvZmZzW2xlbiArIDFdID0gb2Zmc1tsZW5dICsgY291bnRbbGVuXTtcbiAgfVxuXG4gIC8qIHNvcnQgc3ltYm9scyBieSBsZW5ndGgsIGJ5IHN5bWJvbCBvcmRlciB3aXRoaW4gZWFjaCBsZW5ndGggKi9cbiAgZm9yIChzeW0gPSAwOyBzeW0gPCBjb2Rlczsgc3ltKyspIHtcbiAgICBpZiAobGVuc1tsZW5zX2luZGV4ICsgc3ltXSAhPT0gMCkge1xuICAgICAgd29ya1tvZmZzW2xlbnNbbGVuc19pbmRleCArIHN5bV1dKytdID0gc3ltO1xuICAgIH1cbiAgfVxuXG4gIC8qXG4gICBDcmVhdGUgYW5kIGZpbGwgaW4gZGVjb2RpbmcgdGFibGVzLiAgSW4gdGhpcyBsb29wLCB0aGUgdGFibGUgYmVpbmdcbiAgIGZpbGxlZCBpcyBhdCBuZXh0IGFuZCBoYXMgY3VyciBpbmRleCBiaXRzLiAgVGhlIGNvZGUgYmVpbmcgdXNlZCBpcyBodWZmXG4gICB3aXRoIGxlbmd0aCBsZW4uICBUaGF0IGNvZGUgaXMgY29udmVydGVkIHRvIGFuIGluZGV4IGJ5IGRyb3BwaW5nIGRyb3BcbiAgIGJpdHMgb2ZmIG9mIHRoZSBib3R0b20uICBGb3IgY29kZXMgd2hlcmUgbGVuIGlzIGxlc3MgdGhhbiBkcm9wICsgY3VycixcbiAgIHRob3NlIHRvcCBkcm9wICsgY3VyciAtIGxlbiBiaXRzIGFyZSBpbmNyZW1lbnRlZCB0aHJvdWdoIGFsbCB2YWx1ZXMgdG9cbiAgIGZpbGwgdGhlIHRhYmxlIHdpdGggcmVwbGljYXRlZCBlbnRyaWVzLlxuXG4gICByb290IGlzIHRoZSBudW1iZXIgb2YgaW5kZXggYml0cyBmb3IgdGhlIHJvb3QgdGFibGUuICBXaGVuIGxlbiBleGNlZWRzXG4gICByb290LCBzdWItdGFibGVzIGFyZSBjcmVhdGVkIHBvaW50ZWQgdG8gYnkgdGhlIHJvb3QgZW50cnkgd2l0aCBhbiBpbmRleFxuICAgb2YgdGhlIGxvdyByb290IGJpdHMgb2YgaHVmZi4gIFRoaXMgaXMgc2F2ZWQgaW4gbG93IHRvIGNoZWNrIGZvciB3aGVuIGFcbiAgIG5ldyBzdWItdGFibGUgc2hvdWxkIGJlIHN0YXJ0ZWQuICBkcm9wIGlzIHplcm8gd2hlbiB0aGUgcm9vdCB0YWJsZSBpc1xuICAgYmVpbmcgZmlsbGVkLCBhbmQgZHJvcCBpcyByb290IHdoZW4gc3ViLXRhYmxlcyBhcmUgYmVpbmcgZmlsbGVkLlxuXG4gICBXaGVuIGEgbmV3IHN1Yi10YWJsZSBpcyBuZWVkZWQsIGl0IGlzIG5lY2Vzc2FyeSB0byBsb29rIGFoZWFkIGluIHRoZVxuICAgY29kZSBsZW5ndGhzIHRvIGRldGVybWluZSB3aGF0IHNpemUgc3ViLXRhYmxlIGlzIG5lZWRlZC4gIFRoZSBsZW5ndGhcbiAgIGNvdW50cyBhcmUgdXNlZCBmb3IgdGhpcywgYW5kIHNvIGNvdW50W10gaXMgZGVjcmVtZW50ZWQgYXMgY29kZXMgYXJlXG4gICBlbnRlcmVkIGluIHRoZSB0YWJsZXMuXG5cbiAgIHVzZWQga2VlcHMgdHJhY2sgb2YgaG93IG1hbnkgdGFibGUgZW50cmllcyBoYXZlIGJlZW4gYWxsb2NhdGVkIGZyb20gdGhlXG4gICBwcm92aWRlZCAqdGFibGUgc3BhY2UuICBJdCBpcyBjaGVja2VkIGZvciBMRU5TIGFuZCBESVNUIHRhYmxlcyBhZ2FpbnN0XG4gICB0aGUgY29uc3RhbnRzIEVOT1VHSF9MRU5TIGFuZCBFTk9VR0hfRElTVFMgdG8gZ3VhcmQgYWdhaW5zdCBjaGFuZ2VzIGluXG4gICB0aGUgaW5pdGlhbCByb290IHRhYmxlIHNpemUgY29uc3RhbnRzLiAgU2VlIHRoZSBjb21tZW50cyBpbiBpbmZ0cmVlcy5oXG4gICBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cblxuICAgc3ltIGluY3JlbWVudHMgdGhyb3VnaCBhbGwgc3ltYm9scywgYW5kIHRoZSBsb29wIHRlcm1pbmF0ZXMgd2hlblxuICAgYWxsIGNvZGVzIG9mIGxlbmd0aCBtYXgsIGkuZS4gYWxsIGNvZGVzLCBoYXZlIGJlZW4gcHJvY2Vzc2VkLiAgVGhpc1xuICAgcm91dGluZSBwZXJtaXRzIGluY29tcGxldGUgY29kZXMsIHNvIGFub3RoZXIgbG9vcCBhZnRlciB0aGlzIG9uZSBmaWxsc1xuICAgaW4gdGhlIHJlc3Qgb2YgdGhlIGRlY29kaW5nIHRhYmxlcyB3aXRoIGludmFsaWQgY29kZSBtYXJrZXJzLlxuICAgKi9cblxuICAvKiBzZXQgdXAgZm9yIGNvZGUgdHlwZSAqL1xuICAvLyBwb29yIG1hbiBvcHRpbWl6YXRpb24gLSB1c2UgaWYtZWxzZSBpbnN0ZWFkIG9mIHN3aXRjaCxcbiAgLy8gdG8gYXZvaWQgZGVvcHRzIGluIG9sZCB2OFxuICBpZiAodHlwZSA9PT0gQ09ERVMpIHtcbiAgICBiYXNlID0gZXh0cmEgPSB3b3JrOyAgICAvKiBkdW1teSB2YWx1ZS0tbm90IHVzZWQgKi9cbiAgICBlbmQgPSAxOTtcblxuICB9IGVsc2UgaWYgKHR5cGUgPT09IExFTlMpIHtcbiAgICBiYXNlID0gbGJhc2U7XG4gICAgYmFzZV9pbmRleCAtPSAyNTc7XG4gICAgZXh0cmEgPSBsZXh0O1xuICAgIGV4dHJhX2luZGV4IC09IDI1NztcbiAgICBlbmQgPSAyNTY7XG5cbiAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgIC8qIERJU1RTICovXG4gICAgYmFzZSA9IGRiYXNlO1xuICAgIGV4dHJhID0gZGV4dDtcbiAgICBlbmQgPSAtMTtcbiAgfVxuXG4gIC8qIGluaXRpYWxpemUgb3B0cyBmb3IgbG9vcCAqL1xuICBodWZmID0gMDsgICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSAqL1xuICBzeW0gPSAwOyAgICAgICAgICAgICAgICAgICAgLyogc3RhcnRpbmcgY29kZSBzeW1ib2wgKi9cbiAgbGVuID0gbWluOyAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgbGVuZ3RoICovXG4gIG5leHQgPSB0YWJsZV9pbmRleDsgICAgICAgICAgICAgIC8qIGN1cnJlbnQgdGFibGUgdG8gZmlsbCBpbiAqL1xuICBjdXJyID0gcm9vdDsgICAgICAgICAgICAgICAgLyogY3VycmVudCB0YWJsZSBpbmRleCBiaXRzICovXG4gIGRyb3AgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBjdXJyZW50IGJpdHMgdG8gZHJvcCBmcm9tIGNvZGUgZm9yIGluZGV4ICovXG4gIGxvdyA9IC0xOyAgICAgICAgICAgICAgICAgICAvKiB0cmlnZ2VyIG5ldyBzdWItdGFibGUgd2hlbiBsZW4gPiByb290ICovXG4gIHVzZWQgPSAxIDw8IHJvb3Q7ICAgICAgICAgIC8qIHVzZSByb290IHRhYmxlIGVudHJpZXMgKi9cbiAgbWFzayA9IHVzZWQgLSAxOyAgICAgICAgICAgIC8qIG1hc2sgZm9yIGNvbXBhcmluZyBsb3cgKi9cblxuICAvKiBjaGVjayBhdmFpbGFibGUgdGFibGUgc3BhY2UgKi9cbiAgaWYgKCh0eXBlID09PSBMRU5TICYmIHVzZWQgPiBFTk9VR0hfTEVOUykgfHxcbiAgICAodHlwZSA9PT0gRElTVFMgJiYgdXNlZCA+IEVOT1VHSF9ESVNUUykpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIC8qIHByb2Nlc3MgYWxsIGNvZGVzIGFuZCBtYWtlIHRhYmxlIGVudHJpZXMgKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIGNyZWF0ZSB0YWJsZSBlbnRyeSAqL1xuICAgIGhlcmVfYml0cyA9IGxlbiAtIGRyb3A7XG4gICAgaWYgKHdvcmtbc3ltXSA8IGVuZCkge1xuICAgICAgaGVyZV9vcCA9IDA7XG4gICAgICBoZXJlX3ZhbCA9IHdvcmtbc3ltXTtcbiAgICB9XG4gICAgZWxzZSBpZiAod29ya1tzeW1dID4gZW5kKSB7XG4gICAgICBoZXJlX29wID0gZXh0cmFbZXh0cmFfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgICAgaGVyZV92YWwgPSBiYXNlW2Jhc2VfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGhlcmVfb3AgPSAzMiArIDY0OyAgICAgICAgIC8qIGVuZCBvZiBibG9jayAqL1xuICAgICAgaGVyZV92YWwgPSAwO1xuICAgIH1cblxuICAgIC8qIHJlcGxpY2F0ZSBmb3IgdGhvc2UgaW5kaWNlcyB3aXRoIGxvdyBsZW4gYml0cyBlcXVhbCB0byBodWZmICovXG4gICAgaW5jciA9IDEgPDwgKGxlbiAtIGRyb3ApO1xuICAgIGZpbGwgPSAxIDw8IGN1cnI7XG4gICAgbWluID0gZmlsbDsgICAgICAgICAgICAgICAgIC8qIHNhdmUgb2Zmc2V0IHRvIG5leHQgdGFibGUgKi9cbiAgICBkbyB7XG4gICAgICBmaWxsIC09IGluY3I7XG4gICAgICB0YWJsZVtuZXh0ICsgKGh1ZmYgPj4gZHJvcCkgKyBmaWxsXSA9IChoZXJlX2JpdHMgPDwgMjQpIHwgKGhlcmVfb3AgPDwgMTYpIHwgaGVyZV92YWwgfDA7XG4gICAgfSB3aGlsZSAoZmlsbCAhPT0gMCk7XG5cbiAgICAvKiBiYWNrd2FyZHMgaW5jcmVtZW50IHRoZSBsZW4tYml0IGNvZGUgaHVmZiAqL1xuICAgIGluY3IgPSAxIDw8IChsZW4gLSAxKTtcbiAgICB3aGlsZSAoaHVmZiAmIGluY3IpIHtcbiAgICAgIGluY3IgPj49IDE7XG4gICAgfVxuICAgIGlmIChpbmNyICE9PSAwKSB7XG4gICAgICBodWZmICY9IGluY3IgLSAxO1xuICAgICAgaHVmZiArPSBpbmNyO1xuICAgIH0gZWxzZSB7XG4gICAgICBodWZmID0gMDtcbiAgICB9XG5cbiAgICAvKiBnbyB0byBuZXh0IHN5bWJvbCwgdXBkYXRlIGNvdW50LCBsZW4gKi9cbiAgICBzeW0rKztcbiAgICBpZiAoLS1jb3VudFtsZW5dID09PSAwKSB7XG4gICAgICBpZiAobGVuID09PSBtYXgpIHsgYnJlYWs7IH1cbiAgICAgIGxlbiA9IGxlbnNbbGVuc19pbmRleCArIHdvcmtbc3ltXV07XG4gICAgfVxuXG4gICAgLyogY3JlYXRlIG5ldyBzdWItdGFibGUgaWYgbmVlZGVkICovXG4gICAgaWYgKGxlbiA+IHJvb3QgJiYgKGh1ZmYgJiBtYXNrKSAhPT0gbG93KSB7XG4gICAgICAvKiBpZiBmaXJzdCB0aW1lLCB0cmFuc2l0aW9uIHRvIHN1Yi10YWJsZXMgKi9cbiAgICAgIGlmIChkcm9wID09PSAwKSB7XG4gICAgICAgIGRyb3AgPSByb290O1xuICAgICAgfVxuXG4gICAgICAvKiBpbmNyZW1lbnQgcGFzdCBsYXN0IHRhYmxlICovXG4gICAgICBuZXh0ICs9IG1pbjsgICAgICAgICAgICAvKiBoZXJlIG1pbiBpcyAxIDw8IGN1cnIgKi9cblxuICAgICAgLyogZGV0ZXJtaW5lIGxlbmd0aCBvZiBuZXh0IHRhYmxlICovXG4gICAgICBjdXJyID0gbGVuIC0gZHJvcDtcbiAgICAgIGxlZnQgPSAxIDw8IGN1cnI7XG4gICAgICB3aGlsZSAoY3VyciArIGRyb3AgPCBtYXgpIHtcbiAgICAgICAgbGVmdCAtPSBjb3VudFtjdXJyICsgZHJvcF07XG4gICAgICAgIGlmIChsZWZ0IDw9IDApIHsgYnJlYWs7IH1cbiAgICAgICAgY3VycisrO1xuICAgICAgICBsZWZ0IDw8PSAxO1xuICAgICAgfVxuXG4gICAgICAvKiBjaGVjayBmb3IgZW5vdWdoIHNwYWNlICovXG4gICAgICB1c2VkICs9IDEgPDwgY3VycjtcbiAgICAgIGlmICgodHlwZSA9PT0gTEVOUyAmJiB1c2VkID4gRU5PVUdIX0xFTlMpIHx8XG4gICAgICAgICh0eXBlID09PSBESVNUUyAmJiB1c2VkID4gRU5PVUdIX0RJU1RTKSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgLyogcG9pbnQgZW50cnkgaW4gcm9vdCB0YWJsZSB0byBzdWItdGFibGUgKi9cbiAgICAgIGxvdyA9IGh1ZmYgJiBtYXNrO1xuICAgICAgLyp0YWJsZS5vcFtsb3ddID0gY3VycjtcbiAgICAgIHRhYmxlLmJpdHNbbG93XSA9IHJvb3Q7XG4gICAgICB0YWJsZS52YWxbbG93XSA9IG5leHQgLSBvcHRzLnRhYmxlX2luZGV4OyovXG4gICAgICB0YWJsZVtsb3ddID0gKHJvb3QgPDwgMjQpIHwgKGN1cnIgPDwgMTYpIHwgKG5leHQgLSB0YWJsZV9pbmRleCkgfDA7XG4gICAgfVxuICB9XG5cbiAgLyogZmlsbCBpbiByZW1haW5pbmcgdGFibGUgZW50cnkgaWYgY29kZSBpcyBpbmNvbXBsZXRlIChndWFyYW50ZWVkIHRvIGhhdmVcbiAgIGF0IG1vc3Qgb25lIHJlbWFpbmluZyBlbnRyeSwgc2luY2UgaWYgdGhlIGNvZGUgaXMgaW5jb21wbGV0ZSwgdGhlXG4gICBtYXhpbXVtIGNvZGUgbGVuZ3RoIHRoYXQgd2FzIGFsbG93ZWQgdG8gZ2V0IHRoaXMgZmFyIGlzIG9uZSBiaXQpICovXG4gIGlmIChodWZmICE9PSAwKSB7XG4gICAgLy90YWJsZS5vcFtuZXh0ICsgaHVmZl0gPSA2NDsgICAgICAgICAgICAvKiBpbnZhbGlkIGNvZGUgbWFya2VyICovXG4gICAgLy90YWJsZS5iaXRzW25leHQgKyBodWZmXSA9IGxlbiAtIGRyb3A7XG4gICAgLy90YWJsZS52YWxbbmV4dCArIGh1ZmZdID0gMDtcbiAgICB0YWJsZVtuZXh0ICsgaHVmZl0gPSAoKGxlbiAtIGRyb3ApIDw8IDI0KSB8ICg2NCA8PCAxNikgfDA7XG4gIH1cblxuICAvKiBzZXQgcmV0dXJuIHBhcmFtZXRlcnMgKi9cbiAgLy9vcHRzLnRhYmxlX2luZGV4ICs9IHVzZWQ7XG4gIG9wdHMuYml0cyA9IHJvb3Q7XG4gIHJldHVybiAwO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgMjogICAgICAnbmVlZCBkaWN0aW9uYXJ5JywgICAgIC8qIFpfTkVFRF9ESUNUICAgICAgIDIgICovXG4gIDE6ICAgICAgJ3N0cmVhbSBlbmQnLCAgICAgICAgICAvKiBaX1NUUkVBTV9FTkQgICAgICAxICAqL1xuICAwOiAgICAgICcnLCAgICAgICAgICAgICAgICAgICAgLyogWl9PSyAgICAgICAgICAgICAgMCAgKi9cbiAgJy0xJzogICAnZmlsZSBlcnJvcicsICAgICAgICAgIC8qIFpfRVJSTk8gICAgICAgICAoLTEpICovXG4gICctMic6ICAgJ3N0cmVhbSBlcnJvcicsICAgICAgICAvKiBaX1NUUkVBTV9FUlJPUiAgKC0yKSAqL1xuICAnLTMnOiAgICdkYXRhIGVycm9yJywgICAgICAgICAgLyogWl9EQVRBX0VSUk9SICAgICgtMykgKi9cbiAgJy00JzogICAnaW5zdWZmaWNpZW50IG1lbW9yeScsIC8qIFpfTUVNX0VSUk9SICAgICAoLTQpICovXG4gICctNSc6ICAgJ2J1ZmZlciBlcnJvcicsICAgICAgICAvKiBaX0JVRl9FUlJPUiAgICAgKC01KSAqL1xuICAnLTYnOiAgICdpbmNvbXBhdGlibGUgdmVyc2lvbicgLyogWl9WRVJTSU9OX0VSUk9SICgtNikgKi9cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuLyogZXNsaW50LWRpc2FibGUgc3BhY2UtdW5hcnktb3BzICovXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbW1vbicpO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vL3ZhciBaX0ZJTFRFUkVEICAgICAgICAgID0gMTtcbi8vdmFyIFpfSFVGRk1BTl9PTkxZICAgICAgPSAyO1xuLy92YXIgWl9STEUgICAgICAgICAgICAgICA9IDM7XG52YXIgWl9GSVhFRCAgICAgICAgICAgICAgID0gNDtcbi8vdmFyIFpfREVGQVVMVF9TVFJBVEVHWSAgPSAwO1xuXG4vKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG52YXIgWl9CSU5BUlkgICAgICAgICAgICAgID0gMDtcbnZhciBaX1RFWFQgICAgICAgICAgICAgICAgPSAxO1xuLy92YXIgWl9BU0NJSSAgICAgICAgICAgICA9IDE7IC8vID0gWl9URVhUXG52YXIgWl9VTktOT1dOICAgICAgICAgICAgID0gMjtcblxuLyo9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG5mdW5jdGlvbiB6ZXJvKGJ1ZikgeyB2YXIgbGVuID0gYnVmLmxlbmd0aDsgd2hpbGUgKC0tbGVuID49IDApIHsgYnVmW2xlbl0gPSAwOyB9IH1cblxuLy8gRnJvbSB6dXRpbC5oXG5cbnZhciBTVE9SRURfQkxPQ0sgPSAwO1xudmFyIFNUQVRJQ19UUkVFUyA9IDE7XG52YXIgRFlOX1RSRUVTICAgID0gMjtcbi8qIFRoZSB0aHJlZSBraW5kcyBvZiBibG9jayB0eXBlICovXG5cbnZhciBNSU5fTUFUQ0ggICAgPSAzO1xudmFyIE1BWF9NQVRDSCAgICA9IDI1ODtcbi8qIFRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIG1hdGNoIGxlbmd0aHMgKi9cblxuLy8gRnJvbSBkZWZsYXRlLmhcbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW50ZXJuYWwgY29tcHJlc3Npb24gc3RhdGUuXG4gKi9cblxudmFyIExFTkdUSF9DT0RFUyAgPSAyOTtcbi8qIG51bWJlciBvZiBsZW5ndGggY29kZXMsIG5vdCBjb3VudGluZyB0aGUgc3BlY2lhbCBFTkRfQkxPQ0sgY29kZSAqL1xuXG52YXIgTElURVJBTFMgICAgICA9IDI1Njtcbi8qIG51bWJlciBvZiBsaXRlcmFsIGJ5dGVzIDAuLjI1NSAqL1xuXG52YXIgTF9DT0RFUyAgICAgICA9IExJVEVSQUxTICsgMSArIExFTkdUSF9DT0RFUztcbi8qIG51bWJlciBvZiBMaXRlcmFsIG9yIExlbmd0aCBjb2RlcywgaW5jbHVkaW5nIHRoZSBFTkRfQkxPQ0sgY29kZSAqL1xuXG52YXIgRF9DT0RFUyAgICAgICA9IDMwO1xuLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGVzICovXG5cbnZhciBCTF9DT0RFUyAgICAgID0gMTk7XG4vKiBudW1iZXIgb2YgY29kZXMgdXNlZCB0byB0cmFuc2ZlciB0aGUgYml0IGxlbmd0aHMgKi9cblxudmFyIEhFQVBfU0laRSAgICAgPSAyICogTF9DT0RFUyArIDE7XG4vKiBtYXhpbXVtIGhlYXAgc2l6ZSAqL1xuXG52YXIgTUFYX0JJVFMgICAgICA9IDE1O1xuLyogQWxsIGNvZGVzIG11c3Qgbm90IGV4Y2VlZCBNQVhfQklUUyBiaXRzICovXG5cbnZhciBCdWZfc2l6ZSAgICAgID0gMTY7XG4vKiBzaXplIG9mIGJpdCBidWZmZXIgaW4gYmlfYnVmICovXG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdGFudHNcbiAqL1xuXG52YXIgTUFYX0JMX0JJVFMgPSA3O1xuLyogQml0IGxlbmd0aCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JMX0JJVFMgYml0cyAqL1xuXG52YXIgRU5EX0JMT0NLICAgPSAyNTY7XG4vKiBlbmQgb2YgYmxvY2sgbGl0ZXJhbCBjb2RlICovXG5cbnZhciBSRVBfM182ICAgICA9IDE2O1xuLyogcmVwZWF0IHByZXZpb3VzIGJpdCBsZW5ndGggMy02IHRpbWVzICgyIGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG52YXIgUkVQWl8zXzEwICAgPSAxNztcbi8qIHJlcGVhdCBhIHplcm8gbGVuZ3RoIDMtMTAgdGltZXMgICgzIGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG52YXIgUkVQWl8xMV8xMzggPSAxODtcbi8qIHJlcGVhdCBhIHplcm8gbGVuZ3RoIDExLTEzOCB0aW1lcyAgKDcgYml0cyBvZiByZXBlYXQgY291bnQpICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGNvbW1hLXNwYWNpbmcsYXJyYXktYnJhY2tldC1zcGFjaW5nICovXG52YXIgZXh0cmFfbGJpdHMgPSAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggbGVuZ3RoIGNvZGUgKi9cbiAgWzAsMCwwLDAsMCwwLDAsMCwxLDEsMSwxLDIsMiwyLDIsMywzLDMsMyw0LDQsNCw0LDUsNSw1LDUsMF07XG5cbnZhciBleHRyYV9kYml0cyA9ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBkaXN0YW5jZSBjb2RlICovXG4gIFswLDAsMCwwLDEsMSwyLDIsMywzLDQsNCw1LDUsNiw2LDcsNyw4LDgsOSw5LDEwLDEwLDExLDExLDEyLDEyLDEzLDEzXTtcblxudmFyIGV4dHJhX2JsYml0cyA9ICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGJpdCBsZW5ndGggY29kZSAqL1xuICBbMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwyLDMsN107XG5cbnZhciBibF9vcmRlciA9XG4gIFsxNiwxNywxOCwwLDgsNyw5LDYsMTAsNSwxMSw0LDEyLDMsMTMsMiwxNCwxLDE1XTtcbi8qIGVzbGludC1lbmFibGUgY29tbWEtc3BhY2luZyxhcnJheS1icmFja2V0LXNwYWNpbmcgKi9cblxuLyogVGhlIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGggY29kZXMgYXJlIHNlbnQgaW4gb3JkZXIgb2YgZGVjcmVhc2luZ1xuICogcHJvYmFiaWxpdHksIHRvIGF2b2lkIHRyYW5zbWl0dGluZyB0aGUgbGVuZ3RocyBmb3IgdW51c2VkIGJpdCBsZW5ndGggY29kZXMuXG4gKi9cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBMb2NhbCBkYXRhLiBUaGVzZSBhcmUgaW5pdGlhbGl6ZWQgb25seSBvbmNlLlxuICovXG5cbi8vIFdlIHByZS1maWxsIGFycmF5cyB3aXRoIDAgdG8gYXZvaWQgdW5pbml0aWFsaXplZCBnYXBzXG5cbnZhciBESVNUX0NPREVfTEVOID0gNTEyOyAvKiBzZWUgZGVmaW5pdGlvbiBvZiBhcnJheSBkaXN0X2NvZGUgYmVsb3cgKi9cblxuLy8gISEhISBVc2UgZmxhdCBhcnJheSBpbnN0ZWFkIG9mIHN0cnVjdHVyZSwgRnJlcSA9IGkqMiwgTGVuID0gaSoyKzFcbnZhciBzdGF0aWNfbHRyZWUgID0gbmV3IEFycmF5KChMX0NPREVTICsgMikgKiAyKTtcbnplcm8oc3RhdGljX2x0cmVlKTtcbi8qIFRoZSBzdGF0aWMgbGl0ZXJhbCB0cmVlLiBTaW5jZSB0aGUgYml0IGxlbmd0aHMgYXJlIGltcG9zZWQsIHRoZXJlIGlzIG5vXG4gKiBuZWVkIGZvciB0aGUgTF9DT0RFUyBleHRyYSBjb2RlcyB1c2VkIGR1cmluZyBoZWFwIGNvbnN0cnVjdGlvbi4gSG93ZXZlclxuICogVGhlIGNvZGVzIDI4NiBhbmQgMjg3IGFyZSBuZWVkZWQgdG8gYnVpbGQgYSBjYW5vbmljYWwgdHJlZSAoc2VlIF90cl9pbml0XG4gKiBiZWxvdykuXG4gKi9cblxudmFyIHN0YXRpY19kdHJlZSAgPSBuZXcgQXJyYXkoRF9DT0RFUyAqIDIpO1xuemVybyhzdGF0aWNfZHRyZWUpO1xuLyogVGhlIHN0YXRpYyBkaXN0YW5jZSB0cmVlLiAoQWN0dWFsbHkgYSB0cml2aWFsIHRyZWUgc2luY2UgYWxsIGNvZGVzIHVzZVxuICogNSBiaXRzLilcbiAqL1xuXG52YXIgX2Rpc3RfY29kZSAgICA9IG5ldyBBcnJheShESVNUX0NPREVfTEVOKTtcbnplcm8oX2Rpc3RfY29kZSk7XG4vKiBEaXN0YW5jZSBjb2Rlcy4gVGhlIGZpcnN0IDI1NiB2YWx1ZXMgY29ycmVzcG9uZCB0byB0aGUgZGlzdGFuY2VzXG4gKiAzIC4uIDI1OCwgdGhlIGxhc3QgMjU2IHZhbHVlcyBjb3JyZXNwb25kIHRvIHRoZSB0b3AgOCBiaXRzIG9mXG4gKiB0aGUgMTUgYml0IGRpc3RhbmNlcy5cbiAqL1xuXG52YXIgX2xlbmd0aF9jb2RlICA9IG5ldyBBcnJheShNQVhfTUFUQ0ggLSBNSU5fTUFUQ0ggKyAxKTtcbnplcm8oX2xlbmd0aF9jb2RlKTtcbi8qIGxlbmd0aCBjb2RlIGZvciBlYWNoIG5vcm1hbGl6ZWQgbWF0Y2ggbGVuZ3RoICgwID09IE1JTl9NQVRDSCkgKi9cblxudmFyIGJhc2VfbGVuZ3RoICAgPSBuZXcgQXJyYXkoTEVOR1RIX0NPREVTKTtcbnplcm8oYmFzZV9sZW5ndGgpO1xuLyogRmlyc3Qgbm9ybWFsaXplZCBsZW5ndGggZm9yIGVhY2ggY29kZSAoMCA9IE1JTl9NQVRDSCkgKi9cblxudmFyIGJhc2VfZGlzdCAgICAgPSBuZXcgQXJyYXkoRF9DT0RFUyk7XG56ZXJvKGJhc2VfZGlzdCk7XG4vKiBGaXJzdCBub3JtYWxpemVkIGRpc3RhbmNlIGZvciBlYWNoIGNvZGUgKDAgPSBkaXN0YW5jZSBvZiAxKSAqL1xuXG5cbmZ1bmN0aW9uIFN0YXRpY1RyZWVEZXNjKHN0YXRpY190cmVlLCBleHRyYV9iaXRzLCBleHRyYV9iYXNlLCBlbGVtcywgbWF4X2xlbmd0aCkge1xuXG4gIHRoaXMuc3RhdGljX3RyZWUgID0gc3RhdGljX3RyZWU7ICAvKiBzdGF0aWMgdHJlZSBvciBOVUxMICovXG4gIHRoaXMuZXh0cmFfYml0cyAgID0gZXh0cmFfYml0czsgICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGNvZGUgb3IgTlVMTCAqL1xuICB0aGlzLmV4dHJhX2Jhc2UgICA9IGV4dHJhX2Jhc2U7ICAgLyogYmFzZSBpbmRleCBmb3IgZXh0cmFfYml0cyAqL1xuICB0aGlzLmVsZW1zICAgICAgICA9IGVsZW1zOyAgICAgICAgLyogbWF4IG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgdHJlZSAqL1xuICB0aGlzLm1heF9sZW5ndGggICA9IG1heF9sZW5ndGg7ICAgLyogbWF4IGJpdCBsZW5ndGggZm9yIHRoZSBjb2RlcyAqL1xuXG4gIC8vIHNob3cgaWYgYHN0YXRpY190cmVlYCBoYXMgZGF0YSBvciBkdW1teSAtIG5lZWRlZCBmb3IgbW9ub21vcnBoaWMgb2JqZWN0c1xuICB0aGlzLmhhc19zdHJlZSAgICA9IHN0YXRpY190cmVlICYmIHN0YXRpY190cmVlLmxlbmd0aDtcbn1cblxuXG52YXIgc3RhdGljX2xfZGVzYztcbnZhciBzdGF0aWNfZF9kZXNjO1xudmFyIHN0YXRpY19ibF9kZXNjO1xuXG5cbmZ1bmN0aW9uIFRyZWVEZXNjKGR5bl90cmVlLCBzdGF0X2Rlc2MpIHtcbiAgdGhpcy5keW5fdHJlZSA9IGR5bl90cmVlOyAgICAgLyogdGhlIGR5bmFtaWMgdHJlZSAqL1xuICB0aGlzLm1heF9jb2RlID0gMDsgICAgICAgICAgICAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbiAgdGhpcy5zdGF0X2Rlc2MgPSBzdGF0X2Rlc2M7ICAgLyogdGhlIGNvcnJlc3BvbmRpbmcgc3RhdGljIHRyZWUgKi9cbn1cblxuXG5cbmZ1bmN0aW9uIGRfY29kZShkaXN0KSB7XG4gIHJldHVybiBkaXN0IDwgMjU2ID8gX2Rpc3RfY29kZVtkaXN0XSA6IF9kaXN0X2NvZGVbMjU2ICsgKGRpc3QgPj4+IDcpXTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIE91dHB1dCBhIHNob3J0IExTQiBmaXJzdCBvbiB0aGUgc3RyZWFtLlxuICogSU4gYXNzZXJ0aW9uOiB0aGVyZSBpcyBlbm91Z2ggcm9vbSBpbiBwZW5kaW5nQnVmLlxuICovXG5mdW5jdGlvbiBwdXRfc2hvcnQocywgdykge1xuLy8gICAgcHV0X2J5dGUocywgKHVjaCkoKHcpICYgMHhmZikpO1xuLy8gICAgcHV0X2J5dGUocywgKHVjaCkoKHVzaCkodykgPj4gOCkpO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9ICh3KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gKHcgPj4+IDgpICYgMHhmZjtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSB2YWx1ZSBvbiBhIGdpdmVuIG51bWJlciBvZiBiaXRzLlxuICogSU4gYXNzZXJ0aW9uOiBsZW5ndGggPD0gMTYgYW5kIHZhbHVlIGZpdHMgaW4gbGVuZ3RoIGJpdHMuXG4gKi9cbmZ1bmN0aW9uIHNlbmRfYml0cyhzLCB2YWx1ZSwgbGVuZ3RoKSB7XG4gIGlmIChzLmJpX3ZhbGlkID4gKEJ1Zl9zaXplIC0gbGVuZ3RoKSkge1xuICAgIHMuYmlfYnVmIHw9ICh2YWx1ZSA8PCBzLmJpX3ZhbGlkKSAmIDB4ZmZmZjtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICAgIHMuYmlfYnVmID0gdmFsdWUgPj4gKEJ1Zl9zaXplIC0gcy5iaV92YWxpZCk7XG4gICAgcy5iaV92YWxpZCArPSBsZW5ndGggLSBCdWZfc2l6ZTtcbiAgfSBlbHNlIHtcbiAgICBzLmJpX2J1ZiB8PSAodmFsdWUgPDwgcy5iaV92YWxpZCkgJiAweGZmZmY7XG4gICAgcy5iaV92YWxpZCArPSBsZW5ndGg7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzZW5kX2NvZGUocywgYywgdHJlZSkge1xuICBzZW5kX2JpdHMocywgdHJlZVtjICogMl0vKi5Db2RlKi8sIHRyZWVbYyAqIDIgKyAxXS8qLkxlbiovKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJldmVyc2UgdGhlIGZpcnN0IGxlbiBiaXRzIG9mIGEgY29kZSwgdXNpbmcgc3RyYWlnaHRmb3J3YXJkIGNvZGUgKGEgZmFzdGVyXG4gKiBtZXRob2Qgd291bGQgdXNlIGEgdGFibGUpXG4gKiBJTiBhc3NlcnRpb246IDEgPD0gbGVuIDw9IDE1XG4gKi9cbmZ1bmN0aW9uIGJpX3JldmVyc2UoY29kZSwgbGVuKSB7XG4gIHZhciByZXMgPSAwO1xuICBkbyB7XG4gICAgcmVzIHw9IGNvZGUgJiAxO1xuICAgIGNvZGUgPj4+PSAxO1xuICAgIHJlcyA8PD0gMTtcbiAgfSB3aGlsZSAoLS1sZW4gPiAwKTtcbiAgcmV0dXJuIHJlcyA+Pj4gMTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIHRoZSBiaXQgYnVmZmVyLCBrZWVwaW5nIGF0IG1vc3QgNyBiaXRzIGluIGl0LlxuICovXG5mdW5jdGlvbiBiaV9mbHVzaChzKSB7XG4gIGlmIChzLmJpX3ZhbGlkID09PSAxNikge1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gICAgcy5iaV9idWYgPSAwO1xuICAgIHMuYmlfdmFsaWQgPSAwO1xuXG4gIH0gZWxzZSBpZiAocy5iaV92YWxpZCA+PSA4KSB7XG4gICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBzLmJpX2J1ZiAmIDB4ZmY7XG4gICAgcy5iaV9idWYgPj49IDg7XG4gICAgcy5iaV92YWxpZCAtPSA4O1xuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb21wdXRlIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGhzIGZvciBhIHRyZWUgYW5kIHVwZGF0ZSB0aGUgdG90YWwgYml0IGxlbmd0aFxuICogZm9yIHRoZSBjdXJyZW50IGJsb2NrLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGRzIGZyZXEgYW5kIGRhZCBhcmUgc2V0LCBoZWFwW2hlYXBfbWF4XSBhbmRcbiAqICAgIGFib3ZlIGFyZSB0aGUgdHJlZSBub2RlcyBzb3J0ZWQgYnkgaW5jcmVhc2luZyBmcmVxdWVuY3kuXG4gKiBPVVQgYXNzZXJ0aW9uczogdGhlIGZpZWxkIGxlbiBpcyBzZXQgdG8gdGhlIG9wdGltYWwgYml0IGxlbmd0aCwgdGhlXG4gKiAgICAgYXJyYXkgYmxfY291bnQgY29udGFpbnMgdGhlIGZyZXF1ZW5jaWVzIGZvciBlYWNoIGJpdCBsZW5ndGguXG4gKiAgICAgVGhlIGxlbmd0aCBvcHRfbGVuIGlzIHVwZGF0ZWQ7IHN0YXRpY19sZW4gaXMgYWxzbyB1cGRhdGVkIGlmIHN0cmVlIGlzXG4gKiAgICAgbm90IG51bGwuXG4gKi9cbmZ1bmN0aW9uIGdlbl9iaXRsZW4ocywgZGVzYylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB0cmVlX2Rlc2MgKmRlc2M7ICAgIC8qIHRoZSB0cmVlIGRlc2NyaXB0b3IgKi9cbntcbiAgdmFyIHRyZWUgICAgICAgICAgICA9IGRlc2MuZHluX3RyZWU7XG4gIHZhciBtYXhfY29kZSAgICAgICAgPSBkZXNjLm1heF9jb2RlO1xuICB2YXIgc3RyZWUgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7XG4gIHZhciBoYXNfc3RyZWUgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5oYXNfc3RyZWU7XG4gIHZhciBleHRyYSAgICAgICAgICAgPSBkZXNjLnN0YXRfZGVzYy5leHRyYV9iaXRzO1xuICB2YXIgYmFzZSAgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuZXh0cmFfYmFzZTtcbiAgdmFyIG1heF9sZW5ndGggICAgICA9IGRlc2Muc3RhdF9kZXNjLm1heF9sZW5ndGg7XG4gIHZhciBoOyAgICAgICAgICAgICAgLyogaGVhcCBpbmRleCAqL1xuICB2YXIgbiwgbTsgICAgICAgICAgIC8qIGl0ZXJhdGUgb3ZlciB0aGUgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgYml0czsgICAgICAgICAgIC8qIGJpdCBsZW5ndGggKi9cbiAgdmFyIHhiaXRzOyAgICAgICAgICAvKiBleHRyYSBiaXRzICovXG4gIHZhciBmOyAgICAgICAgICAgICAgLyogZnJlcXVlbmN5ICovXG4gIHZhciBvdmVyZmxvdyA9IDA7ICAgLyogbnVtYmVyIG9mIGVsZW1lbnRzIHdpdGggYml0IGxlbmd0aCB0b28gbGFyZ2UgKi9cblxuICBmb3IgKGJpdHMgPSAwOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBzLmJsX2NvdW50W2JpdHNdID0gMDtcbiAgfVxuXG4gIC8qIEluIGEgZmlyc3QgcGFzcywgY29tcHV0ZSB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RocyAod2hpY2ggbWF5XG4gICAqIG92ZXJmbG93IGluIHRoZSBjYXNlIG9mIHRoZSBiaXQgbGVuZ3RoIHRyZWUpLlxuICAgKi9cbiAgdHJlZVtzLmhlYXBbcy5oZWFwX21heF0gKiAyICsgMV0vKi5MZW4qLyA9IDA7IC8qIHJvb3Qgb2YgdGhlIGhlYXAgKi9cblxuICBmb3IgKGggPSBzLmhlYXBfbWF4ICsgMTsgaCA8IEhFQVBfU0laRTsgaCsrKSB7XG4gICAgbiA9IHMuaGVhcFtoXTtcbiAgICBiaXRzID0gdHJlZVt0cmVlW24gKiAyICsgMV0vKi5EYWQqLyAqIDIgKyAxXS8qLkxlbiovICsgMTtcbiAgICBpZiAoYml0cyA+IG1heF9sZW5ndGgpIHtcbiAgICAgIGJpdHMgPSBtYXhfbGVuZ3RoO1xuICAgICAgb3ZlcmZsb3crKztcbiAgICB9XG4gICAgdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSBiaXRzO1xuICAgIC8qIFdlIG92ZXJ3cml0ZSB0cmVlW25dLkRhZCB3aGljaCBpcyBubyBsb25nZXIgbmVlZGVkICovXG5cbiAgICBpZiAobiA+IG1heF9jb2RlKSB7IGNvbnRpbnVlOyB9IC8qIG5vdCBhIGxlYWYgbm9kZSAqL1xuXG4gICAgcy5ibF9jb3VudFtiaXRzXSsrO1xuICAgIHhiaXRzID0gMDtcbiAgICBpZiAobiA+PSBiYXNlKSB7XG4gICAgICB4Yml0cyA9IGV4dHJhW24gLSBiYXNlXTtcbiAgICB9XG4gICAgZiA9IHRyZWVbbiAqIDJdLyouRnJlcSovO1xuICAgIHMub3B0X2xlbiArPSBmICogKGJpdHMgKyB4Yml0cyk7XG4gICAgaWYgKGhhc19zdHJlZSkge1xuICAgICAgcy5zdGF0aWNfbGVuICs9IGYgKiAoc3RyZWVbbiAqIDIgKyAxXS8qLkxlbiovICsgeGJpdHMpO1xuICAgIH1cbiAgfVxuICBpZiAob3ZlcmZsb3cgPT09IDApIHsgcmV0dXJuOyB9XG5cbiAgLy8gVHJhY2UoKHN0ZGVycixcIlxcbmJpdCBsZW5ndGggb3ZlcmZsb3dcXG5cIikpO1xuICAvKiBUaGlzIGhhcHBlbnMgZm9yIGV4YW1wbGUgb24gb2JqMiBhbmQgcGljIG9mIHRoZSBDYWxnYXJ5IGNvcnB1cyAqL1xuXG4gIC8qIEZpbmQgdGhlIGZpcnN0IGJpdCBsZW5ndGggd2hpY2ggY291bGQgaW5jcmVhc2U6ICovXG4gIGRvIHtcbiAgICBiaXRzID0gbWF4X2xlbmd0aCAtIDE7XG4gICAgd2hpbGUgKHMuYmxfY291bnRbYml0c10gPT09IDApIHsgYml0cy0tOyB9XG4gICAgcy5ibF9jb3VudFtiaXRzXS0tOyAgICAgIC8qIG1vdmUgb25lIGxlYWYgZG93biB0aGUgdHJlZSAqL1xuICAgIHMuYmxfY291bnRbYml0cyArIDFdICs9IDI7IC8qIG1vdmUgb25lIG92ZXJmbG93IGl0ZW0gYXMgaXRzIGJyb3RoZXIgKi9cbiAgICBzLmJsX2NvdW50W21heF9sZW5ndGhdLS07XG4gICAgLyogVGhlIGJyb3RoZXIgb2YgdGhlIG92ZXJmbG93IGl0ZW0gYWxzbyBtb3ZlcyBvbmUgc3RlcCB1cCxcbiAgICAgKiBidXQgdGhpcyBkb2VzIG5vdCBhZmZlY3QgYmxfY291bnRbbWF4X2xlbmd0aF1cbiAgICAgKi9cbiAgICBvdmVyZmxvdyAtPSAyO1xuICB9IHdoaWxlIChvdmVyZmxvdyA+IDApO1xuXG4gIC8qIE5vdyByZWNvbXB1dGUgYWxsIGJpdCBsZW5ndGhzLCBzY2FubmluZyBpbiBpbmNyZWFzaW5nIGZyZXF1ZW5jeS5cbiAgICogaCBpcyBzdGlsbCBlcXVhbCB0byBIRUFQX1NJWkUuIChJdCBpcyBzaW1wbGVyIHRvIHJlY29uc3RydWN0IGFsbFxuICAgKiBsZW5ndGhzIGluc3RlYWQgb2YgZml4aW5nIG9ubHkgdGhlIHdyb25nIG9uZXMuIFRoaXMgaWRlYSBpcyB0YWtlblxuICAgKiBmcm9tICdhcicgd3JpdHRlbiBieSBIYXJ1aGlrbyBPa3VtdXJhLilcbiAgICovXG4gIGZvciAoYml0cyA9IG1heF9sZW5ndGg7IGJpdHMgIT09IDA7IGJpdHMtLSkge1xuICAgIG4gPSBzLmJsX2NvdW50W2JpdHNdO1xuICAgIHdoaWxlIChuICE9PSAwKSB7XG4gICAgICBtID0gcy5oZWFwWy0taF07XG4gICAgICBpZiAobSA+IG1heF9jb2RlKSB7IGNvbnRpbnVlOyB9XG4gICAgICBpZiAodHJlZVttICogMiArIDFdLyouTGVuKi8gIT09IGJpdHMpIHtcbiAgICAgICAgLy8gVHJhY2UoKHN0ZGVycixcImNvZGUgJWQgYml0cyAlZC0+JWRcXG5cIiwgbSwgdHJlZVttXS5MZW4sIGJpdHMpKTtcbiAgICAgICAgcy5vcHRfbGVuICs9IChiaXRzIC0gdHJlZVttICogMiArIDFdLyouTGVuKi8pICogdHJlZVttICogMl0vKi5GcmVxKi87XG4gICAgICAgIHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovID0gYml0cztcbiAgICAgIH1cbiAgICAgIG4tLTtcbiAgICB9XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEdlbmVyYXRlIHRoZSBjb2RlcyBmb3IgYSBnaXZlbiB0cmVlIGFuZCBiaXQgY291bnRzICh3aGljaCBuZWVkIG5vdCBiZVxuICogb3B0aW1hbCkuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBhcnJheSBibF9jb3VudCBjb250YWlucyB0aGUgYml0IGxlbmd0aCBzdGF0aXN0aWNzIGZvclxuICogdGhlIGdpdmVuIHRyZWUgYW5kIHRoZSBmaWVsZCBsZW4gaXMgc2V0IGZvciBhbGwgdHJlZSBlbGVtZW50cy5cbiAqIE9VVCBhc3NlcnRpb246IHRoZSBmaWVsZCBjb2RlIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMgb2Ygbm9uXG4gKiAgICAgemVybyBjb2RlIGxlbmd0aC5cbiAqL1xuZnVuY3Rpb24gZ2VuX2NvZGVzKHRyZWUsIG1heF9jb2RlLCBibF9jb3VudClcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAgICAgICAgICAgIC8qIHRoZSB0cmVlIHRvIGRlY29yYXRlICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgICAgICAgICAgICAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbi8vICAgIHVzaGYgKmJsX2NvdW50OyAgICAgICAgICAgIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggKi9cbntcbiAgdmFyIG5leHRfY29kZSA9IG5ldyBBcnJheShNQVhfQklUUyArIDEpOyAvKiBuZXh0IGNvZGUgdmFsdWUgZm9yIGVhY2ggYml0IGxlbmd0aCAqL1xuICB2YXIgY29kZSA9IDA7ICAgICAgICAgICAgICAvKiBydW5uaW5nIGNvZGUgdmFsdWUgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAgICAgICAgLyogYml0IGluZGV4ICovXG4gIHZhciBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGNvZGUgaW5kZXggKi9cblxuICAvKiBUaGUgZGlzdHJpYnV0aW9uIGNvdW50cyBhcmUgZmlyc3QgdXNlZCB0byBnZW5lcmF0ZSB0aGUgY29kZSB2YWx1ZXNcbiAgICogd2l0aG91dCBiaXQgcmV2ZXJzYWwuXG4gICAqL1xuICBmb3IgKGJpdHMgPSAxOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBuZXh0X2NvZGVbYml0c10gPSBjb2RlID0gKGNvZGUgKyBibF9jb3VudFtiaXRzIC0gMV0pIDw8IDE7XG4gIH1cbiAgLyogQ2hlY2sgdGhhdCB0aGUgYml0IGNvdW50cyBpbiBibF9jb3VudCBhcmUgY29uc2lzdGVudC4gVGhlIGxhc3QgY29kZVxuICAgKiBtdXN0IGJlIGFsbCBvbmVzLlxuICAgKi9cbiAgLy9Bc3NlcnQgKGNvZGUgKyBibF9jb3VudFtNQVhfQklUU10tMSA9PSAoMTw8TUFYX0JJVFMpLTEsXG4gIC8vICAgICAgICBcImluY29uc2lzdGVudCBiaXQgY291bnRzXCIpO1xuICAvL1RyYWNldigoc3RkZXJyLFwiXFxuZ2VuX2NvZGVzOiBtYXhfY29kZSAlZCBcIiwgbWF4X2NvZGUpKTtcblxuICBmb3IgKG4gPSAwOyAgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgdmFyIGxlbiA9IHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovO1xuICAgIGlmIChsZW4gPT09IDApIHsgY29udGludWU7IH1cbiAgICAvKiBOb3cgcmV2ZXJzZSB0aGUgYml0cyAqL1xuICAgIHRyZWVbbiAqIDJdLyouQ29kZSovID0gYmlfcmV2ZXJzZShuZXh0X2NvZGVbbGVuXSsrLCBsZW4pO1xuXG4gICAgLy9UcmFjZWN2KHRyZWUgIT0gc3RhdGljX2x0cmVlLCAoc3RkZXJyLFwiXFxubiAlM2QgJWMgbCAlMmQgYyAlNHggKCV4KSBcIixcbiAgICAvLyAgICAgbiwgKGlzZ3JhcGgobikgPyBuIDogJyAnKSwgbGVuLCB0cmVlW25dLkNvZGUsIG5leHRfY29kZVtsZW5dLTEpKTtcbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgdmFyaW91cyAnY29uc3RhbnQnIHRhYmxlcy5cbiAqL1xuZnVuY3Rpb24gdHJfc3RhdGljX2luaXQoKSB7XG4gIHZhciBuOyAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBiaXRzOyAgICAgLyogYml0IGNvdW50ZXIgKi9cbiAgdmFyIGxlbmd0aDsgICAvKiBsZW5ndGggdmFsdWUgKi9cbiAgdmFyIGNvZGU7ICAgICAvKiBjb2RlIHZhbHVlICovXG4gIHZhciBkaXN0OyAgICAgLyogZGlzdGFuY2UgaW5kZXggKi9cbiAgdmFyIGJsX2NvdW50ID0gbmV3IEFycmF5KE1BWF9CSVRTICsgMSk7XG4gIC8qIG51bWJlciBvZiBjb2RlcyBhdCBlYWNoIGJpdCBsZW5ndGggZm9yIGFuIG9wdGltYWwgdHJlZSAqL1xuXG4gIC8vIGRvIGNoZWNrIGluIF90cl9pbml0KClcbiAgLy9pZiAoc3RhdGljX2luaXRfZG9uZSkgcmV0dXJuO1xuXG4gIC8qIEZvciBzb21lIGVtYmVkZGVkIHRhcmdldHMsIGdsb2JhbCB2YXJpYWJsZXMgYXJlIG5vdCBpbml0aWFsaXplZDogKi9cbi8qI2lmZGVmIE5PX0lOSVRfR0xPQkFMX1BPSU5URVJTXG4gIHN0YXRpY19sX2Rlc2Muc3RhdGljX3RyZWUgPSBzdGF0aWNfbHRyZWU7XG4gIHN0YXRpY19sX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2xiaXRzO1xuICBzdGF0aWNfZF9kZXNjLnN0YXRpY190cmVlID0gc3RhdGljX2R0cmVlO1xuICBzdGF0aWNfZF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9kYml0cztcbiAgc3RhdGljX2JsX2Rlc2MuZXh0cmFfYml0cyA9IGV4dHJhX2JsYml0cztcbiNlbmRpZiovXG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgbWFwcGluZyBsZW5ndGggKDAuLjI1NSkgLT4gbGVuZ3RoIGNvZGUgKDAuLjI4KSAqL1xuICBsZW5ndGggPSAwO1xuICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgTEVOR1RIX0NPREVTIC0gMTsgY29kZSsrKSB7XG4gICAgYmFzZV9sZW5ndGhbY29kZV0gPSBsZW5ndGg7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IGV4dHJhX2xiaXRzW2NvZGVdKTsgbisrKSB7XG4gICAgICBfbGVuZ3RoX2NvZGVbbGVuZ3RoKytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGxlbmd0aCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IGxlbmd0aCAhPSAyNTZcIik7XG4gIC8qIE5vdGUgdGhhdCB0aGUgbGVuZ3RoIDI1NSAobWF0Y2ggbGVuZ3RoIDI1OCkgY2FuIGJlIHJlcHJlc2VudGVkXG4gICAqIGluIHR3byBkaWZmZXJlbnQgd2F5czogY29kZSAyODQgKyA1IGJpdHMgb3IgY29kZSAyODUsIHNvIHdlXG4gICAqIG92ZXJ3cml0ZSBsZW5ndGhfY29kZVsyNTVdIHRvIHVzZSB0aGUgYmVzdCBlbmNvZGluZzpcbiAgICovXG4gIF9sZW5ndGhfY29kZVtsZW5ndGggLSAxXSA9IGNvZGU7XG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgbWFwcGluZyBkaXN0ICgwLi4zMkspIC0+IGRpc3QgY29kZSAoMC4uMjkpICovXG4gIGRpc3QgPSAwO1xuICBmb3IgKGNvZGUgPSAwOyBjb2RlIDwgMTY7IGNvZGUrKykge1xuICAgIGJhc2VfZGlzdFtjb2RlXSA9IGRpc3Q7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IGV4dHJhX2RiaXRzW2NvZGVdKTsgbisrKSB7XG4gICAgICBfZGlzdF9jb2RlW2Rpc3QrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZGlzdCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IGRpc3QgIT0gMjU2XCIpO1xuICBkaXN0ID4+PSA3OyAvKiBmcm9tIG5vdyBvbiwgYWxsIGRpc3RhbmNlcyBhcmUgZGl2aWRlZCBieSAxMjggKi9cbiAgZm9yICg7IGNvZGUgPCBEX0NPREVTOyBjb2RlKyspIHtcbiAgICBiYXNlX2Rpc3RbY29kZV0gPSBkaXN0IDw8IDc7XG4gICAgZm9yIChuID0gMDsgbiA8ICgxIDw8IChleHRyYV9kYml0c1tjb2RlXSAtIDcpKTsgbisrKSB7XG4gICAgICBfZGlzdF9jb2RlWzI1NiArIGRpc3QrK10gPSBjb2RlO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZGlzdCA9PSAyNTYsIFwidHJfc3RhdGljX2luaXQ6IDI1NitkaXN0ICE9IDUxMlwiKTtcblxuICAvKiBDb25zdHJ1Y3QgdGhlIGNvZGVzIG9mIHRoZSBzdGF0aWMgbGl0ZXJhbCB0cmVlICovXG4gIGZvciAoYml0cyA9IDA7IGJpdHMgPD0gTUFYX0JJVFM7IGJpdHMrKykge1xuICAgIGJsX2NvdW50W2JpdHNdID0gMDtcbiAgfVxuXG4gIG4gPSAwO1xuICB3aGlsZSAobiA8PSAxNDMpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gODtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOF0rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyNTUpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gOTtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOV0rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyNzkpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gNztcbiAgICBuKys7XG4gICAgYmxfY291bnRbN10rKztcbiAgfVxuICB3aGlsZSAobiA8PSAyODcpIHtcbiAgICBzdGF0aWNfbHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gODtcbiAgICBuKys7XG4gICAgYmxfY291bnRbOF0rKztcbiAgfVxuICAvKiBDb2RlcyAyODYgYW5kIDI4NyBkbyBub3QgZXhpc3QsIGJ1dCB3ZSBtdXN0IGluY2x1ZGUgdGhlbSBpbiB0aGVcbiAgICogdHJlZSBjb25zdHJ1Y3Rpb24gdG8gZ2V0IGEgY2Fub25pY2FsIEh1ZmZtYW4gdHJlZSAobG9uZ2VzdCBjb2RlXG4gICAqIGFsbCBvbmVzKVxuICAgKi9cbiAgZ2VuX2NvZGVzKHN0YXRpY19sdHJlZSwgTF9DT0RFUyArIDEsIGJsX2NvdW50KTtcblxuICAvKiBUaGUgc3RhdGljIGRpc3RhbmNlIHRyZWUgaXMgdHJpdmlhbDogKi9cbiAgZm9yIChuID0gMDsgbiA8IERfQ09ERVM7IG4rKykge1xuICAgIHN0YXRpY19kdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSA1O1xuICAgIHN0YXRpY19kdHJlZVtuICogMl0vKi5Db2RlKi8gPSBiaV9yZXZlcnNlKG4sIDUpO1xuICB9XG5cbiAgLy8gTm93IGRhdGEgcmVhZHkgYW5kIHdlIGNhbiBpbml0IHN0YXRpYyB0cmVlc1xuICBzdGF0aWNfbF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKHN0YXRpY19sdHJlZSwgZXh0cmFfbGJpdHMsIExJVEVSQUxTICsgMSwgTF9DT0RFUywgTUFYX0JJVFMpO1xuICBzdGF0aWNfZF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKHN0YXRpY19kdHJlZSwgZXh0cmFfZGJpdHMsIDAsICAgICAgICAgIERfQ09ERVMsIE1BWF9CSVRTKTtcbiAgc3RhdGljX2JsX2Rlc2MgPSBuZXcgU3RhdGljVHJlZURlc2MobmV3IEFycmF5KDApLCBleHRyYV9ibGJpdHMsIDAsICAgICAgICAgQkxfQ09ERVMsIE1BWF9CTF9CSVRTKTtcblxuICAvL3N0YXRpY19pbml0X2RvbmUgPSB0cnVlO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSBhIG5ldyBibG9jay5cbiAqL1xuZnVuY3Rpb24gaW5pdF9ibG9jayhzKSB7XG4gIHZhciBuOyAvKiBpdGVyYXRlcyBvdmVyIHRyZWUgZWxlbWVudHMgKi9cblxuICAvKiBJbml0aWFsaXplIHRoZSB0cmVlcy4gKi9cbiAgZm9yIChuID0gMDsgbiA8IExfQ09ERVM7ICBuKyspIHsgcy5keW5fbHRyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfVxuICBmb3IgKG4gPSAwOyBuIDwgRF9DT0RFUzsgIG4rKykgeyBzLmR5bl9kdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG4gIGZvciAobiA9IDA7IG4gPCBCTF9DT0RFUzsgbisrKSB7IHMuYmxfdHJlZVtuICogMl0vKi5GcmVxKi8gPSAwOyB9XG5cbiAgcy5keW5fbHRyZWVbRU5EX0JMT0NLICogMl0vKi5GcmVxKi8gPSAxO1xuICBzLm9wdF9sZW4gPSBzLnN0YXRpY19sZW4gPSAwO1xuICBzLmxhc3RfbGl0ID0gcy5tYXRjaGVzID0gMDtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZsdXNoIHRoZSBiaXQgYnVmZmVyIGFuZCBhbGlnbiB0aGUgb3V0cHV0IG9uIGEgYnl0ZSBib3VuZGFyeVxuICovXG5mdW5jdGlvbiBiaV93aW5kdXAocylcbntcbiAgaWYgKHMuYmlfdmFsaWQgPiA4KSB7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgfSBlbHNlIGlmIChzLmJpX3ZhbGlkID4gMCkge1xuICAgIC8vcHV0X2J5dGUocywgKEJ5dGUpcy0+YmlfYnVmKTtcbiAgICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IHMuYmlfYnVmO1xuICB9XG4gIHMuYmlfYnVmID0gMDtcbiAgcy5iaV92YWxpZCA9IDA7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29weSBhIHN0b3JlZCBibG9jaywgc3RvcmluZyBmaXJzdCB0aGUgbGVuZ3RoIGFuZCBpdHNcbiAqIG9uZSdzIGNvbXBsZW1lbnQgaWYgcmVxdWVzdGVkLlxuICovXG5mdW5jdGlvbiBjb3B5X2Jsb2NrKHMsIGJ1ZiwgbGVuLCBoZWFkZXIpXG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgICAgKmJ1ZjsgICAgLyogdGhlIGlucHV0IGRhdGEgKi9cbi8vdW5zaWduZWQgbGVuOyAgICAgLyogaXRzIGxlbmd0aCAqL1xuLy9pbnQgICAgICBoZWFkZXI7ICAvKiB0cnVlIGlmIGJsb2NrIGhlYWRlciBtdXN0IGJlIHdyaXR0ZW4gKi9cbntcbiAgYmlfd2luZHVwKHMpOyAgICAgICAgLyogYWxpZ24gb24gYnl0ZSBib3VuZGFyeSAqL1xuXG4gIGlmIChoZWFkZXIpIHtcbiAgICBwdXRfc2hvcnQocywgbGVuKTtcbiAgICBwdXRfc2hvcnQocywgfmxlbik7XG4gIH1cbi8vICB3aGlsZSAobGVuLS0pIHtcbi8vICAgIHB1dF9ieXRlKHMsICpidWYrKyk7XG4vLyAgfVxuICB1dGlscy5hcnJheVNldChzLnBlbmRpbmdfYnVmLCBzLndpbmRvdywgYnVmLCBsZW4sIHMucGVuZGluZyk7XG4gIHMucGVuZGluZyArPSBsZW47XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcGFyZXMgdG8gc3VidHJlZXMsIHVzaW5nIHRoZSB0cmVlIGRlcHRoIGFzIHRpZSBicmVha2VyIHdoZW5cbiAqIHRoZSBzdWJ0cmVlcyBoYXZlIGVxdWFsIGZyZXF1ZW5jeS4gVGhpcyBtaW5pbWl6ZXMgdGhlIHdvcnN0IGNhc2UgbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBzbWFsbGVyKHRyZWUsIG4sIG0sIGRlcHRoKSB7XG4gIHZhciBfbjIgPSBuICogMjtcbiAgdmFyIF9tMiA9IG0gKiAyO1xuICByZXR1cm4gKHRyZWVbX24yXS8qLkZyZXEqLyA8IHRyZWVbX20yXS8qLkZyZXEqLyB8fFxuICAgICAgICAgKHRyZWVbX24yXS8qLkZyZXEqLyA9PT0gdHJlZVtfbTJdLyouRnJlcSovICYmIGRlcHRoW25dIDw9IGRlcHRoW21dKSk7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUmVzdG9yZSB0aGUgaGVhcCBwcm9wZXJ0eSBieSBtb3ZpbmcgZG93biB0aGUgdHJlZSBzdGFydGluZyBhdCBub2RlIGssXG4gKiBleGNoYW5naW5nIGEgbm9kZSB3aXRoIHRoZSBzbWFsbGVzdCBvZiBpdHMgdHdvIHNvbnMgaWYgbmVjZXNzYXJ5LCBzdG9wcGluZ1xuICogd2hlbiB0aGUgaGVhcCBwcm9wZXJ0eSBpcyByZS1lc3RhYmxpc2hlZCAoZWFjaCBmYXRoZXIgc21hbGxlciB0aGFuIGl0c1xuICogdHdvIHNvbnMpLlxuICovXG5mdW5jdGlvbiBwcWRvd25oZWFwKHMsIHRyZWUsIGspXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgY3RfZGF0YSAqdHJlZTsgIC8qIHRoZSB0cmVlIHRvIHJlc3RvcmUgKi9cbi8vICAgIGludCBrOyAgICAgICAgICAgICAgIC8qIG5vZGUgdG8gbW92ZSBkb3duICovXG57XG4gIHZhciB2ID0gcy5oZWFwW2tdO1xuICB2YXIgaiA9IGsgPDwgMTsgIC8qIGxlZnQgc29uIG9mIGsgKi9cbiAgd2hpbGUgKGogPD0gcy5oZWFwX2xlbikge1xuICAgIC8qIFNldCBqIHRvIHRoZSBzbWFsbGVzdCBvZiB0aGUgdHdvIHNvbnM6ICovXG4gICAgaWYgKGogPCBzLmhlYXBfbGVuICYmXG4gICAgICBzbWFsbGVyKHRyZWUsIHMuaGVhcFtqICsgMV0sIHMuaGVhcFtqXSwgcy5kZXB0aCkpIHtcbiAgICAgIGorKztcbiAgICB9XG4gICAgLyogRXhpdCBpZiB2IGlzIHNtYWxsZXIgdGhhbiBib3RoIHNvbnMgKi9cbiAgICBpZiAoc21hbGxlcih0cmVlLCB2LCBzLmhlYXBbal0sIHMuZGVwdGgpKSB7IGJyZWFrOyB9XG5cbiAgICAvKiBFeGNoYW5nZSB2IHdpdGggdGhlIHNtYWxsZXN0IHNvbiAqL1xuICAgIHMuaGVhcFtrXSA9IHMuaGVhcFtqXTtcbiAgICBrID0gajtcblxuICAgIC8qIEFuZCBjb250aW51ZSBkb3duIHRoZSB0cmVlLCBzZXR0aW5nIGogdG8gdGhlIGxlZnQgc29uIG9mIGsgKi9cbiAgICBqIDw8PSAxO1xuICB9XG4gIHMuaGVhcFtrXSA9IHY7XG59XG5cblxuLy8gaW5saW5lZCBtYW51YWxseVxuLy8gdmFyIFNNQUxMRVNUID0gMTtcblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIHRoZSBibG9jayBkYXRhIGNvbXByZXNzZWQgdXNpbmcgdGhlIGdpdmVuIEh1ZmZtYW4gdHJlZXNcbiAqL1xuZnVuY3Rpb24gY29tcHJlc3NfYmxvY2socywgbHRyZWUsIGR0cmVlKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGNvbnN0IGN0X2RhdGEgKmx0cmVlOyAvKiBsaXRlcmFsIHRyZWUgKi9cbi8vICAgIGNvbnN0IGN0X2RhdGEgKmR0cmVlOyAvKiBkaXN0YW5jZSB0cmVlICovXG57XG4gIHZhciBkaXN0OyAgICAgICAgICAgLyogZGlzdGFuY2Ugb2YgbWF0Y2hlZCBzdHJpbmcgKi9cbiAgdmFyIGxjOyAgICAgICAgICAgICAvKiBtYXRjaCBsZW5ndGggb3IgdW5tYXRjaGVkIGNoYXIgKGlmIGRpc3QgPT0gMCkgKi9cbiAgdmFyIGx4ID0gMDsgICAgICAgICAvKiBydW5uaW5nIGluZGV4IGluIGxfYnVmICovXG4gIHZhciBjb2RlOyAgICAgICAgICAgLyogdGhlIGNvZGUgdG8gc2VuZCAqL1xuICB2YXIgZXh0cmE7ICAgICAgICAgIC8qIG51bWJlciBvZiBleHRyYSBiaXRzIHRvIHNlbmQgKi9cblxuICBpZiAocy5sYXN0X2xpdCAhPT0gMCkge1xuICAgIGRvIHtcbiAgICAgIGRpc3QgPSAocy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgbHggKiAyXSA8PCA4KSB8IChzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBseCAqIDIgKyAxXSk7XG4gICAgICBsYyA9IHMucGVuZGluZ19idWZbcy5sX2J1ZiArIGx4XTtcbiAgICAgIGx4Kys7XG5cbiAgICAgIGlmIChkaXN0ID09PSAwKSB7XG4gICAgICAgIHNlbmRfY29kZShzLCBsYywgbHRyZWUpOyAvKiBzZW5kIGEgbGl0ZXJhbCBieXRlICovXG4gICAgICAgIC8vVHJhY2Vjdihpc2dyYXBoKGxjKSwgKHN0ZGVycixcIiAnJWMnIFwiLCBsYykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogSGVyZSwgbGMgaXMgdGhlIG1hdGNoIGxlbmd0aCAtIE1JTl9NQVRDSCAqL1xuICAgICAgICBjb2RlID0gX2xlbmd0aF9jb2RlW2xjXTtcbiAgICAgICAgc2VuZF9jb2RlKHMsIGNvZGUgKyBMSVRFUkFMUyArIDEsIGx0cmVlKTsgLyogc2VuZCB0aGUgbGVuZ3RoIGNvZGUgKi9cbiAgICAgICAgZXh0cmEgPSBleHRyYV9sYml0c1tjb2RlXTtcbiAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7XG4gICAgICAgICAgbGMgLT0gYmFzZV9sZW5ndGhbY29kZV07XG4gICAgICAgICAgc2VuZF9iaXRzKHMsIGxjLCBleHRyYSk7ICAgICAgIC8qIHNlbmQgdGhlIGV4dHJhIGxlbmd0aCBiaXRzICovXG4gICAgICAgIH1cbiAgICAgICAgZGlzdC0tOyAvKiBkaXN0IGlzIG5vdyB0aGUgbWF0Y2ggZGlzdGFuY2UgLSAxICovXG4gICAgICAgIGNvZGUgPSBkX2NvZGUoZGlzdCk7XG4gICAgICAgIC8vQXNzZXJ0IChjb2RlIDwgRF9DT0RFUywgXCJiYWQgZF9jb2RlXCIpO1xuXG4gICAgICAgIHNlbmRfY29kZShzLCBjb2RlLCBkdHJlZSk7ICAgICAgIC8qIHNlbmQgdGhlIGRpc3RhbmNlIGNvZGUgKi9cbiAgICAgICAgZXh0cmEgPSBleHRyYV9kYml0c1tjb2RlXTtcbiAgICAgICAgaWYgKGV4dHJhICE9PSAwKSB7XG4gICAgICAgICAgZGlzdCAtPSBiYXNlX2Rpc3RbY29kZV07XG4gICAgICAgICAgc2VuZF9iaXRzKHMsIGRpc3QsIGV4dHJhKTsgICAvKiBzZW5kIHRoZSBleHRyYSBkaXN0YW5jZSBiaXRzICovXG4gICAgICAgIH1cbiAgICAgIH0gLyogbGl0ZXJhbCBvciBtYXRjaCBwYWlyID8gKi9cblxuICAgICAgLyogQ2hlY2sgdGhhdCB0aGUgb3ZlcmxheSBiZXR3ZWVuIHBlbmRpbmdfYnVmIGFuZCBkX2J1ZitsX2J1ZiBpcyBvazogKi9cbiAgICAgIC8vQXNzZXJ0KCh1SW50KShzLT5wZW5kaW5nKSA8IHMtPmxpdF9idWZzaXplICsgMipseCxcbiAgICAgIC8vICAgICAgIFwicGVuZGluZ0J1ZiBvdmVyZmxvd1wiKTtcblxuICAgIH0gd2hpbGUgKGx4IDwgcy5sYXN0X2xpdCk7XG4gIH1cblxuICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBsdHJlZSk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdHJ1Y3Qgb25lIEh1ZmZtYW4gdHJlZSBhbmQgYXNzaWducyB0aGUgY29kZSBiaXQgc3RyaW5ncyBhbmQgbGVuZ3Rocy5cbiAqIFVwZGF0ZSB0aGUgdG90YWwgYml0IGxlbmd0aCBmb3IgdGhlIGN1cnJlbnQgYmxvY2suXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZCBmcmVxIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMuXG4gKiBPVVQgYXNzZXJ0aW9uczogdGhlIGZpZWxkcyBsZW4gYW5kIGNvZGUgYXJlIHNldCB0byB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RoXG4gKiAgICAgYW5kIGNvcnJlc3BvbmRpbmcgY29kZS4gVGhlIGxlbmd0aCBvcHRfbGVuIGlzIHVwZGF0ZWQ7IHN0YXRpY19sZW4gaXNcbiAqICAgICBhbHNvIHVwZGF0ZWQgaWYgc3RyZWUgaXMgbm90IG51bGwuIFRoZSBmaWVsZCBtYXhfY29kZSBpcyBzZXQuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkX3RyZWUocywgZGVzYylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICB0cmVlX2Rlc2MgKmRlc2M7IC8qIHRoZSB0cmVlIGRlc2NyaXB0b3IgKi9cbntcbiAgdmFyIHRyZWUgICAgID0gZGVzYy5keW5fdHJlZTtcbiAgdmFyIHN0cmVlICAgID0gZGVzYy5zdGF0X2Rlc2Muc3RhdGljX3RyZWU7XG4gIHZhciBoYXNfc3RyZWUgPSBkZXNjLnN0YXRfZGVzYy5oYXNfc3RyZWU7XG4gIHZhciBlbGVtcyAgICA9IGRlc2Muc3RhdF9kZXNjLmVsZW1zO1xuICB2YXIgbiwgbTsgICAgICAgICAgLyogaXRlcmF0ZSBvdmVyIGhlYXAgZWxlbWVudHMgKi9cbiAgdmFyIG1heF9jb2RlID0gLTE7IC8qIGxhcmdlc3QgY29kZSB3aXRoIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xuICB2YXIgbm9kZTsgICAgICAgICAgLyogbmV3IG5vZGUgYmVpbmcgY3JlYXRlZCAqL1xuXG4gIC8qIENvbnN0cnVjdCB0aGUgaW5pdGlhbCBoZWFwLCB3aXRoIGxlYXN0IGZyZXF1ZW50IGVsZW1lbnQgaW5cbiAgICogaGVhcFtTTUFMTEVTVF0uIFRoZSBzb25zIG9mIGhlYXBbbl0gYXJlIGhlYXBbMipuXSBhbmQgaGVhcFsyKm4rMV0uXG4gICAqIGhlYXBbMF0gaXMgbm90IHVzZWQuXG4gICAqL1xuICBzLmhlYXBfbGVuID0gMDtcbiAgcy5oZWFwX21heCA9IEhFQVBfU0laRTtcblxuICBmb3IgKG4gPSAwOyBuIDwgZWxlbXM7IG4rKykge1xuICAgIGlmICh0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgICAgcy5oZWFwWysrcy5oZWFwX2xlbl0gPSBtYXhfY29kZSA9IG47XG4gICAgICBzLmRlcHRoW25dID0gMDtcblxuICAgIH0gZWxzZSB7XG4gICAgICB0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDA7XG4gICAgfVxuICB9XG5cbiAgLyogVGhlIHBremlwIGZvcm1hdCByZXF1aXJlcyB0aGF0IGF0IGxlYXN0IG9uZSBkaXN0YW5jZSBjb2RlIGV4aXN0cyxcbiAgICogYW5kIHRoYXQgYXQgbGVhc3Qgb25lIGJpdCBzaG91bGQgYmUgc2VudCBldmVuIGlmIHRoZXJlIGlzIG9ubHkgb25lXG4gICAqIHBvc3NpYmxlIGNvZGUuIFNvIHRvIGF2b2lkIHNwZWNpYWwgY2hlY2tzIGxhdGVyIG9uIHdlIGZvcmNlIGF0IGxlYXN0XG4gICAqIHR3byBjb2RlcyBvZiBub24gemVybyBmcmVxdWVuY3kuXG4gICAqL1xuICB3aGlsZSAocy5oZWFwX2xlbiA8IDIpIHtcbiAgICBub2RlID0gcy5oZWFwWysrcy5oZWFwX2xlbl0gPSAobWF4X2NvZGUgPCAyID8gKyttYXhfY29kZSA6IDApO1xuICAgIHRyZWVbbm9kZSAqIDJdLyouRnJlcSovID0gMTtcbiAgICBzLmRlcHRoW25vZGVdID0gMDtcbiAgICBzLm9wdF9sZW4tLTtcblxuICAgIGlmIChoYXNfc3RyZWUpIHtcbiAgICAgIHMuc3RhdGljX2xlbiAtPSBzdHJlZVtub2RlICogMiArIDFdLyouTGVuKi87XG4gICAgfVxuICAgIC8qIG5vZGUgaXMgMCBvciAxIHNvIGl0IGRvZXMgbm90IGhhdmUgZXh0cmEgYml0cyAqL1xuICB9XG4gIGRlc2MubWF4X2NvZGUgPSBtYXhfY29kZTtcblxuICAvKiBUaGUgZWxlbWVudHMgaGVhcFtoZWFwX2xlbi8yKzEgLi4gaGVhcF9sZW5dIGFyZSBsZWF2ZXMgb2YgdGhlIHRyZWUsXG4gICAqIGVzdGFibGlzaCBzdWItaGVhcHMgb2YgaW5jcmVhc2luZyBsZW5ndGhzOlxuICAgKi9cbiAgZm9yIChuID0gKHMuaGVhcF9sZW4gPj4gMS8qaW50IC8yKi8pOyBuID49IDE7IG4tLSkgeyBwcWRvd25oZWFwKHMsIHRyZWUsIG4pOyB9XG5cbiAgLyogQ29uc3RydWN0IHRoZSBIdWZmbWFuIHRyZWUgYnkgcmVwZWF0ZWRseSBjb21iaW5pbmcgdGhlIGxlYXN0IHR3b1xuICAgKiBmcmVxdWVudCBub2Rlcy5cbiAgICovXG4gIG5vZGUgPSBlbGVtczsgICAgICAgICAgICAgIC8qIG5leHQgaW50ZXJuYWwgbm9kZSBvZiB0aGUgdHJlZSAqL1xuICBkbyB7XG4gICAgLy9wcXJlbW92ZShzLCB0cmVlLCBuKTsgIC8qIG4gPSBub2RlIG9mIGxlYXN0IGZyZXF1ZW5jeSAqL1xuICAgIC8qKiogcHFyZW1vdmUgKioqL1xuICAgIG4gPSBzLmhlYXBbMS8qU01BTExFU1QqL107XG4gICAgcy5oZWFwWzEvKlNNQUxMRVNUKi9dID0gcy5oZWFwW3MuaGVhcF9sZW4tLV07XG4gICAgcHFkb3duaGVhcChzLCB0cmVlLCAxLypTTUFMTEVTVCovKTtcbiAgICAvKioqL1xuXG4gICAgbSA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTsgLyogbSA9IG5vZGUgb2YgbmV4dCBsZWFzdCBmcmVxdWVuY3kgKi9cblxuICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbjsgLyoga2VlcCB0aGUgbm9kZXMgc29ydGVkIGJ5IGZyZXF1ZW5jeSAqL1xuICAgIHMuaGVhcFstLXMuaGVhcF9tYXhdID0gbTtcblxuICAgIC8qIENyZWF0ZSBhIG5ldyBub2RlIGZhdGhlciBvZiBuIGFuZCBtICovXG4gICAgdHJlZVtub2RlICogMl0vKi5GcmVxKi8gPSB0cmVlW24gKiAyXS8qLkZyZXEqLyArIHRyZWVbbSAqIDJdLyouRnJlcSovO1xuICAgIHMuZGVwdGhbbm9kZV0gPSAocy5kZXB0aFtuXSA+PSBzLmRlcHRoW21dID8gcy5kZXB0aFtuXSA6IHMuZGVwdGhbbV0pICsgMTtcbiAgICB0cmVlW24gKiAyICsgMV0vKi5EYWQqLyA9IHRyZWVbbSAqIDIgKyAxXS8qLkRhZCovID0gbm9kZTtcblxuICAgIC8qIGFuZCBpbnNlcnQgdGhlIG5ldyBub2RlIGluIHRoZSBoZWFwICovXG4gICAgcy5oZWFwWzEvKlNNQUxMRVNUKi9dID0gbm9kZSsrO1xuICAgIHBxZG93bmhlYXAocywgdHJlZSwgMS8qU01BTExFU1QqLyk7XG5cbiAgfSB3aGlsZSAocy5oZWFwX2xlbiA+PSAyKTtcblxuICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IHMuaGVhcFsxLypTTUFMTEVTVCovXTtcblxuICAvKiBBdCB0aGlzIHBvaW50LCB0aGUgZmllbGRzIGZyZXEgYW5kIGRhZCBhcmUgc2V0LiBXZSBjYW4gbm93XG4gICAqIGdlbmVyYXRlIHRoZSBiaXQgbGVuZ3Rocy5cbiAgICovXG4gIGdlbl9iaXRsZW4ocywgZGVzYyk7XG5cbiAgLyogVGhlIGZpZWxkIGxlbiBpcyBub3cgc2V0LCB3ZSBjYW4gZ2VuZXJhdGUgdGhlIGJpdCBjb2RlcyAqL1xuICBnZW5fY29kZXModHJlZSwgbWF4X2NvZGUsIHMuYmxfY291bnQpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2NhbiBhIGxpdGVyYWwgb3IgZGlzdGFuY2UgdHJlZSB0byBkZXRlcm1pbmUgdGhlIGZyZXF1ZW5jaWVzIG9mIHRoZSBjb2Rlc1xuICogaW4gdGhlIGJpdCBsZW5ndGggdHJlZS5cbiAqL1xuZnVuY3Rpb24gc2Nhbl90cmVlKHMsIHRyZWUsIG1heF9jb2RlKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAgLyogdGhlIHRyZWUgdG8gYmUgc2Nhbm5lZCAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAvKiBhbmQgaXRzIGxhcmdlc3QgY29kZSBvZiBub24gemVybyBmcmVxdWVuY3kgKi9cbntcbiAgdmFyIG47ICAgICAgICAgICAgICAgICAgICAgLyogaXRlcmF0ZXMgb3ZlciBhbGwgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgcHJldmxlbiA9IC0xOyAgICAgICAgICAvKiBsYXN0IGVtaXR0ZWQgbGVuZ3RoICovXG4gIHZhciBjdXJsZW47ICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IGNvZGUgKi9cblxuICB2YXIgbmV4dGxlbiA9IHRyZWVbMCAqIDIgKyAxXS8qLkxlbiovOyAvKiBsZW5ndGggb2YgbmV4dCBjb2RlICovXG5cbiAgdmFyIGNvdW50ID0gMDsgICAgICAgICAgICAgLyogcmVwZWF0IGNvdW50IG9mIHRoZSBjdXJyZW50IGNvZGUgKi9cbiAgdmFyIG1heF9jb3VudCA9IDc7ICAgICAgICAgLyogbWF4IHJlcGVhdCBjb3VudCAqL1xuICB2YXIgbWluX2NvdW50ID0gNDsgICAgICAgICAvKiBtaW4gcmVwZWF0IGNvdW50ICovXG5cbiAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgbWluX2NvdW50ID0gMztcbiAgfVxuICB0cmVlWyhtYXhfY29kZSArIDEpICogMiArIDFdLyouTGVuKi8gPSAweGZmZmY7IC8qIGd1YXJkICovXG5cbiAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgY3VybGVuID0gbmV4dGxlbjtcbiAgICBuZXh0bGVuID0gdHJlZVsobiArIDEpICogMiArIDFdLyouTGVuKi87XG5cbiAgICBpZiAoKytjb3VudCA8IG1heF9jb3VudCAmJiBjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkge1xuICAgICAgcy5ibF90cmVlW2N1cmxlbiAqIDJdLyouRnJlcSovICs9IGNvdW50O1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gIT09IDApIHtcblxuICAgICAgaWYgKGN1cmxlbiAhPT0gcHJldmxlbikgeyBzLmJsX3RyZWVbY3VybGVuICogMl0vKi5GcmVxKi8rKzsgfVxuICAgICAgcy5ibF90cmVlW1JFUF8zXzYgKiAyXS8qLkZyZXEqLysrO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8PSAxMCkge1xuICAgICAgcy5ibF90cmVlW1JFUFpfM18xMCAqIDJdLyouRnJlcSovKys7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgcy5ibF90cmVlW1JFUFpfMTFfMTM4ICogMl0vKi5GcmVxKi8rKztcbiAgICB9XG5cbiAgICBjb3VudCA9IDA7XG4gICAgcHJldmxlbiA9IGN1cmxlbjtcblxuICAgIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIGlmIChjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIG1heF9jb3VudCA9IDY7XG4gICAgICBtaW5fY291bnQgPSAzO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIG1heF9jb3VudCA9IDc7XG4gICAgICBtaW5fY291bnQgPSA0O1xuICAgIH1cbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBhIGxpdGVyYWwgb3IgZGlzdGFuY2UgdHJlZSBpbiBjb21wcmVzc2VkIGZvcm0sIHVzaW5nIHRoZSBjb2RlcyBpblxuICogYmxfdHJlZS5cbiAqL1xuZnVuY3Rpb24gc2VuZF90cmVlKHMsIHRyZWUsIG1heF9jb2RlKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7IC8qIHRoZSB0cmVlIHRvIGJlIHNjYW5uZWQgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgICAgLyogYW5kIGl0cyBsYXJnZXN0IGNvZGUgb2Ygbm9uIHplcm8gZnJlcXVlbmN5ICovXG57XG4gIHZhciBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgYWxsIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIHByZXZsZW4gPSAtMTsgICAgICAgICAgLyogbGFzdCBlbWl0dGVkIGxlbmd0aCAqL1xuICB2YXIgY3VybGVuOyAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBjb2RlICovXG5cbiAgdmFyIG5leHRsZW4gPSB0cmVlWzAgKiAyICsgMV0vKi5MZW4qLzsgLyogbGVuZ3RoIG9mIG5leHQgY29kZSAqL1xuXG4gIHZhciBjb3VudCA9IDA7ICAgICAgICAgICAgIC8qIHJlcGVhdCBjb3VudCBvZiB0aGUgY3VycmVudCBjb2RlICovXG4gIHZhciBtYXhfY291bnQgPSA3OyAgICAgICAgIC8qIG1heCByZXBlYXQgY291bnQgKi9cbiAgdmFyIG1pbl9jb3VudCA9IDQ7ICAgICAgICAgLyogbWluIHJlcGVhdCBjb3VudCAqL1xuXG4gIC8qIHRyZWVbbWF4X2NvZGUrMV0uTGVuID0gLTE7ICovICAvKiBndWFyZCBhbHJlYWR5IHNldCAqL1xuICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgIG1heF9jb3VudCA9IDEzODtcbiAgICBtaW5fY291bnQgPSAzO1xuICB9XG5cbiAgZm9yIChuID0gMDsgbiA8PSBtYXhfY29kZTsgbisrKSB7XG4gICAgY3VybGVuID0gbmV4dGxlbjtcbiAgICBuZXh0bGVuID0gdHJlZVsobiArIDEpICogMiArIDFdLyouTGVuKi87XG5cbiAgICBpZiAoKytjb3VudCA8IG1heF9jb3VudCAmJiBjdXJsZW4gPT09IG5leHRsZW4pIHtcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8IG1pbl9jb3VudCkge1xuICAgICAgZG8geyBzZW5kX2NvZGUocywgY3VybGVuLCBzLmJsX3RyZWUpOyB9IHdoaWxlICgtLWNvdW50ICE9PSAwKTtcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7XG4gICAgICBpZiAoY3VybGVuICE9PSBwcmV2bGVuKSB7XG4gICAgICAgIHNlbmRfY29kZShzLCBjdXJsZW4sIHMuYmxfdHJlZSk7XG4gICAgICAgIGNvdW50LS07XG4gICAgICB9XG4gICAgICAvL0Fzc2VydChjb3VudCA+PSAzICYmIGNvdW50IDw9IDYsIFwiIDNfNj9cIik7XG4gICAgICBzZW5kX2NvZGUocywgUkVQXzNfNiwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDMsIDIpO1xuXG4gICAgfSBlbHNlIGlmIChjb3VudCA8PSAxMCkge1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUFpfM18xMCwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDMsIDMpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBaXzExXzEzOCwgcy5ibF90cmVlKTtcbiAgICAgIHNlbmRfYml0cyhzLCBjb3VudCAtIDExLCA3KTtcbiAgICB9XG5cbiAgICBjb3VudCA9IDA7XG4gICAgcHJldmxlbiA9IGN1cmxlbjtcbiAgICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgICAgbWF4X2NvdW50ID0gMTM4O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBtYXhfY291bnQgPSA2O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSB7XG4gICAgICBtYXhfY291bnQgPSA3O1xuICAgICAgbWluX2NvdW50ID0gNDtcbiAgICB9XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbnN0cnVjdCB0aGUgSHVmZm1hbiB0cmVlIGZvciB0aGUgYml0IGxlbmd0aHMgYW5kIHJldHVybiB0aGUgaW5kZXggaW5cbiAqIGJsX29yZGVyIG9mIHRoZSBsYXN0IGJpdCBsZW5ndGggY29kZSB0byBzZW5kLlxuICovXG5mdW5jdGlvbiBidWlsZF9ibF90cmVlKHMpIHtcbiAgdmFyIG1heF9ibGluZGV4OyAgLyogaW5kZXggb2YgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgb2Ygbm9uIHplcm8gZnJlcSAqL1xuXG4gIC8qIERldGVybWluZSB0aGUgYml0IGxlbmd0aCBmcmVxdWVuY2llcyBmb3IgbGl0ZXJhbCBhbmQgZGlzdGFuY2UgdHJlZXMgKi9cbiAgc2Nhbl90cmVlKHMsIHMuZHluX2x0cmVlLCBzLmxfZGVzYy5tYXhfY29kZSk7XG4gIHNjYW5fdHJlZShzLCBzLmR5bl9kdHJlZSwgcy5kX2Rlc2MubWF4X2NvZGUpO1xuXG4gIC8qIEJ1aWxkIHRoZSBiaXQgbGVuZ3RoIHRyZWU6ICovXG4gIGJ1aWxkX3RyZWUocywgcy5ibF9kZXNjKTtcbiAgLyogb3B0X2xlbiBub3cgaW5jbHVkZXMgdGhlIGxlbmd0aCBvZiB0aGUgdHJlZSByZXByZXNlbnRhdGlvbnMsIGV4Y2VwdFxuICAgKiB0aGUgbGVuZ3RocyBvZiB0aGUgYml0IGxlbmd0aHMgY29kZXMgYW5kIHRoZSA1KzUrNCBiaXRzIGZvciB0aGUgY291bnRzLlxuICAgKi9cblxuICAvKiBEZXRlcm1pbmUgdGhlIG51bWJlciBvZiBiaXQgbGVuZ3RoIGNvZGVzIHRvIHNlbmQuIFRoZSBwa3ppcCBmb3JtYXRcbiAgICogcmVxdWlyZXMgdGhhdCBhdCBsZWFzdCA0IGJpdCBsZW5ndGggY29kZXMgYmUgc2VudC4gKGFwcG5vdGUudHh0IHNheXNcbiAgICogMyBidXQgdGhlIGFjdHVhbCB2YWx1ZSB1c2VkIGlzIDQuKVxuICAgKi9cbiAgZm9yIChtYXhfYmxpbmRleCA9IEJMX0NPREVTIC0gMTsgbWF4X2JsaW5kZXggPj0gMzsgbWF4X2JsaW5kZXgtLSkge1xuICAgIGlmIChzLmJsX3RyZWVbYmxfb3JkZXJbbWF4X2JsaW5kZXhdICogMiArIDFdLyouTGVuKi8gIT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICAvKiBVcGRhdGUgb3B0X2xlbiB0byBpbmNsdWRlIHRoZSBiaXQgbGVuZ3RoIHRyZWUgYW5kIGNvdW50cyAqL1xuICBzLm9wdF9sZW4gKz0gMyAqIChtYXhfYmxpbmRleCArIDEpICsgNSArIDUgKyA0O1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmR5biB0cmVlczogZHluICVsZCwgc3RhdCAlbGRcIixcbiAgLy8gICAgICAgIHMtPm9wdF9sZW4sIHMtPnN0YXRpY19sZW4pKTtcblxuICByZXR1cm4gbWF4X2JsaW5kZXg7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIHRoZSBoZWFkZXIgZm9yIGEgYmxvY2sgdXNpbmcgZHluYW1pYyBIdWZmbWFuIHRyZWVzOiB0aGUgY291bnRzLCB0aGVcbiAqIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGggY29kZXMsIHRoZSBsaXRlcmFsIHRyZWUgYW5kIHRoZSBkaXN0YW5jZSB0cmVlLlxuICogSU4gYXNzZXJ0aW9uOiBsY29kZXMgPj0gMjU3LCBkY29kZXMgPj0gMSwgYmxjb2RlcyA+PSA0LlxuICovXG5mdW5jdGlvbiBzZW5kX2FsbF90cmVlcyhzLCBsY29kZXMsIGRjb2RlcywgYmxjb2Rlcylcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBpbnQgbGNvZGVzLCBkY29kZXMsIGJsY29kZXM7IC8qIG51bWJlciBvZiBjb2RlcyBmb3IgZWFjaCB0cmVlICovXG57XG4gIHZhciByYW5rOyAgICAgICAgICAgICAgICAgICAgLyogaW5kZXggaW4gYmxfb3JkZXIgKi9cblxuICAvL0Fzc2VydCAobGNvZGVzID49IDI1NyAmJiBkY29kZXMgPj0gMSAmJiBibGNvZGVzID49IDQsIFwibm90IGVub3VnaCBjb2Rlc1wiKTtcbiAgLy9Bc3NlcnQgKGxjb2RlcyA8PSBMX0NPREVTICYmIGRjb2RlcyA8PSBEX0NPREVTICYmIGJsY29kZXMgPD0gQkxfQ09ERVMsXG4gIC8vICAgICAgICBcInRvbyBtYW55IGNvZGVzXCIpO1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIGNvdW50czogXCIpKTtcbiAgc2VuZF9iaXRzKHMsIGxjb2RlcyAtIDI1NywgNSk7IC8qIG5vdCArMjU1IGFzIHN0YXRlZCBpbiBhcHBub3RlLnR4dCAqL1xuICBzZW5kX2JpdHMocywgZGNvZGVzIC0gMSwgICA1KTtcbiAgc2VuZF9iaXRzKHMsIGJsY29kZXMgLSA0LCAgNCk7IC8qIG5vdCAtMyBhcyBzdGF0ZWQgaW4gYXBwbm90ZS50eHQgKi9cbiAgZm9yIChyYW5rID0gMDsgcmFuayA8IGJsY29kZXM7IHJhbmsrKykge1xuICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuYmwgY29kZSAlMmQgXCIsIGJsX29yZGVyW3JhbmtdKSk7XG4gICAgc2VuZF9iaXRzKHMsIHMuYmxfdHJlZVtibF9vcmRlcltyYW5rXSAqIDIgKyAxXS8qLkxlbiovLCAzKTtcbiAgfVxuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIHRyZWU6IHNlbnQgJWxkXCIsIHMtPmJpdHNfc2VudCkpO1xuXG4gIHNlbmRfdHJlZShzLCBzLmR5bl9sdHJlZSwgbGNvZGVzIC0gMSk7IC8qIGxpdGVyYWwgdHJlZSAqL1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmxpdCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcblxuICBzZW5kX3RyZWUocywgcy5keW5fZHRyZWUsIGRjb2RlcyAtIDEpOyAvKiBkaXN0YW5jZSB0cmVlICovXG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiXFxuZGlzdCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENoZWNrIGlmIHRoZSBkYXRhIHR5cGUgaXMgVEVYVCBvciBCSU5BUlksIHVzaW5nIHRoZSBmb2xsb3dpbmcgYWxnb3JpdGhtOlxuICogLSBURVhUIGlmIHRoZSB0d28gY29uZGl0aW9ucyBiZWxvdyBhcmUgc2F0aXNmaWVkOlxuICogICAgYSkgVGhlcmUgYXJlIG5vIG5vbi1wb3J0YWJsZSBjb250cm9sIGNoYXJhY3RlcnMgYmVsb25naW5nIHRvIHRoZVxuICogICAgICAgXCJibGFjayBsaXN0XCIgKDAuLjYsIDE0Li4yNSwgMjguLjMxKS5cbiAqICAgIGIpIFRoZXJlIGlzIGF0IGxlYXN0IG9uZSBwcmludGFibGUgY2hhcmFjdGVyIGJlbG9uZ2luZyB0byB0aGVcbiAqICAgICAgIFwid2hpdGUgbGlzdFwiICg5IHtUQUJ9LCAxMCB7TEZ9LCAxMyB7Q1J9LCAzMi4uMjU1KS5cbiAqIC0gQklOQVJZIG90aGVyd2lzZS5cbiAqIC0gVGhlIGZvbGxvd2luZyBwYXJ0aWFsbHktcG9ydGFibGUgY29udHJvbCBjaGFyYWN0ZXJzIGZvcm0gYVxuICogICBcImdyYXkgbGlzdFwiIHRoYXQgaXMgaWdub3JlZCBpbiB0aGlzIGRldGVjdGlvbiBhbGdvcml0aG06XG4gKiAgICg3IHtCRUx9LCA4IHtCU30sIDExIHtWVH0sIDEyIHtGRn0sIDI2IHtTVUJ9LCAyNyB7RVNDfSkuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBmaWVsZHMgRnJlcSBvZiBkeW5fbHRyZWUgYXJlIHNldC5cbiAqL1xuZnVuY3Rpb24gZGV0ZWN0X2RhdGFfdHlwZShzKSB7XG4gIC8qIGJsYWNrX21hc2sgaXMgdGhlIGJpdCBtYXNrIG9mIGJsYWNrLWxpc3RlZCBieXRlc1xuICAgKiBzZXQgYml0cyAwLi42LCAxNC4uMjUsIGFuZCAyOC4uMzFcbiAgICogMHhmM2ZmYzA3ZiA9IGJpbmFyeSAxMTExMDAxMTExMTExMTExMTEwMDAwMDAwMTExMTExMVxuICAgKi9cbiAgdmFyIGJsYWNrX21hc2sgPSAweGYzZmZjMDdmO1xuICB2YXIgbjtcblxuICAvKiBDaGVjayBmb3Igbm9uLXRleHR1YWwgKFwiYmxhY2stbGlzdGVkXCIpIGJ5dGVzLiAqL1xuICBmb3IgKG4gPSAwOyBuIDw9IDMxOyBuKyssIGJsYWNrX21hc2sgPj4+PSAxKSB7XG4gICAgaWYgKChibGFja19tYXNrICYgMSkgJiYgKHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkpIHtcbiAgICAgIHJldHVybiBaX0JJTkFSWTtcbiAgICB9XG4gIH1cblxuICAvKiBDaGVjayBmb3IgdGV4dHVhbCAoXCJ3aGl0ZS1saXN0ZWRcIikgYnl0ZXMuICovXG4gIGlmIChzLmR5bl9sdHJlZVs5ICogMl0vKi5GcmVxKi8gIT09IDAgfHwgcy5keW5fbHRyZWVbMTAgKiAyXS8qLkZyZXEqLyAhPT0gMCB8fFxuICAgICAgcy5keW5fbHRyZWVbMTMgKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgIHJldHVybiBaX1RFWFQ7XG4gIH1cbiAgZm9yIChuID0gMzI7IG4gPCBMSVRFUkFMUzsgbisrKSB7XG4gICAgaWYgKHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyAhPT0gMCkge1xuICAgICAgcmV0dXJuIFpfVEVYVDtcbiAgICB9XG4gIH1cblxuICAvKiBUaGVyZSBhcmUgbm8gXCJibGFjay1saXN0ZWRcIiBvciBcIndoaXRlLWxpc3RlZFwiIGJ5dGVzOlxuICAgKiB0aGlzIHN0cmVhbSBlaXRoZXIgaXMgZW1wdHkgb3IgaGFzIHRvbGVyYXRlZCAoXCJncmF5LWxpc3RlZFwiKSBieXRlcyBvbmx5LlxuICAgKi9cbiAgcmV0dXJuIFpfQklOQVJZO1xufVxuXG5cbnZhciBzdGF0aWNfaW5pdF9kb25lID0gZmFsc2U7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgdHJlZSBkYXRhIHN0cnVjdHVyZXMgZm9yIGEgbmV3IHpsaWIgc3RyZWFtLlxuICovXG5mdW5jdGlvbiBfdHJfaW5pdChzKVxue1xuXG4gIGlmICghc3RhdGljX2luaXRfZG9uZSkge1xuICAgIHRyX3N0YXRpY19pbml0KCk7XG4gICAgc3RhdGljX2luaXRfZG9uZSA9IHRydWU7XG4gIH1cblxuICBzLmxfZGVzYyAgPSBuZXcgVHJlZURlc2Mocy5keW5fbHRyZWUsIHN0YXRpY19sX2Rlc2MpO1xuICBzLmRfZGVzYyAgPSBuZXcgVHJlZURlc2Mocy5keW5fZHRyZWUsIHN0YXRpY19kX2Rlc2MpO1xuICBzLmJsX2Rlc2MgPSBuZXcgVHJlZURlc2Mocy5ibF90cmVlLCBzdGF0aWNfYmxfZGVzYyk7XG5cbiAgcy5iaV9idWYgPSAwO1xuICBzLmJpX3ZhbGlkID0gMDtcblxuICAvKiBJbml0aWFsaXplIHRoZSBmaXJzdCBibG9jayBvZiB0aGUgZmlyc3QgZmlsZTogKi9cbiAgaW5pdF9ibG9jayhzKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSBzdG9yZWQgYmxvY2tcbiAqL1xuZnVuY3Rpb24gX3RyX3N0b3JlZF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpXG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgKmJ1ZjsgICAgICAgLyogaW5wdXQgYmxvY2sgKi9cbi8vdWxnIHN0b3JlZF9sZW47ICAgLyogbGVuZ3RoIG9mIGlucHV0IGJsb2NrICovXG4vL2ludCBsYXN0OyAgICAgICAgIC8qIG9uZSBpZiB0aGlzIGlzIHRoZSBsYXN0IGJsb2NrIGZvciBhIGZpbGUgKi9cbntcbiAgc2VuZF9iaXRzKHMsIChTVE9SRURfQkxPQ0sgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7ICAgIC8qIHNlbmQgYmxvY2sgdHlwZSAqL1xuICBjb3B5X2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgdHJ1ZSk7IC8qIHdpdGggaGVhZGVyICovXG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIG9uZSBlbXB0eSBzdGF0aWMgYmxvY2sgdG8gZ2l2ZSBlbm91Z2ggbG9va2FoZWFkIGZvciBpbmZsYXRlLlxuICogVGhpcyB0YWtlcyAxMCBiaXRzLCBvZiB3aGljaCA3IG1heSByZW1haW4gaW4gdGhlIGJpdCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIF90cl9hbGlnbihzKSB7XG4gIHNlbmRfYml0cyhzLCBTVEFUSUNfVFJFRVMgPDwgMSwgMyk7XG4gIHNlbmRfY29kZShzLCBFTkRfQkxPQ0ssIHN0YXRpY19sdHJlZSk7XG4gIGJpX2ZsdXNoKHMpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRGV0ZXJtaW5lIHRoZSBiZXN0IGVuY29kaW5nIGZvciB0aGUgY3VycmVudCBibG9jazogZHluYW1pYyB0cmVlcywgc3RhdGljXG4gKiB0cmVlcyBvciBzdG9yZSwgYW5kIG91dHB1dCB0aGUgZW5jb2RlZCBibG9jayB0byB0aGUgemlwIGZpbGUuXG4gKi9cbmZ1bmN0aW9uIF90cl9mbHVzaF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpXG4vL0RlZmxhdGVTdGF0ZSAqcztcbi8vY2hhcmYgKmJ1ZjsgICAgICAgLyogaW5wdXQgYmxvY2ssIG9yIE5VTEwgaWYgdG9vIG9sZCAqL1xuLy91bGcgc3RvcmVkX2xlbjsgICAvKiBsZW5ndGggb2YgaW5wdXQgYmxvY2sgKi9cbi8vaW50IGxhc3Q7ICAgICAgICAgLyogb25lIGlmIHRoaXMgaXMgdGhlIGxhc3QgYmxvY2sgZm9yIGEgZmlsZSAqL1xue1xuICB2YXIgb3B0X2xlbmIsIHN0YXRpY19sZW5iOyAgLyogb3B0X2xlbiBhbmQgc3RhdGljX2xlbiBpbiBieXRlcyAqL1xuICB2YXIgbWF4X2JsaW5kZXggPSAwOyAgICAgICAgLyogaW5kZXggb2YgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgb2Ygbm9uIHplcm8gZnJlcSAqL1xuXG4gIC8qIEJ1aWxkIHRoZSBIdWZmbWFuIHRyZWVzIHVubGVzcyBhIHN0b3JlZCBibG9jayBpcyBmb3JjZWQgKi9cbiAgaWYgKHMubGV2ZWwgPiAwKSB7XG5cbiAgICAvKiBDaGVjayBpZiB0aGUgZmlsZSBpcyBiaW5hcnkgb3IgdGV4dCAqL1xuICAgIGlmIChzLnN0cm0uZGF0YV90eXBlID09PSBaX1VOS05PV04pIHtcbiAgICAgIHMuc3RybS5kYXRhX3R5cGUgPSBkZXRlY3RfZGF0YV90eXBlKHMpO1xuICAgIH1cblxuICAgIC8qIENvbnN0cnVjdCB0aGUgbGl0ZXJhbCBhbmQgZGlzdGFuY2UgdHJlZXMgKi9cbiAgICBidWlsZF90cmVlKHMsIHMubF9kZXNjKTtcbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5saXQgZGF0YTogZHluICVsZCwgc3RhdCAlbGRcIiwgcy0+b3B0X2xlbixcbiAgICAvLyAgICAgICAgcy0+c3RhdGljX2xlbikpO1xuXG4gICAgYnVpbGRfdHJlZShzLCBzLmRfZGVzYyk7XG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxuZGlzdCBkYXRhOiBkeW4gJWxkLCBzdGF0ICVsZFwiLCBzLT5vcHRfbGVuLFxuICAgIC8vICAgICAgICBzLT5zdGF0aWNfbGVuKSk7XG4gICAgLyogQXQgdGhpcyBwb2ludCwgb3B0X2xlbiBhbmQgc3RhdGljX2xlbiBhcmUgdGhlIHRvdGFsIGJpdCBsZW5ndGhzIG9mXG4gICAgICogdGhlIGNvbXByZXNzZWQgYmxvY2sgZGF0YSwgZXhjbHVkaW5nIHRoZSB0cmVlIHJlcHJlc2VudGF0aW9ucy5cbiAgICAgKi9cblxuICAgIC8qIEJ1aWxkIHRoZSBiaXQgbGVuZ3RoIHRyZWUgZm9yIHRoZSBhYm92ZSB0d28gdHJlZXMsIGFuZCBnZXQgdGhlIGluZGV4XG4gICAgICogaW4gYmxfb3JkZXIgb2YgdGhlIGxhc3QgYml0IGxlbmd0aCBjb2RlIHRvIHNlbmQuXG4gICAgICovXG4gICAgbWF4X2JsaW5kZXggPSBidWlsZF9ibF90cmVlKHMpO1xuXG4gICAgLyogRGV0ZXJtaW5lIHRoZSBiZXN0IGVuY29kaW5nLiBDb21wdXRlIHRoZSBibG9jayBsZW5ndGhzIGluIGJ5dGVzLiAqL1xuICAgIG9wdF9sZW5iID0gKHMub3B0X2xlbiArIDMgKyA3KSA+Pj4gMztcbiAgICBzdGF0aWNfbGVuYiA9IChzLnN0YXRpY19sZW4gKyAzICsgNykgPj4+IDM7XG5cbiAgICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJcXG5vcHQgJWx1KCVsdSkgc3RhdCAlbHUoJWx1KSBzdG9yZWQgJWx1IGxpdCAldSBcIixcbiAgICAvLyAgICAgICAgb3B0X2xlbmIsIHMtPm9wdF9sZW4sIHN0YXRpY19sZW5iLCBzLT5zdGF0aWNfbGVuLCBzdG9yZWRfbGVuLFxuICAgIC8vICAgICAgICBzLT5sYXN0X2xpdCkpO1xuXG4gICAgaWYgKHN0YXRpY19sZW5iIDw9IG9wdF9sZW5iKSB7IG9wdF9sZW5iID0gc3RhdGljX2xlbmI7IH1cblxuICB9IGVsc2Uge1xuICAgIC8vIEFzc2VydChidWYgIT0gKGNoYXIqKTAsIFwibG9zdCBidWZcIik7XG4gICAgb3B0X2xlbmIgPSBzdGF0aWNfbGVuYiA9IHN0b3JlZF9sZW4gKyA1OyAvKiBmb3JjZSBhIHN0b3JlZCBibG9jayAqL1xuICB9XG5cbiAgaWYgKChzdG9yZWRfbGVuICsgNCA8PSBvcHRfbGVuYikgJiYgKGJ1ZiAhPT0gLTEpKSB7XG4gICAgLyogNDogdHdvIHdvcmRzIGZvciB0aGUgbGVuZ3RocyAqL1xuXG4gICAgLyogVGhlIHRlc3QgYnVmICE9IE5VTEwgaXMgb25seSBuZWNlc3NhcnkgaWYgTElUX0JVRlNJWkUgPiBXU0laRS5cbiAgICAgKiBPdGhlcndpc2Ugd2UgY2FuJ3QgaGF2ZSBwcm9jZXNzZWQgbW9yZSB0aGFuIFdTSVpFIGlucHV0IGJ5dGVzIHNpbmNlXG4gICAgICogdGhlIGxhc3QgYmxvY2sgZmx1c2gsIGJlY2F1c2UgY29tcHJlc3Npb24gd291bGQgaGF2ZSBiZWVuXG4gICAgICogc3VjY2Vzc2Z1bC4gSWYgTElUX0JVRlNJWkUgPD0gV1NJWkUsIGl0IGlzIG5ldmVyIHRvbyBsYXRlIHRvXG4gICAgICogdHJhbnNmb3JtIGEgYmxvY2sgaW50byBhIHN0b3JlZCBibG9jay5cbiAgICAgKi9cbiAgICBfdHJfc3RvcmVkX2Jsb2NrKHMsIGJ1Ziwgc3RvcmVkX2xlbiwgbGFzdCk7XG5cbiAgfSBlbHNlIGlmIChzLnN0cmF0ZWd5ID09PSBaX0ZJWEVEIHx8IHN0YXRpY19sZW5iID09PSBvcHRfbGVuYikge1xuXG4gICAgc2VuZF9iaXRzKHMsIChTVEFUSUNfVFJFRVMgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7XG4gICAgY29tcHJlc3NfYmxvY2socywgc3RhdGljX2x0cmVlLCBzdGF0aWNfZHRyZWUpO1xuXG4gIH0gZWxzZSB7XG4gICAgc2VuZF9iaXRzKHMsIChEWU5fVFJFRVMgPDwgMSkgKyAobGFzdCA/IDEgOiAwKSwgMyk7XG4gICAgc2VuZF9hbGxfdHJlZXMocywgcy5sX2Rlc2MubWF4X2NvZGUgKyAxLCBzLmRfZGVzYy5tYXhfY29kZSArIDEsIG1heF9ibGluZGV4ICsgMSk7XG4gICAgY29tcHJlc3NfYmxvY2socywgcy5keW5fbHRyZWUsIHMuZHluX2R0cmVlKTtcbiAgfVxuICAvLyBBc3NlcnQgKHMtPmNvbXByZXNzZWRfbGVuID09IHMtPmJpdHNfc2VudCwgXCJiYWQgY29tcHJlc3NlZCBzaXplXCIpO1xuICAvKiBUaGUgYWJvdmUgY2hlY2sgaXMgbWFkZSBtb2QgMl4zMiwgZm9yIGZpbGVzIGxhcmdlciB0aGFuIDUxMiBNQlxuICAgKiBhbmQgdUxvbmcgaW1wbGVtZW50ZWQgb24gMzIgYml0cy5cbiAgICovXG4gIGluaXRfYmxvY2socyk7XG5cbiAgaWYgKGxhc3QpIHtcbiAgICBiaV93aW5kdXAocyk7XG4gIH1cbiAgLy8gVHJhY2V2KChzdGRlcnIsXCJcXG5jb21wcmxlbiAlbHUoJWx1KSBcIiwgcy0+Y29tcHJlc3NlZF9sZW4+PjMsXG4gIC8vICAgICAgIHMtPmNvbXByZXNzZWRfbGVuLTcqbGFzdCkpO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNhdmUgdGhlIG1hdGNoIGluZm8gYW5kIHRhbGx5IHRoZSBmcmVxdWVuY3kgY291bnRzLiBSZXR1cm4gdHJ1ZSBpZlxuICogdGhlIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBfdHJfdGFsbHkocywgZGlzdCwgbGMpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdW5zaWduZWQgZGlzdDsgIC8qIGRpc3RhbmNlIG9mIG1hdGNoZWQgc3RyaW5nICovXG4vLyAgICB1bnNpZ25lZCBsYzsgICAgLyogbWF0Y2ggbGVuZ3RoLU1JTl9NQVRDSCBvciB1bm1hdGNoZWQgY2hhciAoaWYgZGlzdD09MCkgKi9cbntcbiAgLy92YXIgb3V0X2xlbmd0aCwgaW5fbGVuZ3RoLCBkY29kZTtcblxuICBzLnBlbmRpbmdfYnVmW3MuZF9idWYgKyBzLmxhc3RfbGl0ICogMl0gICAgID0gKGRpc3QgPj4+IDgpICYgMHhmZjtcbiAgcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgcy5sYXN0X2xpdCAqIDIgKyAxXSA9IGRpc3QgJiAweGZmO1xuXG4gIHMucGVuZGluZ19idWZbcy5sX2J1ZiArIHMubGFzdF9saXRdID0gbGMgJiAweGZmO1xuICBzLmxhc3RfbGl0Kys7XG5cbiAgaWYgKGRpc3QgPT09IDApIHtcbiAgICAvKiBsYyBpcyB0aGUgdW5tYXRjaGVkIGNoYXIgKi9cbiAgICBzLmR5bl9sdHJlZVtsYyAqIDJdLyouRnJlcSovKys7XG4gIH0gZWxzZSB7XG4gICAgcy5tYXRjaGVzKys7XG4gICAgLyogSGVyZSwgbGMgaXMgdGhlIG1hdGNoIGxlbmd0aCAtIE1JTl9NQVRDSCAqL1xuICAgIGRpc3QtLTsgICAgICAgICAgICAgLyogZGlzdCA9IG1hdGNoIGRpc3RhbmNlIC0gMSAqL1xuICAgIC8vQXNzZXJ0KCh1c2gpZGlzdCA8ICh1c2gpTUFYX0RJU1QocykgJiZcbiAgICAvLyAgICAgICAodXNoKWxjIDw9ICh1c2gpKE1BWF9NQVRDSC1NSU5fTUFUQ0gpICYmXG4gICAgLy8gICAgICAgKHVzaClkX2NvZGUoZGlzdCkgPCAodXNoKURfQ09ERVMsICBcIl90cl90YWxseTogYmFkIG1hdGNoXCIpO1xuXG4gICAgcy5keW5fbHRyZWVbKF9sZW5ndGhfY29kZVtsY10gKyBMSVRFUkFMUyArIDEpICogMl0vKi5GcmVxKi8rKztcbiAgICBzLmR5bl9kdHJlZVtkX2NvZGUoZGlzdCkgKiAyXS8qLkZyZXEqLysrO1xuICB9XG5cbi8vICghKSBUaGlzIGJsb2NrIGlzIGRpc2FibGVkIGluIHpsaWIgZGVmYXVsdHMsXG4vLyBkb24ndCBlbmFibGUgaXQgZm9yIGJpbmFyeSBjb21wYXRpYmlsaXR5XG5cbi8vI2lmZGVmIFRSVU5DQVRFX0JMT0NLXG4vLyAgLyogVHJ5IHRvIGd1ZXNzIGlmIGl0IGlzIHByb2ZpdGFibGUgdG8gc3RvcCB0aGUgY3VycmVudCBibG9jayBoZXJlICovXG4vLyAgaWYgKChzLmxhc3RfbGl0ICYgMHgxZmZmKSA9PT0gMCAmJiBzLmxldmVsID4gMikge1xuLy8gICAgLyogQ29tcHV0ZSBhbiB1cHBlciBib3VuZCBmb3IgdGhlIGNvbXByZXNzZWQgbGVuZ3RoICovXG4vLyAgICBvdXRfbGVuZ3RoID0gcy5sYXN0X2xpdCo4O1xuLy8gICAgaW5fbGVuZ3RoID0gcy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQ7XG4vL1xuLy8gICAgZm9yIChkY29kZSA9IDA7IGRjb2RlIDwgRF9DT0RFUzsgZGNvZGUrKykge1xuLy8gICAgICBvdXRfbGVuZ3RoICs9IHMuZHluX2R0cmVlW2Rjb2RlKjJdLyouRnJlcSovICogKDUgKyBleHRyYV9kYml0c1tkY29kZV0pO1xuLy8gICAgfVxuLy8gICAgb3V0X2xlbmd0aCA+Pj49IDM7XG4vLyAgICAvL1RyYWNldigoc3RkZXJyLFwiXFxubGFzdF9saXQgJXUsIGluICVsZCwgb3V0IH4lbGQoJWxkJSUpIFwiLFxuLy8gICAgLy8gICAgICAgcy0+bGFzdF9saXQsIGluX2xlbmd0aCwgb3V0X2xlbmd0aCxcbi8vICAgIC8vICAgICAgIDEwMEwgLSBvdXRfbGVuZ3RoKjEwMEwvaW5fbGVuZ3RoKSk7XG4vLyAgICBpZiAocy5tYXRjaGVzIDwgKHMubGFzdF9saXQ+PjEpLyppbnQgLzIqLyAmJiBvdXRfbGVuZ3RoIDwgKGluX2xlbmd0aD4+MSkvKmludCAvMiovKSB7XG4vLyAgICAgIHJldHVybiB0cnVlO1xuLy8gICAgfVxuLy8gIH1cbi8vI2VuZGlmXG5cbiAgcmV0dXJuIChzLmxhc3RfbGl0ID09PSBzLmxpdF9idWZzaXplIC0gMSk7XG4gIC8qIFdlIGF2b2lkIGVxdWFsaXR5IHdpdGggbGl0X2J1ZnNpemUgYmVjYXVzZSBvZiB3cmFwYXJvdW5kIGF0IDY0S1xuICAgKiBvbiAxNiBiaXQgbWFjaGluZXMgYW5kIGJlY2F1c2Ugc3RvcmVkIGJsb2NrcyBhcmUgcmVzdHJpY3RlZCB0b1xuICAgKiA2NEstMSBieXRlcy5cbiAgICovXG59XG5cbmV4cG9ydHMuX3RyX2luaXQgID0gX3RyX2luaXQ7XG5leHBvcnRzLl90cl9zdG9yZWRfYmxvY2sgPSBfdHJfc3RvcmVkX2Jsb2NrO1xuZXhwb3J0cy5fdHJfZmx1c2hfYmxvY2sgID0gX3RyX2ZsdXNoX2Jsb2NrO1xuZXhwb3J0cy5fdHJfdGFsbHkgPSBfdHJfdGFsbHk7XG5leHBvcnRzLl90cl9hbGlnbiA9IF90cl9hbGlnbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gKEMpIDE5OTUtMjAxMyBKZWFuLWxvdXAgR2FpbGx5IGFuZCBNYXJrIEFkbGVyXG4vLyAoQykgMjAxNC0yMDE3IFZpdGFseSBQdXpyaW4gYW5kIEFuZHJleSBUdXBpdHNpblxuLy9cbi8vIFRoaXMgc29mdHdhcmUgaXMgcHJvdmlkZWQgJ2FzLWlzJywgd2l0aG91dCBhbnkgZXhwcmVzcyBvciBpbXBsaWVkXG4vLyB3YXJyYW50eS4gSW4gbm8gZXZlbnQgd2lsbCB0aGUgYXV0aG9ycyBiZSBoZWxkIGxpYWJsZSBmb3IgYW55IGRhbWFnZXNcbi8vIGFyaXNpbmcgZnJvbSB0aGUgdXNlIG9mIHRoaXMgc29mdHdhcmUuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBncmFudGVkIHRvIGFueW9uZSB0byB1c2UgdGhpcyBzb2Z0d2FyZSBmb3IgYW55IHB1cnBvc2UsXG4vLyBpbmNsdWRpbmcgY29tbWVyY2lhbCBhcHBsaWNhdGlvbnMsIGFuZCB0byBhbHRlciBpdCBhbmQgcmVkaXN0cmlidXRlIGl0XG4vLyBmcmVlbHksIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyByZXN0cmljdGlvbnM6XG4vL1xuLy8gMS4gVGhlIG9yaWdpbiBvZiB0aGlzIHNvZnR3YXJlIG11c3Qgbm90IGJlIG1pc3JlcHJlc2VudGVkOyB5b3UgbXVzdCBub3Rcbi8vICAgY2xhaW0gdGhhdCB5b3Ugd3JvdGUgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLiBJZiB5b3UgdXNlIHRoaXMgc29mdHdhcmVcbi8vICAgaW4gYSBwcm9kdWN0LCBhbiBhY2tub3dsZWRnbWVudCBpbiB0aGUgcHJvZHVjdCBkb2N1bWVudGF0aW9uIHdvdWxkIGJlXG4vLyAgIGFwcHJlY2lhdGVkIGJ1dCBpcyBub3QgcmVxdWlyZWQuXG4vLyAyLiBBbHRlcmVkIHNvdXJjZSB2ZXJzaW9ucyBtdXN0IGJlIHBsYWlubHkgbWFya2VkIGFzIHN1Y2gsIGFuZCBtdXN0IG5vdCBiZVxuLy8gICBtaXNyZXByZXNlbnRlZCBhcyBiZWluZyB0aGUgb3JpZ2luYWwgc29mdHdhcmUuXG4vLyAzLiBUaGlzIG5vdGljZSBtYXkgbm90IGJlIHJlbW92ZWQgb3IgYWx0ZXJlZCBmcm9tIGFueSBzb3VyY2UgZGlzdHJpYnV0aW9uLlxuXG5mdW5jdGlvbiBaU3RyZWFtKCkge1xuICAvKiBuZXh0IGlucHV0IGJ5dGUgKi9cbiAgdGhpcy5pbnB1dCA9IG51bGw7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcbiAgdGhpcy5uZXh0X2luID0gMDtcbiAgLyogbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSBhdCBpbnB1dCAqL1xuICB0aGlzLmF2YWlsX2luID0gMDtcbiAgLyogdG90YWwgbnVtYmVyIG9mIGlucHV0IGJ5dGVzIHJlYWQgc28gZmFyICovXG4gIHRoaXMudG90YWxfaW4gPSAwO1xuICAvKiBuZXh0IG91dHB1dCBieXRlIHNob3VsZCBiZSBwdXQgdGhlcmUgKi9cbiAgdGhpcy5vdXRwdXQgPSBudWxsOyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG4gIHRoaXMubmV4dF9vdXQgPSAwO1xuICAvKiByZW1haW5pbmcgZnJlZSBzcGFjZSBhdCBvdXRwdXQgKi9cbiAgdGhpcy5hdmFpbF9vdXQgPSAwO1xuICAvKiB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgb3V0cHV0IHNvIGZhciAqL1xuICB0aGlzLnRvdGFsX291dCA9IDA7XG4gIC8qIGxhc3QgZXJyb3IgbWVzc2FnZSwgTlVMTCBpZiBubyBlcnJvciAqL1xuICB0aGlzLm1zZyA9ICcnLypaX05VTEwqLztcbiAgLyogbm90IHZpc2libGUgYnkgYXBwbGljYXRpb25zICovXG4gIHRoaXMuc3RhdGUgPSBudWxsO1xuICAvKiBiZXN0IGd1ZXNzIGFib3V0IHRoZSBkYXRhIHR5cGU6IGJpbmFyeSBvciB0ZXh0ICovXG4gIHRoaXMuZGF0YV90eXBlID0gMi8qWl9VTktOT1dOKi87XG4gIC8qIGFkbGVyMzIgdmFsdWUgb2YgdGhlIHVuY29tcHJlc3NlZCBkYXRhICovXG4gIHRoaXMuYWRsZXIgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFpTdHJlYW07XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAhcHJvY2Vzcy52ZXJzaW9uIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YwLicpID09PSAwIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLicpID09PSAwICYmIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS44LicpICE9PSAwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0geyBuZXh0VGljazogbmV4dFRpY2sgfTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcHJvY2Vzc1xufVxuXG5mdW5jdGlvbiBuZXh0VGljayhmbiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJjYWxsYmFja1wiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG4gIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgYXJncywgaTtcbiAgc3dpdGNoIChsZW4pIHtcbiAgY2FzZSAwOlxuICBjYXNlIDE6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZm4pO1xuICBjYXNlIDI6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrT25lKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxKTtcbiAgICB9KTtcbiAgY2FzZSAzOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1R3bygpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMik7XG4gICAgfSk7XG4gIGNhc2UgNDpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUaHJlZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgfSk7XG4gIGRlZmF1bHQ6XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICBhcmdzW2krK10gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGljaygpIHtcbiAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0pO1xuICB9XG59XG5cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfXJldHVybiBrZXlzO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuXG57XG4gIC8vIGF2b2lkIHNjb3BlIGNyZWVwLCB0aGUga2V5cyBhcnJheSBjYW4gdGhlbiBiZSBjb2xsZWN0ZWRcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG4gIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xuICAgIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG5cbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsXG4gIC8vIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuO1xuXG4gIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG4gIHBuYS5uZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gIHNlbGYuZW5kKCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbkR1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLnB1c2gobnVsbCk7XG4gIHRoaXMuZW5kKCk7XG5cbiAgcG5hLm5leHRUaWNrKGNiLCBlcnIpO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgZGVidWdVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGRlYnVnID0gdm9pZCAwO1xuaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0Jyk7XG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xudmFyIFN0cmluZ0RlY29kZXI7XG5cbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XG5cbnZhciBrUHJveHlFdmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG5cbmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHtcbiAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd25cbiAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uXG4gIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pO1xuXG4gIC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcbiAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXG4gIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKGlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG4gIHZhciBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIHJlYWRhYmxlSHdtID0gb3B0aW9ucy5yZWFkYWJsZUhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG5cbiAgaWYgKGh3bSB8fCBod20gPT09IDApIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bTtlbHNlIGlmIChpc0R1cGxleCAmJiAocmVhZGFibGVId20gfHwgcmVhZGFibGVId20gPT09IDApKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSByZWFkYWJsZUh3bTtlbHNlIHRoaXMuaGlnaFdhdGVyTWFyayA9IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcbiAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cbiAgLy8gYXJyYXkuc2hpZnQoKVxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIGV2ZW50ICdyZWFkYWJsZScvJ2RhdGEnIGlzIGVtaXR0ZWRcbiAgLy8gaW1tZWRpYXRlbHksIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2VcbiAgLy8gYW55IGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHJlYWQgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgY2IoZXJyKTtcbn07XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgc2tpcENodW5rQ2hlY2s7XG5cbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgICB9XG4gICAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZmFsc2UsIHNraXBDaHVua0NoZWNrKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgbnVsbCwgdHJ1ZSwgZmFsc2UpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCwgc2tpcENodW5rQ2hlY2spIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKCFza2lwQ2h1bmtDaGVjaykgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgICBpZiAoZXIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGNodW5rKSAhPT0gQnVmZmVyLnByb3RvdHlwZSkge1xuICAgICAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xuICAgICAgICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpKTtlbHNlIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kZWQpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuay5sZW5ndGggIT09IDApIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7ZWxzZSBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBhZGRUb0Zyb250KSB7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9IGVsc2Uge1xuICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG5cbiAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfVxuICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlcjtcbiAgaWYgKCFfaXNVaW50OEFycmF5KGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5uZWVkUmVhZGFibGUgfHwgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTtcblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxuICAgIC8vIHRpbnkgYW1vdW50c1xuICAgIG4tLTtcbiAgICBuIHw9IG4gPj4+IDE7XG4gICAgbiB8PSBuID4+PiAyO1xuICAgIG4gfD0gbiA+Pj4gNDtcbiAgICBuIHw9IG4gPj4+IDg7XG4gICAgbiB8PSBuID4+PiAxNjtcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcbiAgaWYgKG4gIT09IG4pIHtcbiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuO1xuICAvLyBEb24ndCBoYXZlIGVub3VnaFxuICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gc3RhdGUubGVuZ3RoO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICBuID0gcGFyc2VJbnQobiwgMTApO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuXG4gIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH1cblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7XG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG4gIH1cblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubGVuZ3RoIC09IG47XG4gIH1cblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgfVxuXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUuc3luYykgcG5hLm5leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7ZWxzZSBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO2Vsc2UgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignX3JlYWQoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcblxuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuXG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiB1bnBpcGU7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBwbmEubmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlLCB1bnBpcGVJbmZvKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGlmICh1bnBpcGVJbmZvICYmIHVucGlwZUluZm8uaGFzVW5waXBlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdW5waXBlSW5mby5oYXNVbnBpcGVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgdW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuXG4gICAgY2xlYW5lZFVwID0gdHJ1ZTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSkgb25kcmFpbigpO1xuICB9XG5cbiAgLy8gSWYgdGhlIHVzZXIgcHVzaGVzIG1vcmUgZGF0YSB3aGlsZSB3ZSdyZSB3cml0aW5nIHRvIGRlc3QgdGhlbiB3ZSdsbCBlbmQgdXBcbiAgLy8gaW4gb25kYXRhIGFnYWluLiBIb3dldmVyLCB3ZSBvbmx5IHdhbnQgdG8gaW5jcmVhc2UgYXdhaXREcmFpbiBvbmNlIGJlY2F1c2VcbiAgLy8gZGVzdCB3aWxsIG9ubHkgZW1pdCBvbmUgJ2RyYWluJyBldmVudCBmb3IgdGhlIG11bHRpcGxlIHdyaXRlcy5cbiAgLy8gPT4gSW50cm9kdWNlIGEgZ3VhcmQgb24gaW5jcmVhc2luZyBhd2FpdERyYWluLlxuICB2YXIgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBpZiAoZmFsc2UgPT09IHJldCAmJiAhaW5jcmVhc2VkQXdhaXREcmFpbikge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHVucGlwZUluZm8gPSB7IGhhc1VucGlwZWQ6IGZhbHNlIH07XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgLy8gZ290IGEgbWF0Y2guXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgfXJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIFN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwbmEubmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn1cblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpO1xuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9XG5cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuICBpZiAoZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge31cbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIF90aGlzLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIF90aGlzLnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgIC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcblxuICAgIHZhciByZXQgPSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICBmb3IgKHZhciBuID0gMDsgbiA8IGtQcm94eUV2ZW50cy5sZW5ndGg7IG4rKykge1xuICAgIHN0cmVhbS5vbihrUHJveHlFdmVudHNbbl0sIHRoaXMuZW1pdC5iaW5kKHRoaXMsIGtQcm94eUV2ZW50c1tuXSkpO1xuICB9XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgdGhpcy5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gZnJvbUxpc3RQYXJ0aWFsKG4sIHN0YXRlLmJ1ZmZlciwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBFeHRyYWN0cyBvbmx5IGVub3VnaCBidWZmZXJlZCBkYXRhIHRvIHNhdGlzZnkgdGhlIGFtb3VudCByZXF1ZXN0ZWQuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0UGFydGlhbChuLCBsaXN0LCBoYXNTdHJpbmdzKSB7XG4gIHZhciByZXQ7XG4gIGlmIChuIDwgbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3NcbiAgICByZXQgPSBsaXN0LmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcbiAgICBsaXN0LmhlYWQuZGF0YSA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKG4pO1xuICB9IGVsc2UgaWYgKG4gPT09IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIGZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXJcbiAgICByZXQgPSBoYXNTdHJpbmdzID8gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkgOiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhXG4vLyBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIHtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgdmFyIHJldCA9IHAuZGF0YTtcbiAgbiAtPSByZXQubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcbiAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YSBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpIHtcbiAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgcC5kYXRhLmNvcHkocmV0KTtcbiAgbiAtPSBwLmRhdGEubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBidWYgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKSB0aHJvdyBuZXcgRXJyb3IoJ1wiZW5kUmVhZGFibGUoKVwiIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignd3JpdGUgY2FsbGJhY2sgY2FsbGVkIG11bHRpcGxlIHRpbWVzJykpO1xuICB9XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuXG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHRoaXMucHVzaChkYXRhKTtcblxuICBjYihlcik7XG5cbiAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IHtcbiAgICBhZnRlclRyYW5zZm9ybTogYWZ0ZXJUcmFuc2Zvcm0uYmluZCh0aGlzKSxcbiAgICBuZWVkVHJhbnNmb3JtOiBmYWxzZSxcbiAgICB0cmFuc2Zvcm1pbmc6IGZhbHNlLFxuICAgIHdyaXRlY2I6IG51bGwsXG4gICAgd3JpdGVjaHVuazogbnVsbCxcbiAgICB3cml0ZWVuY29kaW5nOiBudWxsXG4gIH07XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdGhpcy5vbigncHJlZmluaXNoJywgcHJlZmluaXNoKTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIGlmICh0eXBlb2YgdGhpcy5fZmx1c2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICAgIGRvbmUoX3RoaXMsIGVyLCBkYXRhKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkb25lKHRoaXMsIG51bGwsIG51bGwpO1xuICB9XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ190cmFuc2Zvcm0oKSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB2YXIgX3RoaXMyID0gdGhpcztcblxuICBEdXBsZXgucHJvdG90eXBlLl9kZXN0cm95LmNhbGwodGhpcywgZXJyLCBmdW5jdGlvbiAoZXJyMikge1xuICAgIGNiKGVycjIpO1xuICAgIF90aGlzMi5lbWl0KCdjbG9zZScpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlciwgZGF0YSkge1xuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgaWYgKHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHN0cmVhbS5fdHJhbnNmb3JtU3RhdGUudHJhbnNmb3JtaW5nKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmcnKTtcblxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKiA8cmVwbGFjZW1lbnQ+ICovXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gIHRoaXMubmV4dCA9IG51bGw7XG59XG5cbi8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG4gIHRoaXMuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgIG9uQ29ya2VkRmluaXNoKF90aGlzLCBzdGF0ZSk7XG4gIH07XG59XG4vKiA8L3JlcGxhY2VtZW50PiAqL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGFzeW5jV3JpdGUgPSAhcHJvY2Vzcy5icm93c2VyICYmIFsndjAuMTAnLCAndjAuOS4nXS5pbmRleE9mKHByb2Nlc3MudmVyc2lvbi5zbGljZSgwLCA1KSkgPiAtMSA/IHNldEltbWVkaWF0ZSA6IHBuYS5uZXh0VGljaztcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGludGVybmFsVXRpbCA9IHtcbiAgZGVwcmVjYXRlOiByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpXG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG5cbnV0aWwuaW5oZXJpdHMoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIG5vcCgpIHt9XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuICB2YXIgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIHdyaXRhYmxlSHdtID0gb3B0aW9ucy53cml0YWJsZUhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG5cbiAgaWYgKGh3bSB8fCBod20gPT09IDApIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bTtlbHNlIGlmIChpc0R1cGxleCAmJiAod3JpdGFibGVId20gfHwgd3JpdGFibGVId20gPT09IDApKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSB3cml0YWJsZUh3bTtlbHNlIHRoaXMuaGlnaFdhdGVyTWFyayA9IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gaWYgX2ZpbmFsIGhhcyBiZWVuIGNhbGxlZFxuICB0aGlzLmZpbmFsQ2FsbGVkID0gZmFsc2U7XG5cbiAgLy8gZHJhaW4gZXZlbnQgZmxhZy5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcbiAgdGhpcy5jb3JrZWQgPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcblxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuICAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcbiAgdGhpcy5wZW5kaW5nY2IgPSAwO1xuXG4gIC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG5cbiAgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHNcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG5cbiAgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5c1xuICAvLyBvbmUgYWxsb2NhdGVkIGFuZCBmcmVlIHRvIHVzZSwgYW5kIHdlIG1haW50YWluIGF0IG1vc3QgdHdvXG4gIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7XG59XG5cbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIGdldEJ1ZmZlcigpIHtcbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlcmVkUmVxdWVzdDtcbiAgdmFyIG91dCA9IFtdO1xuICB3aGlsZSAoY3VycmVudCkge1xuICAgIG91dC5wdXNoKGN1cnJlbnQpO1xuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywge1xuICAgICAgZ2V0OiBpbnRlcm5hbFV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyKCk7XG4gICAgICB9LCAnX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgJyArICdpbnN0ZWFkLicsICdERVAwMDAzJylcbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge31cbn0pKCk7XG5cbi8vIFRlc3QgX3dyaXRhYmxlU3RhdGUgZm9yIGluaGVyaXRhbmNlIHRvIGFjY291bnQgZm9yIER1cGxleCBzdHJlYW1zLFxuLy8gd2hvc2UgcHJvdG90eXBlIGNoYWluIG9ubHkgcG9pbnRzIHRvIFJlYWRhYmxlLlxudmFyIHJlYWxIYXNJbnN0YW5jZTtcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5oYXNJbnN0YW5jZSAmJiB0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh0aGlzICE9PSBXcml0YWJsZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICByZXR1cm4gb2JqZWN0ICYmIG9iamVjdC5fd3JpdGFibGVTdGF0ZSBpbnN0YW5jZW9mIFdyaXRhYmxlU3RhdGU7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgdGhpcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdG9vLlxuICAvLyBgcmVhbEhhc0luc3RhbmNlYCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB1c2luZyBwbGFpbiBgaW5zdGFuY2VvZmBcbiAgLy8gd291bGQgcmV0dXJuIGZhbHNlLCBhcyBubyBgX3dyaXRhYmxlU3RhdGVgIHByb3BlcnR5IGlzIGF0dGFjaGVkLlxuXG4gIC8vIFRyeWluZyB0byB1c2UgdGhlIGN1c3RvbSBgaW5zdGFuY2VvZmAgZm9yIFdyaXRhYmxlIGhlcmUgd2lsbCBhbHNvIGJyZWFrIHRoZVxuICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3JcbiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICBpZiAoIXJlYWxIYXNJbnN0YW5jZS5jYWxsKFdyaXRhYmxlLCB0aGlzKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSB7XG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgfVxuXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3kuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldjtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbmFsID09PSAnZnVuY3Rpb24nKSB0aGlzLl9maW5hbCA9IG9wdGlvbnMuZmluYWw7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKSk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbn1cblxuLy8gQ2hlY2tzIHRoYXQgYSB1c2VyLXN1cHBsaWVkIGNodW5rIGlzIHZhbGlkLCBlc3BlY2lhbGx5IGZvciB0aGUgcGFydGljdWxhclxuLy8gbW9kZSB0aGUgc3RyZWFtIGlzIGluLiBDdXJyZW50bHkgdGhpcyBtZWFucyB0aGF0IGBudWxsYCBpcyBuZXZlciBhY2NlcHRlZFxuLy8gYW5kIHVuZGVmaW5lZC9ub24tc3RyaW5nIHZhbHVlcyBhcmUgb25seSBhbGxvd2VkIGluIG9iamVjdCBtb2RlLlxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgdmFyIGVyID0gZmFsc2U7XG5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuICB2YXIgaXNCdWYgPSAhc3RhdGUub2JqZWN0TW9kZSAmJiBfaXNVaW50OEFycmF5KGNodW5rKTtcblxuICBpZiAoaXNCdWYgJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHtcbiAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGlzQnVmKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG5cbiAgaWYgKHN0YXRlLmVuZGVkKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmIChpc0J1ZiB8fCB2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIHN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG5cbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBpZiAoIWlzQnVmKSB7XG4gICAgdmFyIG5ld0NodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG4gICAgaWYgKGNodW5rICE9PSBuZXdDaHVuaykge1xuICAgICAgaXNCdWYgPSB0cnVlO1xuICAgICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgICAgIGNodW5rID0gbmV3Q2h1bms7XG4gICAgfVxuICB9XG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7XG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSB7XG4gICAgICBjaHVuazogY2h1bmssXG4gICAgICBlbmNvZGluZzogZW5jb2RpbmcsXG4gICAgICBpc0J1ZjogaXNCdWYsXG4gICAgICBjYWxsYmFjazogY2IsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuXG4gIGlmIChzeW5jKSB7XG4gICAgLy8gZGVmZXIgdGhlIGNhbGxiYWNrIGlmIHdlIGFyZSBiZWluZyBjYWxsZWQgc3luY2hyb25vdXNseVxuICAgIC8vIHRvIGF2b2lkIHBpbGluZyB1cCB0aGluZ3Mgb24gdGhlIHN0YWNrXG4gICAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG4gICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXBwZW5cbiAgICAvLyBhZnRlciBlcnJvclxuICAgIHBuYS5uZXh0VGljayhmaW5pc2hNYXliZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjYWxsZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlZm9yZSBpZlxuICAgIC8vIGl0IGlzIGFzeW5jXG4gICAgY2IoZXIpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYnV0IGZpbmlzaCBtdXN0XG4gICAgLy8gYWx3YXlzIGZvbGxvdyBlcnJvclxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG5cbiAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8qPHJlcGxhY2VtZW50PiovXG4gICAgICBhc3luY1dyaXRlKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICAvKjwvcmVwbGFjZW1lbnQ+Ki9cbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG5cbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBhbGxCdWZmZXJzID0gdHJ1ZTtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGlmICghZW50cnkuaXNCdWYpIGFsbEJ1ZmZlcnMgPSBmYWxzZTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuICAgIGJ1ZmZlci5hbGxCdWZmZXJzID0gYWxsQnVmZmVycztcblxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTtcblxuICAgIC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQtLTtcbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB9XG5cbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignX3dyaXRlKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5mdW5jdGlvbiBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uX2ZpbmFsKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH1cbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQgJiYgIXN0YXRlLmZpbmFsQ2FsbGVkKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uX2ZpbmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICAgIHN0YXRlLmZpbmFsQ2FsbGVkID0gdHJ1ZTtcbiAgICAgIHBuYS5uZXh0VGljayhjYWxsRmluYWwsIHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgcG5hLm5leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb25Db3JrZWRGaW5pc2goY29ya1JlcSwgc3RhdGUsIGVycikge1xuICB2YXIgZW50cnkgPSBjb3JrUmVxLmVudHJ5O1xuICBjb3JrUmVxLmVudHJ5ID0gbnVsbDtcbiAgd2hpbGUgKGVudHJ5KSB7XG4gICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgY2IoZXJyKTtcbiAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gIH1cbiAgaWYgKHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSkge1xuICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gY29ya1JlcTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBjb3JrUmVxO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5lbmQoKTtcbiAgY2IoZXJyKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuZnVuY3Rpb24gY29weUJ1ZmZlcihzcmMsIHRhcmdldCwgb2Zmc2V0KSB7XG4gIHNyYy5jb3B5KHRhcmdldCwgb2Zmc2V0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1ZmZlckxpc3QpO1xuXG4gICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoKHYpIHtcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IG51bGwgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgdGhpcy50YWlsID0gZW50cnk7XG4gICAgKyt0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gdW5zaGlmdCh2KSB7XG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiB0aGlzLmhlYWQgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgICsrdGhpcy5sZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO2Vsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG4gICAgLS10aGlzLmxlbmd0aDtcbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIGpvaW4ocykge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgIHZhciByZXQgPSAnJyArIHAuZGF0YTtcbiAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgcmV0ICs9IHMgKyBwLmRhdGE7XG4gICAgfXJldHVybiByZXQ7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0KG4pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSByZXR1cm4gdGhpcy5oZWFkLmRhdGE7XG4gICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuID4+PiAwKTtcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKHApIHtcbiAgICAgIGNvcHlCdWZmZXIocC5kYXRhLCByZXQsIGkpO1xuICAgICAgaSArPSBwLmRhdGEubGVuZ3RoO1xuICAgICAgcCA9IHAubmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICByZXR1cm4gQnVmZmVyTGlzdDtcbn0oKTtcblxuaWYgKHV0aWwgJiYgdXRpbC5pbnNwZWN0ICYmIHV0aWwuaW5zcGVjdC5jdXN0b20pIHtcbiAgbW9kdWxlLmV4cG9ydHMucHJvdG90eXBlW3V0aWwuaW5zcGVjdC5jdXN0b21dID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB1dGlsLmluc3BlY3QoeyBsZW5ndGg6IHRoaXMubGVuZ3RoIH0pO1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyAnICcgKyBvYmo7XG4gIH07XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vLyB1bmRvY3VtZW50ZWQgY2IoKSBBUEksIG5lZWRlZCBmb3IgY29yZSwgbm90IGZvciBwdWJsaWMgQVBJXG5mdW5jdGlvbiBkZXN0cm95KGVyciwgY2IpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgcmVhZGFibGVEZXN0cm95ZWQgPSB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB2YXIgd3JpdGFibGVEZXN0cm95ZWQgPSB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuXG4gIGlmIChyZWFkYWJsZURlc3Ryb3llZCB8fCB3cml0YWJsZURlc3Ryb3llZCkge1xuICAgIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2UgaWYgKGVyciAmJiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUgfHwgIXRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSkge1xuICAgICAgcG5hLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHdlIHNldCBkZXN0cm95ZWQgdG8gdHJ1ZSBiZWZvcmUgZmlyaW5nIGVycm9yIGNhbGxiYWNrcyBpbiBvcmRlclxuICAvLyB0byBtYWtlIGl0IHJlLWVudHJhbmNlIHNhZmUgaW4gY2FzZSBkZXN0cm95KCkgaXMgY2FsbGVkIHdpdGhpbiBjYWxsYmFja3NcblxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGlmIHRoaXMgaXMgYSBkdXBsZXggc3RyZWFtIG1hcmsgdGhlIHdyaXRhYmxlIHBhcnQgYXMgZGVzdHJveWVkIGFzIHdlbGxcbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICB0aGlzLl9kZXN0cm95KGVyciB8fCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKCFjYiAmJiBlcnIpIHtcbiAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgX3RoaXMsIGVycik7XG4gICAgICBpZiAoX3RoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHVuZGVzdHJveSgpIHtcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0RXJyb3JOVChzZWxmLCBlcnIpIHtcbiAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZXN0cm95OiBkZXN0cm95LFxuICB1bmRlc3Ryb3k6IHVuZGVzdHJveVxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpLlBhc3NUaHJvdWdoXG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IGV4cG9ydHM7XG5leHBvcnRzLlJlYWRhYmxlID0gZXhwb3J0cztcbmV4cG9ydHMuV3JpdGFibGUgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5leHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5leHBvcnRzLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG5leHBvcnRzLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3JlYWRhYmxlJykuVHJhbnNmb3JtXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKVxudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXJcblxuLy8gYWx0ZXJuYXRpdmUgdG8gdXNpbmcgT2JqZWN0LmtleXMgZm9yIG9sZCBicm93c2Vyc1xuZnVuY3Rpb24gY29weVByb3BzIChzcmMsIGRzdCkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgZHN0W2tleV0gPSBzcmNba2V5XVxuICB9XG59XG5pZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmFsbG9jICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KSB7XG4gIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyXG59IGVsc2Uge1xuICAvLyBDb3B5IHByb3BlcnRpZXMgZnJvbSByZXF1aXJlKCdidWZmZXInKVxuICBjb3B5UHJvcHMoYnVmZmVyLCBleHBvcnRzKVxuICBleHBvcnRzLkJ1ZmZlciA9IFNhZmVCdWZmZXJcbn1cblxuZnVuY3Rpb24gU2FmZUJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlclxuY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcilcblxuU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICB2YXIgYnVmID0gQnVmZmVyKHNpemUpXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKDApXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoc2l6ZSlcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpXG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicgPyBzZXRJbW1lZGlhdGUgOlxuXHRmdW5jdGlvbiBzZXRJbW1lZGlhdGUoKSB7XG5cdFx0dmFyIGFyZ3MgPSBbXS5zbGljZS5hcHBseShhcmd1bWVudHMpO1xuXHRcdGFyZ3Muc3BsaWNlKDEsIDAsIDApO1xuXHRcdHNldFRpbWVvdXQuYXBwbHkobnVsbCwgYXJncyk7XG5cdH07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmluaGVyaXRzKFN0cmVhbSwgRUUpO1xuU3RyZWFtLlJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzJyk7XG5TdHJlYW0uV3JpdGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMnKTtcblN0cmVhbS5EdXBsZXggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzJyk7XG5TdHJlYW0uVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcycpO1xuU3RyZWFtLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzJyk7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtO1xuXG5cblxuLy8gb2xkLXN0eWxlIHN0cmVhbXMuICBOb3RlIHRoYXQgdGhlIHBpcGUgbWV0aG9kICh0aGUgb25seSByZWxldmFudFxuLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy5cblxuZnVuY3Rpb24gU3RyZWFtKCkge1xuICBFRS5jYWxsKHRoaXMpO1xufVxuXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGlmIChkZXN0LndyaXRhYmxlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkge1xuICAgICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XG4gICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7XG4gICAgICBzb3VyY2UucmVzdW1lKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLlxuICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH1cblxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPT09IDApIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIHJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG4gIH1cblxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApO1xuICBzb3VyY2Uub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpO1xuXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXG4gIHJldHVybiBkZXN0O1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgaXNFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nIHx8IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBlbmNvZGluZyA9ICcnICsgZW5jb2Rpbmc7XG4gIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6Y2FzZSAndXRmOCc6Y2FzZSAndXRmLTgnOmNhc2UgJ2FzY2lpJzpjYXNlICdiaW5hcnknOmNhc2UgJ2Jhc2U2NCc6Y2FzZSAndWNzMic6Y2FzZSAndWNzLTInOmNhc2UgJ3V0ZjE2bGUnOmNhc2UgJ3V0Zi0xNmxlJzpjYXNlICdyYXcnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX25vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICBpZiAoIWVuYykgcmV0dXJuICd1dGY4JztcbiAgdmFyIHJldHJpZWQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmMpIHtcbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gJ3V0ZjgnO1xuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuICd1dGYxNmxlJztcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gJ2xhdGluMSc7XG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGVuYztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChyZXRyaWVkKSByZXR1cm47IC8vIHVuZGVmaW5lZFxuICAgICAgICBlbmMgPSAoJycgKyBlbmMpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHJpZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gRG8gbm90IGNhY2hlIGBCdWZmZXIuaXNFbmNvZGluZ2Agd2hlbiBjaGVja2luZyBlbmNvZGluZyBuYW1lcyBhcyBzb21lXG4vLyBtb2R1bGVzIG1vbmtleS1wYXRjaCBpdCB0byBzdXBwb3J0IGFkZGl0aW9uYWwgZW5jb2RpbmdzXG5mdW5jdGlvbiBub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgdmFyIG5lbmMgPSBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKTtcbiAgaWYgKHR5cGVvZiBuZW5jICE9PSAnc3RyaW5nJyAmJiAoQnVmZmVyLmlzRW5jb2RpbmcgPT09IGlzRW5jb2RpbmcgfHwgIWlzRW5jb2RpbmcoZW5jKSkpIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuYyk7XG4gIHJldHVybiBuZW5jIHx8IGVuYztcbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLlxuZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gU3RyaW5nRGVjb2RlcjtcbmZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IG5vcm1hbGl6ZUVuY29kaW5nKGVuY29kaW5nKTtcbiAgdmFyIG5iO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIHRoaXMudGV4dCA9IHV0ZjE2VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gdXRmMTZFbmQ7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIHRoaXMuZmlsbExhc3QgPSB1dGY4RmlsbExhc3Q7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgdGhpcy50ZXh0ID0gYmFzZTY0VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gYmFzZTY0RW5kO1xuICAgICAgbmIgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBzaW1wbGVXcml0ZTtcbiAgICAgIHRoaXMuZW5kID0gc2ltcGxlRW5kO1xuICAgICAgcmV0dXJuO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAwO1xuICB0aGlzLmxhc3RUb3RhbCA9IDA7XG4gIHRoaXMubGFzdENoYXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobmIpO1xufVxuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgdmFyIHI7XG4gIHZhciBpO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHIgPSB0aGlzLmZpbGxMYXN0KGJ1Zik7XG4gICAgaWYgKHIgPT09IHVuZGVmaW5lZCkgcmV0dXJuICcnO1xuICAgIGkgPSB0aGlzLmxhc3ROZWVkO1xuICAgIHRoaXMubGFzdE5lZWQgPSAwO1xuICB9IGVsc2Uge1xuICAgIGkgPSAwO1xuICB9XG4gIGlmIChpIDwgYnVmLmxlbmd0aCkgcmV0dXJuIHIgPyByICsgdGhpcy50ZXh0KGJ1ZiwgaSkgOiB0aGlzLnRleHQoYnVmLCBpKTtcbiAgcmV0dXJuIHIgfHwgJyc7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSB1dGY4RW5kO1xuXG4vLyBSZXR1cm5zIG9ubHkgY29tcGxldGUgY2hhcmFjdGVycyBpbiBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUudGV4dCA9IHV0ZjhUZXh0O1xuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIHBhcnRpYWwgbm9uLVVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5maWxsTGFzdCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn07XG5cbi8vIENoZWNrcyB0aGUgdHlwZSBvZiBhIFVURi04IGJ5dGUsIHdoZXRoZXIgaXQncyBBU0NJSSwgYSBsZWFkaW5nIGJ5dGUsIG9yIGFcbi8vIGNvbnRpbnVhdGlvbiBieXRlLiBJZiBhbiBpbnZhbGlkIGJ5dGUgaXMgZGV0ZWN0ZWQsIC0yIGlzIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrQnl0ZShieXRlKSB7XG4gIGlmIChieXRlIDw9IDB4N0YpIHJldHVybiAwO2Vsc2UgaWYgKGJ5dGUgPj4gNSA9PT0gMHgwNikgcmV0dXJuIDI7ZWxzZSBpZiAoYnl0ZSA+PiA0ID09PSAweDBFKSByZXR1cm4gMztlbHNlIGlmIChieXRlID4+IDMgPT09IDB4MUUpIHJldHVybiA0O1xuICByZXR1cm4gYnl0ZSA+PiA2ID09PSAweDAyID8gLTEgOiAtMjtcbn1cblxuLy8gQ2hlY2tzIGF0IG1vc3QgMyBieXRlcyBhdCB0aGUgZW5kIG9mIGEgQnVmZmVyIGluIG9yZGVyIHRvIGRldGVjdCBhblxuLy8gaW5jb21wbGV0ZSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3Rlci4gVGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyAoMiwgMywgb3IgNClcbi8vIG5lZWRlZCB0byBjb21wbGV0ZSB0aGUgVVRGLTggY2hhcmFjdGVyIChpZiBhcHBsaWNhYmxlKSBhcmUgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tJbmNvbXBsZXRlKHNlbGYsIGJ1ZiwgaSkge1xuICB2YXIgaiA9IGJ1Zi5sZW5ndGggLSAxO1xuICBpZiAoaiA8IGkpIHJldHVybiAwO1xuICB2YXIgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMTtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMjtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkge1xuICAgICAgaWYgKG5iID09PSAyKSBuYiA9IDA7ZWxzZSBzZWxmLmxhc3ROZWVkID0gbmIgLSAzO1xuICAgIH1cbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vIFZhbGlkYXRlcyBhcyBtYW55IGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciBhc1xuLy8gbmVlZGVkIG9yIGFyZSBhdmFpbGFibGUuIElmIHdlIHNlZSBhIG5vbi1jb250aW51YXRpb24gYnl0ZSB3aGVyZSB3ZSBleHBlY3Rcbi8vIG9uZSwgd2UgXCJyZXBsYWNlXCIgdGhlIHZhbGlkYXRlZCBjb250aW51YXRpb24gYnl0ZXMgd2UndmUgc2VlbiBzbyBmYXIgd2l0aFxuLy8gYSBzaW5nbGUgVVRGLTggcmVwbGFjZW1lbnQgY2hhcmFjdGVyICgnXFx1ZmZmZCcpLCB0byBtYXRjaCB2OCdzIFVURi04IGRlY29kaW5nXG4vLyBiZWhhdmlvci4gVGhlIGNvbnRpbnVhdGlvbiBieXRlIGNoZWNrIGlzIGluY2x1ZGVkIHRocmVlIHRpbWVzIGluIHRoZSBjYXNlXG4vLyB3aGVyZSBhbGwgb2YgdGhlIGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBjaGFyYWN0ZXIgZXhpc3QgaW4gdGhlIHNhbWUgYnVmZmVyLlxuLy8gSXQgaXMgYWxzbyBkb25lIHRoaXMgd2F5IGFzIGEgc2xpZ2h0IHBlcmZvcm1hbmNlIGluY3JlYXNlIGluc3RlYWQgb2YgdXNpbmcgYVxuLy8gbG9vcC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0V4dHJhQnl0ZXMoc2VsZiwgYnVmLCBwKSB7XG4gIGlmICgoYnVmWzBdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICBzZWxmLmxhc3ROZWVkID0gMDtcbiAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICB9XG4gIGlmIChzZWxmLmxhc3ROZWVkID4gMSAmJiBidWYubGVuZ3RoID4gMSkge1xuICAgIGlmICgoYnVmWzFdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgIHNlbGYubGFzdE5lZWQgPSAxO1xuICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICB9XG4gICAgaWYgKHNlbGYubGFzdE5lZWQgPiAyICYmIGJ1Zi5sZW5ndGggPiAyKSB7XG4gICAgICBpZiAoKGJ1ZlsyXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICAgIHNlbGYubGFzdE5lZWQgPSAyO1xuICAgICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXIuXG5mdW5jdGlvbiB1dGY4RmlsbExhc3QoYnVmKSB7XG4gIHZhciBwID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICB2YXIgciA9IHV0ZjhDaGVja0V4dHJhQnl0ZXModGhpcywgYnVmLCBwKTtcbiAgaWYgKHIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHI7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn1cblxuLy8gUmV0dXJucyBhbGwgY29tcGxldGUgVVRGLTggY2hhcmFjdGVycyBpbiBhIEJ1ZmZlci4gSWYgdGhlIEJ1ZmZlciBlbmRlZCBvbiBhXG4vLyBwYXJ0aWFsIGNoYXJhY3RlciwgdGhlIGNoYXJhY3RlcidzIGJ5dGVzIGFyZSBidWZmZXJlZCB1bnRpbCB0aGUgcmVxdWlyZWRcbi8vIG51bWJlciBvZiBieXRlcyBhcmUgYXZhaWxhYmxlLlxuZnVuY3Rpb24gdXRmOFRleHQoYnVmLCBpKSB7XG4gIHZhciB0b3RhbCA9IHV0ZjhDaGVja0luY29tcGxldGUodGhpcywgYnVmLCBpKTtcbiAgaWYgKCF0aGlzLmxhc3ROZWVkKSByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSk7XG4gIHRoaXMubGFzdFRvdGFsID0gdG90YWw7XG4gIHZhciBlbmQgPSBidWYubGVuZ3RoIC0gKHRvdGFsIC0gdGhpcy5sYXN0TmVlZCk7XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIDAsIGVuZCk7XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpLCBlbmQpO1xufVxuXG4vLyBGb3IgVVRGLTgsIGEgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGlzIGFkZGVkIHdoZW4gZW5kaW5nIG9uIGEgcGFydGlhbFxuLy8gY2hhcmFjdGVyLlxuZnVuY3Rpb24gdXRmOEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyAnXFx1ZmZmZCc7XG4gIHJldHVybiByO1xufVxuXG4vLyBVVEYtMTZMRSB0eXBpY2FsbHkgbmVlZHMgdHdvIGJ5dGVzIHBlciBjaGFyYWN0ZXIsIGJ1dCBldmVuIGlmIHdlIGhhdmUgYW4gZXZlblxuLy8gbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSBlbmQgb24gYSBsZWFkaW5nL2hpZ2hcbi8vIHN1cnJvZ2F0ZS4gSW4gdGhhdCBjYXNlLCB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBuZXh0IHR3byBieXRlcyBpbiBvcmRlciB0b1xuLy8gZGVjb2RlIHRoZSBsYXN0IGNoYXJhY3RlciBwcm9wZXJseS5cbmZ1bmN0aW9uIHV0ZjE2VGV4dChidWYsIGkpIHtcbiAgaWYgKChidWYubGVuZ3RoIC0gaSkgJSAyID09PSAwKSB7XG4gICAgdmFyIHIgPSBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpKTtcbiAgICBpZiAocikge1xuICAgICAgdmFyIGMgPSByLmNoYXJDb2RlQXQoci5sZW5ndGggLSAxKTtcbiAgICAgIGlmIChjID49IDB4RDgwMCAmJiBjIDw9IDB4REJGRikge1xuICAgICAgICB0aGlzLmxhc3ROZWVkID0gMjtcbiAgICAgICAgdGhpcy5sYXN0VG90YWwgPSA0O1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiByLnNsaWNlKDAsIC0xKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDE7XG4gIHRoaXMubGFzdFRvdGFsID0gMjtcbiAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpLCBidWYubGVuZ3RoIC0gMSk7XG59XG5cbi8vIEZvciBVVEYtMTZMRSB3ZSBkbyBub3QgZXhwbGljaXRseSBhcHBlbmQgc3BlY2lhbCByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGlmIHdlXG4vLyBlbmQgb24gYSBwYXJ0aWFsIGNoYXJhY3Rlciwgd2Ugc2ltcGx5IGxldCB2OCBoYW5kbGUgdGhhdC5cbmZ1bmN0aW9uIHV0ZjE2RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgdmFyIGVuZCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgICByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ3V0ZjE2bGUnLCAwLCBlbmQpO1xuICB9XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRUZXh0KGJ1ZiwgaSkge1xuICB2YXIgbiA9IChidWYubGVuZ3RoIC0gaSkgJSAzO1xuICBpZiAobiA9PT0gMCkgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSk7XG4gIHRoaXMubGFzdE5lZWQgPSAzIC0gbjtcbiAgdGhpcy5sYXN0VG90YWwgPSAzO1xuICBpZiAobiA9PT0gMSkge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGksIGJ1Zi5sZW5ndGggLSBuKTtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ2Jhc2U2NCcsIDAsIDMgLSB0aGlzLmxhc3ROZWVkKTtcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFBhc3MgYnl0ZXMgb24gdGhyb3VnaCBmb3Igc2luZ2xlLWJ5dGUgZW5jb2RpbmdzIChlLmcuIGFzY2lpLCBsYXRpbjEsIGhleClcbmZ1bmN0aW9uIHNpbXBsZVdyaXRlKGJ1Zikge1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVFbmQoYnVmKSB7XG4gIHJldHVybiBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xufSIsInZhciBuZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MvYnJvd3Nlci5qcycpLm5leHRUaWNrO1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGltbWVkaWF0ZUlkcyA9IHt9O1xudmFyIG5leHRJbW1lZGlhdGVJZCA9IDA7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7IHRpbWVvdXQuY2xvc2UoKTsgfTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBUaGF0J3Mgbm90IGhvdyBub2RlLmpzIGltcGxlbWVudHMgaXQgYnV0IHRoZSBleHBvc2VkIGFwaSBpcyB0aGUgc2FtZS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gc2V0SW1tZWRpYXRlIDogZnVuY3Rpb24oZm4pIHtcbiAgdmFyIGlkID0gbmV4dEltbWVkaWF0ZUlkKys7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBmYWxzZSA6IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICBpbW1lZGlhdGVJZHNbaWRdID0gdHJ1ZTtcblxuICBuZXh0VGljayhmdW5jdGlvbiBvbk5leHRUaWNrKCkge1xuICAgIGlmIChpbW1lZGlhdGVJZHNbaWRdKSB7XG4gICAgICAvLyBmbi5jYWxsKCkgaXMgZmFzdGVyIHNvIHdlIG9wdGltaXplIGZvciB0aGUgY29tbW9uIHVzZS1jYXNlXG4gICAgICAvLyBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2NhbGwtYXBwbHktc2VndVxuICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbi5jYWxsKG51bGwpO1xuICAgICAgfVxuICAgICAgLy8gUHJldmVudCBpZHMgZnJvbSBsZWFraW5nXG4gICAgICBleHBvcnRzLmNsZWFySW1tZWRpYXRlKGlkKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBpZDtcbn07XG5cbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSB0eXBlb2YgY2xlYXJJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IGNsZWFySW1tZWRpYXRlIDogZnVuY3Rpb24oaWQpIHtcbiAgZGVsZXRlIGltbWVkaWF0ZUlkc1tpZF07XG59OyIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZTtcblxuLyoqXG4gKiBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLm5vRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRocm93RGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBpbnZva2VkLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudHJhY2VEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCBpbnZva2UgYGNvbnNvbGUudHJhY2UoKWAgaW5zdGVhZCBvZiBgY29uc29sZS5lcnJvcigpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSBmdW5jdGlvbiB0byBkZXByZWNhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSB0aGUgc3RyaW5nIHRvIHByaW50IHRvIHRoZSBjb25zb2xlIHdoZW4gYGZuYCBpcyBpbnZva2VkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3IFwiZGVwcmVjYXRlZFwiIHZlcnNpb24gb2YgYGZuYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZXByZWNhdGUgKGZuLCBtc2cpIHtcbiAgaWYgKGNvbmZpZygnbm9EZXByZWNhdGlvbicpKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZygndHJhY2VEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgYGxvY2FsU3RvcmFnZWAgZm9yIGJvb2xlYW4gdmFsdWVzIGZvciB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbmZpZyAobmFtZSkge1xuICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lc1xuICB0cnkge1xuICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdO1xuICBpZiAobnVsbCA9PSB2YWwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbn1cbiIsImltcG9ydCBKU1ppcCBmcm9tIFwianN6aXBcIjtcclxuaW1wb3J0IHtJdXBsb2FkZmlsZUxpc3R9IGZyb20gXCIuL0lDb21tb25cIjtcclxuaW1wb3J0IHtnZXRCaW5hcnlDb250ZW50fSBmcm9tIFwiLi9jb21tb24vbWV0aG9kXCJcclxuXHJcblxyXG5leHBvcnQgY2xhc3MgSGFuZGxlWmlwe1xyXG4gICAgdXBsb2FkRmlsZTpGaWxlOyBcclxuICAgIHdvcmtCb29rOkpTWmlwOyBcclxuICAgIFxyXG4gICAgY29uc3RydWN0b3IoZmlsZT86RmlsZSl7XHJcbiAgICAgICAgLy8gU3VwcG9ydCBub2RlanMgZnMgdG8gcmVhZCBmaWxlc1xyXG4gICAgICAgIC8vIGlmKGZpbGUgaW5zdGFuY2VvZiBGaWxlKXtcclxuICAgICAgICAgICAgdGhpcy51cGxvYWRGaWxlID0gZmlsZTtcclxuICAgICAgICAvLyB9XHJcbiAgICB9XHJcblxyXG4gICAgdW56aXBGaWxlKHN1Y2Nlc3NGdW5jOihmaWxlOkl1cGxvYWRmaWxlTGlzdCk9PnZvaWQsIGVycm9yRnVuYzooZXJyOkVycm9yKT0+dm9pZCk6dm9pZCB7IFxyXG4gICAgICAgIC8vIHZhciBuZXdfemlwOkpTWmlwID0gbmV3IEpTWmlwKCk7XHJcbiAgICAgICAgSlNaaXAubG9hZEFzeW5jKHRoaXMudXBsb2FkRmlsZSkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDEpIHJlYWQgdGhlIEJsb2JcclxuICAgICAgICAudGhlbihmdW5jdGlvbih6aXA6YW55KSB7XHJcbiAgICAgICAgICAgIGxldCBmaWxlTGlzdDpJdXBsb2FkZmlsZUxpc3QgPSA8SXVwbG9hZGZpbGVMaXN0Pnt9LCBsYXN0SW5kZXg6bnVtYmVyID0gT2JqZWN0LmtleXMoemlwLmZpbGVzKS5sZW5ndGgsIGluZGV4Om51bWJlcj0wO1xyXG4gICAgICAgICAgICB6aXAuZm9yRWFjaChmdW5jdGlvbiAocmVsYXRpdmVQYXRoOmFueSwgemlwRW50cnk6YW55KSB7ICAvLyAyKSBwcmludCBlbnRyaWVzXHJcbiAgICAgICAgICAgICAgICBsZXQgZmlsZU5hbWUgPSB6aXBFbnRyeS5uYW1lO1xyXG4gICAgICAgICAgICAgICAgbGV0IGZpbGVOYW1lQXJyID0gZmlsZU5hbWUuc3BsaXQoXCIuXCIpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHN1ZmZpeCA9IGZpbGVOYW1lQXJyW2ZpbGVOYW1lQXJyLmxlbmd0aC0xXS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGZpbGVUeXBlID0gXCJzdHJpbmdcIjtcclxuICAgICAgICAgICAgICAgIGlmKHN1ZmZpeCBpbiB7XCJwbmdcIjoxLCBcImpwZWdcIjoxLCBcImpwZ1wiOjEsIFwiZ2lmXCI6MSxcImJtcFwiOjEsXCJ0aWZcIjoxLFwid2VicFwiOjEsfSl7XHJcbiAgICAgICAgICAgICAgICAgICAgZmlsZVR5cGUgPSBcImJhc2U2NFwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihzdWZmaXg9PVwiZW1mXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbGVUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgemlwRW50cnkuYXN5bmMoZmlsZVR5cGUpLnRoZW4oZnVuY3Rpb24gKGRhdGE6c3RyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZmlsZVR5cGU9PVwiYmFzZTY0XCIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gXCJkYXRhOmltYWdlL1wiKyBzdWZmaXggK1wiO2Jhc2U2NCxcIiArIGRhdGE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGVMaXN0W3ppcEVudHJ5Lm5hbWVdID0gZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhsYXN0SW5kZXgsIGluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICBpZihsYXN0SW5kZXg9PWluZGV4KzEpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzRnVuYyhmaWxlTGlzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIH0sIGZ1bmN0aW9uIChlOkVycm9yKSB7XHJcbiAgICAgICAgICAgIGVycm9yRnVuYyhlKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICB1bnppcEZpbGVCeVVybCh1cmw6c3RyaW5nLHN1Y2Nlc3NGdW5jOihmaWxlOkl1cGxvYWRmaWxlTGlzdCk9PnZvaWQsIGVycm9yRnVuYzooZXJyOkVycm9yKT0+dm9pZCk6dm9pZCB7IFxyXG4gICAgICAgIHZhciBuZXdfemlwOkpTWmlwID0gbmV3IEpTWmlwKCk7XHJcbiAgICAgICAgZ2V0QmluYXJ5Q29udGVudCh1cmwsIGZ1bmN0aW9uKGVycjphbnksIGRhdGE6YW55KSB7XHJcbiAgICAgICAgICAgIGlmKGVycikge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyOyAvLyBvciBoYW5kbGUgZXJyXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAgICAgSlNaaXAubG9hZEFzeW5jKGRhdGEpLnRoZW4oZnVuY3Rpb24oemlwOmFueSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IGZpbGVMaXN0Okl1cGxvYWRmaWxlTGlzdCA9IDxJdXBsb2FkZmlsZUxpc3Q+e30sIGxhc3RJbmRleDpudW1iZXIgPSBPYmplY3Qua2V5cyh6aXAuZmlsZXMpLmxlbmd0aCwgaW5kZXg6bnVtYmVyPTA7XHJcbiAgICAgICAgICAgICAgICB6aXAuZm9yRWFjaChmdW5jdGlvbiAocmVsYXRpdmVQYXRoOmFueSwgemlwRW50cnk6YW55KSB7ICAvLyAyKSBwcmludCBlbnRyaWVzXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZpbGVOYW1lID0gemlwRW50cnkubmFtZTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZmlsZU5hbWVBcnIgPSBmaWxlTmFtZS5zcGxpdChcIi5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN1ZmZpeCA9IGZpbGVOYW1lQXJyW2ZpbGVOYW1lQXJyLmxlbmd0aC0xXS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBmaWxlVHlwZSA9IFwic3RyaW5nXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3VmZml4IGluIHtcInBuZ1wiOjEsIFwianBlZ1wiOjEsIFwianBnXCI6MSwgXCJnaWZcIjoxLFwiYm1wXCI6MSxcInRpZlwiOjEsXCJ3ZWJwXCI6MSx9KXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZVR5cGUgPSBcImJhc2U2NFwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHN1ZmZpeD09XCJlbWZcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB6aXBFbnRyeS5hc3luYyhmaWxlVHlwZSkudGhlbihmdW5jdGlvbiAoZGF0YTphbnkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZmlsZVR5cGU9PVwiYmFzZTY0XCIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IFwiZGF0YTppbWFnZS9cIisgc3VmZml4ICtcIjtiYXNlNjQsXCIgKyBkYXRhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVMaXN0W3ppcEVudHJ5Lm5hbWVdID0gZGF0YTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2cobGFzdEluZGV4LCBpbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGxhc3RJbmRleD09aW5kZXgrMSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzRnVuYyhmaWxlTGlzdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlOkVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvckZ1bmMoZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFxyXG4gICAgfVxyXG5cclxuICAgIG5ld1ppcEZpbGUoKTp2b2lkIHsgXHJcbiAgICAgICAgdmFyIHppcCA9IG5ldyBKU1ppcCgpO1xyXG4gICAgICAgIHRoaXMud29ya0Jvb2sgPSAgemlwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vdGl0bGU6XCJuZXN0ZWQvaGVsbG8udHh0XCIsIGNvbnRlbnQ6XCJIZWxsbyBXb3JsZGFzZGZhc2Zhc2RmYXNmYXNmYXNmYXNmYXNkZmFzXCJcclxuICAgIGFkZFRvWmlwRmlsZSh0aXRsZTpzdHJpbmcsY29udGVudDpzdHJpbmcpOnZvaWQgeyBcclxuICAgICAgICBpZih0aGlzLndvcmtCb29rPT1udWxsKXtcclxuICAgICAgICAgICAgdmFyIHppcCA9IG5ldyBKU1ppcCgpO1xyXG4gICAgICAgICAgICB0aGlzLndvcmtCb29rID0gIHppcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy53b3JrQm9vay5maWxlKHRpdGxlLCBjb250ZW50KTtcclxuICAgIH1cclxufSIsImltcG9ydCB7IElMdWNreUZpbGUsIElMdWNreUZpbGVJbmZvLElsdWNreVNoZWV0LElsdWNreVNoZWV0Q2VsbGRhdGEsSWx1Y2t5U2hlZXRDb25maWcsSWxhc3RDb250ZW50RGF0YSxJbHVja3lTaGVldENlbGxkYXRhVmFsdWUsSWx1Y2t5U2hlZXRDZWxsZGF0YVZhbHVlTWVyZ2UsSUx1Y2t5U2hlZXRDZWxsRm9ybWF0LElsdWNreVNoZWV0Q29uZmlnTWVyZ2VzLElsdWNreVNoZWV0Q29uZmlnTWVyZ2UsSU1hcGx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbEZvckltcCxJbHVja3lTaGVldGJvcmRlckluZm9DZWxsVmFsdWUsSWx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbFZhbHVlU3R5bGUsSWx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbEZvckltcCxJbHVja3lTaGVldFJvd0FuZENvbHVtbkxlbixJbHVja3lTaGVldFJvd0FuZENvbHVtbkhpZGRlbixJbHVja3lTaGVldFNlbGVjdGlvbixJbHVja3lzaGVldEZyb3plbixJbHVja3lTaGVldENoYXJ0LElsdWNreVNoZWV0UGl2b3RUYWJsZSxJbHVja3lzaGVldENvbmRpdGlvbkZvcm1hdCxJbHVja3lzaGVldENhbGNDaGFpbixJTHVja3lJbmxpbmVTdHJpbmcsSWx1Y2t5SW1hZ2UsSWx1Y2t5SW1hZ2VCb3JkZXIsSWx1Y2t5SW1hZ2VDcm9wLElsdWNreUltYWdlRGVmYXVsdCxJbHVja3lJbWFnZXMsIElsdWNreXNoZWV0SHlwZXJsaW5rLCBJbHVja3lzaGVldERhdGFWZXJpZmljYXRpb259IGZyb20gXCIuL0lMdWNrXCI7XHJcblxyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBMdWNreUZpbGVCYXNlIGltcGxlbWVudHMgSUx1Y2t5RmlsZSB7XHJcbiAgICBpbmZvOklMdWNreUZpbGVJbmZvXHJcbiAgICBzaGVldHM6SWx1Y2t5U2hlZXRbXVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgTHVja3lTaGVldEJhc2UgaW1wbGVtZW50cyBJbHVja3lTaGVldHtcclxuICAgIG5hbWU6c3RyaW5nXHJcbiAgICBjb2xvcjpzdHJpbmdcclxuICAgIGNvbmZpZzpJbHVja3lTaGVldENvbmZpZ1xyXG4gICAgaW5kZXg6c3RyaW5nXHJcbiAgICBzdGF0dXM6c3RyaW5nXHJcbiAgICBvcmRlcjpzdHJpbmdcclxuICAgIHJvdzpudW1iZXJcclxuICAgIGNvbHVtbjpudW1iZXJcclxuICAgIGx1Y2t5c2hlZXRfc2VsZWN0X3NhdmU6SWx1Y2t5U2hlZXRTZWxlY3Rpb25bXVxyXG4gICAgc2Nyb2xsTGVmdDpudW1iZXJcclxuICAgIHNjcm9sbFRvcDpudW1iZXJcclxuICAgIHpvb21SYXRpbzpudW1iZXJcclxuICAgIHNob3dHcmlkTGluZXM6c3RyaW5nXHJcbiAgICBkZWZhdWx0Q29sV2lkdGg6bnVtYmVyXHJcbiAgICBkZWZhdWx0Um93SGVpZ2h0Om51bWJlclxyXG5cclxuICAgIGNlbGxkYXRhOklsdWNreVNoZWV0Q2VsbGRhdGFbXVxyXG4gICAgY2hhcnQ6SWx1Y2t5U2hlZXRDaGFydFtdXHJcblxyXG4gICAgaXNQaXZvdFRhYmxlOmJvb2xlYW5cclxuICAgIHBpdm90VGFibGU6SWx1Y2t5U2hlZXRQaXZvdFRhYmxlXHJcblxyXG4gICAgbHVja3lzaGVldF9jb25kaXRpb25mb3JtYXRfc2F2ZTpJbHVja3lzaGVldENvbmRpdGlvbkZvcm1hdFtdXHJcbiAgICBmcmVlemVuOklsdWNreXNoZWV0RnJvemVuXHJcblxyXG4gICAgY2FsY0NoYWluOklsdWNreXNoZWV0Q2FsY0NoYWluW11cclxuXHJcbiAgICBpbWFnZXM6SWx1Y2t5SW1hZ2VzXHJcbiAgICBcclxuICAgIGRhdGFWZXJpZmljYXRpb246IElsdWNreXNoZWV0RGF0YVZlcmlmaWNhdGlvbjtcclxuICAgIGh5cGVybGluazogSWx1Y2t5c2hlZXRIeXBlcmxpbmtcclxuICAgIGhpZGU6IG51bWJlcjtcclxuICAgIGxhc3RDb250ZW50RGF0YTogSWxhc3RDb250ZW50RGF0YTtcclxuICAgIFxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgTHVja3lGaWxlSW5mbyBpbXBsZW1lbnRzIElMdWNreUZpbGVJbmZve1xyXG4gICAgbmFtZTpzdHJpbmdcclxuICAgIGNyZWF0b3I6c3RyaW5nXHJcbiAgICBsYXN0bW9kaWZpZWRieTpzdHJpbmdcclxuICAgIGNyZWF0ZWRUaW1lOnN0cmluZ1xyXG4gICAgbW9kaWZpZWRUaW1lOnN0cmluZ1xyXG4gICAgY29tcGFueTpzdHJpbmdcclxuICAgIGFwcHZlcnNpb246c3RyaW5nXHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBMdWNreVNoZWV0Q2VsbGRhdGFCYXNlIGltcGxlbWVudHMgSWx1Y2t5U2hlZXRDZWxsZGF0YXtcclxuICAgIHI6bnVtYmVyXHJcbiAgICBjOm51bWJlclxyXG4gICAgdjpJbHVja3lTaGVldENlbGxkYXRhVmFsdWUgfCBzdHJpbmcgfCBudWxsXHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBMdWNreVNoZWV0Q2VsbGRhdGFWYWx1ZSBpbXBsZW1lbnRzIElsdWNreVNoZWV0Q2VsbGRhdGFWYWx1ZXtcclxuICAgIGN0OiBMdWNreVNoZWV0Q2VsbEZvcm1hdCB8IHVuZGVmaW5lZCAvL2NlbGx0eXBlLENlbGwgdmFsdWUgZm9ybWF0OiB0ZXh0LCB0aW1lLCBldGMuIG51bWZtdHNcclxuICAgIGJnOiBzdHJpbmcgfCB1bmRlZmluZWQvL2JhY2tncm91bmQsI2ZmZjAwMCxcdGZpbGxcclxuICAgIGZmOiBzdHJpbmcgfCB1bmRlZmluZWQvL2ZvbnRmYW1pbHksIGZvbnRzXHJcbiAgICBmYzogc3RyaW5nIHwgdW5kZWZpbmVkLy9mb250Y29sb3IgZm9udHNcclxuICAgIGJsOiBudW1iZXIgfCB1bmRlZmluZWQvL0JvbGQsIGZvbnRzXHJcbiAgICBpdDogbnVtYmVyIHwgdW5kZWZpbmVkLy9pdGFsaWMsIGZvbnRzXHJcbiAgICBmczogbnVtYmVyIHwgdW5kZWZpbmVkLy9mb250IHNpemUsIGZvbnRzXHJcbiAgICBjbDogbnVtYmVyIHwgdW5kZWZpbmVkLy9zdHJpa2UsIDAgUmVndWxhciwgMSBzdHJpa2VzLCBmb250c1xyXG4gICAgdW46IG51bWJlciB8IHVuZGVmaW5lZC8vdW5kZXJsaW5lLCAwIFJlZ3VsYXIsIDEgdW5kZXJsaW5lcywgZm9udHNcclxuICAgIHZ0OiBudW1iZXIgfCB1bmRlZmluZWQvL1ZlcnRpY2FsIGFsaWdubWVudCwgMCBtaWRkbGUsIDEgdXAsIDIgZG93biwgYWxpZ25tZW50XHJcbiAgICBodDogbnVtYmVyIHwgdW5kZWZpbmVkLy9Ib3Jpem9udGFsIGFsaWdubWVudCwwIGNlbnRlciwgMSBsZWZ0LCAyIHJpZ2h0LCBhbGlnbm1lbnRcclxuICAgIG1jOiBJbHVja3lTaGVldENlbGxkYXRhVmFsdWVNZXJnZSB8IHVuZGVmaW5lZCAvL01lcmdlIENlbGxzLCBtZXJnZUNlbGxzXHJcbiAgICB0cjogbnVtYmVyIHwgdW5kZWZpbmVkIC8vVGV4dCByb3RhdGlvbiwwOiAw44CBMyBWZXJ0aWNhbCB0ZXh0IGFsaWdubWVudFxyXG4gICAgdGI6IG51bWJlciB8IHVuZGVmaW5lZCAvL1RleHQgd3JhcCwwIHRydW5jYXRpb24sIDEgb3ZlcmZsb3csIDIgd29yZCB3cmFwLCBhbGlnbm1lbnRcclxuICAgIHY6IHN0cmluZyB8IHVuZGVmaW5lZCAvL09yaWdpbmFsIHZhbHVlLCB2XHJcbiAgICBtOiBzdHJpbmcgfCB1bmRlZmluZWQgLy9EaXNwbGF5IHZhbHVlLCB2XHJcbiAgICBmOiBzdHJpbmcgfCB1bmRlZmluZWQgLy9mb3JtdWxhLCBmXHJcbiAgICBydDpudW1iZXIgfCB1bmRlZmluZWQgLy90ZXh0IHJvdGF0aW9uIGFuZ2xlIDAtMTgwIGFsaWdubWVudFxyXG4gICAgcXA6bnVtYmVyIHwgdW5kZWZpbmVkIC8vcXVvdGVQcmVmaXgsIHNob3cgbnVtYmVyIGFzIHN0cmluZ1xyXG59XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIEx1Y2t5U2hlZXRDZWxsRm9ybWF0IGltcGxlbWVudHMgSUx1Y2t5U2hlZXRDZWxsRm9ybWF0IHtcclxuICAgIGZhOnN0cmluZ1xyXG4gICAgdDpzdHJpbmdcclxuICAgIHM6THVja3lJbmxpbmVTdHJpbmdbXSB8IHVuZGVmaW5lZFxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgTHVja3lJbmxpbmVTdHJpbmcgaW1wbGVtZW50cyBJTHVja3lJbmxpbmVTdHJpbmcge1xyXG4gICAgZmY6c3RyaW5nIHwgdW5kZWZpbmVkIC8vZm9udCBmYW1pbHlcclxuICAgIGZjOnN0cmluZyB8IHVuZGVmaW5lZC8vZm9udCBjb2xvclxyXG4gICAgZnM6bnVtYmVyIHwgdW5kZWZpbmVkLy9mb250IHNpemVcclxuICAgIGNsOm51bWJlciB8IHVuZGVmaW5lZC8vc3RyaWtlXHJcbiAgICB1bjpudW1iZXIgfCB1bmRlZmluZWQvL3VuZGVybGluZVxyXG4gICAgYmw6bnVtYmVyIHwgdW5kZWZpbmVkLy9ibG9kXHJcbiAgICBpdDpudW1iZXIgfCB1bmRlZmluZWQvL2l0YWxpY1xyXG4gICAgdmE6bnVtYmVyIHwgdW5kZWZpbmVkLy8xc3ViIGFuZCAyc3VwZXIgYW5kIDBub25lXHJcbiAgICB2OnN0cmluZyB8IHVuZGVmaW5lZFxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgTHVja3lDb25maWcgaW1wbGVtZW50cyBJbHVja3lTaGVldENvbmZpZ3tcclxuICAgIG1lcmdlOklsdWNreVNoZWV0Q29uZmlnTWVyZ2VzXHJcbiAgICBib3JkZXJJbmZvOklsdWNreVNoZWV0Ym9yZGVySW5mb0NlbGxGb3JJbXBbXVxyXG4gICAgLy8gX2JvcmRlckluZm86IElNYXBsdWNreVNoZWV0Ym9yZGVySW5mb0NlbGxGb3JJbXBcclxuICAgIHJvd2xlbjpJbHVja3lTaGVldFJvd0FuZENvbHVtbkxlblxyXG4gICAgY29sdW1ubGVuOklsdWNreVNoZWV0Um93QW5kQ29sdW1uTGVuXHJcbiAgICByb3doaWRkZW46SWx1Y2t5U2hlZXRSb3dBbmRDb2x1bW5IaWRkZW5cclxuICAgIGNvbGhpZGRlbjpJbHVja3lTaGVldFJvd0FuZENvbHVtbkhpZGRlblxyXG5cclxuICAgIGN1c3RvbUhlaWdodDpJbHVja3lTaGVldFJvd0FuZENvbHVtbkhpZGRlblxyXG4gICAgY3VzdG9tV2lkdGg6SWx1Y2t5U2hlZXRSb3dBbmRDb2x1bW5IaWRkZW5cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbEZvckltcCBpbXBsZW1lbnRzIElsdWNreVNoZWV0Ym9yZGVySW5mb0NlbGxGb3JJbXB7XHJcbiAgICByYW5nZVR5cGU6c3RyaW5nXHJcbiAgICAvLyBjZWxsczpzdHJpbmdbXVxyXG4gICAgdmFsdWU6SWx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbFZhbHVlXHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBMdWNreVNoZWV0Ym9yZGVySW5mb0NlbGxWYWx1ZSBpbXBsZW1lbnRzIElsdWNreVNoZWV0Ym9yZGVySW5mb0NlbGxWYWx1ZXtcclxuICAgIHJvd19pbmRleDogbnVtYmVyXHJcbiAgICBjb2xfaW5kZXg6IG51bWJlclxyXG4gICAgbDogSWx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbFZhbHVlU3R5bGVcclxuICAgIHI6IElsdWNreVNoZWV0Ym9yZGVySW5mb0NlbGxWYWx1ZVN0eWxlXHJcbiAgICB0OiBJbHVja3lTaGVldGJvcmRlckluZm9DZWxsVmFsdWVTdHlsZVxyXG4gICAgYjogSWx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbFZhbHVlU3R5bGVcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbFZhbHVlU3R5bGUgaW1wbGVtZW50cyBJbHVja3lTaGVldGJvcmRlckluZm9DZWxsVmFsdWVTdHlsZXtcclxuICAgIFwic3R5bGVcIjogbnVtYmVyXHJcbiAgICBcImNvbG9yXCI6IHN0cmluZ1xyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgTHVja3lTaGVldENvbmZpZ01lcmdlIGltcGxlbWVudHMgSWx1Y2t5U2hlZXRDb25maWdNZXJnZXtcclxuICAgIHI6IG51bWJlclxyXG4gICAgYzogbnVtYmVyXHJcbiAgICByczogbnVtYmVyXHJcbiAgICBjczogbnVtYmVyXHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBMdWNreXNoZWV0Q2FsY0NoYWluIGltcGxlbWVudHMgSWx1Y2t5c2hlZXRDYWxjQ2hhaW57XHJcbiAgICByOm51bWJlclxyXG4gICAgYzpudW1iZXJcclxuICAgIGluZGV4OnN0cmluZyB8IHVuZGVmaW5lZFxyXG59XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIEx1Y2t5SW1hZ2VCYXNlIGltcGxlbWVudHMgSWx1Y2t5SW1hZ2V7XHJcbiAgICBib3JkZXI6IElsdWNreUltYWdlQm9yZGVyXHJcbiAgICBjcm9wOiBJbHVja3lJbWFnZUNyb3BcclxuICAgIGRlZmF1bHQ6IElsdWNreUltYWdlRGVmYXVsdFxyXG5cclxuICAgIGZpeGVkTGVmdDogbnVtYmVyXHJcbiAgICBmaXhlZFRvcDogbnVtYmVyXHJcbiAgICBpc0ZpeGVkUG9zOiBCb29sZWFuXHJcbiAgICBvcmlnaW5IZWlnaHQ6IG51bWJlclxyXG4gICAgb3JpZ2luV2lkdGg6IG51bWJlclxyXG4gICAgc3JjOiBzdHJpbmdcclxuICAgIHR5cGU6IHN0cmluZ1xyXG59IiwiaW1wb3J0IHsgSWx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbEZvckltcCxJbHVja3lTaGVldENlbGxkYXRhVmFsdWUsSWx1Y2t5U2hlZXRDZWxsZGF0YVZhbHVlTWVyZ2UsSUx1Y2t5U2hlZXRDZWxsRm9ybWF0IH0gZnJvbSBcIi4vSUx1Y2tcIjtcclxuaW1wb3J0IHsgUmVhZFhtbCwgRWxlbWVudCwgSVN0eWxlQ29sbGVjdGlvbnMsZ2V0Q29sb3IsZ2V0bGluZVN0cmluZ0F0dHIgfSBmcm9tIFwiLi9SZWFkWG1sXCI7XHJcbmltcG9ydCB7Z2V0WG1sQXR0aWJ1dGUsIGdldENvbHVtbldpZHRoUGl4ZWwsIGdldFJvd0hlaWdodFBpeGVsLGdldGNlbGxyYW5nZSwgZXNjYXBlQ2hhcmFjdGVyLCBpc0NoaW5lc2UsIGlzSmFwYW5lc2UsIGlzS29lcmEsaXNDb250YWluTXVsdGlUeXBlfSBmcm9tIFwiLi4vY29tbW9uL21ldGhvZFwiO1xyXG5pbXBvcnQgeyBTVF9DZWxsVHlwZSwgaW5kZXhlZENvbG9ycywgT0VNX0NIQVJTRVQsYm9yZGVyVHlwZXMsZm9udEZhbWlseXMgfSBmcm9tIFwiLi4vY29tbW9uL2NvbnN0YW50XCJcclxuaW1wb3J0IHsgSWF0dHJpYnV0ZUxpc3QsIHN0cmluZ1RvTnVtIH0gZnJvbSBcIi4uL0lDb21tb25cIjtcclxuaW1wb3J0IHsgTHVja3lTaGVldGJvcmRlckluZm9DZWxsVmFsdWVTdHlsZSxMdWNreVNoZWV0Ym9yZGVySW5mb0NlbGxGb3JJbXAsTHVja3lTaGVldGJvcmRlckluZm9DZWxsVmFsdWUsTHVja3lTaGVldENlbGxkYXRhQmFzZSxMdWNreVNoZWV0Q2VsbGRhdGFWYWx1ZSxMdWNreVNoZWV0Q2VsbEZvcm1hdCxMdWNreUlubGluZVN0cmluZyB9IGZyb20gXCIuL0x1Y2t5QmFzZVwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIEx1Y2t5U2hlZXRDZWxsZGF0YSBleHRlbmRzIEx1Y2t5U2hlZXRDZWxsZGF0YUJhc2V7XHJcbiAgICBfYm9yZGVyT2JqZWN0OklsdWNreVNoZWV0Ym9yZGVySW5mb0NlbGxGb3JJbXBcclxuICAgIF9mb211bGFSZWY6c3RyaW5nXHJcbiAgICBfZm9ybXVsYVNpOnN0cmluZ1xyXG4gICAgX2Zvcm11bGFUeXBlOnN0cmluZ1xyXG5cclxuICAgIHByaXZhdGUgc2hlZXRGaWxlOnN0cmluZ1xyXG4gICAgcHJpdmF0ZSByZWFkWG1sOlJlYWRYbWxcclxuICAgIHByaXZhdGUgY2VsbDpFbGVtZW50XHJcbiAgICBwcml2YXRlIHN0eWxlczpJU3R5bGVDb2xsZWN0aW9uc1xyXG4gICAgcHJpdmF0ZSBzaGFyZWRTdHJpbmdzOkVsZW1lbnRbXVxyXG4gICAgcHJpdmF0ZSBtZXJnZUNlbGxzOkVsZW1lbnRbXVxyXG5cclxuICAgIGNvbnN0cnVjdG9yKGNlbGw6RWxlbWVudCwgc3R5bGVzOklTdHlsZUNvbGxlY3Rpb25zLCBzaGFyZWRTdHJpbmdzOkVsZW1lbnRbXSwgbWVyZ2VDZWxsczpFbGVtZW50W10sIHNoZWV0RmlsZTpzdHJpbmcsIFJlYWRYbWw6UmVhZFhtbCl7XHJcbiAgICAgICAgLy9Qcml2YXRlXHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmNlbGwgPSBjZWxsO1xyXG4gICAgICAgIHRoaXMuc2hlZXRGaWxlID0gc2hlZXRGaWxlO1xyXG4gICAgICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzO1xyXG4gICAgICAgIHRoaXMuc2hhcmVkU3RyaW5ncyA9IHNoYXJlZFN0cmluZ3M7XHJcbiAgICAgICAgdGhpcy5yZWFkWG1sID0gUmVhZFhtbDtcclxuICAgICAgICB0aGlzLm1lcmdlQ2VsbHMgPSBtZXJnZUNlbGxzO1xyXG5cclxuICAgICAgICBsZXQgYXR0ckxpc3QgPSBjZWxsLmF0dHJpYnV0ZUxpc3Q7XHJcbiAgICAgICAgbGV0IHIgPSBhdHRyTGlzdC5yLCBzID0gYXR0ckxpc3QucywgdCA9IGF0dHJMaXN0LnQ7XHJcbiAgICAgICAgbGV0IHJhbmdlID0gZ2V0Y2VsbHJhbmdlKHIpO1xyXG5cclxuICAgICAgICB0aGlzLnIgPSByYW5nZS5yb3dbMF07XHJcbiAgICAgICAgdGhpcy5jID0gcmFuZ2UuY29sdW1uWzBdO1xyXG4gICAgICAgIHRoaXMudiA9IHRoaXMuZ2VuZXJhdGVWYWx1ZShzLCB0KTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwYXJhbSBzIFN0eWxlIGluZGV4ICxzdGFydCAxXHJcbiAgICAqIEBwYXJhbSB0IENlbGwgdHlwZSwgT3B0aW9uYWwgdmFsdWUgaXMgU1RfQ2VsbFR5cGUsIGl0J3MgZm91bmQgYXQgY29uc3RhdC50c1xyXG4gICAgKi9cclxuICAgIHByaXZhdGUgZ2VuZXJhdGVWYWx1ZShzOnN0cmluZywgdDpzdHJpbmcpe1xyXG4gICAgICAgIGxldCB2ID0gdGhpcy5jZWxsLmdldElubmVyRWxlbWVudHMoXCJ2XCIpO1xyXG4gICAgICAgIGxldCBmID0gdGhpcy5jZWxsLmdldElubmVyRWxlbWVudHMoXCJmXCIpO1xyXG5cclxuICAgICAgICBpZih2PT1udWxsKXtcclxuICAgICAgICAgICAgdiA9IHRoaXMuY2VsbC5nZXRJbm5lckVsZW1lbnRzKFwidFwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBjZWxsWGZzID0gdGhpcy5zdHlsZXNbXCJjZWxsWGZzXCJdIGFzIEVsZW1lbnRbXTtcclxuICAgICAgICBsZXQgY2VsbFN0eWxlWGZzID0gdGhpcy5zdHlsZXNbXCJjZWxsU3R5bGVYZnNcIl0gYXMgRWxlbWVudFtdO1xyXG4gICAgICAgIGxldCBjZWxsU3R5bGVzID0gdGhpcy5zdHlsZXNbXCJjZWxsU3R5bGVzXCJdIGFzIEVsZW1lbnRbXTtcclxuICAgICAgICBsZXQgZm9udHMgPSB0aGlzLnN0eWxlc1tcImZvbnRzXCJdIGFzIEVsZW1lbnRbXTtcclxuICAgICAgICBsZXQgZmlsbHMgPSB0aGlzLnN0eWxlc1tcImZpbGxzXCJdIGFzIEVsZW1lbnRbXTtcclxuICAgICAgICBsZXQgYm9yZGVycyA9IHRoaXMuc3R5bGVzW1wiYm9yZGVyc1wiXSBhcyBFbGVtZW50W107XHJcbiAgICAgICAgbGV0IG51bWZtdHMgPSB0aGlzLnN0eWxlc1tcIm51bWZtdHNcIl0gYXMgSWF0dHJpYnV0ZUxpc3Q7XHJcbiAgICAgICAgbGV0IGNsclNjaGVtZSA9IHRoaXMuc3R5bGVzW1wiY2xyU2NoZW1lXCJdIGFzIEVsZW1lbnRbXTtcclxuXHJcbiAgICAgICAgbGV0IHNoYXJlZFN0cmluZ3MgPSB0aGlzLnNoYXJlZFN0cmluZ3M7XHJcbiAgICAgICAgbGV0IGNlbGxWYWx1ZSA9IG5ldyBMdWNreVNoZWV0Q2VsbGRhdGFWYWx1ZSgpO1xyXG5cclxuICAgICAgICBpZihmIT1udWxsKXtcclxuICAgICAgICAgICAgbGV0IGZvcm11bGEgPSBmWzBdLCBhdHRyTGlzdCA9IGZvcm11bGEuYXR0cmlidXRlTGlzdDtcclxuICAgICAgICAgICAgbGV0IHQgPSBhdHRyTGlzdC50LCByZWYgPSBhdHRyTGlzdC5yZWYsIHNpID0gYXR0ckxpc3Quc2k7XHJcbiAgICAgICAgICAgIGxldCBmb3JtdWxhVmFsdWUgPWZbMF0udmFsdWU7XHJcbiAgICAgICAgICAgIGlmKHQ9PVwic2hhcmVkXCIpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZm9tdWxhUmVmID0gcmVmO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZm9ybXVsYVR5cGUgPSB0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZm9ybXVsYVNpID0gc2k7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2cocmVmLCB0LCBzaSk7XHJcbiAgICAgICAgICAgIGlmKHJlZiE9bnVsbCB8fCAoZm9ybXVsYVZhbHVlIT1udWxsICYmIGZvcm11bGFWYWx1ZS5sZW5ndGg+MCkpe1xyXG4gICAgICAgICAgICAgICAgZm9ybXVsYVZhbHVlID0gZXNjYXBlQ2hhcmFjdGVyKGZvcm11bGFWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBjZWxsVmFsdWUuZiA9IFwiPVwiICsgZm9ybXVsYVZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGZhbWlseUZvbnQgPSBudWxsO1xyXG4gICAgICAgIGxldCBxdW90ZVByZWZpeDtcclxuICAgICAgICBpZihzIT1udWxsKXtcclxuICAgICAgICAgICAgbGV0IHNOdW0gPSBwYXJzZUludChzKTtcclxuICAgICAgICAgICAgbGV0IGNlbGxYZiA9IGNlbGxYZnNbc051bV07XHJcbiAgICAgICAgICAgIGxldCB4ZklkID0gY2VsbFhmLmF0dHJpYnV0ZUxpc3QueGZJZDtcclxuXHJcbiAgICAgICAgICAgIGxldCBudW1GbXRJZCxmb250SWQsZmlsbElkLGJvcmRlcklkO1xyXG4gICAgICAgICAgICBsZXQgaG9yaXpvbnRhbCx2ZXJ0aWNhbCwgd3JhcFRleHQsIHRleHRSb3RhdGlvbiwgc2hyaW5rVG9GaXQsIGluZGVudCxhcHBseVByb3RlY3Rpb247XHJcblxyXG4gICAgICAgICAgICBpZih4ZklkIT1udWxsKXtcclxuICAgICAgICAgICAgICAgIGxldCBjZWxsU3R5bGVYZiA9IGNlbGxTdHlsZVhmc1twYXJzZUludCh4ZklkKV07XHJcbiAgICAgICAgICAgICAgICBsZXQgYXR0ckxpc3QgPSBjZWxsU3R5bGVYZi5hdHRyaWJ1dGVMaXN0O1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBhcHBseU51bWJlckZvcm1hdCA9IGF0dHJMaXN0LmFwcGx5TnVtYmVyRm9ybWF0O1xyXG4gICAgICAgICAgICAgICAgbGV0IGFwcGx5Rm9udCA9IGF0dHJMaXN0LmFwcGx5Rm9udDtcclxuICAgICAgICAgICAgICAgIGxldCBhcHBseUZpbGwgPSBhdHRyTGlzdC5hcHBseUZpbGw7XHJcbiAgICAgICAgICAgICAgICBsZXQgYXBwbHlCb3JkZXIgPSBhdHRyTGlzdC5hcHBseUJvcmRlcjtcclxuICAgICAgICAgICAgICAgIGxldCBhcHBseUFsaWdubWVudCA9IGF0dHJMaXN0LmFwcGx5QWxpZ25tZW50O1xyXG4gICAgICAgICAgICAgICAgLy8gbGV0IGFwcGx5UHJvdGVjdGlvbiA9IGF0dHJMaXN0LmFwcGx5UHJvdGVjdGlvbjtcclxuXHJcbiAgICAgICAgICAgICAgICBhcHBseVByb3RlY3Rpb24gPSBhdHRyTGlzdC5hcHBseVByb3RlY3Rpb247XHJcbiAgICAgICAgICAgICAgICBxdW90ZVByZWZpeCA9IGF0dHJMaXN0LnF1b3RlUHJlZml4O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmKGFwcGx5TnVtYmVyRm9ybWF0IT1cIjBcIiAmJiBhdHRyTGlzdC5udW1GbXRJZCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYoYXR0ckxpc3QubnVtRm10SWQhPVwiMFwiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtRm10SWQgPSBhdHRyTGlzdC5udW1GbXRJZDtcclxuICAgICAgICAgICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZihhcHBseUZvbnQhPVwiMFwiICYmIGF0dHJMaXN0LmZvbnRJZCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9udElkID0gYXR0ckxpc3QuZm9udElkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYoYXBwbHlGaWxsIT1cIjBcIiAmJiBhdHRyTGlzdC5maWxsSWQhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbGxJZCA9IGF0dHJMaXN0LmZpbGxJZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKGFwcGx5Qm9yZGVyIT1cIjBcIiAmJiBhdHRyTGlzdC5ib3JkZXJJZCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVySWQgPSBhdHRyTGlzdC5ib3JkZXJJZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmKGFwcGx5QWxpZ25tZW50IT1udWxsICYmIGFwcGx5QWxpZ25tZW50IT1cIjBcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFsaWdubWVudCA9IGNlbGxTdHlsZVhmLmdldElubmVyRWxlbWVudHMoXCJhbGlnbm1lbnRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoYWxpZ25tZW50IT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGF0dHJMaXN0ID0gYWxpZ25tZW50WzBdLmF0dHJpYnV0ZUxpc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGF0dHJMaXN0Lmhvcml6b250YWwhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaG9yaXpvbnRhbCA9IGF0dHJMaXN0Lmhvcml6b250YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoYXR0ckxpc3QudmVydGljYWwhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVydGljYWwgPSBhdHRyTGlzdC52ZXJ0aWNhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihhdHRyTGlzdC53cmFwVGV4dCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3cmFwVGV4dCA9IGF0dHJMaXN0LndyYXBUZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGF0dHJMaXN0LnRleHRSb3RhdGlvbiE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0Um90YXRpb24gPSBhdHRyTGlzdC50ZXh0Um90YXRpb247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoYXR0ckxpc3Quc2hyaW5rVG9GaXQhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hyaW5rVG9GaXQgPSBhdHRyTGlzdC5zaHJpbmtUb0ZpdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihhdHRyTGlzdC5pbmRlbnQhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZW50ID0gYXR0ckxpc3QuaW5kZW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBsZXQgYXBwbHlOdW1iZXJGb3JtYXQgPSBjZWxsWGYuYXR0cmlidXRlTGlzdC5hcHBseU51bWJlckZvcm1hdDtcclxuICAgICAgICAgICAgbGV0IGFwcGx5Rm9udCA9IGNlbGxYZi5hdHRyaWJ1dGVMaXN0LmFwcGx5Rm9udDtcclxuICAgICAgICAgICAgbGV0IGFwcGx5RmlsbCA9IGNlbGxYZi5hdHRyaWJ1dGVMaXN0LmFwcGx5RmlsbDtcclxuICAgICAgICAgICAgbGV0IGFwcGx5Qm9yZGVyID0gY2VsbFhmLmF0dHJpYnV0ZUxpc3QuYXBwbHlCb3JkZXI7XHJcbiAgICAgICAgICAgIGxldCBhcHBseUFsaWdubWVudCA9IGNlbGxYZi5hdHRyaWJ1dGVMaXN0LmFwcGx5QWxpZ25tZW50O1xyXG5cclxuICAgICAgICAgICAgaWYoY2VsbFhmLmF0dHJpYnV0ZUxpc3QuYXBwbHlQcm90ZWN0aW9uIT1udWxsKXtcclxuICAgICAgICAgICAgICAgIGFwcGx5UHJvdGVjdGlvbiA9IGNlbGxYZi5hdHRyaWJ1dGVMaXN0LmFwcGx5UHJvdGVjdGlvbjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoY2VsbFhmLmF0dHJpYnV0ZUxpc3QucXVvdGVQcmVmaXghPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgcXVvdGVQcmVmaXggPSBjZWxsWGYuYXR0cmlidXRlTGlzdC5xdW90ZVByZWZpeDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoYXBwbHlOdW1iZXJGb3JtYXQhPVwiMFwiICYmIGNlbGxYZi5hdHRyaWJ1dGVMaXN0Lm51bUZtdElkIT1udWxsKXtcclxuICAgICAgICAgICAgICAgIG51bUZtdElkID0gY2VsbFhmLmF0dHJpYnV0ZUxpc3QubnVtRm10SWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoYXBwbHlGb250IT1cIjBcIil7XHJcbiAgICAgICAgICAgICAgICBmb250SWQgPSBjZWxsWGYuYXR0cmlidXRlTGlzdC5mb250SWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoYXBwbHlGaWxsIT1cIjBcIil7XHJcbiAgICAgICAgICAgICAgICBmaWxsSWQgPSBjZWxsWGYuYXR0cmlidXRlTGlzdC5maWxsSWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYoYXBwbHlCb3JkZXIhPVwiMFwiKXtcclxuICAgICAgICAgICAgICAgIGJvcmRlcklkID1jZWxsWGYuYXR0cmlidXRlTGlzdC5ib3JkZXJJZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihhcHBseUFsaWdubWVudCE9XCIwXCIpe1xyXG4gICAgICAgICAgICAgICAgbGV0IGFsaWdubWVudCA9IGNlbGxYZi5nZXRJbm5lckVsZW1lbnRzKFwiYWxpZ25tZW50XCIpO1xyXG4gICAgICAgICAgICAgICAgaWYoYWxpZ25tZW50IT1udWxsICYmIGFsaWdubWVudC5sZW5ndGg+MCl7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGF0dHJMaXN0ID0gYWxpZ25tZW50WzBdLmF0dHJpYnV0ZUxpc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoYXR0ckxpc3QuaG9yaXpvbnRhbCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvcml6b250YWwgPSBhdHRyTGlzdC5ob3Jpem9udGFsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZihhdHRyTGlzdC52ZXJ0aWNhbCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnRpY2FsID0gYXR0ckxpc3QudmVydGljYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGF0dHJMaXN0LndyYXBUZXh0IT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgd3JhcFRleHQgPSBhdHRyTGlzdC53cmFwVGV4dDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoYXR0ckxpc3QudGV4dFJvdGF0aW9uIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFJvdGF0aW9uID0gYXR0ckxpc3QudGV4dFJvdGF0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZihhdHRyTGlzdC5zaHJpbmtUb0ZpdCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNocmlua1RvRml0ID0gYXR0ckxpc3Quc2hyaW5rVG9GaXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGF0dHJMaXN0LmluZGVudCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGVudCA9IGF0dHJMaXN0LmluZGVudDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgaWYobnVtRm10SWQhPXVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgICAgICBsZXQgbnVtZiA9IG51bWZtdHNbcGFyc2VJbnQobnVtRm10SWQpXTtcclxuICAgICAgICAgICAgICAgIGxldCBjZWxsRm9ybWF0ID0gbmV3IEx1Y2t5U2hlZXRDZWxsRm9ybWF0KCk7XHJcbiAgICAgICAgICAgICAgICBjZWxsRm9ybWF0LmZhID0gZXNjYXBlQ2hhcmFjdGVyKG51bWYpO1xyXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2cobnVtZiwgbnVtRm10SWQsIHRoaXMudik7XHJcbiAgICAgICAgICAgICAgICBjZWxsRm9ybWF0LnQgPSB0IHx8ICdkJztcclxuICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS5jdCA9IGNlbGxGb3JtYXQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKGZpbGxJZCE9dW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgICAgIGxldCBmaWxsSWROdW0gPSBwYXJzZUludChmaWxsSWQpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGZpbGwgID0gZmlsbHNbZmlsbElkTnVtXTtcclxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGNlbGxWYWx1ZS52KTtcclxuICAgICAgICAgICAgICAgIGxldCBiZyA9IHRoaXMuZ2V0QmFja2dyb3VuZEJ5RmlsbChmaWxsLCBjbHJTY2hlbWUpO1xyXG4gICAgICAgICAgICAgICAgaWYoYmchPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS5iZyA9IGJnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgaWYoZm9udElkIT11bmRlZmluZWQpe1xyXG4gICAgICAgICAgICAgICAgbGV0IGZvbnRJZE51bSA9IHBhcnNlSW50KGZvbnRJZCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgZm9udCA9IGZvbnRzW2ZvbnRJZE51bV07XHJcbiAgICAgICAgICAgICAgICBpZihmb250IT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgc3ogPSBmb250LmdldElubmVyRWxlbWVudHMoXCJzelwiKTsvL2ZvbnQgc2l6ZVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjb2xvcnMgPSBmb250LmdldElubmVyRWxlbWVudHMoXCJjb2xvclwiKTsvL2ZvbnQgY29sb3JcclxuICAgICAgICAgICAgICAgICAgICBsZXQgZmFtaWx5ID0gZm9udC5nZXRJbm5lckVsZW1lbnRzKFwibmFtZVwiKTsvL2ZvbnQgZmFtaWx5XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZhbWlseU92ZXJyaWRlcyA9IGZvbnQuZ2V0SW5uZXJFbGVtZW50cyhcImZhbWlseVwiKTsvL2ZvbnQgZmFtaWx5IHdpbGwgYmUgb3ZlcnJpZGVkIGJ5IG5hbWVcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY2hhcnNldCA9IGZvbnQuZ2V0SW5uZXJFbGVtZW50cyhcImNoYXJzZXRcIik7Ly9mb250IGNoYXJzZXRcclxuICAgICAgICAgICAgICAgICAgICBsZXQgYm9sZHMgPSBmb250LmdldElubmVyRWxlbWVudHMoXCJiXCIpOy8vZm9udCBib2xkXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGl0YWxpY3MgPSBmb250LmdldElubmVyRWxlbWVudHMoXCJpXCIpOy8vZm9udCBpdGFsaWNcclxuICAgICAgICAgICAgICAgICAgICBsZXQgc3RyaWtlcyA9IGZvbnQuZ2V0SW5uZXJFbGVtZW50cyhcInN0cmlrZVwiKTsvL2ZvbnQgaXRhbGljXHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHVuZGVybGluZXMgPSBmb250LmdldElubmVyRWxlbWVudHMoXCJ1XCIpOy8vZm9udCBpdGFsaWNcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoc3ohPW51bGwgJiYgc3oubGVuZ3RoPjApe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZnMgPSBzelswXS5hdHRyaWJ1dGVMaXN0LnZhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoZnMhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLmZzID0gcGFyc2VJbnQoZnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoY29sb3JzIT1udWxsICYmIGNvbG9ycy5sZW5ndGg+MCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjb2xvciA9IGNvbG9yc1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZjID0gZ2V0Q29sb3IoY29sb3IsIHRoaXMuc3R5bGVzLCBcInRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGZjIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS5mYyA9IGZjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZmFtaWx5T3ZlcnJpZGVzIT1udWxsICYmIGZhbWlseU92ZXJyaWRlcy5sZW5ndGg+MCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWwgPSBmYW1pbHlPdmVycmlkZXNbMF0uYXR0cmlidXRlTGlzdC52YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHZhbCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYW1pbHlGb250ID0gZm9udEZhbWlseXNbdmFsXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoZmFtaWx5IT1udWxsICYmIGZhbWlseS5sZW5ndGg+MCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB2YWwgPSBmYW1pbHlbMF0uYXR0cmlidXRlTGlzdC52YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHZhbCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUuZmYgPSB2YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihib2xkcyE9bnVsbCAmJiBib2xkcy5sZW5ndGg+MCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBib2xkID0gYm9sZHNbMF0uYXR0cmlidXRlTGlzdC52YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGJvbGQ9PVwiMFwiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS5ibCA9ICAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUuYmwgPSAgMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYoaXRhbGljcyE9bnVsbCAmJiBpdGFsaWNzLmxlbmd0aD4wKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGl0YWxpYyA9IGl0YWxpY3NbMF0uYXR0cmlidXRlTGlzdC52YWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGl0YWxpYz09XCIwXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLml0ID0gIDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS5pdCA9ICAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihzdHJpa2VzIT1udWxsICYmIHN0cmlrZXMubGVuZ3RoPjApe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3RyaWtlID0gc3RyaWtlc1swXS5hdHRyaWJ1dGVMaXN0LnZhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3RyaWtlPT1cIjBcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUuY2wgPSAgMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLmNsID0gIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKHVuZGVybGluZXMhPW51bGzCoCYmwqB1bmRlcmxpbmVzLmxlbmd0aD4wKXtcclxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgbGV0wqB1bmRlcmxpbmXCoD3CoHVuZGVybGluZXNbMF0uYXR0cmlidXRlTGlzdC52YWw7XHJcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoGlmKHVuZGVybGluZT09XCJzaW5nbGVcIil7XHJcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgY2VsbFZhbHVlLnVuwqA9wqDCoDE7XHJcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoH1cclxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgZWxzZcKgaWYodW5kZXJsaW5lPT1cImRvdWJsZVwiKXtcclxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBjZWxsVmFsdWUudW7CoD3CoMKgMjtcclxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgfVxyXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBlbHNlwqBpZih1bmRlcmxpbmU9PVwic2luZ2xlQWNjb3VudGluZ1wiKXtcclxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBjZWxsVmFsdWUudW7CoD3CoMKgMztcclxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgfVxyXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBlbHNlwqBpZih1bmRlcmxpbmU9PVwiZG91YmxlQWNjb3VudGluZ1wiKXtcclxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBjZWxsVmFsdWUudW7CoD3CoMKgNDtcclxuwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgfVxyXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqBlbHNle1xyXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoGNlbGxWYWx1ZS51bsKgPcKgwqAwO1xyXG7CoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqB9XHJcbsKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqDCoMKgwqB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIHZ0OiBudW1iZXIgfCB1bmRlZmluZWQvL1ZlcnRpY2FsIGFsaWdubWVudCwgMCBtaWRkbGUsIDEgdXAsIDIgZG93biwgYWxpZ25tZW50XHJcbiAgICAgICAgICAgIC8vIGh0OiBudW1iZXIgfCB1bmRlZmluZWQvL0hvcml6b250YWwgYWxpZ25tZW50LDAgY2VudGVyLCAxIGxlZnQsIDIgcmlnaHQsIGFsaWdubWVudFxyXG4gICAgICAgICAgICAvLyB0cjogbnVtYmVyIHwgdW5kZWZpbmVkIC8vVGV4dCByb3RhdGlvbiwwOiAw44CBMTogNDUg44CBMjogLTQ144CBMyBWZXJ0aWNhbCB0ZXh044CBNDogOTAg44CBNTogLTkwLCBhbGlnbm1lbnRcclxuICAgICAgICAgICAgLy8gdGI6IG51bWJlciB8IHVuZGVmaW5lZCAvL1RleHQgd3JhcCwwIHRydW5jYXRpb24sIDEgb3ZlcmZsb3csIDIgd29yZCB3cmFwLCBhbGlnbm1lbnRcclxuXHJcbiAgICAgICAgICAgIGlmKGhvcml6b250YWwhPXVuZGVmaW5lZCl7Ly9Ib3Jpem9udGFsIGFsaWdubWVudFxyXG4gICAgICAgICAgICAgICAgaWYoaG9yaXpvbnRhbD09XCJjZW50ZXJcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLmh0ID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoaG9yaXpvbnRhbD09XCJjZW50ZXJDb250aW51b3VzXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS5odCA9IDA7Ly9sdWNreXNoZWV0IHVuc3VwcG9ydFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihob3Jpem9udGFsPT1cImxlZnRcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLmh0ID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoaG9yaXpvbnRhbD09XCJyaWdodFwiKXtcclxuICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUuaHQgPSAyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihob3Jpem9udGFsPT1cImRpc3RyaWJ1dGVkXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS5odCA9IDA7Ly9sdWNreXNoZWV0IHVuc3VwcG9ydFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihob3Jpem9udGFsPT1cImZpbGxcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgY2VsbFZhbHVlLmh0ID0gMTsvL2x1Y2t5c2hlZXQgdW5zdXBwb3J0XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGhvcml6b250YWw9PVwiZ2VuZXJhbFwiKXtcclxuICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUuaHQgPSAxOy8vbHVja3lzaGVldCB1bnN1cHBvcnRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoaG9yaXpvbnRhbD09XCJqdXN0aWZ5XCIpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS5odCA9IDA7Ly9sdWNreXNoZWV0IHVuc3VwcG9ydFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUuaHQgPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZih2ZXJ0aWNhbCE9dW5kZWZpbmVkKXsvL1ZlcnRpY2FsIGFsaWdubWVudFxyXG4gICAgICAgICAgICAgICAgaWYodmVydGljYWw9PVwiYm90dG9tXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS52dCA9IDI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKHZlcnRpY2FsPT1cImNlbnRlclwiKXtcclxuICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUudnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZih2ZXJ0aWNhbD09XCJkaXN0cmlidXRlZFwiKXtcclxuICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUudnQgPSAwOy8vbHVja3lzaGVldCB1bnN1cHBvcnRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYodmVydGljYWw9PVwianVzdGlmeVwiKXtcclxuICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUudnQgPSAwOy8vbHVja3lzaGVldCB1bnN1cHBvcnRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYodmVydGljYWw9PVwidG9wXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS52dCA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS52dCA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvL3NvbWV0aW1lcyBib3R0b20gc3R5bGUgaXMgbG9zdCBhZnRlciBzZXR0aW5nIGl0IGluIGV4Y2VsXHJcbiAgICAgICAgICAgICAgICAvL3doZW4gdmVydGljYWwgaXMgdW5kZWZpbmVkIHNldCBpdCB0byAyLlxyXG4gICAgICAgICAgICAgICAgY2VsbFZhbHVlLnZ0ID0gMjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYod3JhcFRleHQhPXVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgICAgICBpZih3cmFwVGV4dD09XCIxXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS50YiA9IDI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS50YiA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS50YiA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHRleHRSb3RhdGlvbiE9dW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgICAgIC8vIHRyOiBudW1iZXIgfCB1bmRlZmluZWQgLy9UZXh0IHJvdGF0aW9uLDA6IDDjgIExOiA0NSDjgIEyOiAtNDXjgIEzIFZlcnRpY2FsIHRleHTjgIE0OiA5MCDjgIE1OiAtOTAsIGFsaWdubWVudFxyXG4gICAgICAgICAgICAgICAgaWYodGV4dFJvdGF0aW9uPT1cIjI1NVwiKXtcclxuICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUudHIgPSAzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gZWxzZSBpZih0ZXh0Um90YXRpb249PVwiNDVcIil7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgY2VsbFZhbHVlLnRyID0gMTtcclxuICAgICAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgICAgIC8vIGVsc2UgaWYodGV4dFJvdGF0aW9uPT1cIjkwXCIpe1xyXG4gICAgICAgICAgICAgICAgLy8gICAgIGNlbGxWYWx1ZS50ciA9IDQ7XHJcbiAgICAgICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICAgICAgICAvLyBlbHNlIGlmKHRleHRSb3RhdGlvbj09XCIxMzVcIil7XHJcbiAgICAgICAgICAgICAgICAvLyAgICAgY2VsbFZhbHVlLnRyID0gMjtcclxuICAgICAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgICAgIC8vIGVsc2UgaWYodGV4dFJvdGF0aW9uPT1cIjE4MFwiKXtcclxuICAgICAgICAgICAgICAgIC8vICAgICBjZWxsVmFsdWUudHIgPSA1O1xyXG4gICAgICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUudHIgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxWYWx1ZS5ydCA9ICBwYXJzZUludCh0ZXh0Um90YXRpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHNocmlua1RvRml0IT11bmRlZmluZWQpey8vbHVja3lzaGVldCB1bnN1cHBvcnRcclxuXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKGluZGVudCE9dW5kZWZpbmVkKXsvL2x1Y2t5c2hlZXQgdW5zdXBwb3J0XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihib3JkZXJJZCE9dW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgICAgIGxldCBib3JkZXJJZE51bSA9IHBhcnNlSW50KGJvcmRlcklkKTtcclxuICAgICAgICAgICAgICAgIGxldCBib3JkZXIgPSBib3JkZXJzW2JvcmRlcklkTnVtXTtcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMuX2JvcmRlcklkID0gYm9yZGVySWROdW07XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IGJvcmRlck9iamVjdCA9IG5ldyBMdWNreVNoZWV0Ym9yZGVySW5mb0NlbGxGb3JJbXAoKTtcclxuICAgICAgICAgICAgICAgIGJvcmRlck9iamVjdC5yYW5nZVR5cGUgPSBcImNlbGxcIjtcclxuICAgICAgICAgICAgICAgIC8vIGJvcmRlck9iamVjdC5jZWxscyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgbGV0IGJvcmRlckNlbGxWYWx1ZSA9IG5ldyBMdWNreVNoZWV0Ym9yZGVySW5mb0NlbGxWYWx1ZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGJvcmRlckNlbGxWYWx1ZS5yb3dfaW5kZXggPSB0aGlzLnI7XHJcbiAgICAgICAgICAgICAgICBib3JkZXJDZWxsVmFsdWUuY29sX2luZGV4ID0gdGhpcy5jO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBsZWZ0cyA9IGJvcmRlci5nZXRJbm5lckVsZW1lbnRzKFwibGVmdFwiKTtcclxuICAgICAgICAgICAgICAgIGxldCByaWdodHMgPSBib3JkZXIuZ2V0SW5uZXJFbGVtZW50cyhcInJpZ2h0XCIpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHRvcHMgPSBib3JkZXIuZ2V0SW5uZXJFbGVtZW50cyhcInRvcFwiKTtcclxuICAgICAgICAgICAgICAgIGxldCBib3R0b21zID0gYm9yZGVyLmdldElubmVyRWxlbWVudHMoXCJib3R0b21cIik7XHJcbiAgICAgICAgICAgICAgICBsZXQgZGlhZ29uYWxzID0gYm9yZGVyLmdldElubmVyRWxlbWVudHMoXCJkaWFnb25hbFwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRzID0gYm9yZGVyLmdldElubmVyRWxlbWVudHMoXCJzdGFydFwiKTtcclxuICAgICAgICAgICAgICAgIGxldCBlbmRzID0gYm9yZGVyLmdldElubmVyRWxlbWVudHMoXCJlbmRcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IGxlZnQgPSB0aGlzLmdldEJvcmRlckluZm8obGVmdHMpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHJpZ2h0ID0gdGhpcy5nZXRCb3JkZXJJbmZvKHJpZ2h0cyk7XHJcbiAgICAgICAgICAgICAgICBsZXQgdG9wID0gdGhpcy5nZXRCb3JkZXJJbmZvKHRvcHMpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGJvdHRvbSA9IHRoaXMuZ2V0Qm9yZGVySW5mbyhib3R0b21zKTtcclxuICAgICAgICAgICAgICAgIGxldCBkaWFnb25hbCA9IHRoaXMuZ2V0Qm9yZGVySW5mbyhkaWFnb25hbHMpO1xyXG5cclxuICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMuZ2V0Qm9yZGVySW5mbyhzdGFydHMpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGVuZCA9IHRoaXMuZ2V0Qm9yZGVySW5mbyhlbmRzKTtcclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgaXNBZGQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZihzdGFydCE9bnVsbCAmJiBzdGFydC5jb2xvciE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ2VsbFZhbHVlLmwgPSBzdGFydDtcclxuICAgICAgICAgICAgICAgICAgICBpc0FkZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoZW5kIT1udWxsICYmIGVuZC5jb2xvciE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ2VsbFZhbHVlLnIgPSBlbmQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNBZGQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKGxlZnQhPW51bGwgJiYgbGVmdC5jb2xvciE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ2VsbFZhbHVlLmwgPSBsZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlzQWRkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZihyaWdodCE9bnVsbCAmJiByaWdodC5jb2xvciE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ2VsbFZhbHVlLnIgPSByaWdodDtcclxuICAgICAgICAgICAgICAgICAgICBpc0FkZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYodG9wIT1udWxsICYmIHRvcC5jb2xvciE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ2VsbFZhbHVlLnQgPSB0b3A7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNBZGQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmKGJvdHRvbSE9bnVsbCAmJiBib3R0b20uY29sb3IhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgIGJvcmRlckNlbGxWYWx1ZS5iID0gYm90dG9tO1xyXG4gICAgICAgICAgICAgICAgICAgIGlzQWRkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZihpc0FkZCl7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyT2JqZWN0LnZhbHVlID0gYm9yZGVyQ2VsbFZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMuY29uZmlnLl9ib3JkZXJJbmZvW2JvcmRlcklkXSA9IGJvcmRlck9iamVjdDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ib3JkZXJPYmplY3QgPSBib3JkZXJPYmplY3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIGNlbGxWYWx1ZS50YiA9IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZih2IT1udWxsKXtcclxuICAgICAgICAgICAgbGV0IHZhbHVlID12WzBdLnZhbHVlO1xyXG5cclxuICAgICAgICAgICAgaWYoLyYjXFxkKzsvLnRlc3QodmFsdWUpKXtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5odG1sRGVjb2RlKHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYodD09U1RfQ2VsbFR5cGVbXCJTaGFyZWRTdHJpbmdcIl0pe1xyXG4gICAgICAgICAgICAgICAgbGV0IHNpSW5kZXggPSBwYXJzZUludCh2WzBdLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGxldCBzaGFyZWRTSSA9IHNoYXJlZFN0cmluZ3Nbc2lJbmRleF07XHJcblxyXG4gICAgICAgICAgICAgICAgbGV0IHJGbGFnID0gc2hhcmVkU0kuZ2V0SW5uZXJFbGVtZW50cyhcInJcIik7XHJcbiAgICAgICAgICAgICAgICBpZihyRmxhZz09bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRGbGFnID0gc2hhcmVkU0kuZ2V0SW5uZXJFbGVtZW50cyhcInRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYodEZsYWchPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGV4dCA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRGbGFnLmZvckVhY2goKHQpPT57XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ICs9IHQudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IGVzY2FwZUNoYXJhY3Rlcih0ZXh0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vaXNDb250YWluTXVsdGlUeXBlKHRleHQpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGZhbWlseUZvbnQ9PVwiUm9tYW5cIiAmJiB0ZXh0Lmxlbmd0aD4wKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZXh0QXJyYXkgPSB0ZXh0LnNwbGl0KFwiXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHByZVdvcmRUeXBlOnN0cmluZyA9IG51bGwsIHdvcmRUZXh0PVwiXCIsIHByZVdob2xlZjpzdHJpbmc9bnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB3aG9sZWYgPSBcIlRpbWVzIE5ldyBSb21hblwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2VsbFZhbHVlLmZmIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aG9sZWYgPSBjZWxsVmFsdWUuZmY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNlbGxGb3JtYXQgPSBjZWxsVmFsdWUuY3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjZWxsRm9ybWF0PT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsRm9ybWF0ID0gbmV3IEx1Y2t5U2hlZXRDZWxsRm9ybWF0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2VsbEZvcm1hdC5zPT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsRm9ybWF0LnMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IobGV0IGk9MDtpPHRleHRBcnJheS5sZW5ndGg7aSsrKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdyA9IHRleHRBcnJheVtpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHlwZTpzdHJpbmcgPSBudWxsLCBmZj13aG9sZWY7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGlzQ2hpbmVzZSh3KSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBcImNcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmY9XCLlrovkvZNcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihpc0phcGFuZXNlKHcpKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9IFwialwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZj1cIll1IEdvdGhpY1wiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGlzS29lcmEodykpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gXCJrXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZmPVwiTWFsZ3VuIEdvdGhpY1wiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gXCJlXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZigodHlwZSE9cHJlV29yZFR5cGUgJiYgcHJlV29yZFR5cGUhPW51bGwpIHx8IGk9PXRleHRBcnJheS5sZW5ndGgtMSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBJbmxpbmVTdHJpbmcgPSBuZXcgTHVja3lJbmxpbmVTdHJpbmcoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy5mZiA9IHByZVdob2xlZjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNlbGxWYWx1ZS5mYyE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuZmMgPSBjZWxsVmFsdWUuZmM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNlbGxWYWx1ZS5mcyE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuZnMgPSBjZWxsVmFsdWUuZnM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNlbGxWYWx1ZS5jbCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuY2wgPSBjZWxsVmFsdWUuY2w7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNlbGxWYWx1ZS51biE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcudW4gPSBjZWxsVmFsdWUudW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNlbGxWYWx1ZS5ibCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuYmwgPSBjZWxsVmFsdWUuYmw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNlbGxWYWx1ZS5pdCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuaXQgPSBjZWxsVmFsdWUuaXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGk9PXRleHRBcnJheS5sZW5ndGgtMSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih0eXBlPT1wcmVXb3JkVHlwZSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLmZmID0gZmY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLnYgPSB3b3JkVGV4dCArIHc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy5mZiA9IHByZVdob2xlZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcudiA9IHdvcmRUZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxGb3JtYXQucy5wdXNoKElubGluZVN0cmluZyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBJbmxpbmVTdHJpbmdMYXN0ID0gbmV3IEx1Y2t5SW5saW5lU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nTGFzdC5mZiA9IGZmO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZ0xhc3QudiA9IHc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2VsbFZhbHVlLmZjIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nTGFzdC5mYyA9IGNlbGxWYWx1ZS5mYztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNlbGxWYWx1ZS5mcyE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZ0xhc3QuZnMgPSBjZWxsVmFsdWUuZnM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjZWxsVmFsdWUuY2whPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmdMYXN0LmNsID0gY2VsbFZhbHVlLmNsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2VsbFZhbHVlLnVuIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nTGFzdC51biA9IGNlbGxWYWx1ZS51bjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNlbGxWYWx1ZS5ibCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZ0xhc3QuYmwgPSBjZWxsVmFsdWUuYmw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjZWxsVmFsdWUuaXQhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmdMYXN0Lml0ID0gY2VsbFZhbHVlLml0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsRm9ybWF0LnMucHVzaChJbmxpbmVTdHJpbmdMYXN0KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy52ID0gd29yZFRleHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsRm9ybWF0LnMucHVzaChJbmxpbmVTdHJpbmcpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd29yZFRleHQgPSB3O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JkVGV4dCArPSB3O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZVdvcmRUeXBlID0gdHlwZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVXaG9sZWYgPSBmZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsRm9ybWF0LnQgPSBcImlubGluZVN0clwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2VsbEZvcm1hdC5zID0gW0lubGluZVN0cmluZ107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUuY3QgPSBjZWxsRm9ybWF0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coY2VsbFZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNle1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGhpcy5yZXBsYWNlU3BlY2lhbFdyYXAodGV4dCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodGV4dC5pbmRleE9mKFwiXFxyXFxuXCIpPi0xIHx8IHRleHQuaW5kZXhPZihcIlxcblwiKT4tMSl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IElubGluZVN0cmluZyA9IG5ldyBMdWNreUlubGluZVN0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy52ID0gdGV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2VsbEZvcm1hdCA9IGNlbGxWYWx1ZS5jdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjZWxsRm9ybWF0PT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbEZvcm1hdCA9IG5ldyBMdWNreVNoZWV0Q2VsbEZvcm1hdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2VsbFZhbHVlLmZmIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLmZmID0gY2VsbFZhbHVlLmZmO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2VsbFZhbHVlLmZjIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLmZjID0gY2VsbFZhbHVlLmZjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2VsbFZhbHVlLmZzIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLmZzID0gY2VsbFZhbHVlLmZzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2VsbFZhbHVlLmNsIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLmNsID0gY2VsbFZhbHVlLmNsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2VsbFZhbHVlLnVuIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLnVuID0gY2VsbFZhbHVlLnVuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2VsbFZhbHVlLmJsIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLmJsID0gY2VsbFZhbHVlLmJsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2VsbFZhbHVlLml0IT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLml0ID0gY2VsbFZhbHVlLml0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbEZvcm1hdC50ID0gXCJpbmxpbmVTdHJcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsRm9ybWF0LnMgPSBbSW5saW5lU3RyaW5nXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUuY3QgPSBjZWxsRm9ybWF0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUudiA9IHRleHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVvdGVQcmVmaXggPSBcIjFcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzdHlsZXM6THVja3lJbmxpbmVTdHJpbmdbXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJGbGFnLmZvckVhY2goKHIpPT57XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0RmxhZyA9IHIuZ2V0SW5uZXJFbGVtZW50cyhcInRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByUHIgPSByLmdldElubmVyRWxlbWVudHMoXCJyUHJcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgSW5saW5lU3RyaW5nID0gbmV3IEx1Y2t5SW5saW5lU3RyaW5nKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0RmxhZyE9bnVsbCAmJiB0RmxhZy5sZW5ndGg+MCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGV4dCA9IHRGbGFnWzBdLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRoaXMucmVwbGFjZVNwZWNpYWxXcmFwKHRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IGVzY2FwZUNoYXJhY3Rlcih0ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy52ID0gdGV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoclByIT1udWxsICYmIHJQci5sZW5ndGg+MCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZnJwciA9IHJQclswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzeiA9IGdldGxpbmVTdHJpbmdBdHRyKGZycHIsXCJzelwiKSwgckZvbnQ9Z2V0bGluZVN0cmluZ0F0dHIoZnJwcixcInJGb250XCIpLCBmYW1pbHk9Z2V0bGluZVN0cmluZ0F0dHIoZnJwcixcImZhbWlseVwiKSwgY2hhcnNldD1nZXRsaW5lU3RyaW5nQXR0cihmcnByLFwiY2hhcnNldFwiKSwgc2NoZW1lPWdldGxpbmVTdHJpbmdBdHRyKGZycHIsXCJzY2hlbWVcIiksIGI9Z2V0bGluZVN0cmluZ0F0dHIoZnJwcixcImJcIiksIGk9Z2V0bGluZVN0cmluZ0F0dHIoZnJwcixcImlcIiksIHU9Z2V0bGluZVN0cmluZ0F0dHIoZnJwcixcInVcIiksIHN0cmlrZT1nZXRsaW5lU3RyaW5nQXR0cihmcnByLFwic3RyaWtlXCIpLCB2ZXJ0QWxpZ249Z2V0bGluZVN0cmluZ0F0dHIoZnJwcixcInZlcnRBbGlnblwiKSwgY29sb3I7XHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjRWxlID0gZnJwci5nZXRJbm5lckVsZW1lbnRzKFwiY29sb3JcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjRWxlIT1udWxsICYmIGNFbGUubGVuZ3RoPjApe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yID0gZ2V0Q29sb3IoY0VsZVswXSx0aGlzLnN0eWxlcywgXCJ0XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZmY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZihmYW1pbHkhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgIGZmID0gZm9udEZhbWlseXNbZmFtaWx5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHJGb250IT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZiA9IHJGb250O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoZmYhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy5mZiA9IGZmO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihjZWxsVmFsdWUuZmYhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy5mZiA9IGNlbGxWYWx1ZS5mZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjb2xvciE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLmZjID0gY29sb3I7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGNlbGxWYWx1ZS5mYyE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLmZjID0gY2VsbFZhbHVlLmZjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN6IT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuZnMgPSBwYXJzZUludChzeik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGNlbGxWYWx1ZS5mcyE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLmZzID0gY2VsbFZhbHVlLmZzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHN0cmlrZSE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLmNsID0gcGFyc2VJbnQoc3RyaWtlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoY2VsbFZhbHVlLmNsIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuY2wgPSBjZWxsVmFsdWUuY2w7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodSE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLnVuID0gcGFyc2VJbnQodSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGNlbGxWYWx1ZS51biE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLnVuID0gY2VsbFZhbHVlLnVuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGIhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy5ibCA9IHBhcnNlSW50KGIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihjZWxsVmFsdWUuYmwhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy5ibCA9IGNlbGxWYWx1ZS5ibDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihpIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuaXQgPSBwYXJzZUludChpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoY2VsbFZhbHVlLml0IT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuaXQgPSBjZWxsVmFsdWUuaXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYodmVydEFsaWduIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcudmEgPSBwYXJzZUludCh2ZXJ0QWxpZ24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmZjpzdHJpbmcgfCB1bmRlZmluZWQgLy9mb250IGZhbWlseVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmM6c3RyaW5nIHwgdW5kZWZpbmVkLy9mb250IGNvbG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBmczpudW1iZXIgfCB1bmRlZmluZWQvL2ZvbnQgc2l6ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2w6bnVtYmVyIHwgdW5kZWZpbmVkLy9zdHJpa2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVuOm51bWJlciB8IHVuZGVmaW5lZC8vdW5kZXJsaW5lXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBibDpudW1iZXIgfCB1bmRlZmluZWQvL2Jsb2RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0Om51bWJlciB8IHVuZGVmaW5lZC8vaXRhbGljXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB2OnN0cmluZyB8IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihJbmxpbmVTdHJpbmcuZmY9PW51bGwgJiYgY2VsbFZhbHVlLmZmIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuZmYgPSBjZWxsVmFsdWUuZmY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoSW5saW5lU3RyaW5nLmZjPT1udWxsICYmIGNlbGxWYWx1ZS5mYyE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLmZjID0gY2VsbFZhbHVlLmZjO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKElubGluZVN0cmluZy5mcz09bnVsbCAmJiBjZWxsVmFsdWUuZnMhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy5mcyA9IGNlbGxWYWx1ZS5mcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihJbmxpbmVTdHJpbmcuY2w9PW51bGwgJiYgY2VsbFZhbHVlLmNsIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuY2wgPSBjZWxsVmFsdWUuY2w7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoSW5saW5lU3RyaW5nLnVuPT1udWxsICYmIGNlbGxWYWx1ZS51biE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSW5saW5lU3RyaW5nLnVuID0gY2VsbFZhbHVlLnVuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKElubGluZVN0cmluZy5ibD09bnVsbCAmJiBjZWxsVmFsdWUuYmwhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElubGluZVN0cmluZy5ibCA9IGNlbGxWYWx1ZS5ibDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihJbmxpbmVTdHJpbmcuaXQ9PW51bGwgJiYgY2VsbFZhbHVlLml0IT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJbmxpbmVTdHJpbmcuaXQgPSBjZWxsVmFsdWUuaXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXMucHVzaChJbmxpbmVTdHJpbmcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBsZXQgY2VsbEZvcm1hdCA9IGNlbGxWYWx1ZS5jdDtcclxuICAgICAgICAgICAgICAgICAgICBpZihjZWxsRm9ybWF0PT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbEZvcm1hdCA9IG5ldyBMdWNreVNoZWV0Q2VsbEZvcm1hdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjZWxsRm9ybWF0LnQgPSBcImlubGluZVN0clwiO1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxGb3JtYXQucyA9IHN0eWxlcztcclxuICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWUuY3QgPSBjZWxsRm9ybWF0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHRvIGJlIGNvbmZpcm1lZFxyXG4gICAgICAgICAgICBlbHNlIGlmKHQ9PVNUX0NlbGxUeXBlW1wiSW5saW5lU3RyaW5nXCJdICYmIHYhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgY2VsbFZhbHVlLnYgPSBcIidcIisgdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGVzY2FwZUNoYXJhY3Rlcih2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICBjZWxsVmFsdWUudiA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihxdW90ZVByZWZpeCE9bnVsbCl7XHJcbiAgICAgICAgICAgIGNlbGxWYWx1ZS5xcCA9IHBhcnNlSW50KHF1b3RlUHJlZml4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjZWxsVmFsdWU7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgcmVwbGFjZVNwZWNpYWxXcmFwKHRleHQ6c3RyaW5nKTpzdHJpbmd7XHJcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvX3gwMDBEXy9nLCBcIlwiKS5yZXBsYWNlKC8mIzEzOyYjMTA7L2csIFwiXFxyXFxuXCIpLnJlcGxhY2UoLyYjMTM7L2csIFwiXFxyXCIpLnJlcGxhY2UoLyYjMTA7L2csIFwiXFxuXCIpO1xyXG4gICAgICAgIHJldHVybiB0ZXh0O1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBwcml2YXRlIGdldEJhY2tncm91bmRCeUZpbGwoZmlsbDpFbGVtZW50LCBjbHJTY2hlbWU6RWxlbWVudFtdKTpzdHJpbmd8bnVsbHtcclxuICAgICAgICBsZXQgcGF0dGVybkZpbGxzID0gZmlsbC5nZXRJbm5lckVsZW1lbnRzKFwicGF0dGVybkZpbGxcIik7XHJcbiAgICAgICAgaWYocGF0dGVybkZpbGxzIT1udWxsKXtcclxuICAgICAgICAgICAgbGV0IHBhdHRlcm5GaWxsID0gcGF0dGVybkZpbGxzWzBdO1xyXG4gICAgICAgICAgICBsZXQgZmdDb2xvcnMgPSBwYXR0ZXJuRmlsbC5nZXRJbm5lckVsZW1lbnRzKFwiZmdDb2xvclwiKTtcclxuICAgICAgICAgICAgbGV0IGJnQ29sb3JzID0gcGF0dGVybkZpbGwuZ2V0SW5uZXJFbGVtZW50cyhcImJnQ29sb3JcIik7XHJcbiAgICAgICAgICAgIGxldCBmZywgYmc7XHJcbiAgICAgICAgICAgIGlmKGZnQ29sb3JzIT1udWxsKXtcclxuICAgICAgICAgICAgICAgIGxldCBmZ0NvbG9yID0gZmdDb2xvcnNbMF07XHJcbiAgICAgICAgICAgICAgICBmZyA9IGdldENvbG9yKGZnQ29sb3IsIHRoaXMuc3R5bGVzKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoYmdDb2xvcnMhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgbGV0IGJnQ29sb3IgPSBiZ0NvbG9yc1swXTtcclxuICAgICAgICAgICAgICAgIGJnID0gZ2V0Q29sb3IoYmdDb2xvciwgdGhpcy5zdHlsZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGZnQ29sb3JzLGJnQ29sb3JzLGNsclNjaGVtZSk7XHJcbiAgICAgICAgICAgIGlmKGZnIT1udWxsKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmKGJnIT1udWxsKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBiZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICBsZXQgZ3JhZGllbnRmaWxscyA9IGZpbGwuZ2V0SW5uZXJFbGVtZW50cyhcImdyYWRpZW50RmlsbFwiKTtcclxuICAgICAgICAgICAgaWYoZ3JhZGllbnRmaWxscyE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAvL2dyYWllbnQgY29sb3IgZmlsbCBoYW5kbGVyXHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBnZXRCb3JkZXJJbmZvKGJvcmRlcnM6RWxlbWVudFtdKTpMdWNreVNoZWV0Ym9yZGVySW5mb0NlbGxWYWx1ZVN0eWxle1xyXG4gICAgICAgIGlmKGJvcmRlcnM9PW51bGwpe1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBib3JkZXIgPSBib3JkZXJzWzBdLCBhdHRyTGlzdCA9IGJvcmRlci5hdHRyaWJ1dGVMaXN0O1xyXG4gICAgICAgIGxldCBjbHJTY2hlbWUgPSB0aGlzLnN0eWxlc1tcImNsclNjaGVtZVwiXSBhcyBFbGVtZW50W107XHJcbiAgICAgICAgbGV0IHN0eWxlOnN0cmluZyA9IGF0dHJMaXN0LnN0eWxlO1xyXG4gICAgICAgIGlmKHN0eWxlPT1udWxsIHx8IHN0eWxlPT1cIm5vbmVcIil7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGNvbG9ycyA9IGJvcmRlci5nZXRJbm5lckVsZW1lbnRzKFwiY29sb3JcIik7XHJcbiAgICAgICAgbGV0IGNvbG9yUmV0ID0gXCIjMDAwMDAwXCI7XHJcbiAgICAgICAgaWYoY29sb3JzIT1udWxsKXtcclxuICAgICAgICAgICAgbGV0IGNvbG9yID0gY29sb3JzWzBdO1xyXG4gICAgICAgICAgICBjb2xvclJldCA9IGdldENvbG9yKGNvbG9yLCB0aGlzLnN0eWxlcywgXCJiXCIpO1xyXG4gICAgICAgICAgICBpZihjb2xvclJldD09bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBjb2xvclJldCA9IFwiIzAwMDAwMFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgcmV0ID0gbmV3IEx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbFZhbHVlU3R5bGUoKTtcclxuICAgICAgICByZXQuc3R5bGUgPSBib3JkZXJUeXBlc1tzdHlsZV07XHJcbiAgICAgICAgcmV0LmNvbG9yID0gY29sb3JSZXQ7XHJcblxyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBodG1sRGVjb2RlIChzdHI6c3RyaW5nKTpzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvJiMoeCk/KFteJl17MSw1fSk7L2csZnVuY3Rpb24oJCwkMSwkMikge1xyXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludCgkMiAsICQxID8gMTY6MTApKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG59XHJcblxyXG4iLCLvu79pbXBvcnQgeyBJTHVja3lGaWxlLElsdWNreVNoZWV0Um93QW5kQ29sdW1uSGlkZGVuLElsdWNreVNoZWV0Um93QW5kQ29sdW1uTGVufSBmcm9tIFwiLi9JTHVja1wiO1xyXG5pbXBvcnQgeyBMdWNreVNoZWV0fSBmcm9tIFwiLi9MdWNreVNoZWV0XCI7XHJcbmltcG9ydCB7SXVwbG9hZGZpbGVMaXN0LCBJYXR0cmlidXRlTGlzdH0gZnJvbSBcIi4uL0lDb21tb25cIjtcclxuaW1wb3J0IHt3b3JrQm9va0ZpbGUsIGNvcmVGaWxlLCBhcHBGaWxlLCBzdHlsZXNGaWxlLCBzaGFyZWRTdHJpbmdzRmlsZSxudW1GbXREZWZhdWx0LHRoZW1lMUZpbGUsY2FsY0NoYWluRmlsZSx3b3JrYm9va1JlbHMsIG51bUZtdERlZmF1bHRNYXB9IGZyb20gXCIuLi9jb21tb24vY29uc3RhbnRcIjtcclxuaW1wb3J0IHsgUmVhZFhtbCxJU3R5bGVDb2xsZWN0aW9ucyxFbGVtZW50IH0gZnJvbSBcIi4vUmVhZFhtbFwiO1xyXG5pbXBvcnQge2dldFhtbEF0dGlidXRlfSBmcm9tIFwiLi4vY29tbW9uL21ldGhvZFwiO1xyXG5pbXBvcnQgeyBMdWNreUZpbGVCYXNlLEx1Y2t5RmlsZUluZm8sTHVja3lTaGVldEJhc2UsTHVja3lTaGVldENlbGxkYXRhQmFzZSxMdWNreVNoZWV0Q2VsbGRhdGFWYWx1ZSxMdWNreVNoZWV0Q2VsbEZvcm1hdCB9IGZyb20gXCIuL0x1Y2t5QmFzZVwiO1xyXG5pbXBvcnQge0ltYWdlTGlzdH0gZnJvbSBcIi4vTHVja3lJbWFnZVwiO1xyXG5cclxuZXhwb3J0IGNsYXNzIEx1Y2t5RmlsZSBleHRlbmRzIEx1Y2t5RmlsZUJhc2Uge1xyXG5cclxuICAgIHByaXZhdGUgZmlsZXM6SXVwbG9hZGZpbGVMaXN0XHJcbiAgICBwcml2YXRlIHNoZWV0TmFtZUxpc3Q6SWF0dHJpYnV0ZUxpc3RcclxuICAgIHByaXZhdGUgcmVhZFhtbDpSZWFkWG1sXHJcbiAgICBwcml2YXRlIGZpbGVOYW1lOnN0cmluZ1xyXG4gICAgcHJpdmF0ZSBzdHlsZXM6SVN0eWxlQ29sbGVjdGlvbnNcclxuICAgIHByaXZhdGUgc2hhcmVkU3RyaW5nczpFbGVtZW50W11cclxuICAgIHByaXZhdGUgY2FsY0NoYWluOkVsZW1lbnRbXVxyXG4gICAgcHJpdmF0ZSBpbWFnZUxpc3Q6SW1hZ2VMaXN0XHJcblxyXG4gICAgY29uc3RydWN0b3IoZmlsZXM6SXVwbG9hZGZpbGVMaXN0LCBmaWxlTmFtZTpzdHJpbmcpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuZmlsZXMgPSBmaWxlcztcclxuICAgICAgICB0aGlzLmZpbGVOYW1lID0gZmlsZU5hbWU7XHJcbiAgICAgICAgdGhpcy5yZWFkWG1sID0gbmV3IFJlYWRYbWwoZmlsZXMpO1xyXG4gICAgICAgIHRoaXMuZ2V0U2hlZXROYW1lTGlzdCgpO1xyXG5cclxuICAgICAgICB0aGlzLnNoYXJlZFN0cmluZ3MgPSB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzc3Qvc2lcIiwgc2hhcmVkU3RyaW5nc0ZpbGUpO1xyXG4gICAgICAgIHRoaXMuY2FsY0NoYWluID0gdGhpcy5yZWFkWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiY2FsY0NoYWluL2NcIiwgY2FsY0NoYWluRmlsZSk7XHJcbiAgICAgICAgdGhpcy5zdHlsZXMgPSB7fTtcclxuICAgICAgICB0aGlzLnN0eWxlc1tcImNlbGxYZnNcIl0gPSAgdGhpcy5yZWFkWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiY2VsbFhmcy94ZlwiLCBzdHlsZXNGaWxlKTtcclxuICAgICAgICB0aGlzLnN0eWxlc1tcImNlbGxTdHlsZVhmc1wiXSA9ICB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJjZWxsU3R5bGVYZnMveGZcIiwgc3R5bGVzRmlsZSk7XHJcbiAgICAgICAgdGhpcy5zdHlsZXNbXCJjZWxsU3R5bGVzXCJdID0gIHRoaXMucmVhZFhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImNlbGxTdHlsZXMvY2VsbFN0eWxlXCIsIHN0eWxlc0ZpbGUpO1xyXG4gICAgICAgIHRoaXMuc3R5bGVzW1wiZm9udHNcIl0gPSAgdGhpcy5yZWFkWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiZm9udHMvZm9udFwiLCBzdHlsZXNGaWxlKTtcclxuICAgICAgICB0aGlzLnN0eWxlc1tcImZpbGxzXCJdID0gIHRoaXMucmVhZFhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImZpbGxzL2ZpbGxcIiwgc3R5bGVzRmlsZSk7XHJcbiAgICAgICAgdGhpcy5zdHlsZXNbXCJib3JkZXJzXCJdID0gIHRoaXMucmVhZFhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImJvcmRlcnMvYm9yZGVyXCIsIHN0eWxlc0ZpbGUpO1xyXG4gICAgICAgIHRoaXMuc3R5bGVzW1wiY2xyU2NoZW1lXCJdID0gIHRoaXMucmVhZFhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImE6Y2xyU2NoZW1lL2E6ZGsxfGE6bHQxfGE6ZGsyfGE6bHQyfGE6YWNjZW50MXxhOmFjY2VudDJ8YTphY2NlbnQzfGE6YWNjZW50NHxhOmFjY2VudDV8YTphY2NlbnQ2fGE6aGxpbmt8YTpmb2xIbGlua1wiLCB0aGVtZTFGaWxlKTtcclxuICAgICAgICB0aGlzLnN0eWxlc1tcImluZGV4ZWRDb2xvcnNcIl0gPSAgdGhpcy5yZWFkWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiY29sb3JzL2luZGV4ZWRDb2xvcnMvcmdiQ29sb3JcIiwgc3R5bGVzRmlsZSk7XHJcbiAgICAgICAgdGhpcy5zdHlsZXNbXCJtcnVDb2xvcnNcIl0gPSAgdGhpcy5yZWFkWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiY29sb3JzL21ydUNvbG9ycy9jb2xvclwiLCBzdHlsZXNGaWxlKTtcclxuXHJcbiAgICAgICAgdGhpcy5pbWFnZUxpc3QgPSBuZXcgSW1hZ2VMaXN0KGZpbGVzKTtcclxuXHJcbiAgICAgICAgbGV0IG51bWZtdHMgPSAgdGhpcy5yZWFkWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwibnVtRm10L251bUZtdFwiLCBzdHlsZXNGaWxlKTtcclxuICAgICAgICBsZXQgbnVtRm10RGVmYXVsdEMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG51bUZtdERlZmF1bHQpKTtcclxuICAgICAgICBmb3IobGV0IGk9MDtpPG51bWZtdHMubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgICAgIGxldCBhdHRyTGlzdCA9IG51bWZtdHNbaV0uYXR0cmlidXRlTGlzdDtcclxuICAgICAgICAgICAgbGV0IG51bWZtdGlkID0gZ2V0WG1sQXR0aWJ1dGUoYXR0ckxpc3QsIFwibnVtRm10SWRcIiwgXCI0OVwiKTtcclxuICAgICAgICAgICAgbGV0IGZvcm1hdGNvZGUgPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJmb3JtYXRDb2RlXCIsIFwiQFwiKTtcclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2cobnVtZm10aWQsIGZvcm1hdGNvZGUpO1xyXG4gICAgICAgICAgICBpZighKG51bWZtdGlkIGluIG51bUZtdERlZmF1bHQpKXtcclxuICAgICAgICAgICAgICAgIG51bUZtdERlZmF1bHRDW251bWZtdGlkXSA9IG51bUZtdERlZmF1bHRNYXBbZm9ybWF0Y29kZV0gfHwgZm9ybWF0Y29kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkobnVtRm10RGVmYXVsdEMpLCBudW1mbXRzKTtcclxuICAgICAgICB0aGlzLnN0eWxlc1tcIm51bWZtdHNcIl0gPSAgbnVtRm10RGVmYXVsdEM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEByZXR1cm4gQWxsIHNoZWV0IG5hbWUgb2Ygd29ya2Jvb2tcclxuICAgICovXHJcbiAgICBwcml2YXRlIGdldFNoZWV0TmFtZUxpc3QoKXtcclxuICAgICAgICBsZXQgd29ya2Jvb2tSZWxMaXN0ID0gdGhpcy5yZWFkWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiUmVsYXRpb25zaGlwcy9SZWxhdGlvbnNoaXBcIiwgd29ya2Jvb2tSZWxzKTtcclxuICAgICAgICBpZih3b3JrYm9va1JlbExpc3Q9PW51bGwpe1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgcmVnZXggPSBuZXcgUmVnRXhwKFwid29ya3NoZWV0cy9bXi9dKj8ueG1sXCIpO1xyXG4gICAgICAgIGxldCBzaGVldE5hbWVzOklhdHRyaWJ1dGVMaXN0ID0ge307XHJcbiAgICAgICAgZm9yKGxldCBpPTA7aTx3b3JrYm9va1JlbExpc3QubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgICAgIGxldCByZWwgPSB3b3JrYm9va1JlbExpc3RbaV0sIGF0dHJMaXN0ID0gcmVsLmF0dHJpYnV0ZUxpc3Q7XHJcbiAgICAgICAgICAgIGxldCBpZCA9IGF0dHJMaXN0W1wiSWRcIl0sIHRhcmdldCA9IGF0dHJMaXN0W1wiVGFyZ2V0XCJdO1xyXG4gICAgICAgICAgICBpZihyZWdleC50ZXN0KHRhcmdldCkpe1xyXG4gICAgICAgICAgICAgICAgaWYodGFyZ2V0LmluZGV4T2YoJy94bCcpID09PSAwKXtcclxuICAgICAgICAgICAgICAgICAgICBzaGVldE5hbWVzW2lkXSA9ICAgdGFyZ2V0LnN1YnN0cigxKTtcclxuICAgICAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgICAgICAgIHNoZWV0TmFtZXNbaWRdID0gICBcInhsL1wiICsgdGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5zaGVldE5hbWVMaXN0ID0gc2hlZXROYW1lcztcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogQHBhcmFtIHNoZWV0TmFtZSBXb3JrU2hlZXQnbmFtZVxyXG4gICAgKiBAcmV0dXJuIHNoZWV0IGZpbGUgbmFtZSBhbmQgcGF0aCBpbiB6aXBcclxuICAgICovXHJcbiAgIHByaXZhdGUgZ2V0U2hlZXRGaWxlQnlzaGVldElkKHNoZWV0SWQ6c3RyaW5nKXtcclxuICAgICAgICAvLyBmb3IobGV0IGk9MDtpPHRoaXMuc2hlZXROYW1lTGlzdC5sZW5ndGg7aSsrKXtcclxuICAgICAgICAvLyAgICAgbGV0IHNoZWV0RmlsZU5hbWUgPSB0aGlzLnNoZWV0TmFtZUxpc3RbaV07XHJcbiAgICAgICAgLy8gICAgIGlmKHNoZWV0RmlsZU5hbWUuaW5kZXhPZihcInNoZWV0XCIrc2hlZXRJZCk+LTEpe1xyXG4gICAgICAgIC8vICAgICAgICAgcmV0dXJuIHNoZWV0RmlsZU5hbWU7XHJcbiAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hlZXROYW1lTGlzdFtzaGVldElkXTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogQHJldHVybiB3b3JrQm9vayBpbmZvcm1hdGlvblxyXG4gICAgKi9cclxuICAgIGdldFdvcmtCb29rSW5mbygpe1xyXG4gICAgICAgIGxldCBDb21wYW55ID0gdGhpcy5yZWFkWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiQ29tcGFueVwiLCBhcHBGaWxlKTtcclxuICAgICAgICBsZXQgQXBwVmVyc2lvbiA9IHRoaXMucmVhZFhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIkFwcFZlcnNpb25cIiwgYXBwRmlsZSk7XHJcbiAgICAgICAgbGV0IGNyZWF0b3IgPSB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJkYzpjcmVhdG9yXCIsIGNvcmVGaWxlKTtcclxuICAgICAgICBsZXQgbGFzdE1vZGlmaWVkQnkgPSB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJjcDpsYXN0TW9kaWZpZWRCeVwiLCBjb3JlRmlsZSk7XHJcbiAgICAgICAgbGV0IGNyZWF0ZWQgPSB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJkY3Rlcm1zOmNyZWF0ZWRcIiwgY29yZUZpbGUpO1xyXG4gICAgICAgIGxldCBtb2RpZmllZCA9IHRoaXMucmVhZFhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImRjdGVybXM6bW9kaWZpZWRcIiwgY29yZUZpbGUpO1xyXG4gICAgICAgIHRoaXMuaW5mbyA9IG5ldyBMdWNreUZpbGVJbmZvKCk7XHJcbiAgICAgICAgdGhpcy5pbmZvLm5hbWUgPSB0aGlzLmZpbGVOYW1lO1xyXG4gICAgICAgIHRoaXMuaW5mby5jcmVhdG9yID0gY3JlYXRvci5sZW5ndGg+MD9jcmVhdG9yWzBdLnZhbHVlOlwiXCI7XHJcbiAgICAgICAgdGhpcy5pbmZvLmxhc3Rtb2RpZmllZGJ5ID0gbGFzdE1vZGlmaWVkQnkubGVuZ3RoPjA/bGFzdE1vZGlmaWVkQnlbMF0udmFsdWU6XCJcIjtcclxuICAgICAgICB0aGlzLmluZm8uY3JlYXRlZFRpbWUgPSBjcmVhdGVkLmxlbmd0aD4wP2NyZWF0ZWRbMF0udmFsdWU6XCJcIjtcclxuICAgICAgICB0aGlzLmluZm8ubW9kaWZpZWRUaW1lID0gbW9kaWZpZWQubGVuZ3RoPjA/bW9kaWZpZWRbMF0udmFsdWU6XCJcIjtcclxuICAgICAgICB0aGlzLmluZm8uY29tcGFueSA9IENvbXBhbnkubGVuZ3RoPjA/Q29tcGFueVswXS52YWx1ZTpcIlwiO1xyXG4gICAgICAgIHRoaXMuaW5mby5hcHB2ZXJzaW9uID0gQXBwVmVyc2lvbi5sZW5ndGg+MD9BcHBWZXJzaW9uWzBdLnZhbHVlOlwiXCI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEByZXR1cm4gQWxsIHNoZWV0ICwgaW5jbHVkZSB3aG9sZSBpbmZvcm1hdGlvblxyXG4gICAgKi9cclxuICAgIGdldFNoZWV0c0Z1bGwoaXNJbml0aWFsQ2VsbDpib29sZWFuPXRydWUpe1xyXG4gICAgICAgIGxldCBzaGVldHMgPSB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzaGVldHMvc2hlZXRcIiwgd29ya0Jvb2tGaWxlKTtcclxuICAgICAgICBsZXQgc2hlZXRMaXN0OklhdHRyaWJ1dGVMaXN0ID0ge307XHJcbiAgICAgICAgZm9yKGxldCBrZXkgaW4gc2hlZXRzKXtcclxuICAgICAgICAgICAgbGV0IHNoZWV0ID0gc2hlZXRzW2tleV07XHJcbiAgICAgICAgICAgIHNoZWV0TGlzdFtzaGVldC5hdHRyaWJ1dGVMaXN0Lm5hbWVdID0gc2hlZXQuYXR0cmlidXRlTGlzdFtcInNoZWV0SWRcIl07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2hlZXRzID0gW107XHJcbiAgICAgICAgbGV0IG9yZGVyID0gMDtcclxuICAgICAgICBmb3IobGV0IGtleSBpbiBzaGVldHMpe1xyXG4gICAgICAgICAgICBsZXQgc2hlZXQgPSBzaGVldHNba2V5XTtcclxuICAgICAgICAgICAgbGV0IHNoZWV0TmFtZSA9IHNoZWV0LmF0dHJpYnV0ZUxpc3QubmFtZTtcclxuICAgICAgICAgICAgbGV0IHNoZWV0SWQgPSBzaGVldC5hdHRyaWJ1dGVMaXN0W1wic2hlZXRJZFwiXTtcclxuICAgICAgICAgICAgbGV0IHJpZCA9IHNoZWV0LmF0dHJpYnV0ZUxpc3RbXCJyOmlkXCJdO1xyXG4gICAgICAgICAgICBsZXQgc2hlZXRGaWxlID0gdGhpcy5nZXRTaGVldEZpbGVCeXNoZWV0SWQocmlkKTtcclxuICAgICAgICAgICAgbGV0IGhpZGUgPSBzaGVldC5hdHRyaWJ1dGVMaXN0LnN0YXRlID09PSBcImhpZGRlblwiID8gMSA6IDA7XHJcblxyXG4gICAgICAgICAgICBsZXQgZHJhd2luZyA9IHRoaXMucmVhZFhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIndvcmtzaGVldC9kcmF3aW5nXCIsIHNoZWV0RmlsZSksIGRyYXdpbmdGaWxlLCBkcmF3aW5nUmVsc0ZpbGU7XHJcbiAgICAgICAgICAgIGlmKGRyYXdpbmchPW51bGwgJiYgZHJhd2luZy5sZW5ndGg+MCl7XHJcbiAgICAgICAgICAgICAgICBsZXQgYXR0ckxpc3QgPSBkcmF3aW5nWzBdLmF0dHJpYnV0ZUxpc3Q7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmlkID0gZ2V0WG1sQXR0aWJ1dGUoYXR0ckxpc3QsIFwicjppZFwiLCBudWxsKTtcclxuICAgICAgICAgICAgICAgIGlmKHJpZCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgZHJhd2luZ0ZpbGUgPSB0aGlzLmdldERyYXdpbmdGaWxlKHJpZCwgc2hlZXRGaWxlKTtcclxuICAgICAgICAgICAgICAgICAgICBkcmF3aW5nUmVsc0ZpbGUgPSB0aGlzLmdldERyYXdpbmdSZWxzRmlsZShkcmF3aW5nRmlsZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHNoZWV0RmlsZSE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBsZXQgc2hlZXQgPSBuZXcgTHVja3lTaGVldChzaGVldE5hbWUsIHNoZWV0SWQsIG9yZGVyLCBpc0luaXRpYWxDZWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hlZXRGaWxlOnNoZWV0RmlsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZFhtbDp0aGlzLnJlYWRYbWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoZWV0TGlzdDpzaGVldExpc3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlczp0aGlzLnN0eWxlcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcmVkU3RyaW5nczp0aGlzLnNoYXJlZFN0cmluZ3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGNDaGFpbjp0aGlzLmNhbGNDaGFpbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VMaXN0OnRoaXMuaW1hZ2VMaXN0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3aW5nRmlsZTpkcmF3aW5nRmlsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHJhd2luZ1JlbHNGaWxlOiBkcmF3aW5nUmVsc0ZpbGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpZGU6IGhpZGUsXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb2x1bW5XaWR0aFNldCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yb3dIZWlnaHRTZXQgPSBbXTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmltYWdlUG9zaXRpb25DYWN1bGF0aW9uKHNoZWV0KTtcclxuXHJcbiAgICAgICAgICAgICAgICB0aGlzLnNoZWV0cy5wdXNoKHNoZWV0KTtcclxuICAgICAgICAgICAgICAgIG9yZGVyKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBjb2x1bW5XaWR0aFNldDpudW1iZXJbXSA9IFtdO1xyXG4gICAgcHJpdmF0ZSByb3dIZWlnaHRTZXQ6bnVtYmVyW10gPSBbXTtcclxuXHJcbiAgICBwcml2YXRlIGV4dGVuZEFycmF5KGluZGV4Om51bWJlciwgc2V0czpudW1iZXJbXSxkZWY6bnVtYmVyLCBoaWRkZW46SWx1Y2t5U2hlZXRSb3dBbmRDb2x1bW5IaWRkZW4sIGxlbnM6SWx1Y2t5U2hlZXRSb3dBbmRDb2x1bW5MZW4pe1xyXG4gICAgICAgIGlmKGluZGV4PHNldHMubGVuZ3RoKXtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSBzZXRzLmxlbmd0aCwgZW5kSW5kZXggPSBpbmRleDtcclxuICAgICAgICBsZXQgYWxsR2FwID0gMDtcclxuICAgICAgICBpZihzdGFydEluZGV4PjApe1xyXG4gICAgICAgICAgICBhbGxHYXAgPSBzZXRzW3N0YXJ0SW5kZXgtMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGVsc2V7XHJcbiAgICAgICAgLy8gICAgIHNldHMucHVzaCgwKTtcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgZm9yKGxldCBpPXN0YXJ0SW5kZXg7aTw9ZW5kSW5kZXg7aSsrKXtcclxuICAgICAgICAgICAgbGV0IGdhcCA9IGRlZiwgaXN0cmluZyAgPSBpLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGlmKGlzdHJpbmcgaW4gaGlkZGVuKXtcclxuICAgICAgICAgICAgICAgIGdhcCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZihpc3RyaW5nIGluIGxlbnMpe1xyXG4gICAgICAgICAgICAgICAgZ2FwID0gbGVuc1tpc3RyaW5nXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYWxsR2FwICs9IE1hdGgucm91bmQoZ2FwICsgMSk7XHJcblxyXG4gICAgICAgICAgICBzZXRzLnB1c2goYWxsR2FwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBpbWFnZVBvc2l0aW9uQ2FjdWxhdGlvbihzaGVldDpMdWNreVNoZWV0KXtcclxuICAgICAgICBsZXQgaW1hZ2VzID0gc2hlZXQuaW1hZ2VzLCBkZWZhdWx0Q29sV2lkdGggPSBzaGVldC5kZWZhdWx0Q29sV2lkdGgsIGRlZmF1bHRSb3dIZWlnaHQgPSBzaGVldC5kZWZhdWx0Um93SGVpZ2h0O1xyXG4gICAgICAgIGxldCBjb2xoaWRkZW4gPSB7fTtcclxuICAgICAgICBpZihzaGVldC5jb25maWcuY29saGlkZGVuKXtcclxuICAgICAgICAgICAgY29saGlkZGVuID0gc2hlZXQuY29uZmlnLmNvbGhpZGRlbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBjb2x1bW5sZW4gPSB7fTtcclxuICAgICAgICBpZihzaGVldC5jb25maWcuY29sdW1ubGVuKXtcclxuICAgICAgICAgICAgY29sdW1ubGVuID0gc2hlZXQuY29uZmlnLmNvbHVtbmxlbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCByb3doaWRkZW4gPSB7fTtcclxuICAgICAgICBpZihzaGVldC5jb25maWcucm93aGlkZGVuKXtcclxuICAgICAgICAgICAgcm93aGlkZGVuID0gc2hlZXQuY29uZmlnLnJvd2hpZGRlbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCByb3dsZW4gPSB7fTtcclxuICAgICAgICBpZihzaGVldC5jb25maWcucm93bGVuKXtcclxuICAgICAgICAgICAgcm93bGVuID0gc2hlZXQuY29uZmlnLnJvd2xlbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvcihsZXQga2V5IGluIGltYWdlcyl7XHJcbiAgICAgICAgICAgIGxldCBpbWFnZU9iamVjdDphbnkgPSBpbWFnZXNba2V5XTsvL0ltYWdlLCBsdWNreUltYWdlXHJcbiAgICAgICAgICAgIGxldCBmcm9tQ29sID0gaW1hZ2VPYmplY3QuZnJvbUNvbDtcclxuICAgICAgICAgICAgbGV0IGZyb21Db2xPZmYgPSBpbWFnZU9iamVjdC5mcm9tQ29sT2ZmO1xyXG4gICAgICAgICAgICBsZXQgZnJvbVJvdyA9IGltYWdlT2JqZWN0LmZyb21Sb3c7XHJcbiAgICAgICAgICAgIGxldCBmcm9tUm93T2ZmID0gaW1hZ2VPYmplY3QuZnJvbVJvd09mZjtcclxuXHJcbiAgICAgICAgICAgIGxldCB0b0NvbCA9IGltYWdlT2JqZWN0LnRvQ29sO1xyXG4gICAgICAgICAgICBsZXQgdG9Db2xPZmYgPSBpbWFnZU9iamVjdC50b0NvbE9mZjtcclxuICAgICAgICAgICAgbGV0IHRvUm93ID0gaW1hZ2VPYmplY3QudG9Sb3c7XHJcbiAgICAgICAgICAgIGxldCB0b1Jvd09mZiA9IGltYWdlT2JqZWN0LnRvUm93T2ZmO1xyXG5cclxuICAgICAgICAgICAgbGV0IHhfbiA9MCx5X24gPSAwO1xyXG4gICAgICAgICAgICBsZXQgY3hfbiA9IDAsIGN5X24gPSAwO1xyXG5cclxuICAgICAgICAgICAgaWYoZnJvbUNvbD49dGhpcy5jb2x1bW5XaWR0aFNldC5sZW5ndGgpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5leHRlbmRBcnJheShmcm9tQ29sLCB0aGlzLmNvbHVtbldpZHRoU2V0LCBkZWZhdWx0Q29sV2lkdGgsIGNvbGhpZGRlbiwgY29sdW1ubGVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihmcm9tQ29sPT0wKXtcclxuICAgICAgICAgICAgICAgIHhfbiA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIHhfbiA9IHRoaXMuY29sdW1uV2lkdGhTZXRbZnJvbUNvbC0xXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB4X24gPSB4X24gKyBmcm9tQ29sT2ZmO1xyXG5cclxuICAgICAgICAgICAgaWYoZnJvbVJvdz49dGhpcy5yb3dIZWlnaHRTZXQubGVuZ3RoKXtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXh0ZW5kQXJyYXkoZnJvbVJvdywgdGhpcy5yb3dIZWlnaHRTZXQsIGRlZmF1bHRSb3dIZWlnaHQsIHJvd2hpZGRlbiwgcm93bGVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihmcm9tUm93PT0wKXtcclxuICAgICAgICAgICAgICAgIHlfbiA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIHlfbiA9IHRoaXMucm93SGVpZ2h0U2V0W2Zyb21Sb3ctMV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgeV9uID0geV9uICsgZnJvbVJvd09mZjtcclxuXHJcblxyXG4gICAgICAgICAgICBpZih0b0NvbD49dGhpcy5jb2x1bW5XaWR0aFNldC5sZW5ndGgpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5leHRlbmRBcnJheSh0b0NvbCwgdGhpcy5jb2x1bW5XaWR0aFNldCwgZGVmYXVsdENvbFdpZHRoLCBjb2xoaWRkZW4sIGNvbHVtbmxlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYodG9Db2w9PTApe1xyXG4gICAgICAgICAgICAgICAgY3hfbiA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIGN4X24gPSB0aGlzLmNvbHVtbldpZHRoU2V0W3RvQ29sLTFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN4X24gPSBjeF9uICsgdG9Db2xPZmYtIHhfbjtcclxuXHJcbiAgICAgICAgICAgIGlmKHRvUm93Pj10aGlzLnJvd0hlaWdodFNldC5sZW5ndGgpe1xyXG4gICAgICAgICAgICAgICAgdGhpcy5leHRlbmRBcnJheSh0b1JvdywgdGhpcy5yb3dIZWlnaHRTZXQsIGRlZmF1bHRSb3dIZWlnaHQsIHJvd2hpZGRlbiwgcm93bGVuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZih0b1Jvdz09MCl7XHJcbiAgICAgICAgICAgICAgICBjeV9uID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgY3lfbiA9IHRoaXMucm93SGVpZ2h0U2V0W3RvUm93LTFdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjeV9uID0gY3lfbiArIHRvUm93T2ZmIC0geV9uO1xyXG5cclxuICAgICAgICAgICAgY29uc29sZS5sb2coZGVmYXVsdENvbFdpZHRoLCBjb2xoaWRkZW4gLCBjb2x1bW5sZW4pO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhmcm9tQ29sLCB0aGlzLmNvbHVtbldpZHRoU2V0W2Zyb21Db2xdICwgZnJvbUNvbE9mZik7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRvQ29sLCB0aGlzLmNvbHVtbldpZHRoU2V0W3RvQ29sXSAsIHRvQ29sT2ZmLCBKU09OLnN0cmluZ2lmeSh0aGlzLmNvbHVtbldpZHRoU2V0KSk7XHJcblxyXG4gICAgICAgICAgICBpbWFnZU9iamVjdC5vcmlnaW5XaWR0aCA9IGN4X247XHJcbiAgICAgICAgICAgIGltYWdlT2JqZWN0Lm9yaWdpbkhlaWdodCA9IGN5X247XHJcblxyXG4gICAgICAgICAgICBpbWFnZU9iamVjdC5jcm9wLmhlaWdodCA9IGN5X247XHJcbiAgICAgICAgICAgIGltYWdlT2JqZWN0LmNyb3Aud2lkdGggPSBjeF9uO1xyXG5cclxuICAgICAgICAgICAgaW1hZ2VPYmplY3QuZGVmYXVsdC5oZWlnaHQgPSBjeV9uO1xyXG4gICAgICAgICAgICBpbWFnZU9iamVjdC5kZWZhdWx0LmxlZnQgPSB4X247XHJcbiAgICAgICAgICAgIGltYWdlT2JqZWN0LmRlZmF1bHQudG9wID0geV9uO1xyXG4gICAgICAgICAgICBpbWFnZU9iamVjdC5kZWZhdWx0LndpZHRoID0gY3hfbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vY29uc29sZS5sb2codGhpcy5jb2x1bW5XaWR0aFNldCwgdGhpcy5yb3dIZWlnaHRTZXQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcmV0dXJuIGRyYXdpbmcgZmlsZSBzdHJpbmdcclxuICAgICovXHJcbiAgIHByaXZhdGUgZ2V0RHJhd2luZ0ZpbGUocmlkOnN0cmluZywgc2hlZXRGaWxlOnN0cmluZyk6c3RyaW5ne1xyXG4gICAgICAgIGxldCBzaGVldFJlbHNQYXRoID0gXCJ4bC93b3Jrc2hlZXRzL19yZWxzL1wiO1xyXG4gICAgICAgIGxldCBzaGVldEZpbGVBcnIgPSBzaGVldEZpbGUuc3BsaXQoXCIvXCIpO1xyXG4gICAgICAgIGxldCBzaGVldFJlbHNOYW1lID0gc2hlZXRGaWxlQXJyW3NoZWV0RmlsZUFyci5sZW5ndGgtMV07XHJcblxyXG4gICAgICAgIGxldCBzaGVldFJlbHNGaWxlID0gc2hlZXRSZWxzUGF0aCArIHNoZWV0UmVsc05hbWUgKyBcIi5yZWxzXCI7XHJcblxyXG4gICAgICAgIGxldCBkcmF3aW5nID0gdGhpcy5yZWFkWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiUmVsYXRpb25zaGlwcy9SZWxhdGlvbnNoaXBcIiwgc2hlZXRSZWxzRmlsZSk7XHJcbiAgICAgICAgaWYoZHJhd2luZy5sZW5ndGg+MCl7XHJcbiAgICAgICAgICAgIGZvcihsZXQgaT0wO2k8ZHJhd2luZy5sZW5ndGg7aSsrKXtcclxuICAgICAgICAgICAgICAgIGxldCByZWxhdGlvbnNoaXAgPSBkcmF3aW5nW2ldO1xyXG4gICAgICAgICAgICAgICAgbGV0IGF0dHJMaXN0ID0gcmVsYXRpb25zaGlwLmF0dHJpYnV0ZUxpc3Q7XHJcbiAgICAgICAgICAgICAgICBsZXQgcmVsYXRpb25zaGlwSWQgPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJJZFwiLCBudWxsKTtcclxuICAgICAgICAgICAgICAgIGlmKHJlbGF0aW9uc2hpcElkPT1yaWQpe1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0YXJnZXQgPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJUYXJnZXRcIiwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYodGFyZ2V0IT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5yZXBsYWNlKC9cXC5cXC5cXC8vZywgXCJcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHByaXZhdGUgZ2V0RHJhd2luZ1JlbHNGaWxlKGRyYXdpbmdGaWxlOnN0cmluZyk6c3RyaW5ne1xyXG4gICAgICAgIGxldCBkcmF3aW5nUmVsc1BhdGggPSBcInhsL2RyYXdpbmdzL19yZWxzL1wiO1xyXG4gICAgICAgIGxldCBkcmF3aW5nRmlsZUFyciA9IGRyYXdpbmdGaWxlLnNwbGl0KFwiL1wiKTtcclxuICAgICAgICBsZXQgZHJhd2luZ1JlbHNOYW1lID0gZHJhd2luZ0ZpbGVBcnJbZHJhd2luZ0ZpbGVBcnIubGVuZ3RoLTFdO1xyXG5cclxuICAgICAgICBsZXQgZHJhd2luZ1JlbHNGaWxlID0gZHJhd2luZ1JlbHNQYXRoICsgZHJhd2luZ1JlbHNOYW1lICsgXCIucmVsc1wiO1xyXG5cclxuICAgICAgICByZXR1cm4gZHJhd2luZ1JlbHNGaWxlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcmV0dXJuIEFsbCBzaGVldCBiYXNlIGluZm9ybWF0aW9uIHdpZHRob3V0IGNlbGwgYW5kIGNvbmZpZ1xyXG4gICAgKi9cclxuICAgIGdldFNoZWV0c1dpdGhvdXRDZWxsKCl7XHJcbiAgICAgICAgdGhpcy5nZXRTaGVldHNGdWxsKGZhbHNlKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogQHJldHVybiBMdWNreVNoZWV0IGZpbGUganNvblxyXG4gICAgKi9cclxuICAgIFBhcnNlKCk6c3RyaW5ne1xyXG4gICAgICAgIC8vIGxldCB4bWwgPSB0aGlzLnJlYWRYbWw7XHJcbiAgICAgICAgLy8gZm9yKGxldCBrZXkgaW4gdGhpcy5zaGVldE5hbWVMaXN0KXtcclxuICAgICAgICAvLyAgICAgbGV0IHNoZWV0TmFtZT10aGlzLnNoZWV0TmFtZUxpc3Rba2V5XTtcclxuICAgICAgICAvLyAgICAgbGV0IHNoZWV0Q29sdW1ucyA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInJvdy9jL2ZcIiwgc2hlZXROYW1lKTtcclxuICAgICAgICAvLyAgICAgY29uc29sZS5sb2coc2hlZXRDb2x1bW5zKTtcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgLy8gcmV0dXJuIFwiXCI7XHJcblxyXG4gICAgICAgIHRoaXMuZ2V0V29ya0Jvb2tJbmZvKCk7XHJcbiAgICAgICAgdGhpcy5nZXRTaGVldHNGdWxsKCk7XHJcblxyXG4gICAgICAgIC8vIGZvcihsZXQgaT0wO2k8dGhpcy5zaGVldHMubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgLy8gICAgIGxldCBzaGVldCA9IHRoaXMuc2hlZXRzW2ldO1xyXG4gICAgICAgIC8vICAgICBsZXQgX2JvcmRlckluZm8gPSBzaGVldC5jb25maWcuX2JvcmRlckluZm87XHJcbiAgICAgICAgLy8gICAgIGlmKF9ib3JkZXJJbmZvPT1udWxsKXtcclxuICAgICAgICAvLyAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIC8vICAgICB9XHJcbiAgICAgICAgLy8gICAgIGxldCBfYm9yZGVySW5mb0tleXMgPSBPYmplY3Qua2V5cyhfYm9yZGVySW5mbyk7XHJcbiAgICAgICAgLy8gICAgIF9ib3JkZXJJbmZvS2V5cy5zb3J0KCk7XHJcbiAgICAgICAgLy8gICAgIGZvcihsZXQgYT0wO2E8X2JvcmRlckluZm9LZXlzLmxlbmd0aDthKyspe1xyXG4gICAgICAgIC8vICAgICAgICAgbGV0IGtleSA9IHBhcnNlSW50KF9ib3JkZXJJbmZvS2V5c1thXSk7XHJcbiAgICAgICAgLy8gICAgICAgICBsZXQgYiA9IF9ib3JkZXJJbmZvW2tleV07XHJcbiAgICAgICAgLy8gICAgICAgICBpZihiLmNlbGxzLmxlbmd0aD09MCl7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgLy8gICAgICAgICB9XHJcbiAgICAgICAgLy8gICAgICAgICBpZihzaGVldC5jb25maWcuYm9yZGVySW5mbz09bnVsbCl7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgc2hlZXQuY29uZmlnLmJvcmRlckluZm8gPSBbXTtcclxuICAgICAgICAvLyAgICAgICAgIH1cclxuICAgICAgICAvLyAgICAgICAgIHNoZWV0LmNvbmZpZy5ib3JkZXJJbmZvLnB1c2goYik7XHJcbiAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAvLyB9XHJcblxyXG4gICAgICAgIHJldHVybiB0aGlzLnRvSnNvblN0cmluZyh0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHRvSnNvblN0cmluZyhmaWxlOklMdWNreUZpbGUpOnN0cmluZ3tcclxuICAgICAgICBsZXQgTHVja3lPdXRQdXRGaWxlID0gbmV3IEx1Y2t5RmlsZUJhc2UoKTtcclxuICAgICAgICBMdWNreU91dFB1dEZpbGUuaW5mbyA9IGZpbGUuaW5mbztcclxuICAgICAgICBMdWNreU91dFB1dEZpbGUuc2hlZXRzID0gW107XHJcblxyXG4gICAgICAgIGZpbGUuc2hlZXRzLmZvckVhY2goKHNoZWV0KT0+e1xyXG4gICAgICAgICAgICBsZXQgc2hlZXRvdXQgPSBuZXcgTHVja3lTaGVldEJhc2UoKTtcclxuICAgICAgICAgICAgLy9sZXQgYXR0ck5hbWUgPSBbXCJuYW1lXCIsXCJjb2xvclwiLFwiY29uZmlnXCIsXCJpbmRleFwiLFwic3RhdHVzXCIsXCJvcmRlclwiLFwicm93XCIsXCJjb2x1bW5cIixcImx1Y2t5c2hlZXRfc2VsZWN0X3NhdmVcIixcInNjcm9sbExlZnRcIixcInNjcm9sbFRvcFwiLFwiem9vbVJhdGlvXCIsXCJzaG93R3JpZExpbmVzXCIsXCJkZWZhdWx0Q29sV2lkdGhcIixcImRlZmF1bHRSb3dIZWlnaHRcIixcImNlbGxkYXRhXCIsXCJjaGFydFwiLFwiaXNQaXZvdFRhYmxlXCIsXCJwaXZvdFRhYmxlXCIsXCJsdWNreXNoZWV0X2NvbmRpdGlvbmZvcm1hdF9zYXZlXCIsXCJmcmVlemVuXCIsXCJjYWxjQ2hhaW5cIl07XHJcblxyXG4gICAgICAgICAgICBpZihzaGVldC5uYW1lIT1udWxsKXtcclxuICAgICAgICAgICAgICAgIHNoZWV0b3V0Lm5hbWUgPSBzaGVldC5uYW1lO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihzaGVldC5jb2xvciE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBzaGVldG91dC5jb2xvciA9IHNoZWV0LmNvbG9yO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihzaGVldC5jb25maWchPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgc2hlZXRvdXQuY29uZmlnID0gc2hlZXQuY29uZmlnO1xyXG4gICAgICAgICAgICAgICAgLy8gaWYoc2hlZXRvdXQuY29uZmlnLl9ib3JkZXJJbmZvIT1udWxsKXtcclxuICAgICAgICAgICAgICAgIC8vICAgICBkZWxldGUgc2hlZXRvdXQuY29uZmlnLl9ib3JkZXJJbmZvO1xyXG4gICAgICAgICAgICAgICAgLy8gfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihzaGVldC5pbmRleCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBzaGVldG91dC5pbmRleCA9IHNoZWV0LmluZGV4O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihzaGVldC5zdGF0dXMhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgc2hlZXRvdXQuc3RhdHVzID0gc2hlZXQuc3RhdHVzO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihzaGVldC5vcmRlciE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBzaGVldG91dC5vcmRlciA9IHNoZWV0Lm9yZGVyO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihzaGVldC5yb3chPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgc2hlZXRvdXQucm93ID0gc2hlZXQucm93O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihzaGVldC5jb2x1bW4hPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgc2hlZXRvdXQuY29sdW1uID0gc2hlZXQuY29sdW1uO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihzaGVldC5sdWNreXNoZWV0X3NlbGVjdF9zYXZlIT1udWxsKXtcclxuICAgICAgICAgICAgICAgIHNoZWV0b3V0Lmx1Y2t5c2hlZXRfc2VsZWN0X3NhdmUgPSBzaGVldC5sdWNreXNoZWV0X3NlbGVjdF9zYXZlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihzaGVldC5zY3JvbGxMZWZ0IT1udWxsKXtcclxuICAgICAgICAgICAgICAgIHNoZWV0b3V0LnNjcm9sbExlZnQgPSBzaGVldC5zY3JvbGxMZWZ0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihzaGVldC5zY3JvbGxUb3AhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgc2hlZXRvdXQuc2Nyb2xsVG9wID0gc2hlZXQuc2Nyb2xsVG9wO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihzaGVldC56b29tUmF0aW8hPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgc2hlZXRvdXQuem9vbVJhdGlvID0gc2hlZXQuem9vbVJhdGlvO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihzaGVldC5zaG93R3JpZExpbmVzIT1udWxsKXtcclxuICAgICAgICAgICAgICAgIHNoZWV0b3V0LnNob3dHcmlkTGluZXMgPSBzaGVldC5zaG93R3JpZExpbmVzO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihzaGVldC5kZWZhdWx0Q29sV2lkdGghPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgc2hlZXRvdXQuZGVmYXVsdENvbFdpZHRoID0gc2hlZXQuZGVmYXVsdENvbFdpZHRoO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihzaGVldC5kZWZhdWx0Um93SGVpZ2h0IT1udWxsKXtcclxuICAgICAgICAgICAgICAgIHNoZWV0b3V0LmRlZmF1bHRSb3dIZWlnaHQgPSBzaGVldC5kZWZhdWx0Um93SGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc2hlZXQubGFzdENvbnRlbnREYXRhICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHNoZWV0b3V0Lmxhc3RDb250ZW50RGF0YSA9IHNoZWV0Lmxhc3RDb250ZW50RGF0YTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYoc2hlZXQuY2VsbGRhdGEhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgLy8gc2hlZXRvdXQuY2VsbGRhdGEgPSBzaGVldC5jZWxsZGF0YTtcclxuICAgICAgICAgICAgICAgIHNoZWV0b3V0LmNlbGxkYXRhID0gW107XHJcbiAgICAgICAgICAgICAgICBzaGVldC5jZWxsZGF0YS5mb3JFYWNoKChjZWxsKT0+e1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjZWxsb3V0ID0gbmV3IEx1Y2t5U2hlZXRDZWxsZGF0YUJhc2UoKTtcclxuICAgICAgICAgICAgICAgICAgICBjZWxsb3V0LnIgPSBjZWxsLnI7XHJcbiAgICAgICAgICAgICAgICAgICAgY2VsbG91dC5jID0gY2VsbC5jO1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbGxvdXQudiA9IGNlbGwudjtcclxuICAgICAgICAgICAgICAgICAgICBzaGVldG91dC5jZWxsZGF0YS5wdXNoKGNlbGxvdXQpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHNoZWV0LmNoYXJ0IT1udWxsKXtcclxuICAgICAgICAgICAgICAgIHNoZWV0b3V0LmNoYXJ0ID0gc2hlZXQuY2hhcnQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHNoZWV0LmlzUGl2b3RUYWJsZSE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBzaGVldG91dC5pc1Bpdm90VGFibGUgPSBzaGVldC5pc1Bpdm90VGFibGU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHNoZWV0LnBpdm90VGFibGUhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgc2hlZXRvdXQucGl2b3RUYWJsZSA9IHNoZWV0LnBpdm90VGFibGU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHNoZWV0Lmx1Y2t5c2hlZXRfY29uZGl0aW9uZm9ybWF0X3NhdmUhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgc2hlZXRvdXQubHVja3lzaGVldF9jb25kaXRpb25mb3JtYXRfc2F2ZSA9IHNoZWV0Lmx1Y2t5c2hlZXRfY29uZGl0aW9uZm9ybWF0X3NhdmU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHNoZWV0LmZyZWV6ZW4hPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgc2hlZXRvdXQuZnJlZXplbiA9IHNoZWV0LmZyZWV6ZW47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHNoZWV0LmNhbGNDaGFpbiE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBzaGVldG91dC5jYWxjQ2hhaW4gPSBzaGVldC5jYWxjQ2hhaW47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHNoZWV0LmltYWdlcyE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBzaGVldG91dC5pbWFnZXMgPSBzaGVldC5pbWFnZXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoc2hlZXQuZGF0YVZlcmlmaWNhdGlvbiAhPSBudWxsKXtcclxuICAgICAgICAgICAgICBzaGVldG91dC5kYXRhVmVyaWZpY2F0aW9uID0gc2hlZXQuZGF0YVZlcmlmaWNhdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmIChzaGVldC5oeXBlcmxpbmsgIT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICBzaGVldG91dC5oeXBlcmxpbmsgPSBzaGVldC5oeXBlcmxpbms7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoc2hlZXQuaGlkZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgc2hlZXRvdXQuaGlkZSA9IHNoZWV0LmhpZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIEx1Y2t5T3V0UHV0RmlsZS5zaGVldHMucHVzaChzaGVldG91dCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShMdWNreU91dFB1dEZpbGUpO1xyXG4gICAgfVxyXG5cclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgSWx1Y2t5SW1hZ2UgfSBmcm9tIFwiLi9JTHVja1wiO1xyXG5pbXBvcnQge0x1Y2t5U2hlZXRDZWxsZGF0YX0gZnJvbSBcIi4vTHVja3lDZWxsXCI7XHJcbmltcG9ydCB7IEl1cGxvYWRmaWxlTGlzdCwgSWF0dHJpYnV0ZUxpc3QgfSBmcm9tIFwiLi4vSUNvbW1vblwiO1xyXG5pbXBvcnQge2dldFhtbEF0dGlidXRlLCBnZXRDb2x1bW5XaWR0aFBpeGVsLCBmcm9tdWxhUmVmLGdldFJvd0hlaWdodFBpeGVsLGdldGNlbGxyYW5nZX0gZnJvbSBcIi4uL2NvbW1vbi9tZXRob2RcIjtcclxuaW1wb3J0IHtib3JkZXJUeXBlc30gZnJvbSBcIi4uL2NvbW1vbi9jb25zdGFudFwiO1xyXG5pbXBvcnQgeyBSZWFkWG1sLCBJU3R5bGVDb2xsZWN0aW9ucywgRWxlbWVudCxnZXRDb2xvciB9IGZyb20gXCIuL1JlYWRYbWxcIjtcclxuaW1wb3J0IHsgTHVja3lJbWFnZUJhc2UgfSBmcm9tIFwiLi9MdWNreUJhc2VcIjtcclxuaW1wb3J0IHsgVURPQyxGcm9tRU1GLFRvQ29udGV4dDJEICB9IGZyb20gXCIuLi9jb21tb24vZW1mXCI7XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIEltYWdlTGlzdCB7XHJcbiAgICBwcml2YXRlIGltYWdlczpJYXR0cmlidXRlTGlzdFxyXG4gICAgY29uc3RydWN0b3IoZmlsZXM6SXVwbG9hZGZpbGVMaXN0KSB7XHJcbiAgICAgICAgaWYoZmlsZXM9PW51bGwpe1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaW1hZ2VzID0ge307XHJcbiAgICAgICAgZm9yKGxldCBmaWxlS2V5IGluIGZpbGVzKXtcclxuICAgICAgICAgICAgLy8gbGV0IHJlZyA9IG5ldyBSZWdFeHAoXCJ4bC9tZWRpYS9pbWFnZTEucG5nXCIsIFwiZ1wiKTtcclxuICAgICAgICAgICAgaWYoZmlsZUtleS5pbmRleE9mKFwieGwvbWVkaWEvXCIpPi0xKXtcclxuICAgICAgICAgICAgICAgIGxldCBmaWxlTmFtZUFyciA9IGZpbGVLZXkuc3BsaXQoXCIuXCIpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHN1ZmZpeCA9IGZpbGVOYW1lQXJyW2ZpbGVOYW1lQXJyLmxlbmd0aC0xXS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYoc3VmZml4IGluIHtcInBuZ1wiOjEsIFwianBlZ1wiOjEsIFwianBnXCI6MSwgXCJnaWZcIjoxLFwiYm1wXCI6MSxcInRpZlwiOjEsXCJ3ZWJwXCI6MSxcImVtZlwiOjF9KXtcclxuICAgICAgICAgICAgICAgICAgICBpZihzdWZmaXg9PVwiZW1mXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcE51bSAgPSAwOyAgLy8gbnVtYmVyIG9mIHRoZSBwYWdlLCB0aGF0IHlvdSB3YW50IHRvIHJlbmRlclxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NhbGUgPSAxOyAgLy8gdGhlIHNjYWxlIG9mIHRoZSBkb2N1bWVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgd3J0ID0gbmV3IFRvQ29udGV4dDJEKHBOdW0sIHNjYWxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlucCwgb3V0LCBzdHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEZyb21FTUYuSyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnAgPSBGcm9tRU1GLkM7ICAgb3V0ID0gRnJvbUVNRi5LOyAgIHN0dD00O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIHAgaW4gaW5wKSBvdXRbaW5wW3BdXSA9IHAuc2xpY2Uoc3R0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgRnJvbUVNRi5QYXJzZShmaWxlc1tmaWxlS2V5XSwgd3J0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbWFnZXNbZmlsZUtleV0gPSB3cnQuY2FudmFzLnRvRGF0YVVSTChcImltYWdlL3BuZ1wiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbWFnZXNbZmlsZUtleV0gPSBmaWxlc1tmaWxlS2V5XTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0SW1hZ2VCeU5hbWUocGF0aE5hbWU6c3RyaW5nKTpJbWFnZXtcclxuICAgICAgICBpZihwYXRoTmFtZSBpbiB0aGlzLmltYWdlcyl7XHJcbiAgICAgICAgICAgIGxldCBiYXNlNjQgPSB0aGlzLmltYWdlc1twYXRoTmFtZV07XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW1hZ2UocGF0aE5hbWUsIGJhc2U2NCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuY2xhc3MgSW1hZ2UgZXh0ZW5kcyBMdWNreUltYWdlQmFzZSB7XHJcblxyXG4gICAgZnJvbUNvbDpudW1iZXJcclxuICAgIGZyb21Db2xPZmY6bnVtYmVyXHJcbiAgICBmcm9tUm93Om51bWJlclxyXG4gICAgZnJvbVJvd09mZjpudW1iZXJcclxuXHJcbiAgICB0b0NvbDpudW1iZXJcclxuICAgIHRvQ29sT2ZmOm51bWJlclxyXG4gICAgdG9Sb3c6bnVtYmVyXHJcbiAgICB0b1Jvd09mZjpudW1iZXJcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihwYXRoTmFtZTpzdHJpbmcsIGJhc2U2NDpzdHJpbmcpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuc3JjID0gYmFzZTY0O1xyXG4gICAgfVxyXG5cclxuICAgIHNldERlZmF1bHQoKXtcclxuXHJcbiAgICB9XHJcbn0iLCLvu79pbXBvcnQgeyBJbHVja3lJbWFnZUJvcmRlcixJbHVja3lJbWFnZUNyb3AsSWx1Y2t5SW1hZ2VEZWZhdWx0LElsdWNreUltYWdlcyxJbHVja3lTaGVldENlbGxkYXRhLElsdWNreVNoZWV0Q2VsbGRhdGFWYWx1ZSxJTWFwbHVja3lTaGVldGJvcmRlckluZm9DZWxsRm9ySW1wLElsdWNreVNoZWV0Ym9yZGVySW5mb0NlbGxWYWx1ZSxJbHVja3lTaGVldGJvcmRlckluZm9DZWxsVmFsdWVTdHlsZSxJRm9ybXVsYVNJLElsdWNreVNoZWV0Um93QW5kQ29sdW1uTGVuLElsdWNreVNoZWV0Um93QW5kQ29sdW1uSGlkZGVuLElsdWNreVNoZWV0U2VsZWN0aW9uLEljZWxsT3RoZXJJbmZvLElmb3JtdWxhTGlzdCxJZm9ybXVsYUxpc3RJdGVtLCBJbHVja3lzaGVldEh5cGVybGluaywgSWx1Y2t5c2hlZXRIeXBlcmxpbmtUeXBlLCBJbHVja3lzaGVldERhdGFWZXJpZmljYXRpb259IGZyb20gXCIuL0lMdWNrXCI7XHJcbmltcG9ydCB7THVja3lTaGVldENlbGxkYXRhfSBmcm9tIFwiLi9MdWNreUNlbGxcIjtcclxuaW1wb3J0IHsgSWF0dHJpYnV0ZUxpc3QgfSBmcm9tIFwiLi4vSUNvbW1vblwiO1xyXG5pbXBvcnQge2dldFhtbEF0dGlidXRlLCBnZXRDb2x1bW5XaWR0aFBpeGVsLCBmcm9tdWxhUmVmLGdldFJvd0hlaWdodFBpeGVsLGdldGNlbGxyYW5nZSxnZW5lcmF0ZVJhbmRvbUluZGV4LGdldFB4QnlFTVVzLCBnZXRNdWx0aVNlcXVlbmNlVG9OdW0sIGdldFRyYW5zUjFDMVRvU2VxdWVuY2UsIGdldFBlZWxPZmZYMTQsIGdldE11bHRpRm9ybXVsYVZhbHVlfSBmcm9tIFwiLi4vY29tbW9uL21ldGhvZFwiO1xyXG5pbXBvcnQge2JvcmRlclR5cGVzLCBDT01NT05fVFlQRTIsIERBVEFfVkVSSUZJQ0FUSU9OX01BUCwgREFUQV9WRVJJRklDQVRJT05fVFlQRTJfTUFQLCB3b3Jrc2hlZXRGaWxlUGF0aH0gZnJvbSBcIi4uL2NvbW1vbi9jb25zdGFudFwiO1xyXG5pbXBvcnQgeyBSZWFkWG1sLCBJU3R5bGVDb2xsZWN0aW9ucywgRWxlbWVudCxnZXRDb2xvciB9IGZyb20gXCIuL1JlYWRYbWxcIjtcclxuaW1wb3J0IHsgTHVja3lGaWxlQmFzZSxMdWNreVNoZWV0QmFzZSxMdWNreUNvbmZpZyxMdWNreVNoZWV0Ym9yZGVySW5mb0NlbGxGb3JJbXAsTHVja3lTaGVldGJvcmRlckluZm9DZWxsVmFsdWUsTHVja3lzaGVldENhbGNDaGFpbixMdWNreVNoZWV0Q29uZmlnTWVyZ2UgfSBmcm9tIFwiLi9MdWNreUJhc2VcIjtcclxuaW1wb3J0IHtJbWFnZUxpc3R9IGZyb20gXCIuL0x1Y2t5SW1hZ2VcIjtcclxuaW1wb3J0IGRheWpzIGZyb20gXCJkYXlqc1wiO1xyXG5cclxuZXhwb3J0IGNsYXNzIEx1Y2t5U2hlZXQgZXh0ZW5kcyBMdWNreVNoZWV0QmFzZSB7XHJcblxyXG4gICAgcHJpdmF0ZSByZWFkWG1sOlJlYWRYbWxcclxuICAgIHByaXZhdGUgc2hlZXRGaWxlOnN0cmluZ1xyXG4gICAgcHJpdmF0ZSBpc0luaXRpYWxDZWxsOmJvb2xlYW5cclxuICAgIHByaXZhdGUgc3R5bGVzOklTdHlsZUNvbGxlY3Rpb25zXHJcbiAgICBwcml2YXRlIHNoYXJlZFN0cmluZ3M6RWxlbWVudFtdXHJcbiAgICBwcml2YXRlIG1lcmdlQ2VsbHM6RWxlbWVudFtdXHJcbiAgICBwcml2YXRlIGNhbGNDaGFpbkVsZXM6RWxlbWVudFtdXHJcbiAgICBwcml2YXRlIHNoZWV0TGlzdDpJYXR0cmlidXRlTGlzdFxyXG5cclxuICAgIHByaXZhdGUgaW1hZ2VMaXN0OkltYWdlTGlzdFxyXG5cclxuICAgIHByaXZhdGUgZm9ybXVsYVJlZkxpc3Q6SUZvcm11bGFTSVxyXG4gICAgLy8gcHJpdmF0ZSBsYXN0Q29udGVudERhdGE6IHtyOiAwLCBjOiAwfTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihzaGVldE5hbWU6c3RyaW5nLCBzaGVldElkOnN0cmluZywgc2hlZXRPcmRlcjpudW1iZXIsaXNJbml0aWFsQ2VsbDpib29sZWFuPWZhbHNlLCBhbGxGaWxlT3B0aW9uOmFueSl7XHJcbiAgICAgICAgLy9Qcml2YXRlXHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmlzSW5pdGlhbENlbGwgPSBpc0luaXRpYWxDZWxsO1xyXG5cclxuICAgICAgICB0aGlzLnJlYWRYbWwgPSBhbGxGaWxlT3B0aW9uLnJlYWRYbWw7XHJcbiAgICAgICAgdGhpcy5zaGVldEZpbGUgPSBhbGxGaWxlT3B0aW9uLnNoZWV0RmlsZTtcclxuICAgICAgICB0aGlzLnN0eWxlcyA9IGFsbEZpbGVPcHRpb24uc3R5bGVzO1xyXG4gICAgICAgIHRoaXMuc2hhcmVkU3RyaW5ncyA9IGFsbEZpbGVPcHRpb24uc2hhcmVkU3RyaW5ncztcclxuICAgICAgICB0aGlzLmNhbGNDaGFpbkVsZXMgPSBhbGxGaWxlT3B0aW9uLmNhbGNDaGFpbjtcclxuICAgICAgICB0aGlzLnNoZWV0TGlzdCA9IGFsbEZpbGVPcHRpb24uc2hlZXRMaXN0O1xyXG4gICAgICAgIHRoaXMuaW1hZ2VMaXN0ID0gYWxsRmlsZU9wdGlvbi5pbWFnZUxpc3Q7XHJcbiAgICAgICAgdGhpcy5oaWRlID0gYWxsRmlsZU9wdGlvbi5oaWRlO1xyXG5cclxuICAgICAgICAvL091dHB1dFxyXG4gICAgICAgIHRoaXMubmFtZSA9IHNoZWV0TmFtZTtcclxuICAgICAgICB0aGlzLmluZGV4ID0gc2hlZXRJZDtcclxuICAgICAgICB0aGlzLm9yZGVyID0gc2hlZXRPcmRlci50b1N0cmluZygpO1xyXG4gICAgICAgIHRoaXMuY29uZmlnID0gbmV3IEx1Y2t5Q29uZmlnKCk7XHJcbiAgICAgICAgdGhpcy5jZWxsZGF0YSA9IFtdO1xyXG4gICAgICAgIHRoaXMubWVyZ2VDZWxscyA9IHRoaXMucmVhZFhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcIm1lcmdlQ2VsbHMvbWVyZ2VDZWxsXCIsIHRoaXMuc2hlZXRGaWxlKTtcclxuICAgICAgICBsZXQgY2xyU2NoZW1lID0gdGhpcy5zdHlsZXNbXCJjbHJTY2hlbWVcIl0gYXMgRWxlbWVudFtdO1xyXG4gICAgICAgIGxldCBzaGVldFZpZXcgPSB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzaGVldFZpZXdzL3NoZWV0Vmlld1wiLCB0aGlzLnNoZWV0RmlsZSk7XHJcbiAgICAgICAgbGV0IHNob3dHcmlkTGluZXMgPSBcIjFcIiwgdGFiU2VsZWN0ZWQ9XCIwXCIsIHpvb21TY2FsZSA9IFwiMTAwXCIsIGFjdGl2ZUNlbGwgPSBcIkExXCI7XHJcbiAgICAgICAgaWYoc2hlZXRWaWV3Lmxlbmd0aD4wKXtcclxuICAgICAgICAgICAgbGV0IGF0dHJMaXN0ID0gc2hlZXRWaWV3WzBdLmF0dHJpYnV0ZUxpc3Q7XHJcbiAgICAgICAgICAgIHNob3dHcmlkTGluZXMgPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJzaG93R3JpZExpbmVzXCIsIFwiMVwiKTtcclxuICAgICAgICAgICAgdGFiU2VsZWN0ZWQgPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJ0YWJTZWxlY3RlZFwiLCBcIjBcIik7XHJcbiAgICAgICAgICAgIHpvb21TY2FsZSA9IGdldFhtbEF0dGlidXRlKGF0dHJMaXN0LCBcInpvb21TY2FsZVwiLCBcIjEwMFwiKTtcclxuICAgICAgICAgICAgLy8gbGV0IGNvbG9ySWQgPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJjb2xvcklkXCIsIFwiMFwiKTtcclxuICAgICAgICAgICAgbGV0IHNlbGVjdGlvbnMgPSBzaGVldFZpZXdbMF0uZ2V0SW5uZXJFbGVtZW50cyhcInNlbGVjdGlvblwiKTtcclxuICAgICAgICAgICAgaWYoc2VsZWN0aW9ucyE9bnVsbCAmJiBzZWxlY3Rpb25zLmxlbmd0aD4wKXtcclxuICAgICAgICAgICAgICAgIGFjdGl2ZUNlbGwgPSBnZXRYbWxBdHRpYnV0ZShzZWxlY3Rpb25zWzBdLmF0dHJpYnV0ZUxpc3QsIFwiYWN0aXZlQ2VsbFwiLCBcIkExXCIpO1xyXG4gICAgICAgICAgICAgICAgbGV0IHJhbmdlOklsdWNreVNoZWV0U2VsZWN0aW9uID0gZ2V0Y2VsbHJhbmdlKGFjdGl2ZUNlbGwsIHRoaXMuc2hlZXRMaXN0LCBzaGVldElkKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubHVja3lzaGVldF9zZWxlY3Rfc2F2ZSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sdWNreXNoZWV0X3NlbGVjdF9zYXZlLnB1c2gocmFuZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2hvd0dyaWRMaW5lcyA9IHNob3dHcmlkTGluZXM7XHJcbiAgICAgICAgdGhpcy5zdGF0dXMgPSB0YWJTZWxlY3RlZDtcclxuICAgICAgICB0aGlzLnpvb21SYXRpbyA9IHBhcnNlSW50KHpvb21TY2FsZSkvMTAwO1xyXG5cclxuICAgICAgICBsZXQgdGFiQ29sb3JzID0gdGhpcy5yZWFkWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2hlZXRQci90YWJDb2xvclwiLCB0aGlzLnNoZWV0RmlsZSk7XHJcbiAgICAgICAgaWYodGFiQ29sb3JzIT1udWxsICYmIHRhYkNvbG9ycy5sZW5ndGg+MCl7XHJcbiAgICAgICAgICAgIGxldCB0YWJDb2xvciA9IHRhYkNvbG9yc1swXSwgYXR0ckxpc3QgPSB0YWJDb2xvci5hdHRyaWJ1dGVMaXN0O1xyXG4gICAgICAgICAgICAvLyBpZihhdHRyTGlzdC5yZ2IhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgbGV0IHRjID0gZ2V0Q29sb3IodGFiQ29sb3IsIHRoaXMuc3R5bGVzLCBcImJcIik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbG9yID0gdGM7XHJcbiAgICAgICAgICAgIC8vIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBzaGVldEZvcm1hdFByID0gdGhpcy5yZWFkWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2hlZXRGb3JtYXRQclwiLCB0aGlzLnNoZWV0RmlsZSk7XHJcbiAgICAgICAgbGV0IGRlZmF1bHRDb2xXaWR0aCwgZGVmYXVsdFJvd0hlaWdodDtcclxuICAgICAgICBpZihzaGVldEZvcm1hdFByLmxlbmd0aD4wKXtcclxuICAgICAgICAgICAgbGV0IGF0dHJMaXN0ID0gc2hlZXRGb3JtYXRQclswXS5hdHRyaWJ1dGVMaXN0O1xyXG4gICAgICAgICAgICBkZWZhdWx0Q29sV2lkdGggPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJkZWZhdWx0Q29sV2lkdGhcIiwgXCI5LjIxXCIpO1xyXG4gICAgICAgICAgICBkZWZhdWx0Um93SGVpZ2h0ID0gZ2V0WG1sQXR0aWJ1dGUoYXR0ckxpc3QsIFwiZGVmYXVsdFJvd0hlaWdodFwiLCBcIjE5XCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5kZWZhdWx0Q29sV2lkdGggPSBnZXRDb2x1bW5XaWR0aFBpeGVsKHBhcnNlRmxvYXQoZGVmYXVsdENvbFdpZHRoKSk7XHJcbiAgICAgICAgdGhpcy5kZWZhdWx0Um93SGVpZ2h0ID0gZ2V0Um93SGVpZ2h0UGl4ZWwocGFyc2VGbG9hdChkZWZhdWx0Um93SGVpZ2h0KSk7XHJcblxyXG5cclxuICAgICAgICB0aGlzLmdlbmVyYXRlQ29uZmlnQ29sdW1uTGVuQW5kSGlkZGVuKCk7XHJcbiAgICAgICAgbGV0IGNlbGxPdGhlckluZm86SWNlbGxPdGhlckluZm8gPSAgdGhpcy5nZW5lcmF0ZUNvbmZpZ1Jvd0xlbkFuZEhpZGRlbkFkZENlbGwoKTtcclxuICAgICAgICBcclxuICAgICAgICBpZih0aGlzLmNhbGNDaGFpbj09bnVsbCl7XHJcbiAgICAgICAgICAgIHRoaXMuY2FsY0NoYWluID0gW107XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgZm9ybXVsYUxpc3RFeGlzdDpJZm9ybXVsYUxpc3Q9e307XHJcbiAgICAgICAgZm9yKGxldCBjPTA7Yzx0aGlzLmNhbGNDaGFpbkVsZXMubGVuZ3RoO2MrKyl7XHJcbiAgICAgICAgICAgIGxldCBjYWxjQ2hhaW5FbGUgPSB0aGlzLmNhbGNDaGFpbkVsZXNbY10sIGF0dHJMaXN0ID0gY2FsY0NoYWluRWxlLmF0dHJpYnV0ZUxpc3Q7XHJcbiAgICAgICAgICAgIGlmKGF0dHJMaXN0LmkhPXNoZWV0SWQpe1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxldCByID0gYXR0ckxpc3QuciAsIGkgPSBhdHRyTGlzdC5pLCBsID0gYXR0ckxpc3QubCwgcyA9IGF0dHJMaXN0LnMsIGEgPSBhdHRyTGlzdC5hLCB0ID0gYXR0ckxpc3QudDtcclxuXHJcbiAgICAgICAgICAgIGxldCByYW5nZSA9IGdldGNlbGxyYW5nZShyKTtcclxuICAgICAgICAgICAgbGV0IGNoYWluID0gbmV3IEx1Y2t5c2hlZXRDYWxjQ2hhaW4oKTtcclxuICAgICAgICAgICAgY2hhaW4uciA9IHJhbmdlLnJvd1swXTtcclxuICAgICAgICAgICAgY2hhaW4uYyA9IHJhbmdlLmNvbHVtblswXTtcclxuICAgICAgICAgICAgY2hhaW4uaW5kZXggPSB0aGlzLmluZGV4O1xyXG4gICAgICAgICAgICB0aGlzLmNhbGNDaGFpbi5wdXNoKGNoYWluKTtcclxuICAgICAgICAgICAgZm9ybXVsYUxpc3RFeGlzdFtcInJcIityK1wiY1wiK2NdID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcblxyXG4gICAgICAgIGlmKHRoaXMuZm9ybXVsYVJlZkxpc3QhPW51bGwpe1xyXG4gICAgICAgICAgICBmb3IobGV0IGtleSBpbiB0aGlzLmZvcm11bGFSZWZMaXN0KXtcclxuICAgICAgICAgICAgICAgIGxldCBmdW5jbGlzdCA9IHRoaXMuZm9ybXVsYVJlZkxpc3Rba2V5XTtcclxuICAgICAgICAgICAgICAgIGxldCBtYWluRnVuYyA9IGZ1bmNsaXN0W1wibWFpblJlZlwiXSwgbWFpbkNlbGxWYWx1ZSA9IG1haW5GdW5jLmNlbGxWYWx1ZTtcclxuICAgICAgICAgICAgICAgIGxldCBmb3JtdWxhVHh0ID0gbWFpbkZ1bmMuZnY7XHJcbiAgICAgICAgICAgICAgICBsZXQgbWFpblIgPSBtYWluQ2VsbFZhbHVlLnIsIG1haW5DID0gbWFpbkNlbGxWYWx1ZS5jO1xyXG4gICAgICAgICAgICAgICAgLy8gbGV0IHJlZlJhbmdlID0gZ2V0Y2VsbHJhbmdlKHJlZik7XHJcbiAgICAgICAgICAgICAgICBmb3IobGV0IG5hbWUgaW4gZnVuY2xpc3Qpe1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKG5hbWUgPT0gXCJtYWluUmVmXCIpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBmdW5jVmFsdWUgPSBmdW5jbGlzdFtuYW1lXSwgY2VsbFZhbHVlID0gZnVuY1ZhbHVlLmNlbGxWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZihjZWxsVmFsdWU9PW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHIgPSBjZWxsVmFsdWUuciwgYyA9IGNlbGxWYWx1ZS5jO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBsZXQgZnVuYyA9IGZvcm11bGFUeHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9mZnNldFJvdyA9IHIgLSBtYWluUiwgb2Zmc2V0Q29sID0gYyAtIG1haW5DO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBpZihvZmZzZXRSb3cgPiAwKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuYyA9IFwiPVwiICsgZnJvbXVsYVJlZi5mdW5jdGlvbkNvcHkoZnVuYywgXCJkb3duXCIsIG9mZnNldFJvdyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYob2Zmc2V0Um93IDwgMCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmMgPSBcIj1cIiArIGZyb211bGFSZWYuZnVuY3Rpb25Db3B5KGZ1bmMsIFwidXBcIiwgTWF0aC5hYnMob2Zmc2V0Um93KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZihvZmZzZXRDb2wgPiAwKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuYyA9IFwiPVwiICsgZnJvbXVsYVJlZi5mdW5jdGlvbkNvcHkoZnVuYywgXCJyaWdodFwiLCBvZmZzZXRDb2wpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKG9mZnNldENvbCA8IDApe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jID0gXCI9XCIgKyBmcm9tdWxhUmVmLmZ1bmN0aW9uQ29weShmdW5jLCBcImxlZnRcIiwgTWF0aC5hYnMob2Zmc2V0Q29sKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhvZmZzZXRSb3csIG9mZnNldENvbCwgZnVuYyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIChjZWxsVmFsdWUudiBhcyBJbHVja3lTaGVldENlbGxkYXRhVmFsdWUgKS5mID0gZnVuYztcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAvL+a3u+WKoOWFseS6q+WFrOW8j+mTvlxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjaGFpbiA9IG5ldyBMdWNreXNoZWV0Q2FsY0NoYWluKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhaW4uciA9IGNlbGxWYWx1ZS5yO1xyXG4gICAgICAgICAgICAgICAgICAgIGNoYWluLmMgPSBjZWxsVmFsdWUuYztcclxuICAgICAgICAgICAgICAgICAgICBjaGFpbi5pbmRleCA9IHRoaXMuaW5kZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxjQ2hhaW4ucHVzaChjaGFpbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvL1RoZXJlIG1heSBiZSBmb3JtdWxhcyB0aGF0IGRvIG5vdCBhcHBlYXIgaW4gY2FsY0NoYWluXHJcbiAgICAgICAgZm9yKGxldCBrZXkgaW4gY2VsbE90aGVySW5mby5mb3JtdWxhTGlzdCl7XHJcbiAgICAgICAgICAgIGlmKCEoa2V5IGluIGZvcm11bGFMaXN0RXhpc3QpKXtcclxuICAgICAgICAgICAgICAgIGxldCBmb3JtdWxhTGlzdEl0ZW0gPSBjZWxsT3RoZXJJbmZvLmZvcm11bGFMaXN0W2tleV07XHJcbiAgICAgICAgICAgICAgICBsZXQgY2hhaW4gPSBuZXcgTHVja3lzaGVldENhbGNDaGFpbigpO1xyXG4gICAgICAgICAgICAgICAgY2hhaW4uciA9IGZvcm11bGFMaXN0SXRlbS5yO1xyXG4gICAgICAgICAgICAgICAgY2hhaW4uYyA9IGZvcm11bGFMaXN0SXRlbS5jO1xyXG4gICAgICAgICAgICAgICAgY2hhaW4uaW5kZXggPSB0aGlzLmluZGV4O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxjQ2hhaW4ucHVzaChjaGFpbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAgIC8vIGRhdGFWZXJpZmljYXRpb24gY29uZmlnXHJcbiAgICAgICAgdGhpcy5kYXRhVmVyaWZpY2F0aW9uID0gdGhpcy5nZW5lcmF0ZUNvbmZpZ0RhdGFWYWxpZGF0aW9ucygpO1xyXG5cclxuICAgICAgICAvLyBoeXBlcmxpbmsgY29uZmlnXHJcbiAgICAgICAgdGhpcy5oeXBlcmxpbmsgPSB0aGlzLmdlbmVyYXRlQ29uZmlnSHlwZXJsaW5rcygpO1xyXG4gICAgICBcclxuICAgICAgICAvLyBzaGVldCBoaWRlXHJcbiAgICAgICAgdGhpcy5oaWRlID0gdGhpcy5oaWRlO1xyXG5cclxuICAgICAgICBpZih0aGlzLm1lcmdlQ2VsbHMhPW51bGwpe1xyXG4gICAgICAgICAgICBmb3IobGV0IGk9MDtpPHRoaXMubWVyZ2VDZWxscy5sZW5ndGg7aSsrKXtcclxuICAgICAgICAgICAgICAgIGxldCBtZXJnZSA9IHRoaXMubWVyZ2VDZWxsc1tpXSwgYXR0ckxpc3QgPSBtZXJnZS5hdHRyaWJ1dGVMaXN0O1xyXG4gICAgICAgICAgICAgICAgbGV0IHJlZiA9IGF0dHJMaXN0LnJlZjtcclxuICAgICAgICAgICAgICAgIGlmKHJlZj09bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBsZXQgcmFuZ2UgPSBnZXRjZWxscmFuZ2UocmVmLCB0aGlzLnNoZWV0TGlzdCwgc2hlZXRJZCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgbWVyZ2VWYWx1ZSA9IG5ldyBMdWNreVNoZWV0Q29uZmlnTWVyZ2UoKTtcclxuICAgICAgICAgICAgICAgIG1lcmdlVmFsdWUuciA9IHJhbmdlLnJvd1swXTtcclxuICAgICAgICAgICAgICAgIG1lcmdlVmFsdWUuYyA9IHJhbmdlLmNvbHVtblswXTtcclxuICAgICAgICAgICAgICAgIG1lcmdlVmFsdWUucnMgPSByYW5nZS5yb3dbMV0tcmFuZ2Uucm93WzBdKzE7XHJcbiAgICAgICAgICAgICAgICBtZXJnZVZhbHVlLmNzID0gcmFuZ2UuY29sdW1uWzFdLXJhbmdlLmNvbHVtblswXSsxO1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5jb25maWcubWVyZ2U9PW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLm1lcmdlID0ge307XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5tZXJnZVtyYW5nZS5yb3dbMF0gKyBcIl9cIiArIHJhbmdlLmNvbHVtblswXV0gPSBtZXJnZVZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgZHJhd2luZ0ZpbGUgPSBhbGxGaWxlT3B0aW9uLmRyYXdpbmdGaWxlLCBkcmF3aW5nUmVsc0ZpbGUgPSBhbGxGaWxlT3B0aW9uLmRyYXdpbmdSZWxzRmlsZTtcclxuICAgICAgICBpZihkcmF3aW5nRmlsZSE9bnVsbCAmJiBkcmF3aW5nUmVsc0ZpbGUhPW51bGwpe1xyXG4gICAgICAgICAgICBsZXQgdHdvQ2VsbEFuY2hvcnMgPSB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ4ZHI6dHdvQ2VsbEFuY2hvclwiLCBkcmF3aW5nRmlsZSk7XHJcblxyXG4gICAgICAgICAgICBpZih0d29DZWxsQW5jaG9ycyE9bnVsbCAmJiB0d29DZWxsQW5jaG9ycy5sZW5ndGg+MCl7XHJcbiAgICAgICAgICAgICAgICBmb3IobGV0IGk9MDtpPHR3b0NlbGxBbmNob3JzLmxlbmd0aDtpKyspe1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCB0d29DZWxsQW5jaG9yID0gdHdvQ2VsbEFuY2hvcnNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVkaXRBcyA9IGdldFhtbEF0dGlidXRlKHR3b0NlbGxBbmNob3IuYXR0cmlidXRlTGlzdCwgXCJlZGl0QXNcIiwgXCJ0d29DZWxsXCIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBsZXQgeGRyRnJvbXMgPSB0d29DZWxsQW5jaG9yLmdldElubmVyRWxlbWVudHMoXCJ4ZHI6ZnJvbVwiKSwgeGRyVG9zID0gdHdvQ2VsbEFuY2hvci5nZXRJbm5lckVsZW1lbnRzKFwieGRyOnRvXCIpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBsZXQgeGRyX2JsaXBmaWxscyA9IHR3b0NlbGxBbmNob3IuZ2V0SW5uZXJFbGVtZW50cyhcImE6YmxpcFwiKTtcclxuICAgICAgICAgICAgICAgICAgICBpZih4ZHJGcm9tcyE9bnVsbCAmJiB4ZHJfYmxpcGZpbGxzIT1udWxsICYmIHhkckZyb21zLmxlbmd0aD4wICYmIHhkcl9ibGlwZmlsbHMubGVuZ3RoPjApe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgeGRyRnJvbSA9IHhkckZyb21zWzBdLCB4ZHJUbyA9IHhkclRvc1swXSx4ZHJfYmxpcGZpbGwgPSB4ZHJfYmxpcGZpbGxzWzBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlbWJlZCA9IGdldFhtbEF0dGlidXRlKHhkcl9ibGlwZmlsbC5hdHRyaWJ1dGVMaXN0LCBcInI6ZW1iZWRcIiwgbnVsbCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW1hZ2VPYmplY3QgPSB0aGlzLmdldEJhc2U2NEJ5UmlkKHJlbWJlZCwgZHJhd2luZ1JlbHNGaWxlKTtcclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbGV0IGFvZmYgPSB4ZHJfeGZybS5nZXRJbm5lckVsZW1lbnRzKFwiYTpvZmZcIiksIGFleHQgPSB4ZHJfeGZybS5nZXRJbm5lckVsZW1lbnRzKFwiYTpleHRcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmKGFvZmYhPW51bGwgJiYgYWV4dCE9bnVsbCAmJiBhb2ZmLmxlbmd0aD4wICYmIGFleHQubGVuZ3RoPjApe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgbGV0IGFvZmZBdHRyaWJ1dGUgPSBhb2ZmWzBdLmF0dHJpYnV0ZUxpc3QsIGFleHRBdHRyaWJ1dGUgPSBhZXh0WzBdLmF0dHJpYnV0ZUxpc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICBsZXQgeCA9IGdldFhtbEF0dGlidXRlKGFvZmZBdHRyaWJ1dGUsIFwieFwiLCBudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgIGxldCB5ID0gZ2V0WG1sQXR0aWJ1dGUoYW9mZkF0dHJpYnV0ZSwgXCJ5XCIsIG51bGwpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgIGxldCBjeCA9IGdldFhtbEF0dGlidXRlKGFleHRBdHRyaWJ1dGUsIFwiY3hcIiwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICBsZXQgY3kgPSBnZXRYbWxBdHRpYnV0ZShhZXh0QXR0cmlidXRlLCBcImN5XCIsIG51bGwpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgIGlmKHghPW51bGwgJiYgeSE9bnVsbCAmJiBjeCE9bnVsbCAmJiBjeSE9bnVsbCAmJiBpbWFnZU9iamVjdCAhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsZXQgeF9uID0gZ2V0UHhCeUVNVXMocGFyc2VJbnQoeCksIFwiY1wiKSx5X24gPSBnZXRQeEJ5RU1VcyhwYXJzZUludCh5KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxldCBjeF9uID0gZ2V0UHhCeUVNVXMocGFyc2VJbnQoY3gpLCBcImNcIiksY3lfbiA9IGdldFB4QnlFTVVzKHBhcnNlSW50KGN5KSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgeF9uID0wLHlfbiA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjeF9uID0gMCwgY3lfbiA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZU9iamVjdC5mcm9tQ29sID0gdGhpcy5nZXRYZHJWYWx1ZSh4ZHJGcm9tLmdldElubmVyRWxlbWVudHMoXCJ4ZHI6Y29sXCIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VPYmplY3QuZnJvbUNvbE9mZiA9IGdldFB4QnlFTVVzKHRoaXMuZ2V0WGRyVmFsdWUoeGRyRnJvbS5nZXRJbm5lckVsZW1lbnRzKFwieGRyOmNvbE9mZlwiKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZU9iamVjdC5mcm9tUm93PSB0aGlzLmdldFhkclZhbHVlKHhkckZyb20uZ2V0SW5uZXJFbGVtZW50cyhcInhkcjpyb3dcIikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZU9iamVjdC5mcm9tUm93T2ZmID0gZ2V0UHhCeUVNVXModGhpcy5nZXRYZHJWYWx1ZSh4ZHJGcm9tLmdldElubmVyRWxlbWVudHMoXCJ4ZHI6cm93T2ZmXCIpKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZU9iamVjdC50b0NvbCA9IHRoaXMuZ2V0WGRyVmFsdWUoeGRyVG8uZ2V0SW5uZXJFbGVtZW50cyhcInhkcjpjb2xcIikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZU9iamVjdC50b0NvbE9mZiA9IGdldFB4QnlFTVVzKHRoaXMuZ2V0WGRyVmFsdWUoeGRyVG8uZ2V0SW5uZXJFbGVtZW50cyhcInhkcjpjb2xPZmZcIikpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VPYmplY3QudG9Sb3cgPSB0aGlzLmdldFhkclZhbHVlKHhkclRvLmdldElubmVyRWxlbWVudHMoXCJ4ZHI6cm93XCIpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VPYmplY3QudG9Sb3dPZmYgPSBnZXRQeEJ5RU1Vcyh0aGlzLmdldFhkclZhbHVlKHhkclRvLmdldElubmVyRWxlbWVudHMoXCJ4ZHI6cm93T2ZmXCIpKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZU9iamVjdC5vcmlnaW5XaWR0aCA9IGN4X247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlT2JqZWN0Lm9yaWdpbkhlaWdodCA9IGN5X247XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihlZGl0QXM9PVwiYWJzb2x1dGVcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZU9iamVjdC50eXBlID0gXCIzXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihlZGl0QXM9PVwib25lQ2VsbFwiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlT2JqZWN0LnR5cGUgPSBcIjJcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VPYmplY3QudHlwZSA9IFwiMVwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZU9iamVjdC5pc0ZpeGVkUG9zID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlT2JqZWN0LmZpeGVkTGVmdCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlT2JqZWN0LmZpeGVkVG9wID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbWFnZUJvcmRlcjpJbHVja3lJbWFnZUJvcmRlciA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBcIiMwMDBcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhZGl1czogMCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlOiBcInNvbGlkXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogMFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlT2JqZWN0LmJvcmRlciA9IGltYWdlQm9yZGVyO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGltYWdlQ3JvcDpJbHVja3lJbWFnZUNyb3AgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGN5X24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRMZWZ0OiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0VG9wOiAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGN4X25cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZU9iamVjdC5jcm9wID0gaW1hZ2VDcm9wO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGltYWdlRGVmYXVsdDpJbHVja3lJbWFnZURlZmF1bHQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGN5X24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiB4X24sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IHlfbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjeF9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2VPYmplY3QuZGVmYXVsdCA9IGltYWdlRGVmYXVsdDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuaW1hZ2VzPT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2VzID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbWFnZXNbZ2VuZXJhdGVSYW5kb21JbmRleChcImltYWdlXCIpXSA9IGltYWdlT2JqZWN0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIH0gXHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBnZXRYZHJWYWx1ZShlbGU6RWxlbWVudFtdKTpudW1iZXJ7XHJcbiAgICAgICAgaWYoZWxlPT1udWxsIHx8IGVsZS5sZW5ndGg9PTApe1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBwYXJzZUludChlbGVbMF0udmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgZ2V0QmFzZTY0QnlSaWQocmlkOnN0cmluZywgZHJhd2luZ1JlbHNGaWxlOnN0cmluZyl7XHJcbiAgICAgICAgbGV0IFJlbGF0aW9uc2hpcHMgPSB0aGlzLnJlYWRYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJSZWxhdGlvbnNoaXBzL1JlbGF0aW9uc2hpcFwiLCBkcmF3aW5nUmVsc0ZpbGUpO1xyXG5cclxuICAgICAgICBpZihSZWxhdGlvbnNoaXBzIT1udWxsICYmIFJlbGF0aW9uc2hpcHMubGVuZ3RoPjApe1xyXG4gICAgICAgICAgICBmb3IobGV0IGk9MDtpPFJlbGF0aW9uc2hpcHMubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgICAgICAgICBsZXQgUmVsYXRpb25zaGlwID0gUmVsYXRpb25zaGlwc1tpXTtcclxuICAgICAgICAgICAgICAgIGxldCBhdHRyTGlzdCA9IFJlbGF0aW9uc2hpcC5hdHRyaWJ1dGVMaXN0O1xyXG4gICAgICAgICAgICAgICAgbGV0IElkID0gZ2V0WG1sQXR0aWJ1dGUoYXR0ckxpc3QsIFwiSWRcIiwgbnVsbCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgc3JjID0gZ2V0WG1sQXR0aWJ1dGUoYXR0ckxpc3QsIFwiVGFyZ2V0XCIsIG51bGwpO1xyXG4gICAgICAgICAgICAgICAgaWYoSWQgPT0gcmlkKXtcclxuICAgICAgICAgICAgICAgICAgICBzcmMgPSBzcmMucmVwbGFjZSgvXFwuXFwuXFwvL2csIFwiXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNyYyA9IFwieGwvXCIgKyBzcmM7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGltZ2FnZSA9IHRoaXMuaW1hZ2VMaXN0LmdldEltYWdlQnlOYW1lKHNyYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGltZ2FnZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBkZXNjIFRoaXMgd2lsbCBjb252ZXJ0IGNvbHMvY29sIHRvIGx1Y2t5c2hlZXQgY29uZmlnIG9mIGNvbHVtbid3aWR0aFxyXG4gICAgKi9cclxuICAgIHByaXZhdGUgZ2VuZXJhdGVDb25maWdDb2x1bW5MZW5BbmRIaWRkZW4oKXtcclxuICAgICAgICBsZXQgY29scyA9IHRoaXMucmVhZFhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImNvbHMvY29sXCIsIHRoaXMuc2hlZXRGaWxlKTtcclxuICAgICAgICBmb3IobGV0IGk9MDtpPGNvbHMubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgICAgIGxldCBjb2wgPSBjb2xzW2ldLCBhdHRyTGlzdCA9IGNvbC5hdHRyaWJ1dGVMaXN0O1xyXG4gICAgICAgICAgICBsZXQgbWluID0gZ2V0WG1sQXR0aWJ1dGUoYXR0ckxpc3QsIFwibWluXCIsIG51bGwpO1xyXG4gICAgICAgICAgICBsZXQgbWF4ID0gZ2V0WG1sQXR0aWJ1dGUoYXR0ckxpc3QsIFwibWF4XCIsIG51bGwpO1xyXG4gICAgICAgICAgICBsZXQgd2lkdGggPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJ3aWR0aFwiLCBudWxsKTtcclxuICAgICAgICAgICAgbGV0IGhpZGRlbiA9IGdldFhtbEF0dGlidXRlKGF0dHJMaXN0LCBcImhpZGRlblwiLCBudWxsKTtcclxuICAgICAgICAgICAgbGV0IGN1c3RvbVdpZHRoID0gZ2V0WG1sQXR0aWJ1dGUoYXR0ckxpc3QsIFwiY3VzdG9tV2lkdGhcIiwgbnVsbCk7XHJcblxyXG5cclxuICAgICAgICAgICAgaWYobWluPT1udWxsIHx8IG1heD09bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGV0IG1pbk51bSA9IHBhcnNlSW50KG1pbiktMSwgbWF4TnVtPXBhcnNlSW50KG1heCktMSwgd2lkdGhOdW09cGFyc2VGbG9hdCh3aWR0aCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBmb3IobGV0IG09bWluTnVtO208PW1heE51bTttKyspe1xyXG4gICAgICAgICAgICAgICAgaWYod2lkdGghPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuY29uZmlnLmNvbHVtbmxlbj09bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLmNvbHVtbmxlbiA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5jb2x1bW5sZW5bbV0gPSBnZXRDb2x1bW5XaWR0aFBpeGVsKHdpZHRoTnVtKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZihoaWRkZW49PVwiMVwiKXtcclxuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmNvbmZpZy5jb2xoaWRkZW49PW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5jb2xoaWRkZW4gPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWcuY29saGlkZGVuW21dID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5jb25maWcuY29sdW1ubGVuKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuY29uZmlnLmNvbHVtbmxlblttXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYoY3VzdG9tV2lkdGghPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuY29uZmlnLmN1c3RvbVdpZHRoPT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWcuY3VzdG9tV2lkdGggPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWcuY3VzdG9tV2lkdGhbbV0gPSAxO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogQGRlc2MgVGhpcyB3aWxsIGNvbnZlcnQgY29scy9jb2wgdG8gbHVja3lzaGVldCBjb25maWcgb2YgY29sdW1uJ3dpZHRoXHJcbiAgICAqL1xyXG4gICAgcHJpdmF0ZSBnZW5lcmF0ZUNvbmZpZ1Jvd0xlbkFuZEhpZGRlbkFkZENlbGwoKTpJY2VsbE90aGVySW5mb3tcclxuICAgICAgICBsZXQgcm93cyA9IHRoaXMucmVhZFhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNoZWV0RGF0YS9yb3dcIiwgdGhpcy5zaGVldEZpbGUpO1xyXG4gICAgICAgIGxldCBjZWxsT3RoZXJJbmZvOkljZWxsT3RoZXJJbmZvID0ge307XHJcbiAgICAgICAgbGV0IGZvcm11bGFMaXN0Oklmb3JtdWxhTGlzdCA9IHt9O1xyXG4gICAgICAgIGNlbGxPdGhlckluZm8uZm9ybXVsYUxpc3QgPSBmb3JtdWxhTGlzdDtcclxuICAgICAgICBmb3IobGV0IGk9MDtpPHJvd3MubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgICAgIGxldCByb3cgPSByb3dzW2ldLCBhdHRyTGlzdCA9IHJvdy5hdHRyaWJ1dGVMaXN0O1xyXG4gICAgICAgICAgICBsZXQgcm93Tm8gPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJyXCIsIG51bGwpO1xyXG4gICAgICAgICAgICBsZXQgaGVpZ2h0ID0gZ2V0WG1sQXR0aWJ1dGUoYXR0ckxpc3QsIFwiaHRcIiwgbnVsbCk7XHJcbiAgICAgICAgICAgIGxldCBoaWRkZW4gPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJoaWRkZW5cIiwgbnVsbCk7XHJcbiAgICAgICAgICAgIGxldCBjdXN0b21IZWlnaHQgPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJjdXN0b21IZWlnaHRcIiwgbnVsbCk7XHJcblxyXG4gICAgICAgICAgICBpZihyb3dObz09bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGV0IHJvd05vTnVtID0gcGFyc2VJbnQocm93Tm8pIC0gMTtcclxuICAgICAgICAgICAgaWYoaGVpZ2h0IT1udWxsKXtcclxuICAgICAgICAgICAgICAgIGxldCBoZWlnaHROdW0gPSBwYXJzZUZsb2F0KGhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmNvbmZpZy5yb3dsZW49PW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLnJvd2xlbiA9IHt9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcucm93bGVuW3Jvd05vTnVtXSA9IGdldFJvd0hlaWdodFBpeGVsKGhlaWdodE51bSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKGhpZGRlbj09XCIxXCIpe1xyXG4gICAgICAgICAgICAgICAgaWYodGhpcy5jb25maWcucm93aGlkZGVuPT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5yb3doaWRkZW4gPSB7fTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLnJvd2hpZGRlbltyb3dOb051bV0gPSAwO1xyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmNvbmZpZy5yb3dsZW4pe1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNvbmZpZy5yb3dsZW5bcm93Tm9OdW1dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKGN1c3RvbUhlaWdodCE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBpZih0aGlzLmNvbmZpZy5jdXN0b21IZWlnaHQ9PW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLmN1c3RvbUhlaWdodCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWcuY3VzdG9tSGVpZ2h0W3Jvd05vTnVtXSA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICBpZih0aGlzLmlzSW5pdGlhbENlbGwpe1xyXG4gICAgICAgICAgICAgICAgbGV0IGNlbGxzID0gcm93LmdldElubmVyRWxlbWVudHMoXCJjXCIpO1xyXG4gICAgICAgICAgICAgICAgZm9yKGxldCBrZXkgaW4gY2VsbHMpe1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBjZWxsID0gY2VsbHNba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgY2VsbFZhbHVlID0gbmV3IEx1Y2t5U2hlZXRDZWxsZGF0YShjZWxsLCB0aGlzLnN0eWxlcywgdGhpcy5zaGFyZWRTdHJpbmdzLCB0aGlzLm1lcmdlQ2VsbHMsdGhpcy5zaGVldEZpbGUsIHRoaXMucmVhZFhtbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYoY2VsbFZhbHVlLl9ib3JkZXJPYmplY3QhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmNvbmZpZy5ib3JkZXJJbmZvPT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLmJvcmRlckluZm8gPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5ib3JkZXJJbmZvLnB1c2goY2VsbFZhbHVlLl9ib3JkZXJPYmplY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgY2VsbFZhbHVlLl9ib3JkZXJPYmplY3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGxldCBib3JkZXJJZCA9IGNlbGxWYWx1ZS5fYm9yZGVySWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYoYm9yZGVySWQhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICBsZXQgYm9yZGVycyA9IHRoaXMuc3R5bGVzW1wiYm9yZGVyc1wiXSBhcyBFbGVtZW50W107XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIGlmKHRoaXMuY29uZmlnLl9ib3JkZXJJbmZvPT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIHRoaXMuY29uZmlnLl9ib3JkZXJJbmZvID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgaWYoIGJvcmRlcklkIGluIHRoaXMuY29uZmlnLl9ib3JkZXJJbmZvKXtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIHRoaXMuY29uZmlnLl9ib3JkZXJJbmZvW2JvcmRlcklkXS5jZWxscy5wdXNoKGNlbGxWYWx1ZS5yICsgXCJfXCIgKyBjZWxsVmFsdWUuYyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIGxldCBib3JkZXIgPSBib3JkZXJzW2JvcmRlcklkXTtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIGxldCBib3JkZXJPYmplY3QgPSBuZXcgTHVja3lTaGVldGJvcmRlckluZm9DZWxsRm9ySW1wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICBib3JkZXJPYmplY3QucmFuZ2VUeXBlID0gXCJjZWxsR3JvdXBcIjtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIGJvcmRlck9iamVjdC5jZWxscyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgbGV0IGJvcmRlckNlbGxWYWx1ZSA9IG5ldyBMdWNreVNoZWV0Ym9yZGVySW5mb0NlbGxWYWx1ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICBsZXQgbGVmdHMgPSBib3JkZXIuZ2V0SW5uZXJFbGVtZW50cyhcImxlZnRcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICBsZXQgcmlnaHRzID0gYm9yZGVyLmdldElubmVyRWxlbWVudHMoXCJyaWdodFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIGxldCB0b3BzID0gYm9yZGVyLmdldElubmVyRWxlbWVudHMoXCJ0b3BcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICBsZXQgYm90dG9tcyA9IGJvcmRlci5nZXRJbm5lckVsZW1lbnRzKFwiYm90dG9tXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgbGV0IGRpYWdvbmFscyA9IGJvcmRlci5nZXRJbm5lckVsZW1lbnRzKFwiZGlhZ29uYWxcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgbGV0IGxlZnQgPSB0aGlzLmdldEJvcmRlckluZm8obGVmdHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgbGV0IHJpZ2h0ID0gdGhpcy5nZXRCb3JkZXJJbmZvKHJpZ2h0cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICBsZXQgdG9wID0gdGhpcy5nZXRCb3JkZXJJbmZvKHRvcHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgbGV0IGJvdHRvbSA9IHRoaXMuZ2V0Qm9yZGVySW5mbyhib3R0b21zKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIGxldCBkaWFnb25hbCA9IHRoaXMuZ2V0Qm9yZGVySW5mbyhkaWFnb25hbHMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIGxldCBpc0FkZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgaWYobGVmdCE9bnVsbCAmJiBsZWZ0LmNvbG9yIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICBib3JkZXJDZWxsVmFsdWUubCA9IGxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgaXNBZGQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIGlmKHJpZ2h0IT1udWxsICYmIHJpZ2h0LmNvbG9yIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICBib3JkZXJDZWxsVmFsdWUuciA9IHJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgIGlzQWRkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICBpZih0b3AhPW51bGwgJiYgdG9wLmNvbG9yIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICBib3JkZXJDZWxsVmFsdWUudCA9IHRvcDtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICBpc0FkZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgaWYoYm90dG9tIT1udWxsICYmIGJvdHRvbS5jb2xvciE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgYm9yZGVyQ2VsbFZhbHVlLmIgPSBib3R0b207XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgaXNBZGQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgIGlmKGlzQWRkKXtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICBib3JkZXJPYmplY3QudmFsdWUgPSBib3JkZXJDZWxsVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgdGhpcy5jb25maWcuX2JvcmRlckluZm9bYm9yZGVySWRdID0gYm9yZGVyT2JqZWN0O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIH1cclxuICAgICAgICAgICAgICAgICAgICBpZihjZWxsVmFsdWUuX2Zvcm11bGFUeXBlPT1cInNoYXJlZFwiKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5mb3JtdWxhUmVmTGlzdD09bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZvcm11bGFSZWZMaXN0ID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuZm9ybXVsYVJlZkxpc3RbY2VsbFZhbHVlLl9mb3JtdWxhU2ldPT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZm9ybXVsYVJlZkxpc3RbY2VsbFZhbHVlLl9mb3JtdWxhU2ldID0ge31cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZ2O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihjZWxsVmFsdWUudiE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdiA9IChjZWxsVmFsdWUudiBhcyBJbHVja3lTaGVldENlbGxkYXRhVmFsdWUpLmY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZWZWYWx1ZSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQ6Y2VsbFZhbHVlLl9mb3JtdWxhVHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZjpjZWxsVmFsdWUuX2ZvbXVsYVJlZixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpOmNlbGxWYWx1ZS5fZm9ybXVsYVNpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnY6ZnYsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsVmFsdWU6Y2VsbFZhbHVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNlbGxWYWx1ZS5fZm9tdWxhUmVmIT1udWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZm9ybXVsYVJlZkxpc3RbY2VsbFZhbHVlLl9mb3JtdWxhU2ldW1wibWFpblJlZlwiXSA9IHJlZlZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZvcm11bGFSZWZMaXN0W2NlbGxWYWx1ZS5fZm9ybXVsYVNpXVtjZWxsVmFsdWUucitcIl9cIitjZWxsVmFsdWUuY10gPSByZWZWYWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2cocmVmVmFsdWUsIHRoaXMuZm9ybXVsYVJlZkxpc3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9UaGVyZSBtYXkgYmUgZm9ybXVsYXMgdGhhdCBkbyBub3QgYXBwZWFyIGluIGNhbGNDaGFpblxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGNlbGxWYWx1ZS52IT1udWxsICYmIChjZWxsVmFsdWUudiBhcyBJbHVja3lTaGVldENlbGxkYXRhVmFsdWUpLmYhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZm9ybXVsYUNlbGw6SWZvcm11bGFMaXN0SXRlbSA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHI6Y2VsbFZhbHVlLnIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjOmNlbGxWYWx1ZS5jXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbE90aGVySW5mby5mb3JtdWxhTGlzdFtcInJcIitjZWxsVmFsdWUucitcImNcIitjZWxsVmFsdWUuY10gPSBmb3JtdWxhQ2VsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbGV0IG1heGNvbHVtbiA9IGNlbGxWYWx1ZS5jO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIChjZWxsVmFsdWUudiAhPSBudWxsICYmIChjZWxsVmFsdWUudiBhcyBJbHVja3lTaGVldENlbGxkYXRhVmFsdWUpLnYgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICBpZiAodGhpcy5sYXN0Q29udGVudERhdGEgIT0gbnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgbGV0IGxhc3RDb250ZW50Q29sID0gdGhpcy5sYXN0Q29udGVudERhdGEuYyA+IGNlbGxWYWx1ZS5jID8gdGhpcy5sYXN0Q29udGVudERhdGEuYyA6IGNlbGxWYWx1ZS5jO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgIHRoaXMubGFzdENvbnRlbnREYXRhID0ge3IgOiBjZWxsVmFsdWUuciwgYzogbGFzdENvbnRlbnRDb2wsIG1heGNvbHVtbjogbWF4Y29sdW1ufTtcclxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgdGhpcy5sYXN0Q29udGVudERhdGEgPSB7ciA6IGNlbGxWYWx1ZS5yLCBjOiBjZWxsVmFsdWUuYywgbWF4Y29sdW1uOiBtYXhjb2x1bW59O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy9sZXQgbWF4Y29sdW1uID0gY2VsbFZhbHVlLmM7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9sZXQgbGFzdENvbnRlbnRDb2wgPSBjZWxsVmFsdWUuYztcclxuICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmxhc3RDb250ZW50RGF0YSA9PSBudWxsKXtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0Q29udGVudERhdGEgPSB7ciA6IGNlbGxWYWx1ZS5yLCBjOiBjZWxsVmFsdWUuYywgbWF4Y29sdW1uOiBjZWxsVmFsdWUuY307XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZWxsVmFsdWUudiAhPSBudWxsICYmIChjZWxsVmFsdWUudiBhcyBJbHVja3lTaGVldENlbGxkYXRhVmFsdWUpLnYgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxhc3RDb250ZW50Q29sID0gdGhpcy5sYXN0Q29udGVudERhdGEuYyA+IGNlbGxWYWx1ZS5jID8gdGhpcy5sYXN0Q29udGVudERhdGEuYyA6IGNlbGxWYWx1ZS5jO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0Q29udGVudERhdGEuYyA9IGxhc3RDb250ZW50Q29sO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0Q29udGVudERhdGEuciA9IGNlbGxWYWx1ZS5yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtYXhjb2x1bW4gPSB0aGlzLmxhc3RDb250ZW50RGF0YS5tYXhjb2x1bW4gPiBjZWxsVmFsdWUuYyA/IHRoaXMubGFzdENvbnRlbnREYXRhLm1heGNvbHVtbiA6IGNlbGxWYWx1ZS5jO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RDb250ZW50RGF0YS5tYXhjb2x1bW4gPSBtYXhjb2x1bW47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAgIFxyXG5cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNlbGxkYXRhLnB1c2goY2VsbFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY2VsbE90aGVySW5mbztcclxuICAgIH1cclxuICBcclxuICAgIC8qKlxyXG4gICAgICogbHVja3lzaGVldCBjb25maWcgb2YgZGF0YVZhbGlkYXRpb25zXHJcbiAgICAgKiBcclxuICAgICAqIEByZXR1cm5zIHtJbHVja3lzaGVldERhdGFWZXJpZmljYXRpb259IC0gZGF0YVZhbGlkYXRpb25zIGNvbmZpZ1xyXG4gICAgICovXHJcbiAgICBwcml2YXRlIGdlbmVyYXRlQ29uZmlnRGF0YVZhbGlkYXRpb25zKCk6IElsdWNreXNoZWV0RGF0YVZlcmlmaWNhdGlvbiB7XHJcbiAgICAgIFxyXG4gICAgICBsZXQgcm93cyA9IHRoaXMucmVhZFhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcclxuICAgICAgICBcImRhdGFWYWxpZGF0aW9ucy9kYXRhVmFsaWRhdGlvblwiLFxyXG4gICAgICAgIHRoaXMuc2hlZXRGaWxlXHJcbiAgICAgICk7XHJcbiAgICAgIGxldCBleHRMc3QgPVxyXG4gICAgICAgIHRoaXMucmVhZFhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcclxuICAgICAgICAgIFwiZXh0THN0L2V4dC94MTQ6ZGF0YVZhbGlkYXRpb25zL3gxNDpkYXRhVmFsaWRhdGlvblwiLFxyXG4gICAgICAgICAgdGhpcy5zaGVldEZpbGVcclxuICAgICAgICApIHx8IFtdO1xyXG4gICAgICBcclxuICAgICAgcm93cyA9IHJvd3MuY29uY2F0KGV4dExzdCk7XHJcbiAgXHJcbiAgICAgIGxldCBkYXRhVmVyaWZpY2F0aW9uOiBJbHVja3lzaGVldERhdGFWZXJpZmljYXRpb24gPSB7fTtcclxuICBcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IHJvdyA9IHJvd3NbaV07XHJcbiAgICAgICAgbGV0IGF0dHJMaXN0ID0gcm93LmF0dHJpYnV0ZUxpc3Q7XHJcbiAgICAgICAgbGV0IGZvcm11bGFWYWx1ZSA9IHJvdy52YWx1ZTtcclxuICBcclxuICAgICAgICBsZXQgdHlwZSA9IGdldFhtbEF0dGlidXRlKGF0dHJMaXN0LCBcInR5cGVcIiwgbnVsbCk7XHJcbiAgICAgICAgaWYoIXR5cGUpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBvcGVyYXRvciA9IFwiXCIsXHJcbiAgICAgICAgICAgIHNxcmVmID0gXCJcIixcclxuICAgICAgICAgICAgc3FyZWZJbmRleEFycjogc3RyaW5nW10gPSBbXSxcclxuICAgICAgICAgICAgdmFsdWVBcnI6IHN0cmluZ1tdID0gW107XHJcbiAgICAgICAgbGV0IF9wcm9oaWJpdElucHV0ID1cclxuICAgICAgICAgIGdldFhtbEF0dGlidXRlKGF0dHJMaXN0LCBcImFsbG93QmxhbmtcIiwgbnVsbCkgIT09IFwiMVwiID8gZmFsc2UgOiB0cnVlO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIHgxNCBwcm9jZXNzaW5nXHJcbiAgICAgICAgY29uc3QgZm9ybXVsYVJlZyA9IG5ldyBSZWdFeHAoLzx4MTQ6Zm9ybXVsYTE+fDx4bTpzcXJlZj4vZylcclxuICAgICAgICBpZiAoZm9ybXVsYVJlZy50ZXN0KGZvcm11bGFWYWx1ZSkgJiYgZXh0THN0Py5sZW5ndGggPj0gMCkge1xyXG4gICAgICAgICAgb3BlcmF0b3IgPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJvcGVyYXRvclwiLCBudWxsKTtcclxuICAgICAgICAgIGNvbnN0IHBlZWxPZmZEYXRhID0gZ2V0UGVlbE9mZlgxNChmb3JtdWxhVmFsdWUpO1xyXG4gICAgICAgICAgc3FyZWYgPSBwZWVsT2ZmRGF0YT8uc3FyZWY7XHJcbiAgICAgICAgICBzcXJlZkluZGV4QXJyID0gZ2V0TXVsdGlTZXF1ZW5jZVRvTnVtKHNxcmVmKTtcclxuICAgICAgICAgIHZhbHVlQXJyID0gZ2V0TXVsdGlGb3JtdWxhVmFsdWUocGVlbE9mZkRhdGE/LmZvcm11bGEpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBvcGVyYXRvciA9IGdldFhtbEF0dGlidXRlKGF0dHJMaXN0LCBcIm9wZXJhdG9yXCIsIG51bGwpO1xyXG4gICAgICAgICAgc3FyZWYgPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJzcXJlZlwiLCBudWxsKTtcclxuICAgICAgICAgIHNxcmVmSW5kZXhBcnIgPSBnZXRNdWx0aVNlcXVlbmNlVG9OdW0oc3FyZWYpO1xyXG4gICAgICAgICAgdmFsdWVBcnIgPSBnZXRNdWx0aUZvcm11bGFWYWx1ZShmb3JtdWxhVmFsdWUpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IF90eXBlID0gREFUQV9WRVJJRklDQVRJT05fTUFQW3R5cGVdO1xyXG4gICAgICAgIGxldCBfdHlwZTIgPSBudWxsO1xyXG4gICAgICAgIGxldCBfdmFsdWUxOiBzdHJpbmcgfCBudW1iZXIgPSB2YWx1ZUFycj8ubGVuZ3RoID49IDEgPyB2YWx1ZUFyclswXSA6IFwiXCI7XHJcbiAgICAgICAgbGV0IF92YWx1ZTI6IHN0cmluZyB8IG51bWJlciA9IHZhbHVlQXJyPy5sZW5ndGggPT09IDIgPyB2YWx1ZUFyclsxXSA6IFwiXCI7XHJcbiAgICAgICAgbGV0IF9oaW50ID0gZ2V0WG1sQXR0aWJ1dGUoYXR0ckxpc3QsIFwicHJvbXB0XCIsIG51bGwpO1xyXG4gICAgICAgIGxldCBfaGludFNob3cgPSBfaGludCA/IHRydWUgOiBmYWxzZVxyXG4gIFxyXG4gICAgICAgIGNvbnN0IG1hdGNoVHlwZSA9IENPTU1PTl9UWVBFMi5pbmNsdWRlcyhfdHlwZSkgPyBcImNvbW1vblwiIDogX3R5cGU7XHJcbiAgICAgICAgLy8gX3R5cGUyID0gb3BlcmF0b3JcclxuICAgICAgICAvLyAgID8gREFUQV9WRVJJRklDQVRJT05fVFlQRTJfTUFQW21hdGNoVHlwZV1bb3BlcmF0b3JdXHJcbiAgICAgICAgLy8gICA6IFwiYndcIjtcclxuICAgICAgICBpZiAoREFUQV9WRVJJRklDQVRJT05fVFlQRTJfTUFQW21hdGNoVHlwZV0gIT0gdW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgX3R5cGUyID0gb3BlcmF0b3IgPyBEQVRBX1ZFUklGSUNBVElPTl9UWVBFMl9NQVBbbWF0Y2hUeXBlXVtvcGVyYXRvcl0gOiBcImJ3XCI7IC8vIG1vYmlsZSBwaG9uZSBudW1iZXIgcHJvY2Vzc2luZ1xyXG4gICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICBfdHlwZTIgPSBcImJ3XCI7XHJcbiAgICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBtb2JpbGUgcGhvbmUgbnVtYmVyIHByb2Nlc3NpbmdcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICBfdHlwZSA9PT0gXCJ0ZXh0X2NvbnRlbnRcIiAmJlxyXG4gICAgICAgICAgKF92YWx1ZTE/LmluY2x1ZGVzKFwiTEVOXCIpIHx8IF92YWx1ZTE/LmluY2x1ZGVzKFwibGVuXCIpKSAmJlxyXG4gICAgICAgICAgX3ZhbHVlMT8uaW5jbHVkZXMoXCI9MTFcIilcclxuICAgICAgICApIHtcclxuICAgICAgICAgIF90eXBlID0gXCJ2YWxpZGl0eVwiO1xyXG4gICAgICAgICAgX3R5cGUyID0gXCJwaG9uZVwiO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gZGF0ZSBwcm9jZXNzaW5nXHJcbiAgICAgICAgaWYgKF90eXBlID09PSBcImRhdGVcIikge1xyXG4gICAgICAgICAgY29uc3QgRDE5MDAgPSBuZXcgRGF0ZSgxODk5LCAxMSwgMzAsIDAsIDAsIDApO1xyXG4gICAgICAgICAgX3ZhbHVlMSA9IGRheWpzKEQxOTAwKVxyXG4gICAgICAgICAgICAuY2xvbmUoKVxyXG4gICAgICAgICAgICAuYWRkKE51bWJlcihfdmFsdWUxKSwgXCJkYXlcIilcclxuICAgICAgICAgICAgLmZvcm1hdChcIllZWVktTU0tRERcIik7XHJcbiAgICAgICAgICBfdmFsdWUyID0gZGF5anMoRDE5MDApXHJcbiAgICAgICAgICAgIC5jbG9uZSgpXHJcbiAgICAgICAgICAgIC5hZGQoTnVtYmVyKF92YWx1ZTIpLCBcImRheVwiKVxyXG4gICAgICAgICAgICAuZm9ybWF0KFwiWVlZWS1NTS1ERFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gY2hlY2tib3ggYW5kIGRyb3Bkb3duIHByb2Nlc3NpbmdcclxuICAgICAgICBpZiAoX3R5cGUgPT09IFwiY2hlY2tib3hcIiB8fCBfdHlwZSA9PT0gXCJkcm9wZG93blwiKSB7XHJcbiAgICAgICAgICBfdHlwZTIgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBkeW5hbWljYWxseSBhZGQgZGF0YVZlcmlmaWNhdGlvbnNcclxuICAgICAgICBmb3IgKGNvbnN0IHJlZiBvZiBzcXJlZkluZGV4QXJyKSB7XHJcbiAgICAgICAgICBkYXRhVmVyaWZpY2F0aW9uW3JlZl0gPSB7XHJcbiAgICAgICAgICAgIHR5cGU6IF90eXBlLFxyXG4gICAgICAgICAgICB0eXBlMjogX3R5cGUyLFxyXG4gICAgICAgICAgICB2YWx1ZTE6IF92YWx1ZTEsXHJcbiAgICAgICAgICAgIHZhbHVlMjogX3ZhbHVlMixcclxuICAgICAgICAgICAgY2hlY2tlZDogZmFsc2UsXHJcbiAgICAgICAgICAgIHJlbW90ZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHByb2hpYml0SW5wdXQ6IF9wcm9oaWJpdElucHV0LFxyXG4gICAgICAgICAgICBoaW50U2hvdzogX2hpbnRTaG93LFxyXG4gICAgICAgICAgICBoaW50VGV4dDogX2hpbnRcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIHJldHVybiBkYXRhVmVyaWZpY2F0aW9uO1xyXG4gICAgfVxyXG4gIFxyXG4gICAgLyoqXHJcbiAgICAgKiBsdWNreXNoZWV0IGNvbmZpZyBvZiBoeXBlcmxpbmtcclxuICAgICAqIFxyXG4gICAgICogQHJldHVybnMge0lsdWNreXNoZWV0SHlwZXJsaW5rfSAtIGh5cGVybGluayBjb25maWdcclxuICAgICAqL1xyXG4gICAgcHJpdmF0ZSBnZW5lcmF0ZUNvbmZpZ0h5cGVybGlua3MoKTogSWx1Y2t5c2hlZXRIeXBlcmxpbmsge1xyXG4gICAgICBsZXQgcm93cyA9IHRoaXMucmVhZFhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZShcclxuICAgICAgICBcImh5cGVybGlua3MvaHlwZXJsaW5rXCIsXHJcbiAgICAgICAgdGhpcy5zaGVldEZpbGVcclxuICAgICAgKTtcclxuICAgICAgbGV0IGh5cGVybGluazogSWx1Y2t5c2hlZXRIeXBlcmxpbmsgPSB7fTtcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV0IHJvdyA9IHJvd3NbaV07XHJcbiAgICAgICAgbGV0IGF0dHJMaXN0ID0gcm93LmF0dHJpYnV0ZUxpc3Q7XHJcbiAgICAgICAgbGV0IHJlZiA9IGdldFhtbEF0dGlidXRlKGF0dHJMaXN0LCBcInJlZlwiLCBudWxsKSxcclxuICAgICAgICAgICAgcmVmQXJyID0gZ2V0TXVsdGlTZXF1ZW5jZVRvTnVtKHJlZiksXHJcbiAgICAgICAgICAgIF9kaXNwbGF5ID0gZ2V0WG1sQXR0aWJ1dGUoYXR0ckxpc3QsIFwiZGlzcGxheVwiLCBudWxsKSxcclxuICAgICAgICAgICAgX2FkZHJlc3MgPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJsb2NhdGlvblwiLCBudWxsKSxcclxuICAgICAgICAgICAgX3Rvb2x0aXAgPSBnZXRYbWxBdHRpYnV0ZShhdHRyTGlzdCwgXCJ0b29sdGlwXCIsIG51bGwpO1xyXG4gICAgICAgIGxldCBfdHlwZTogSWx1Y2t5c2hlZXRIeXBlcmxpbmtUeXBlID0gX2FkZHJlc3MgPyBcImludGVybmFsXCIgOiBcImV4dGVybmFsXCI7XHJcbiAgXHJcbiAgICAgICAgLy8gZXh0ZXJuYWwgaHlwZXJsaW5rXHJcbiAgICAgICAgaWYgKCFfYWRkcmVzcykge1xyXG4gICAgICAgICAgbGV0IHJpZCA9IGF0dHJMaXN0W1wicjppZFwiXTtcclxuICAgICAgICAgIGxldCBzaGVldEZpbGUgPSB0aGlzLnNoZWV0RmlsZTtcclxuICAgICAgICAgIGxldCByZWxhdGlvbnNoaXBMaXN0ID0gdGhpcy5yZWFkWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKFxyXG4gICAgICAgICAgICBcIlJlbGF0aW9uc2hpcHMvUmVsYXRpb25zaGlwXCIsXHJcbiAgICAgICAgICAgIGB4bC93b3Jrc2hlZXRzL19yZWxzLyR7c2hlZXRGaWxlLnJlcGxhY2Uod29ya3NoZWV0RmlsZVBhdGgsIFwiXCIpfS5yZWxzYFxyXG4gICAgICAgICAgKTtcclxuICBcclxuICAgICAgICAgIGNvbnN0IGZpbmRSaWQgPSByZWxhdGlvbnNoaXBMaXN0Py5maW5kKFxyXG4gICAgICAgICAgICAoZSkgPT4gZS5hdHRyaWJ1dGVMaXN0W1wiSWRcIl0gPT09IHJpZFxyXG4gICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICBpZiAoZmluZFJpZCkge1xyXG4gICAgICAgICAgICBfYWRkcmVzcyA9IGZpbmRSaWQuYXR0cmlidXRlTGlzdFtcIlRhcmdldFwiXTtcclxuICAgICAgICAgICAgX3R5cGUgPSBmaW5kUmlkLmF0dHJpYnV0ZUxpc3RbXHJcbiAgICAgICAgICAgICAgXCJUYXJnZXRNb2RlXCJcclxuICAgICAgICAgICAgXT8udG9Mb2NhbGVMb3dlckNhc2UoKSBhcyBJbHVja3lzaGVldEh5cGVybGlua1R5cGU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBtYXRjaCBSMUMxXHJcbiAgICAgICAgY29uc3QgYWRkcmVzc1JlZyA9IG5ldyBSZWdFeHAoL14uKiFSKFtcXGQkXSkrQyhbXFxkJF0pKiQvZylcclxuICAgICAgICBpZiAoYWRkcmVzc1JlZy50ZXN0KF9hZGRyZXNzKSkge1xyXG4gICAgICAgICAgX2FkZHJlc3MgPSBnZXRUcmFuc1IxQzFUb1NlcXVlbmNlKF9hZGRyZXNzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gZHluYW1pY2FsbHkgYWRkIGh5cGVybGlua3NcclxuICAgICAgICBmb3IgKGNvbnN0IHJlZiBvZiByZWZBcnIpIHtcclxuICAgICAgICAgIGh5cGVybGlua1tyZWZdID0ge1xyXG4gICAgICAgICAgICBsaW5rQWRkcmVzczogX2FkZHJlc3MsXHJcbiAgICAgICAgICAgIGxpbmtUb29sdGlwOiBfdG9vbHRpcCB8fCBcIlwiLFxyXG4gICAgICAgICAgICBsaW5rVHlwZTogX3R5cGUsXHJcbiAgICAgICAgICAgIGRpc3BsYXk6IF9kaXNwbGF5IHx8IFwiXCIsXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgcmV0dXJuIGh5cGVybGluaztcclxuICAgIH1cclxuXHJcbiAgICAvLyBwcml2YXRlIGdldEJvcmRlckluZm8oYm9yZGVyczpFbGVtZW50W10pOkx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbFZhbHVlU3R5bGV7XHJcbiAgICAvLyAgICAgaWYoYm9yZGVycz09bnVsbCl7XHJcbiAgICAvLyAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgLy8gICAgIH1cclxuXHJcbiAgICAvLyAgICAgbGV0IGJvcmRlciA9IGJvcmRlcnNbMF0sIGF0dHJMaXN0ID0gYm9yZGVyLmF0dHJpYnV0ZUxpc3Q7XHJcbiAgICAvLyAgICAgbGV0IGNsclNjaGVtZSA9IHRoaXMuc3R5bGVzW1wiY2xyU2NoZW1lXCJdIGFzIEVsZW1lbnRbXTtcclxuICAgIC8vICAgICBsZXQgc3R5bGU6c3RyaW5nID0gYXR0ckxpc3Quc3R5bGU7XHJcbiAgICAvLyAgICAgaWYoc3R5bGU9PW51bGwgfHwgc3R5bGU9PVwibm9uZVwiKXtcclxuICAgIC8vICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAvLyAgICAgfVxyXG5cclxuICAgIC8vICAgICBsZXQgY29sb3JzID0gYm9yZGVyLmdldElubmVyRWxlbWVudHMoXCJjb2xvclwiKTtcclxuICAgIC8vICAgICBsZXQgY29sb3JSZXQgPSBcIiMwMDAwMDBcIjtcclxuICAgIC8vICAgICBpZihjb2xvcnMhPW51bGwpe1xyXG4gICAgLy8gICAgICAgICBsZXQgY29sb3IgPSBjb2xvcnNbMF07XHJcbiAgICAvLyAgICAgICAgIGNvbG9yUmV0ID0gZ2V0Q29sb3IoY29sb3IsIGNsclNjaGVtZSk7XHJcbiAgICAvLyAgICAgfVxyXG5cclxuICAgIC8vICAgICBsZXQgcmV0ID0gbmV3IEx1Y2t5U2hlZXRib3JkZXJJbmZvQ2VsbFZhbHVlU3R5bGUoKTtcclxuICAgIC8vICAgICByZXQuc3R5bGUgPSBib3JkZXJUeXBlc1tzdHlsZV07XHJcbiAgICAvLyAgICAgcmV0LmNvbG9yID0gY29sb3JSZXQ7XHJcblxyXG4gICAgLy8gICAgIHJldHVybiByZXQ7XHJcbiAgICAvLyB9XHJcbn1cclxuIiwiaW1wb3J0IHtJdXBsb2FkZmlsZUxpc3QsIElhdHRyaWJ1dGVMaXN0LCBzdHJpbmdUb051bX0gZnJvbSBcIi4uL0lDb21tb25cIjtcclxuaW1wb3J0IHtpbmRleGVkQ29sb3JzfSAgZnJvbSBcIi4uL2NvbW1vbi9jb25zdGFudFwiO1xyXG5pbXBvcnQge0xpZ2h0ZW5EYXJrZW5Db2xvcn0gIGZyb20gXCIuLi9jb21tb24vbWV0aG9kXCI7XHJcblxyXG5cclxuY2xhc3MgeG1sb3BlcmF0aW9uIHtcclxuICAgIC8qKlxyXG4gICAgKiBAcGFyYW0gdGFnIFNlYXJjaCB4bWwgdGFnIG5hbWUgLCBkaXYsdGl0bGUgZXRjLlxyXG4gICAgKiBAcGFyYW0gZmlsZSBYbWwgc3RyaW5nXHJcbiAgICAqIEByZXR1cm4gWG1sIGVsZW1lbnQgc3RyaW5nIFxyXG4gICAgKi9cclxuICAgIHByb3RlY3RlZCBnZXRFbGVtZW50c0J5T25lVGFnKHRhZzpzdHJpbmcsIGZpbGU6c3RyaW5nKTpzdHJpbmdbXXtcclxuICAgICAgICAvLzxhOlteLz46IF0rPz4uKj88L2E6W14vPjogXSs/PlxyXG4gICAgICAgIGxldCByZWFkVGFnUmVnO1xyXG4gICAgICAgIGlmKHRhZy5pbmRleE9mKFwifFwiKT4tMSl7XHJcbiAgICAgICAgICAgIGxldCB0YWdzID0gdGFnLnNwbGl0KFwifFwiKSwgdGFnc1JlZ1R4dD1cIlwiO1xyXG4gICAgICAgICAgICBmb3IobGV0IGk9MDtpPHRhZ3MubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgICAgICAgICBsZXQgdCA9IHRhZ3NbaV07XHJcbiAgICAgICAgICAgICAgICB0YWdzUmVnVHh0ICs9IFwifDxcIisgdCArXCIgW14+XSs/W14vXT5bXFxcXHNcXFxcU10qPzwvXCIrIHQgK1wiPnw8XCIrIHQgK1wiIFtePl0rPy8+fDxcIisgdCArXCI+W1xcXFxzXFxcXFNdKj88L1wiKyB0ICtcIj58PFwiKyB0ICtcIi8+XCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGFnc1JlZ1R4dCA9IHRhZ3NSZWdUeHQuc3Vic3RyKDEsIHRhZ3NSZWdUeHQubGVuZ3RoKTtcclxuICAgICAgICAgICAgcmVhZFRhZ1JlZyA9IG5ldyBSZWdFeHAodGFnc1JlZ1R4dCwgXCJnXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICByZWFkVGFnUmVnID0gbmV3IFJlZ0V4cChcIjxcIisgdGFnICtcIiBbXj5dKz9bXi9dPltcXFxcc1xcXFxTXSo/PC9cIisgdGFnICtcIj58PFwiKyB0YWcgK1wiIFtePl0rPy8+fDxcIisgdGFnICtcIj5bXFxcXHNcXFxcU10qPzwvXCIrIHRhZyArXCI+fDxcIisgdGFnICtcIi8+XCIsIFwiZ1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgbGV0IHJldCA9IGZpbGUubWF0Y2gocmVhZFRhZ1JlZyk7XHJcbiAgICAgICAgaWYocmV0PT1udWxsKXtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFJlYWRYbWwgZXh0ZW5kcyB4bWxvcGVyYXRpb257XHJcbiAgICBvcmlnaW5GaWxlOkl1cGxvYWRmaWxlTGlzdFxyXG4gICAgY29uc3RydWN0b3IoZmlsZXM6SXVwbG9hZGZpbGVMaXN0KXtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMub3JpZ2luRmlsZSA9IGZpbGVzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAqIEBwYXJhbSBwYXRoIFNlYXJjaCB4bWwgdGFnIGdyb3VwICwgZGl2LHRpdGxlIGV0Yy5cclxuICAgICogQHBhcmFtIGZpbGVOYW1lIE9uZSBvZiB1cGxvYWRmaWxlTGlzdCwgdXBsb2FkZmlsZUxpc3QgaXMgZmlsZSBncm91cCwge2tleTp2YWx1ZX1cclxuICAgICogQHJldHVybiBYbWwgZWxlbWVudCBjYWxzc1xyXG4gICAgKi9cclxuICAgIGdldEVsZW1lbnRzQnlUYWdOYW1lKHBhdGg6c3RyaW5nLCBmaWxlTmFtZTpzdHJpbmcpOiBFbGVtZW50W117XHJcbiAgICAgICAgXHJcbiAgICAgICAgbGV0IGZpbGUgPSB0aGlzLmdldEZpbGVCeU5hbWUoZmlsZU5hbWUpO1xyXG4gICAgICAgIGxldCBwYXRoQXJyID0gcGF0aC5zcGxpdChcIi9cIiksIHJldDpzdHJpbmdbXSB8IHN0cmluZztcclxuICAgICAgICBmb3IobGV0IGtleSBpbiBwYXRoQXJyKXtcclxuICAgICAgICAgICAgbGV0IHBhdGggPSBwYXRoQXJyW2tleV07XHJcbiAgICAgICAgICAgIGlmKHJldD09dW5kZWZpbmVkKXtcclxuICAgICAgICAgICAgICAgIHJldCA9IHRoaXMuZ2V0RWxlbWVudHNCeU9uZVRhZyhwYXRoLGZpbGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICBpZihyZXQgaW5zdGFuY2VvZiBBcnJheSl7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGl0ZW1zOnN0cmluZ1tdPVtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvcihsZXQga2V5IGluIHJldCl7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpdGVtID0gcmV0W2tleV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zID0gaXRlbXMuY29uY2F0KHRoaXMuZ2V0RWxlbWVudHNCeU9uZVRhZyhwYXRoLGl0ZW0pKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gaXRlbXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgICAgIHJldCA9IHRoaXMuZ2V0RWxlbWVudHNCeU9uZVRhZyhwYXRoLHJldCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBlbGVtZW50czpFbGVtZW50W10gPSBbXTtcclxuXHJcbiAgICAgICAgZm9yKGxldCBpPTA7aTxyZXQubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgICAgIGxldCBlbGUgPSBuZXcgRWxlbWVudChyZXRbaV0pO1xyXG4gICAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZWxlbWVudHM7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEBwYXJhbSBuYW1lIE9uZSBvZiB1cGxvYWRmaWxlTGlzdCdzIG5hbWUsIHNlYXJjaCBmb3IgZmlsZSBieSB0aGlzIHBhcmFtZXRlclxyXG4gICAgKiBAcmV0cnVuIFNlbGVjdCBhIGZpbGUgZnJvbSB1cGxvYWRmaWxlTGlzdFxyXG4gICAgKi9cclxuICAgIHByaXZhdGUgZ2V0RmlsZUJ5TmFtZShuYW1lOnN0cmluZyk6c3RyaW5ne1xyXG4gICAgICAgIGZvcihsZXQgZmlsZUtleSBpbiB0aGlzLm9yaWdpbkZpbGUpe1xyXG4gICAgICAgICAgICBpZihmaWxlS2V5LmluZGV4T2YobmFtZSk+LTEpe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luRmlsZVtmaWxlS2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgIH1cclxuXHJcbiAgICBcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEVsZW1lbnQgZXh0ZW5kcyB4bWxvcGVyYXRpb24ge1xyXG4gICAgZWxlbWVudFN0cmluZzpzdHJpbmdcclxuICAgIGF0dHJpYnV0ZUxpc3Q6SWF0dHJpYnV0ZUxpc3RcclxuICAgIHZhbHVlOnN0cmluZ1xyXG4gICAgY29udGFpbmVyOnN0cmluZ1xyXG4gICAgY29uc3RydWN0b3Ioc3RyOnN0cmluZyl7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmVsZW1lbnRTdHJpbmcgPSBzdHI7XHJcbiAgICAgICAgdGhpcy5zZXRWYWx1ZSgpO1xyXG4gICAgICAgIGNvbnN0IHJlYWRBdHRyUmVnID0gbmV3IFJlZ0V4cCgnW2EtekEtWjAtOV86XSo/PVwiLio/XCInLCBcImdcIik7XHJcbiAgICAgICAgbGV0IGF0dHJMaXN0ID0gdGhpcy5jb250YWluZXIubWF0Y2gocmVhZEF0dHJSZWcpO1xyXG4gICAgICAgIHRoaXMuYXR0cmlidXRlTGlzdCA9IHt9O1xyXG4gICAgICAgIGlmKGF0dHJMaXN0IT1udWxsKXtcclxuICAgICAgICAgICAgZm9yKGxldCBrZXkgaW4gYXR0ckxpc3Qpe1xyXG4gICAgICAgICAgICAgICAgbGV0IGF0dHJGdWxsID0gYXR0ckxpc3Rba2V5XTtcclxuICAgICAgICAgICAgICAgIC8vIGxldCBhbD0gYXR0ckZ1bGwuc3BsaXQoXCI9XCIpO1xyXG4gICAgICAgICAgICAgICAgaWYoYXR0ckZ1bGwubGVuZ3RoPT0wKXtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCBhdHRyS2V5ID0gYXR0ckZ1bGwuc3Vic3RyKDAsIGF0dHJGdWxsLmluZGV4T2YoJz0nKSk7XHJcbiAgICAgICAgICAgICAgICBsZXQgYXR0clZhbHVlID0gYXR0ckZ1bGwuc3Vic3RyKGF0dHJGdWxsLmluZGV4T2YoJz0nKSArIDEpO1xyXG4gICAgICAgICAgICAgICAgaWYoYXR0cktleT09bnVsbCB8fCBhdHRyVmFsdWU9PW51bGwgfHxhdHRyS2V5Lmxlbmd0aD09MCB8fCBhdHRyVmFsdWUubGVuZ3RoPT0wKXtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlTGlzdFthdHRyS2V5XSA9IGF0dHJWYWx1ZS5zdWJzdHIoMSwgYXR0clZhbHVlLmxlbmd0aC0yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogQHBhcmFtIG5hbWUgR2V0IGF0dHJpYnV0ZSBieSBrZXkgaW4gZWxlbWVudFxyXG4gICAgKiBAcmV0dXJuIFNpbmdsZSBhdHRyaWJ1dGVcclxuICAgICovXHJcbiAgICBnZXQobmFtZTpzdHJpbmcpOnN0cmluZ3xudW1iZXJ8Ym9vbGVhbntcclxuICAgICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVMaXN0W25hbWVdO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAcGFyYW0gdGFnIEdldCBlbGVtZW50cyBieSB0YWcgaW4gZWxlbWVudFN0cmluZ1xyXG4gICAgKiBAcmV0dXJuIEVsZW1lbnQgZ3JvdXBcclxuICAgICovXHJcbiAgICBnZXRJbm5lckVsZW1lbnRzKHRhZzpzdHJpbmcpOkVsZW1lbnRbXXtcclxuICAgICAgICBsZXQgcmV0ID0gdGhpcy5nZXRFbGVtZW50c0J5T25lVGFnKHRhZyx0aGlzLmVsZW1lbnRTdHJpbmcpO1xyXG4gICAgICAgIGxldCBlbGVtZW50czpFbGVtZW50W10gPSBbXTtcclxuXHJcbiAgICAgICAgZm9yKGxldCBpPTA7aTxyZXQubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgICAgIGxldCBlbGUgPSBuZXcgRWxlbWVudChyZXRbaV0pO1xyXG4gICAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZihlbGVtZW50cy5sZW5ndGg9PTApe1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgKiBAZGVzYyBnZXQgeG1sIGRvbSB2YWx1ZSBhbmQgY29udGFpbmVyLCA8Y29udGFpbmVyPnZhbHVlPC9jb250YWluZXI+XHJcbiAgICAqL1xyXG4gICAgcHJpdmF0ZSBzZXRWYWx1ZSgpe1xyXG4gICAgICAgIGxldCBzdHIgPSB0aGlzLmVsZW1lbnRTdHJpbmc7XHJcbiAgICAgICAgaWYoc3RyLnN1YnN0cihzdHIubGVuZ3RoLTIsIDIpPT1cIi8+XCIpe1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJcIjtcclxuICAgICAgICAgICAgdGhpcy5jb250YWluZXIgPSBzdHI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIGxldCBmaXJzdFRhZyA9IHRoaXMuZ2V0Rmlyc3RUYWcoKTtcclxuICAgICAgICAgICAgY29uc3QgZmlyc3RUYWdSZWcgPSBuZXcgUmVnRXhwKFwiKDxcIisgZmlyc3RUYWcgK1wiIFtePl0rP1teL10+KShbXFxcXHNcXFxcU10qPyk8L1wiKyBmaXJzdFRhZyArXCI+fCg8XCIrIGZpcnN0VGFnICtcIj4pKFtcXFxcc1xcXFxTXSo/KTwvXCIrIGZpcnN0VGFnICtcIj5cIiwgXCJnXCIpO1xyXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gZmlyc3RUYWdSZWcuZXhlYyhzdHIpO1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlmKHJlc3VsdFsxXSE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIgPSByZXN1bHRbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHJlc3VsdFsyXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIgPSByZXN1bHRbM107XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHJlc3VsdFs0XTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogQGRlc2MgZ2V0IHhtbCBkb20gZmlyc3QgdGFnLCA8YT48Yj48L2I+PC9hPiwgZ2V0IGFcclxuICAgICovXHJcbiAgICBwcml2YXRlIGdldEZpcnN0VGFnKCl7XHJcbiAgICAgICAgbGV0IHN0ciA9IHRoaXMuZWxlbWVudFN0cmluZztcclxuICAgICAgICBsZXQgZmlyc3RUYWcgPSBzdHIuc3Vic3RyKDAsIHN0ci5pbmRleE9mKCcgJykpO1xyXG4gICAgICAgIGlmKGZpcnN0VGFnPT1cIlwiIHx8IGZpcnN0VGFnLmluZGV4T2YoXCI+XCIpPi0xKXtcclxuICAgICAgICAgICAgZmlyc3RUYWcgPSBzdHIuc3Vic3RyKDAsIHN0ci5pbmRleE9mKCc+JykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaXJzdFRhZyA9IGZpcnN0VGFnLnN1YnN0cigxLGZpcnN0VGFnLmxlbmd0aCk7XHJcbiAgICAgICAgcmV0dXJuIGZpcnN0VGFnO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJU3R5bGVDb2xsZWN0aW9ucyB7XHJcbiAgICBbaW5kZXg6c3RyaW5nXTpFbGVtZW50W10gfCBJYXR0cmlidXRlTGlzdFxyXG59XHJcblxyXG5mdW5jdGlvbiBjb21iaW5lSW5kZXhlZENvbG9yKGluZGV4ZWRDb2xvcnNJbm5lcjpFbGVtZW50W10sIGluZGV4ZWRDb2xvcnM6SWF0dHJpYnV0ZUxpc3QpOklhdHRyaWJ1dGVMaXN0e1xyXG4gICAgbGV0IHJldDpJYXR0cmlidXRlTGlzdCA9IHt9O1xyXG4gICAgaWYoaW5kZXhlZENvbG9yc0lubmVyPT1udWxsIHx8IGluZGV4ZWRDb2xvcnNJbm5lci5sZW5ndGg9PTApe1xyXG4gICAgICAgIHJldHVybiBpbmRleGVkQ29sb3JzO1xyXG4gICAgfVxyXG4gICAgZm9yKGxldCBrZXkgaW4gaW5kZXhlZENvbG9ycyl7XHJcbiAgICAgICAgbGV0IHZhbHVlID0gaW5kZXhlZENvbG9yc1trZXldLCBrbiA9IHBhcnNlSW50KGtleSk7XHJcbiAgICAgICAgbGV0IGlubmVyID0gaW5kZXhlZENvbG9yc0lubmVyW2tuXTtcclxuICAgICAgICBpZihpbm5lcj09bnVsbCl7XHJcbiAgICAgICAgICAgIHJldFtrZXldID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2V7XHJcbiAgICAgICAgICAgIGxldCByZ2IgPSBpbm5lci5hdHRyaWJ1dGVMaXN0LnJnYjtcclxuICAgICAgICAgICAgcmV0W2tleV0gPSByZ2I7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXQ7XHJcbn1cclxuXHJcbi8vY2xyU2NoZW1lOkVsZW1lbnRbXVxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29sb3IoY29sb3I6RWxlbWVudCwgc3R5bGVzOklTdHlsZUNvbGxlY3Rpb25zICwgdHlwZTpzdHJpbmc9XCJnXCIpe1xyXG4gICAgbGV0IGF0dHJMaXN0ID0gY29sb3IuYXR0cmlidXRlTGlzdDtcclxuICAgIGxldCBjbHJTY2hlbWUgPSBzdHlsZXNbXCJjbHJTY2hlbWVcIl0gYXMgRWxlbWVudFtdO1xyXG4gICAgbGV0IGluZGV4ZWRDb2xvcnNJbm5lciA9IHN0eWxlc1tcImluZGV4ZWRDb2xvcnNcIl0gYXMgRWxlbWVudFtdO1xyXG4gICAgbGV0IG1ydUNvbG9yc0lubmVyID0gc3R5bGVzW1wibXJ1Q29sb3JzXCJdO1xyXG4gICAgbGV0IGluZGV4ZWRDb2xvcnNMaXN0ID0gY29tYmluZUluZGV4ZWRDb2xvcihpbmRleGVkQ29sb3JzSW5uZXIsIGluZGV4ZWRDb2xvcnMpO1xyXG4gICAgbGV0IGluZGV4ZWQgPSBhdHRyTGlzdC5pbmRleGVkLCByZ2IgPSBhdHRyTGlzdC5yZ2IsIHRoZW1lID0gYXR0ckxpc3QudGhlbWUsIHRpbnQgPSBhdHRyTGlzdC50aW50O1xyXG4gICAgbGV0IGJnO1xyXG4gICAgaWYoaW5kZXhlZCE9bnVsbCl7XHJcbiAgICAgICAgbGV0IGluZGV4ZWROdW0gPSBwYXJzZUludChpbmRleGVkKTtcclxuICAgICAgICBiZyA9IGluZGV4ZWRDb2xvcnNMaXN0W2luZGV4ZWROdW1dO1xyXG4gICAgICAgIGlmKGJnIT1udWxsKXtcclxuICAgICAgICAgICAgYmcgPSBiZy5zdWJzdHJpbmcoYmcubGVuZ3RoLTYsIGJnLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGJnID0gXCIjXCIrYmc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZihyZ2IhPW51bGwpe1xyXG4gICAgICAgIHJnYiA9IHJnYi5zdWJzdHJpbmcocmdiLmxlbmd0aC02LCByZ2IubGVuZ3RoKTtcclxuICAgICAgICBiZyA9IFwiI1wiK3JnYjtcclxuICAgIH1cclxuICAgIGVsc2UgaWYodGhlbWUhPW51bGwpe1xyXG4gICAgICAgIGxldCB0aGVtZU51bSA9IHBhcnNlSW50KHRoZW1lKTtcclxuICAgICAgICBpZih0aGVtZU51bT09MCl7XHJcbiAgICAgICAgICAgIHRoZW1lTnVtID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZih0aGVtZU51bT09MSl7XHJcbiAgICAgICAgICAgIHRoZW1lTnVtID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZih0aGVtZU51bT09Mil7XHJcbiAgICAgICAgICAgIHRoZW1lTnVtID0gMztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZih0aGVtZU51bT09Myl7XHJcbiAgICAgICAgICAgIHRoZW1lTnVtID0gMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGNsclNjaGVtZUVsZW1lbnQgPSBjbHJTY2hlbWVbdGhlbWVOdW1dO1xyXG4gICAgICAgIGlmKGNsclNjaGVtZUVsZW1lbnQhPW51bGwpe1xyXG4gICAgICAgICAgICBsZXQgY2xycyA9IGNsclNjaGVtZUVsZW1lbnQuZ2V0SW5uZXJFbGVtZW50cyhcImE6c3lzQ2xyfGE6c3JnYkNsclwiKTtcclxuICAgICAgICAgICAgaWYoY2xycyE9bnVsbCl7XHJcbiAgICAgICAgICAgICAgICBsZXQgY2xyID0gY2xyc1swXTtcclxuICAgICAgICAgICAgICAgIGxldCBjbHJBdHRyTGlzdCA9IGNsci5hdHRyaWJ1dGVMaXN0O1xyXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coY2xyLmNvbnRhaW5lciwgKTtcclxuICAgICAgICAgICAgICAgIGlmKGNsci5jb250YWluZXIuaW5kZXhPZihcInN5c0NsclwiKT4tMSl7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYodHlwZT09XCJnXCIgJiYgY2xyQXR0ckxpc3QudmFsPT1cIndpbmRvd1RleHRcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIGJnID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAvLyB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBpZigodHlwZT09XCJ0XCIgfHwgdHlwZT09XCJiXCIpICYmIGNsckF0dHJMaXN0LnZhbD09XCJ3aW5kb3dcIil7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIGJnID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICAvLyB9ICAgICAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIFxyXG4gICAgICAgICAgICAgICAgICAgIGlmKGNsckF0dHJMaXN0Lmxhc3RDbHIhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiZyA9IFwiI1wiICsgY2xyQXR0ckxpc3QubGFzdENscjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihjbHJBdHRyTGlzdC52YWwhPW51bGwpe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBiZyA9IFwiI1wiICsgY2xyQXR0ckxpc3QudmFsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGNsci5jb250YWluZXIuaW5kZXhPZihcInNyZ2JDbHJcIik+LTEpe1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGNsckF0dHJMaXN0LnZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYmcgPSBcIiNcIiArIGNsckF0dHJMaXN0LnZhbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYodGludCE9bnVsbCl7XHJcbiAgICAgICAgbGV0IHRpbnROdW0gPSBwYXJzZUZsb2F0KHRpbnQpO1xyXG4gICAgICAgIGlmKGJnIT1udWxsKXtcclxuICAgICAgICAgICAgYmcgPSBMaWdodGVuRGFya2VuQ29sb3IoYmcsIHRpbnROdW0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYmc7XHJcbn1cclxuXHJcblxyXG4vKiogXHJcbiAqIEBkb20geG1sIGF0dHJpYnV0ZSBvYmplY3RcclxuICogQGF0dHIgYXR0cmlidXRlIG5hbWVcclxuICogQGQgaWYgYXR0cmlidXRlIGlzIG51bGwsIHJldHVybiBkZWZhdWx0IHZhbHVlIFxyXG4gKiBAcmV0dXJuIGF0dHJpYnV0ZSB2YWx1ZVxyXG4qL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0bGluZVN0cmluZ0F0dHIoZnJwcjpFbGVtZW50LCBhdHRyOnN0cmluZyk6c3RyaW5ne1xyXG4gICAgbGV0IGF0dHJFbGUgPSBmcnByLmdldElubmVyRWxlbWVudHMoYXR0ciksIHZhbHVlO1xyXG5cclxuICAgIGlmKGF0dHJFbGUhPW51bGwgJiYgYXR0ckVsZS5sZW5ndGg+MCl7XHJcbiAgICAgICAgaWYoYXR0cj09XCJiXCIgfHwgYXR0cj09XCJpXCIgfHwgYXR0cj09XCJzdHJpa2VcIil7XHJcbiAgICAgICAgICAgIHZhbHVlID0gXCIxXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoYXR0cj09XCJ1XCIpe1xyXG4gICAgICAgICAgICBsZXQgdiA9IGF0dHJFbGVbMF0uYXR0cmlidXRlTGlzdC52YWw7XHJcbiAgICAgICAgICAgIGlmKHY9PVwiZG91YmxlXCIpe1xyXG4gICAgICAgICAgICAgICAgdmFsdWXCoD3CoMKgXCIyXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZcKgaWYodj09XCJzaW5nbGVBY2NvdW50aW5nXCIpe1xyXG4gICAgICAgICAgICAgICAgdmFsdWXCoD3CoMKgXCIzXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZcKgaWYodj09XCJkb3VibGVBY2NvdW50aW5nXCIpe1xyXG4gICAgICAgICAgICAgICAgdmFsdWXCoD3CoMKgXCI0XCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZXtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gXCIxXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihhdHRyPT1cInZlcnRBbGlnblwiKXtcclxuICAgICAgICAgICAgbGV0IHYgPSBhdHRyRWxlWzBdLmF0dHJpYnV0ZUxpc3QudmFsO1xyXG4gICAgICAgICAgICBpZih2PT1cInN1YnNjcmlwdFwiKXtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gXCIxXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZih2PT1cInN1cGVyc2NyaXB0XCIpe1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBcIjJcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICB2YWx1ZSA9IGF0dHJFbGVbMF0uYXR0cmlidXRlTGlzdC52YWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB2YWx1ZTtcclxufSIsImltcG9ydCB7c3RyaW5nVG9OdW0sIElhdHRyaWJ1dGVMaXN0LCBudW1Ub3N0cmluZywgSURhdGFWZXJpZmljYXRpb25NYXAsIElEYXRhVmVyaWZpY2F0aW9uVHlwZTJNYXB9IGZyb20gXCIuLi9JQ29tbW9uXCI7XHJcblxyXG5leHBvcnQgY29uc3QgY29sdW1lSGVhZGVyX3dvcmQ6c3RyaW5nW10gPSBbJ0EnLCAnQicsICdDJywgJ0QnLCAnRScsICdGJywgJ0cnLCAnSCcsICdJJywgJ0onLCAnSycsICdMJywgJ00nLCAnTicsICdPJywgJ1AnLCAnUScsICdSJywgJ1MnLCAnVCcsICdVJywgJ1YnLCAnVycsICdYJywgJ1knLCAnWiddO1xyXG5cclxuZXhwb3J0IGNvbnN0IGNvbHVtZUhlYWRlcl93b3JkX2luZGV4OnN0cmluZ1RvTnVtID0geyAnQSc6IDAsICdCJzogMSwgJ0MnOiAyLCAnRCc6IDMsICdFJzogNCwgJ0YnOiA1LCAnRyc6IDYsICdIJzogNywgJ0knOiA4LCAnSic6IDksICdLJzogMTAsICdMJzogMTEsICdNJzogMTIsICdOJzogMTMsICdPJzogMTQsICdQJzogMTUsICdRJzogMTYsICdSJzogMTcsICdTJzogMTgsICdUJzogMTksICdVJzogMjAsICdWJzogMjEsICdXJzogMjIsICdYJzogMjMsICdZJzogMjQsICdaJzogMjUgfTtcclxuXHJcbmV4cG9ydCBjb25zdCBjb3JlRmlsZSA9IFwiZG9jUHJvcHMvY29yZS54bWxcIjtcclxuZXhwb3J0IGNvbnN0IGFwcEZpbGUgPSBcImRvY1Byb3BzL2FwcC54bWxcIjtcclxuZXhwb3J0IGNvbnN0IGNvbnRlbnRUeXBlc0ZpbGUgPSBcIltDb250ZW50X1R5cGVzXS54bWxcIjtcclxuZXhwb3J0IGNvbnN0IHdvcmtCb29rRmlsZSA9IFwieGwvd29ya2Jvb2sueG1sXCI7XHJcbmV4cG9ydCBjb25zdCBjYWxjQ2hhaW5GaWxlID0gXCJ4bC9jYWxjQ2hhaW4ueG1sXCI7XHJcbmV4cG9ydCBjb25zdCBzdHlsZXNGaWxlID0gXCJ4bC9zdHlsZXMueG1sXCI7XHJcbmV4cG9ydCBjb25zdCBzaGFyZWRTdHJpbmdzRmlsZSA9IFwieGwvc2hhcmVkU3RyaW5ncy54bWxcIjtcclxuZXhwb3J0IGNvbnN0IHdvcmtzaGVldEZpbGVQYXRoID0gXCJ4bC93b3Jrc2hlZXRzL1wiO1xyXG5leHBvcnQgY29uc3QgdGhlbWUxRmlsZSA9IFwieGwvdGhlbWUvdGhlbWUxLnhtbFwiO1xyXG5leHBvcnQgY29uc3Qgd29ya2Jvb2tSZWxzPSBcInhsL19yZWxzL3dvcmtib29rLnhtbC5yZWxzXCI7XHJcblxyXG5cclxuXHJcblxyXG4vL0V4Y2VsIEJ1aWx0LUluIGNlbGwgdHlwZVxyXG5leHBvcnQgY29uc3QgU1RfQ2VsbFR5cGU6SWF0dHJpYnV0ZUxpc3QgPXtcclxuICAgIFwiQm9vbGVhblwiOlwiYlwiLFxyXG4gICAgXCJEYXRlXCI6XCJkXCIsXHJcbiAgICBcIkVycm9yXCI6XCJlXCIsXHJcbiAgICBcIklubGluZVN0cmluZ1wiOlwiaW5saW5lU3RyXCIsXHJcbiAgICBcIk51bWJlclwiOlwiblwiLFxyXG4gICAgXCJTaGFyZWRTdHJpbmdcIjpcInNcIixcclxuICAgIFwiU3RyaW5nXCI6XCJzdHJcIixcclxufVxyXG5cclxuLy9FeGNlbCBCdWlsdC1JbiBjZWxsIHN0eWxlXHJcbmV4cG9ydCBjb25zdCBCdWlsdEluQ2VsbFN0eWxlczpJYXR0cmlidXRlTGlzdCA9IHtcclxuICAgIFwiMFwiOlwiTm9ybWFsXCIsXHJcblxyXG59XHJcblxyXG5cclxuZXhwb3J0IGxldCBudW1GbXREZWZhdWx0OklhdHRyaWJ1dGVMaXN0ID0ge1xyXG4gICAgXCIwXCI6J0dlbmVyYWwnLFxyXG4gICAgXCIxXCI6ICcwJyxcclxuICAgIFwiMlwiOiAnMC4wMCcsXHJcbiAgICBcIjNcIjogJyMsIyMwJyxcclxuICAgIFwiNFwiOiAnIywjIzAuMDAnLFxyXG4gICAgXCI5XCI6JzAlJyxcclxuICAgIFwiMTBcIjogJzAuMDAlJyxcclxuICAgIFwiMTFcIjogJzAuMDBFKzAwJyxcclxuICAgIFwiMTJcIjogJyMgPy8/JyxcclxuICAgIFwiMTNcIjogJyMgPz8vPz8nLFxyXG4gICAgXCIxNFwiOiAnbS9kL3l5JyxcclxuICAgIFwiMTVcIjogJ2QtbW1tLXl5JyxcclxuICAgIFwiMTZcIjogJ2QtbW1tJyxcclxuICAgIFwiMTdcIjogJ21tbS15eScsXHJcbiAgICBcIjE4XCI6ICdoOm1tIEFNL1BNJyxcclxuICAgIFwiMTlcIjogJ2g6bW06c3MgQU0vUE0nLFxyXG4gICAgXCIyMFwiOiAnaDptbScsXHJcbiAgICBcIjIxXCI6ICdoOm1tOnNzJyxcclxuICAgIFwiMjJcIjogJ20vZC95eSBoOm1tJyxcclxuICAgIFwiMzdcIjogJyMsIyMwIDsoIywjIzApJyxcclxuICAgIFwiMzhcIjogJyMsIyMwIDtbUmVkXSgjLCMjMCknLFxyXG4gICAgXCIzOVwiOiAnIywjIzAuMDA7KCMsIyMwLjAwKScsXHJcbiAgICBcIjQwXCI6ICcjLCMjMC4wMDtbUmVkXSgjLCMjMC4wMCknLFxyXG4gICAgXCI0NVwiOiAnbW06c3MnLFxyXG4gICAgXCI0NlwiOiAnW2hdOm1tOnNzJyxcclxuICAgIFwiNDdcIjogJ21tc3MuMCcsXHJcbiAgICBcIjQ4XCI6ICcjIzAuMEUrMCcsXHJcbiAgICBcIjQ5XCI6ICdAJ1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgaW5kZXhlZENvbG9yczpJYXR0cmlidXRlTGlzdCA9IHtcclxuICAgIFwiMFwiOicwMDAwMDAwMCcsXHJcbiAgICBcIjFcIjonMDBGRkZGRkYnLFxyXG4gICAgXCIyXCI6JzAwRkYwMDAwJyxcclxuICAgIFwiM1wiOicwMDAwRkYwMCcsXHJcbiAgICBcIjRcIjonMDAwMDAwRkYnLFxyXG4gICAgXCI1XCI6JzAwRkZGRjAwJyxcclxuICAgIFwiNlwiOicwMEZGMDBGRicsXHJcbiAgICBcIjdcIjonMDAwMEZGRkYnLFxyXG4gICAgXCI4XCI6JzAwMDAwMDAwJyxcclxuICAgIFwiOVwiOicwMEZGRkZGRicsXHJcbiAgICBcIjEwXCI6JzAwRkYwMDAwJyxcclxuICAgIFwiMTFcIjonMDAwMEZGMDAnLFxyXG4gICAgXCIxMlwiOicwMDAwMDBGRicsXHJcbiAgICBcIjEzXCI6JzAwRkZGRjAwJyxcclxuICAgIFwiMTRcIjonMDBGRjAwRkYnLFxyXG4gICAgXCIxNVwiOicwMDAwRkZGRicsXHJcbiAgICBcIjE2XCI6JzAwODAwMDAwJyxcclxuICAgIFwiMTdcIjonMDAwMDgwMDAnLFxyXG4gICAgXCIxOFwiOicwMDAwMDA4MCcsXHJcbiAgICBcIjE5XCI6JzAwODA4MDAwJyxcclxuICAgIFwiMjBcIjonMDA4MDAwODAnLFxyXG4gICAgXCIyMVwiOicwMDAwODA4MCcsXHJcbiAgICBcIjIyXCI6JzAwQzBDMEMwJyxcclxuICAgIFwiMjNcIjonMDA4MDgwODAnLFxyXG4gICAgXCIyNFwiOicwMDk5OTlGRicsXHJcbiAgICBcIjI1XCI6JzAwOTkzMzY2JyxcclxuICAgIFwiMjZcIjonMDBGRkZGQ0MnLFxyXG4gICAgXCIyN1wiOicwMENDRkZGRicsXHJcbiAgICBcIjI4XCI6JzAwNjYwMDY2JyxcclxuICAgIFwiMjlcIjonMDBGRjgwODAnLFxyXG4gICAgXCIzMFwiOicwMDAwNjZDQycsXHJcbiAgICBcIjMxXCI6JzAwQ0NDQ0ZGJyxcclxuICAgIFwiMzJcIjonMDAwMDAwODAnLFxyXG4gICAgXCIzM1wiOicwMEZGMDBGRicsXHJcbiAgICBcIjM0XCI6JzAwRkZGRjAwJyxcclxuICAgIFwiMzVcIjonMDAwMEZGRkYnLFxyXG4gICAgXCIzNlwiOicwMDgwMDA4MCcsXHJcbiAgICBcIjM3XCI6JzAwODAwMDAwJyxcclxuICAgIFwiMzhcIjonMDAwMDgwODAnLFxyXG4gICAgXCIzOVwiOicwMDAwMDBGRicsXHJcbiAgICBcIjQwXCI6JzAwMDBDQ0ZGJyxcclxuICAgIFwiNDFcIjonMDBDQ0ZGRkYnLFxyXG4gICAgXCI0MlwiOicwMENDRkZDQycsXHJcbiAgICBcIjQzXCI6JzAwRkZGRjk5JyxcclxuICAgIFwiNDRcIjonMDA5OUNDRkYnLFxyXG4gICAgXCI0NVwiOicwMEZGOTlDQycsXHJcbiAgICBcIjQ2XCI6JzAwQ0M5OUZGJyxcclxuICAgIFwiNDdcIjonMDBGRkNDOTknLFxyXG4gICAgXCI0OFwiOicwMDMzNjZGRicsXHJcbiAgICBcIjQ5XCI6JzAwMzNDQ0NDJyxcclxuICAgIFwiNTBcIjonMDA5OUNDMDAnLFxyXG4gICAgXCI1MVwiOicwMEZGQ0MwMCcsXHJcbiAgICBcIjUyXCI6JzAwRkY5OTAwJyxcclxuICAgIFwiNTNcIjonMDBGRjY2MDAnLFxyXG4gICAgXCI1NFwiOicwMDY2NjY5OScsXHJcbiAgICBcIjU1XCI6JzAwOTY5Njk2JyxcclxuICAgIFwiNTZcIjonMDAwMDMzNjYnLFxyXG4gICAgXCI1N1wiOicwMDMzOTk2NicsXHJcbiAgICBcIjU4XCI6JzAwMDAzMzAwJyxcclxuICAgIFwiNTlcIjonMDAzMzMzMDAnLFxyXG4gICAgXCI2MFwiOicwMDk5MzMwMCcsXHJcbiAgICBcIjYxXCI6JzAwOTkzMzY2JyxcclxuICAgIFwiNjJcIjonMDAzMzMzOTknLFxyXG4gICAgXCI2M1wiOicwMDMzMzMzMycsXHJcbiAgICBcIjY0XCI6bnVsbCwvL3N5c3RlbSBGb3JlZ3JvdW5kIG4vYVxyXG4gICAgXCI2NVwiOm51bGwsLy9zeXN0ZW0gQmFja2dyb3VuZCBuL2FcclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IE9FTV9DSEFSU0VUOklhdHRyaWJ1dGVMaXN0ID0ge1xyXG4gICAgXCIwXCI6IFwiQU5TSV9DSEFSU0VUXCIsXHJcbiAgICBcIjFcIjogXCJERUZBVUxUX0NIQVJTRVRcIixcclxuICAgIFwiMlwiOiBcIlNZTUJPTF9DSEFSU0VUXCIsXHJcbiAgICBcIjc3XCI6IFwiTUFDX0NIQVJTRVRcIixcclxuICAgIFwiMTI4XCI6IFwiU0hJRlRKSVNfQ0hBUlNFVFwiLFxyXG4gICAgXCIxMjlcIjogXCJIQU5HVUxfQ0hBUlNFVFwiLFxyXG4gICAgXCIxMzBcIjogXCJKT0hBQl9DSEFSU0VUXCIsXHJcbiAgICBcIjEzNFwiOiBcIkdCMjMxMl9DSEFSU0VUXCIsXHJcbiAgICBcIjEzNlwiOiBcIkNISU5FU0VCSUc1X0NIQVJTRVRcIixcclxuICAgIFwiMTYxXCI6IFwiR1JFRUtfQ0hBUlNFVFwiLFxyXG4gICAgXCIxNjJcIjogXCJUVVJLSVNIX0NIQVJTRVRcIixcclxuICAgIFwiMTYzXCI6IFwiVklFVE5BTUVTRV9DSEFSU0VUXCIsXHJcbiAgICBcIjE3N1wiOiBcIkhFQlJFV19DSEFSU0VUXCIsXHJcbiAgICBcIjE3OFwiOiBcIkFSQUJJQ19DSEFSU0VUXCIsXHJcbiAgICBcIjE4NlwiOiBcIkJBTFRJQ19DSEFSU0VUXCIsXHJcbiAgICBcIjIwNFwiOiBcIlJVU1NJQU5fQ0hBUlNFVFwiLFxyXG4gICAgXCIyMjJcIjogXCJUSEFJX0NIQVJTRVRcIixcclxuICAgIFwiMjM4XCI6IFwiRUFTVEVVUk9QRV9DSEFSU0VUXCIsXHJcbiAgICBcIjI1NVwiOiBcIk9FTV9DSEFSU0VUXCIsXHJcbn1cclxuXHJcblxyXG5leHBvcnQgY29uc3QgYm9yZGVyVHlwZXM6c3RyaW5nVG9OdW0gPSB7XHJcbiAgICBcIm5vbmVcIjowLFxyXG4gICAgXCJ0aGluXCI6MSwgXHJcbiAgICBcImhhaXJcIjoyLCBcclxuICAgIFwiZG90dGVkXCI6MywgXHJcbiAgICBcImRhc2hlZFwiOjQsIFxyXG4gICAgXCJkYXNoRG90XCI6NSwgXHJcbiAgICBcImRhc2hEb3REb3RcIjo2LCBcclxuICAgIFwiZG91YmxlXCI6NywgXHJcbiAgICBcIm1lZGl1bVwiOjgsIFxyXG4gICAgXCJtZWRpdW1EYXNoZWRcIjo5LCBcclxuICAgIFwibWVkaXVtRGFzaERvdFwiOjEwLCBcclxuICAgIFwibWVkaXVtRGFzaERvdERvdFwiOjExLCBcclxuICAgIFwic2xhbnREYXNoRG90XCI6MTIsIFxyXG4gICAgXCJ0aGlja1wiOjEzXHJcbn1cclxuXHJcblxyXG5leHBvcnQgbGV0IG51bUZtdERlZmF1bHRNYXA6IElhdHRyaWJ1dGVMaXN0ID0ge1xyXG4gICAgXCJ5eXl5L20vZDtAXCI6IFwieXl5eS9NTS9kZFwiLFxyXG4gICAgXCJ5eXl5JnF1b3Q75bm0JnF1b3Q7bSZxdW90O+aciCZxdW90O2QmcXVvdDvml6UmcXVvdDs7QFwiOlxyXG4gICAgICBcInl5eXkmcXVvdDvlubQmcXVvdDtNTSZxdW90O+aciCZxdW90O2RkJnF1b3Q75pelJnF1b3Q7XCIsXHJcbiAgICBcIlskLTQwOV15eXl5L20vZFxcXFwgaDptbVxcXFwgQU0vUE07QFwiOiBcInl5eXkvTU0vZGQgaGg6bW0gQU0vUE1cIixcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBmb250RmFtaWx5czpJYXR0cmlidXRlTGlzdCA9IHtcclxuICAgIFwiMFwiOlwiZGVmdWFsdFwiLFxyXG4gICAgXCIxXCI6XCJSb21hblwiLFxyXG4gICAgXCIyXCI6XCJTd2lzc1wiLFxyXG4gICAgXCIzXCI6XCJNb2Rlcm5cIixcclxuICAgIFwiNFwiOlwiU2NyaXB0XCIsXHJcbiAgICBcIjVcIjpcIkRlY29yYXRpdmVcIlxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgREFUQV9WRVJJRklDQVRJT05fTUFQOiBJRGF0YVZlcmlmaWNhdGlvbk1hcCA9IHtcclxuICAgIGxpc3Q6IFwiZHJvcGRvd25cIixcclxuICAgIHdob2xlOiBcIm51bWJlcl9pbnRlZ2VyXCIsXHJcbiAgICBkZWNpbWFsOiBcIm51bWJlcl9kZWNpbWFsXCIsXHJcbiAgICBjdXN0b206IFwidGV4dF9jb250ZW50XCIsXHJcbiAgICB0ZXh0TGVuZ3RoOiBcInRleHRfbGVuZ3RoXCIsXHJcbiAgICBkYXRlOiBcImRhdGVcIixcclxuICAgIFwidW5rbm93bjFcIjogXCJudW1iZXJcIiwgLy8gbm8gbWF0Y2ggeWV0XHJcbiAgICBcInVua25vd24yXCI6IFwiY2hlY2tib3hcIiwgLy8gbm8gbWF0Y2ggeWV0XHJcbiAgICBcInVua25vd24zXCI6IFwidmFsaWRpdHlcIiwgLy8gbm8gbWF0Y2ggeWV0XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgQ09NTU9OX1RZUEUyOiBzdHJpbmdbXSA9IFtcclxuICAgIFwibnVtYmVyXCIsXHJcbiAgICBcIm51bWJlcl9pbnRlZ2VyXCIsXHJcbiAgICBcIm51bWJlcl9kZWNpbWFsXCIsXHJcbiAgICBcInRleHRfbGVuZ3RoXCIsXHJcbl07XHJcblxyXG5leHBvcnQgY29uc3QgREFUQV9WRVJJRklDQVRJT05fVFlQRTJfTUFQOiBJRGF0YVZlcmlmaWNhdGlvblR5cGUyTWFwID0ge1xyXG4gICAgY29tbW9uOiB7XHJcbiAgICAgIGJldHdlZW46IFwiYndcIixcclxuICAgICAgbm90QmV0d2VlbjogXCJuYlwiLFxyXG4gICAgICBlcXVhbDogXCJlcVwiLFxyXG4gICAgICBub3RFcXVhbFRvOiBcIm5lXCIsXHJcbiAgICAgIG1vcmVUaGFuVGhlOiBcImd0XCIsXHJcbiAgICAgIGxlc3NUaGFuOiBcImx0XCIsXHJcbiAgICAgIGdyZWF0ZXJPckVxdWFsVG86IFwiZ3RlXCIsXHJcbiAgICAgIGxlc3NUaGFuT3JFcXVhbFRvOiBcImx0ZVwiLFxyXG4gICAgfSxcclxuICAgIHRleHRfY29udGVudDoge1xyXG4gICAgICBpbmNsdWRlOiBcImluY2x1ZGVcIixcclxuICAgICAgZXhjbHVkZTogXCJleGNsdWRlXCIsXHJcbiAgICAgIGVxdWFsOiBcImVxdWFsXCIsXHJcbiAgICB9LFxyXG4gICAgZGF0ZToge1xyXG4gICAgICBiZXR3ZWVuOiBcImJ3XCIsXHJcbiAgICAgIG5vdEJldHdlZW46IFwibmJcIixcclxuICAgICAgZXF1YWw6IFwiZXFcIixcclxuICAgICAgbm90RXF1YWxUbzogXCJuZVwiLFxyXG4gICAgICBlYXJsaWVyVGhhbjogXCJiZlwiLFxyXG4gICAgICBub0VhcmxpZXJUaGFuOiBcIm5iZlwiLFxyXG4gICAgICBsYXRlclRoYW46IFwiYWZcIixcclxuICAgICAgbm9MYXRlclRoYW46IFwibmFmXCIsXHJcbiAgICB9LFxyXG4gICAgdmFsaWRpdHk6IHtcclxuICAgICAgY2FyZDogXCJjYXJkXCIsXHJcbiAgICAgIHBob25lOiBcInBob25lXCIsXHJcbiAgICB9LFxyXG59O1xyXG4iLCJleHBvcnQgbGV0IFVET0M6YW55ID0ge307XHJcblx0XHJcblx0VURPQy5HID0ge1xyXG5cdFx0Y29uY2F0IDogZnVuY3Rpb24ocDphbnkscjphbnkpIHtcclxuXHRcdFx0Zm9yKHZhciBpPTA7IGk8ci5jbWRzLmxlbmd0aDsgaSsrKSBwLmNtZHMucHVzaChyLmNtZHNbaV0pO1xyXG5cdFx0XHRmb3IodmFyIGk9MDsgaTxyLmNyZHMubGVuZ3RoOyBpKyspIHAuY3Jkcy5wdXNoKHIuY3Jkc1tpXSk7XHJcblx0XHR9LFxyXG5cdFx0Z2V0QkIgIDogZnVuY3Rpb24ocHM6YW55KSB7XHJcblx0XHRcdHZhciB4MD0xZTk5LCB5MD0xZTk5LCB4MT0teDAsIHkxPS15MDtcclxuXHRcdFx0Zm9yKHZhciBpPTA7IGk8cHMubGVuZ3RoOyBpKz0yKSB7ICB2YXIgeD1wc1tpXSx5PXBzW2krMV07ICBpZih4PHgwKXgwPXg7IGVsc2UgaWYoeD54MSl4MT14OyAgaWYoeTx5MCl5MD15OyAgZWxzZSBpZih5PnkxKXkxPXk7ICB9XHJcblx0XHRcdHJldHVybiBbeDAseTAseDEseTFdO1xyXG5cdFx0fSxcclxuXHRcdHJlY3RUb1BhdGg6IGZ1bmN0aW9uKHI6YW55KSB7ICByZXR1cm4gIHtjbWRzOltcIk1cIixcIkxcIixcIkxcIixcIkxcIixcIlpcIl0sY3JkczpbclswXSxyWzFdLHJbMl0sclsxXSwgclsyXSxyWzNdLHJbMF0sclszXV19OyAgfSxcclxuXHRcdC8vIGEgaW5zaWRlIGJcclxuXHRcdGluc2lkZUJveDogZnVuY3Rpb24oYTphbnksYjphbnkpIHsgIHJldHVybiBiWzBdPD1hWzBdICYmIGJbMV08PWFbMV0gJiYgYVsyXTw9YlsyXSAmJiBhWzNdPD1iWzNdOyAgIH0sXHJcblx0XHRpc0JveCA6IGZ1bmN0aW9uKHA6YW55LCBiYjphbnkpIHtcclxuXHRcdFx0dmFyIHNhbWVDcmQ4ID0gZnVuY3Rpb24ocGNyZDphbnksIGNyZHM6YW55KSB7XHJcblx0XHRcdFx0Zm9yKHZhciBvPTA7IG88ODsgbys9MikgeyAgdmFyIGVxID0gdHJ1ZTsgIGZvcih2YXIgaj0wOyBqPDg7IGorKykgaWYoTWF0aC5hYnMoY3Jkc1tqXS1wY3JkWyhqK28pJjddKT49MikgeyAgZXEgPSBmYWxzZTsgIGJyZWFrOyAgfSAgICBpZihlcSkgcmV0dXJuIHRydWU7ICB9XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9O1xyXG5cdFx0XHRpZihwLmNtZHMubGVuZ3RoPjEwKSByZXR1cm4gZmFsc2U7XHJcblx0XHRcdHZhciBjbWRzPXAuY21kcy5qb2luKFwiXCIpLCBjcmRzPXAuY3JkcztcclxuXHRcdFx0dmFyIHNhbWVSZWN0ID0gZmFsc2U7XHJcblx0XHRcdGlmKChjbWRzPT1cIk1MTExaXCIgICYmIGNyZHMubGVuZ3RoPT0gOCkgXHJcblx0XHRcdCB8fChjbWRzPT1cIk1MTExMWlwiICYmIGNyZHMubGVuZ3RoPT0xMCkgKSB7XHJcblx0XHRcdFx0aWYoY3Jkcy5sZW5ndGg9PTEwKSBjcmRzPWNyZHMuc2xpY2UoMCw4KTtcclxuXHRcdFx0XHR2YXIgeDA9YmJbMF0seTA9YmJbMV0seDE9YmJbMl0seTE9YmJbM107XHJcblx0XHRcdFx0aWYoIXNhbWVSZWN0KSBzYW1lUmVjdCA9IHNhbWVDcmQ4KGNyZHMsIFt4MCx5MCx4MSx5MCx4MSx5MSx4MCx5MV0pO1xyXG5cdFx0XHRcdGlmKCFzYW1lUmVjdCkgc2FtZVJlY3QgPSBzYW1lQ3JkOChjcmRzLCBbeDAseTEseDEseTEseDEseTAseDAseTBdKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gc2FtZVJlY3Q7XHJcblx0XHR9LFxyXG5cdFx0Ym94QXJlYTogZnVuY3Rpb24oYTphbnkpIHsgIHZhciB3PWFbMl0tYVswXSwgaD1hWzNdLWFbMV07ICByZXR1cm4gdypoOyAgfSxcclxuXHRcdG5ld1BhdGg6IGZ1bmN0aW9uKGdzdDphbnkgICAgKSB7ICBnc3QucHRoID0ge2NtZHM6W10sIGNyZHM6W119OyAgfSxcclxuXHRcdG1vdmVUbyA6IGZ1bmN0aW9uKGdzdDphbnkseDphbnkseTphbnkpIHsgIHZhciBwPVVET0MuTS5tdWx0UG9pbnQoZ3N0LmN0bSxbeCx5XSk7ICAvL2lmKGdzdC5jcG9zWzBdPT1wWzBdICYmIGdzdC5jcG9zWzFdPT1wWzFdKSByZXR1cm47XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0Z3N0LnB0aC5jbWRzLnB1c2goXCJNXCIpOyAgZ3N0LnB0aC5jcmRzLnB1c2gocFswXSxwWzFdKTsgIGdzdC5jcG9zID0gcDsgIH0sXHJcblx0XHRsaW5lVG8gOiBmdW5jdGlvbihnc3Q6YW55LHg6YW55LHk6YW55KSB7ICB2YXIgcD1VRE9DLk0ubXVsdFBvaW50KGdzdC5jdG0sW3gseV0pOyAgaWYoZ3N0LmNwb3NbMF09PXBbMF0gJiYgZ3N0LmNwb3NbMV09PXBbMV0pIHJldHVybjtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRnc3QucHRoLmNtZHMucHVzaChcIkxcIik7ICBnc3QucHRoLmNyZHMucHVzaChwWzBdLHBbMV0pOyAgZ3N0LmNwb3MgPSBwOyAgfSxcclxuXHRcdGN1cnZlVG86IGZ1bmN0aW9uKGdzdDphbnkseDE6YW55LHkxOmFueSx4MjphbnkseTI6YW55LHgzOmFueSx5MzphbnkpIHsgICB2YXIgcDsgIFxyXG5cdFx0XHRwPVVET0MuTS5tdWx0UG9pbnQoZ3N0LmN0bSxbeDEseTFdKTsgIHgxPXBbMF07ICB5MT1wWzFdO1xyXG5cdFx0XHRwPVVET0MuTS5tdWx0UG9pbnQoZ3N0LmN0bSxbeDIseTJdKTsgIHgyPXBbMF07ICB5Mj1wWzFdO1xyXG5cdFx0XHRwPVVET0MuTS5tdWx0UG9pbnQoZ3N0LmN0bSxbeDMseTNdKTsgIHgzPXBbMF07ICB5Mz1wWzFdOyAgZ3N0LmNwb3MgPSBwO1xyXG5cdFx0XHRnc3QucHRoLmNtZHMucHVzaChcIkNcIik7ICBcclxuXHRcdFx0Z3N0LnB0aC5jcmRzLnB1c2goeDEseTEseDIseTIseDMseTMpOyAgXHJcblx0XHR9LFxyXG5cdFx0Y2xvc2VQYXRoOiBmdW5jdGlvbihnc3Q6YW55ICApIHsgIGdzdC5wdGguY21kcy5wdXNoKFwiWlwiKTsgIH0sXHJcblx0XHRhcmMgOiBmdW5jdGlvbihnc3Q6YW55LHg6YW55LHk6YW55LHI6YW55LGEwOmFueSxhMTphbnksIG5lZzphbnkpIHtcclxuXHRcdFx0XHJcblx0XHRcdC8vIGNpcmNsZSBmcm9tIGEwIGNvdW50ZXItY2xvY2std2lzZSB0byBhMVxyXG5cdFx0XHRpZihuZWcpIHdoaWxlKGExPmEwKSBhMS09MipNYXRoLlBJO1xyXG5cdFx0XHRlbHNlICAgIHdoaWxlKGExPGEwKSBhMSs9MipNYXRoLlBJO1xyXG5cdFx0XHR2YXIgdGggPSAoYTEtYTApLzQ7XHJcblx0XHRcdFxyXG5cdFx0XHR2YXIgeDAgPSBNYXRoLmNvcyh0aC8yKSwgeTAgPSAtTWF0aC5zaW4odGgvMik7XHJcblx0XHRcdHZhciB4MSA9ICg0LXgwKS8zLCB5MSA9IHkwPT0wID8geTAgOiAoMS14MCkqKDMteDApLygzKnkwKTtcclxuXHRcdFx0dmFyIHgyID0geDEsIHkyID0gLXkxO1xyXG5cdFx0XHR2YXIgeDMgPSB4MCwgeTMgPSAteTA7XHJcblx0XHRcdFxyXG5cdFx0XHR2YXIgcDAgPSBbeDAseTBdLCBwMSA9IFt4MSx5MV0sIHAyID0gW3gyLHkyXSwgcDMgPSBbeDMseTNdO1xyXG5cdFx0XHRcclxuXHRcdFx0dmFyIHB0aCA9IHtjbWRzOlsoZ3N0LnB0aC5jbWRzLmxlbmd0aD09MCk/XCJNXCI6XCJMXCIsXCJDXCIsXCJDXCIsXCJDXCIsXCJDXCJdLCBjcmRzOlt4MCx5MCx4MSx5MSx4Mix5Mix4Myx5M119O1xyXG5cdFx0XHRcclxuXHRcdFx0dmFyIHJvdCA9IFsxLDAsMCwxLDAsMF07ICBVRE9DLk0ucm90YXRlKHJvdCwtdGgpO1xyXG5cdFx0XHRcclxuXHRcdFx0Zm9yKHZhciBpPTA7IGk8MzsgaSsrKSB7XHJcblx0XHRcdFx0cDEgPSBVRE9DLk0ubXVsdFBvaW50KHJvdCxwMSk7ICBwMiA9IFVET0MuTS5tdWx0UG9pbnQocm90LHAyKTsgIHAzID0gVURPQy5NLm11bHRQb2ludChyb3QscDMpO1xyXG5cdFx0XHRcdHB0aC5jcmRzLnB1c2gocDFbMF0scDFbMV0scDJbMF0scDJbMV0scDNbMF0scDNbMV0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdFxyXG5cdFx0XHR2YXIgc2MgPSBbciwwLDAscix4LHldOyAgXHJcblx0XHRcdFVET0MuTS5yb3RhdGUocm90LCAtYTArdGgvMik7ICBVRE9DLk0uY29uY2F0KHJvdCwgc2MpOyAgVURPQy5NLm11bHRBcnJheShyb3QsIHB0aC5jcmRzKTtcclxuXHRcdFx0VURPQy5NLm11bHRBcnJheShnc3QuY3RtLCBwdGguY3Jkcyk7XHJcblx0XHRcdFxyXG5cdFx0XHRVRE9DLkcuY29uY2F0KGdzdC5wdGgsIHB0aCk7XHJcblx0XHRcdHZhciB5OmFueT1wdGguY3Jkcy5wb3AoKTsgIHg9cHRoLmNyZHMucG9wKCk7XHJcblx0XHRcdGdzdC5jcG9zID0gW3gseV07XHJcblx0XHR9LFxyXG5cdFx0dG9Qb2x5IDogZnVuY3Rpb24ocDphbnkpIHtcclxuXHRcdFx0aWYocC5jbWRzWzBdIT1cIk1cIiB8fCBwLmNtZHNbcC5jbWRzLmxlbmd0aC0xXSE9XCJaXCIpIHJldHVybiBudWxsO1xyXG5cdFx0XHRmb3IodmFyIGk9MTsgaTxwLmNtZHMubGVuZ3RoLTE7IGkrKykgaWYocC5jbWRzW2ldIT1cIkxcIikgcmV0dXJuIG51bGw7XHJcblx0XHRcdHZhciBvdXQgPSBbXSwgY2wgPSBwLmNyZHMubGVuZ3RoO1xyXG5cdFx0XHRpZihwLmNyZHNbMF09PXAuY3Jkc1tjbC0yXSAmJiBwLmNyZHNbMV09PXAuY3Jkc1tjbC0xXSkgY2wtPTI7XHJcblx0XHRcdGZvcih2YXIgaT0wOyBpPGNsOyBpKz0yKSBvdXQucHVzaChbcC5jcmRzW2ldLHAuY3Jkc1tpKzFdXSk7XHJcblx0XHRcdGlmKFVET0MuRy5wb2x5QXJlYShwLmNyZHMpPDApIG91dC5yZXZlcnNlKCk7XHJcblx0XHRcdHJldHVybiBvdXQ7XHJcblx0XHR9LFxyXG5cdFx0ZnJvbVBvbHkgOiBmdW5jdGlvbihwOmFueSkge1xyXG5cdFx0XHR2YXIgbzphbnkgPSB7Y21kczpbXSxjcmRzOltdfTtcclxuXHRcdFx0Zm9yKHZhciBpPTA7IGk8cC5sZW5ndGg7IGkrKykgeyBvLmNyZHMucHVzaChwW2ldWzBdLCBwW2ldWzFdKTsgIG8uY21kcy5wdXNoKGk9PTA/XCJNXCI6XCJMXCIpOyAgfVxyXG5cdFx0XHRvLmNtZHMucHVzaChcIlpcIik7XHJcblx0XHRcdHJldHVybiBvO1xyXG5cdFx0fSxcclxuXHRcdHBvbHlBcmVhIDogZnVuY3Rpb24ocDphbnkpIHtcclxuXHRcdFx0aWYocC5sZW5ndGggPDYpIHJldHVybiAwO1xyXG5cdFx0XHR2YXIgbCA9IHAubGVuZ3RoIC0gMjtcclxuXHRcdFx0dmFyIHN1bSA9IChwWzBdLXBbbF0pICogKHBbbCsxXStwWzFdKTtcclxuXHRcdFx0Zm9yKHZhciBpPTA7IGk8bDsgaSs9MilcclxuXHRcdFx0XHRzdW0gKz0gKHBbaSsyXS1wW2ldKSAqIChwW2krMV0rcFtpKzNdKTtcclxuXHRcdFx0cmV0dXJuIC0gc3VtICogMC41O1xyXG5cdFx0fSxcclxuXHRcdHBvbHlDbGlwIDogZnVuY3Rpb24ocDA6YW55LCBwMTphbnkpIHsgIC8vIHAwIGNsaXBwZWQgYnkgcDFcclxuICAgICAgICAgICAgdmFyIGNwMTphbnksIGNwMjphbnksIHM6YW55LCBlOmFueTtcclxuICAgICAgICAgICAgdmFyIGluc2lkZSA9IGZ1bmN0aW9uIChwOmFueSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChjcDJbMF0tY3AxWzBdKSoocFsxXS1jcDFbMV0pID4gKGNwMlsxXS1jcDFbMV0pKihwWzBdLWNwMVswXSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhciBpc2MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGMgPSBbIGNwMVswXSAtIGNwMlswXSwgY3AxWzFdIC0gY3AyWzFdIF0sXHJcbiAgICAgICAgICAgICAgICAgICAgZHAgPSBbIHNbMF0gLSBlWzBdLCBzWzFdIC0gZVsxXSBdLFxyXG4gICAgICAgICAgICAgICAgICAgIG4xID0gY3AxWzBdICogY3AyWzFdIC0gY3AxWzFdICogY3AyWzBdLFxyXG4gICAgICAgICAgICAgICAgICAgIG4yID0gc1swXSAqIGVbMV0gLSBzWzFdICogZVswXSwgXHJcbiAgICAgICAgICAgICAgICAgICAgbjMgPSAxLjAgLyAoZGNbMF0gKiBkcFsxXSAtIGRjWzFdICogZHBbMF0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsobjEqZHBbMF0gLSBuMipkY1swXSkgKiBuMywgKG4xKmRwWzFdIC0gbjIqZGNbMV0pICogbjNdO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB2YXIgb3V0ID0gcDA7XHJcbiAgICAgICAgICAgIGNwMSA9IHAxW3AxLmxlbmd0aC0xXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiBpbiBwMSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNwMiA9IHAxW2pdO1xyXG4gICAgICAgICAgICAgICAgdmFyIGlucCA9IG91dDtcclxuICAgICAgICAgICAgICAgIG91dCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgcyA9IGlucFtpbnAubGVuZ3RoIC0gMV07IC8vbGFzdCBvbiB0aGUgaW5wdXQgbGlzdFxyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSBpbiBpbnApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IGlucFtpXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5zaWRlKGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaW5zaWRlKHMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChpc2MoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2goZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGluc2lkZShzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChpc2MoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHMgPSBlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3AxID0gY3AyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBvdXRcclxuICAgICAgICB9XHJcblx0fVxyXG5cdFVET0MuTSA9IHtcclxuXHRcdGdldFNjYWxlIDogZnVuY3Rpb24obTphbnkpIHsgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5hYnMobVswXSptWzNdLW1bMV0qbVsyXSkpOyAgfSxcclxuXHRcdHRyYW5zbGF0ZTogZnVuY3Rpb24obTphbnkseDphbnkseTphbnkpIHsgIFVET0MuTS5jb25jYXQobSwgWzEsMCwwLDEseCx5XSk7ICB9LFxyXG5cdFx0cm90YXRlICAgOiBmdW5jdGlvbihtOmFueSxhOmFueSAgKSB7ICBVRE9DLk0uY29uY2F0KG0sIFtNYXRoLmNvcyhhKSwgLU1hdGguc2luKGEpLCBNYXRoLnNpbihhKSwgTWF0aC5jb3MoYSksMCwwXSk7ICB9LFxyXG5cdFx0c2NhbGUgICAgOiBmdW5jdGlvbihtOmFueSx4OmFueSx5OmFueSkgeyAgVURPQy5NLmNvbmNhdChtLCBbeCwwLDAseSwwLDBdKTsgIH0sXHJcblx0XHRjb25jYXQgICA6IGZ1bmN0aW9uKG06YW55LHc6YW55ICApIHsgIFxyXG5cdFx0XHR2YXIgYT1tWzBdLGI9bVsxXSxjPW1bMl0sZD1tWzNdLHR4PW1bNF0sdHk9bVs1XTtcclxuXHRcdFx0bVswXSA9IChhICp3WzBdKSsoYiAqd1syXSk7ICAgICAgIG1bMV0gPSAoYSAqd1sxXSkrKGIgKndbM10pO1xyXG5cdFx0XHRtWzJdID0gKGMgKndbMF0pKyhkICp3WzJdKTsgICAgICAgbVszXSA9IChjICp3WzFdKSsoZCAqd1szXSk7XHJcblx0XHRcdG1bNF0gPSAodHgqd1swXSkrKHR5KndbMl0pK3dbNF07ICBtWzVdID0gKHR4KndbMV0pKyh0eSp3WzNdKSt3WzVdOyBcclxuXHRcdH0sXHJcblx0XHRpbnZlcnQgICA6IGZ1bmN0aW9uKG06YW55ICAgICkgeyAgXHJcblx0XHRcdHZhciBhPW1bMF0sYj1tWzFdLGM9bVsyXSxkPW1bM10sdHg9bVs0XSx0eT1tWzVdLCBhZGJjPWEqZC1iKmM7XHJcblx0XHRcdG1bMF0gPSBkL2FkYmM7ICBtWzFdID0gLWIvYWRiYzsgIG1bMl0gPS1jL2FkYmM7ICBtWzNdID0gIGEvYWRiYztcclxuXHRcdFx0bVs0XSA9IChjKnR5IC0gZCp0eCkvYWRiYzsgIG1bNV0gPSAoYip0eCAtIGEqdHkpL2FkYmM7XHJcblx0XHR9LFxyXG5cdFx0bXVsdFBvaW50OiBmdW5jdGlvbihtOmFueSwgcDphbnkgKSB7ICB2YXIgeD1wWzBdLHk9cFsxXTsgIHJldHVybiBbeCptWzBdK3kqbVsyXSttWzRdLCAgIHgqbVsxXSt5Km1bM10rbVs1XV07ICB9LFxyXG5cdFx0bXVsdEFycmF5OiBmdW5jdGlvbihtOmFueSwgYTphbnkgKSB7ICBmb3IodmFyIGk9MDsgaTxhLmxlbmd0aDsgaSs9MikgeyAgdmFyIHg9YVtpXSx5PWFbaSsxXTsgIGFbaV09eCptWzBdK3kqbVsyXSttWzRdOyAgYVtpKzFdPXgqbVsxXSt5Km1bM10rbVs1XTsgIH0gIH1cclxuXHR9XHJcblx0VURPQy5DID0ge1xyXG5cdFx0c3JnYkdhbW1hIDogZnVuY3Rpb24oeDphbnkpIHsgIHJldHVybiB4IDwgMC4wMDMxMzA4ID8gMTIuOTIgKiB4IDogMS4wNTUgKiBNYXRoLnBvdyh4LCAxLjAgLyAyLjQpIC0gMC4wNTU7ICB9LFxyXG5cdFx0Y215a1RvUmdiIDogZnVuY3Rpb24oY2xyOmFueSkgeyBcclxuXHRcdFx0dmFyIGM9Y2xyWzBdLCBtPWNsclsxXSwgeT1jbHJbMl0sIGs9Y2xyWzNdO1xyXG5cdFx0XHQvLyByZXR1cm4gWzEtTWF0aC5taW4oMSxjK2spLCAxLU1hdGgubWluKDEsIG0rayksIDEtTWF0aC5taW4oMSx5K2spXTtcclxuXHRcdFx0dmFyIHIgPSAyNTVcclxuXHRcdFx0KyBjICogKC00LjM4NzMzMjM4NDYwOTk4OCAgKiBjICsgNTQuNDg2MTUxOTQxODkxNzYgICogbSArICAxOC44MjI5MDUwMjE2NTMwMiAgKiB5ICsgMjEyLjI1NjYyNDUxNjM5NTg1ICogayArICAtMjg1LjIzMzEwMjYxMzcwMDQpIFxyXG5cdFx0XHQrIG0gKiAoIDEuNzE0OTc2MzQ3NzM2MjEzNCAqIG0gLSA1LjYwOTY3MzY5MDQwNDczMTUgKiB5ICsgLTE3Ljg3Mzg3MDg2MTQxNTQ0NCAqIGsgLSA1LjQ5NzAwNjQyNzE5NjM2NikgXHJcblx0XHRcdCsgeSAqICgtMi41MjE3MzQwMTMxNjgzMDMzICogeSAtIDIxLjI0ODkyMzMzNzM1MzA3MyAqIGsgKyAgMTcuNTExOTI3MDg0MTgxMykgXHJcblx0XHRcdCsgayAqICgtMjEuODYxMjIxNDc0NjM2MDUgICogayAtIDE4OS40ODE4MDgzNTkyMjc0Nyk7XHJcblx0XHRcdHZhciBnID0gMjU1XHJcblx0XHRcdCsgYyAqICg4Ljg0MTA0MTQyMjAzNjE0OSAgICogYyArIDYwLjExODAyNzA0NTU5NzM2NiAqIG0gKyAgNi44NzE0MjU1OTIwNDkwMDcgICogeSArIDMxLjE1OTEwMDEzMDA1NTkyMiAqIGsgKyAgLTc5LjI5NzA4NDQ4MTY1NDgpIFxyXG5cdFx0XHQrIG0gKiAoLTE1LjMxMDM2MTMwNjk2NzgxNyAqIG0gKyAxNy41NzUyNTEyNjExMDk0ODIgKiB5ICsgIDEzMS4zNTI1MDkxMjQ5Mzk3NiAqIGsgLSAxOTAuOTQ1MzMwMjU4ODk1MSkgXHJcblx0XHRcdCsgeSAqICg0LjQ0NDMzOTEwMjg1MjczOSAgICogeSArIDkuODYzMjg2MTQ5MzQwNSAgICAqIGsgLSAgMjQuODY3NDE1ODI1NTU4NzgpIFxyXG5cdFx0XHQrIGsgKiAoLTIwLjczNzMyNTQ3MTE4MTAzNCAqIGsgLSAxODcuODA0NTM3MDk3MTk1NzgpO1xyXG5cdFx0XHR2YXIgYiA9IDI1NVxyXG5cdFx0XHQrIGMgKiAoMC44ODQyNTIyNDMwMDAzMjk2ICAqIGMgKyA4LjA3ODY3NzUwMzExMjkyOCAgKiBtICsgIDMwLjg5OTc4MzA5NzAzNzI5ICAqIHkgLSAwLjIzODgzMjM4Njg5MTc4OTM0ICogayArIC0xNC4xODM1NzY3OTk2NzMyODYpIFxyXG5cdFx0XHQrIG0gKiAoMTAuNDk1OTMyNzM0MzIwNzIgICAqIG0gKyA2My4wMjM3ODQ5NDc1NDA1MiAgKiB5ICsgIDUwLjYwNjk1NzY1NjM2MDczNCAqIGsgLSAxMTIuMjM4ODQyNTM3MTkyNDgpIFxyXG5cdFx0XHQrIHkgKiAoMC4wMzI5NjA0MTExNDg3MzIxNyAqIHkgKyAxMTUuNjAzODQ0NDk2NDY2NDEgKiBrICsgLTE5My41ODIwOTM1Njg2MTUwNSlcclxuXHRcdFx0KyBrICogKC0yMi4zMzgxNjgwNzMwOTg4NiAgKiBrIC0gMTgwLjEyNjEzOTc0NzA4MzY3KTtcclxuXHJcblx0XHRcdHJldHVybiBbTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgci8yNTUpKSwgTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgZy8yNTUpKSwgTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgYi8yNTUpKV07XHJcblx0XHRcdC8vdmFyIGlLID0gMS1jWzNdOyAgXHJcblx0XHRcdC8vcmV0dXJuIFsoMS1jWzBdKSppSywgKDEtY1sxXSkqaUssICgxLWNbMl0pKmlLXTsgIFxyXG5cdFx0fSxcclxuXHRcdGxhYlRvUmdiICA6IGZ1bmN0aW9uKGxhYjphbnkpIHtcclxuXHRcdFx0dmFyIGsgPSA5MDMuMywgZSA9IDAuMDA4ODU2LCBMID0gbGFiWzBdLCBhID0gbGFiWzFdLCBiID0gbGFiWzJdO1xyXG5cdFx0XHR2YXIgZnkgPSAoTCsxNikvMTE2LCBmeTMgPSBmeSpmeSpmeTtcclxuXHRcdFx0dmFyIGZ6ID0gZnkgLSBiLzIwMCwgZnozID0gZnoqZnoqZno7XHJcblx0XHRcdHZhciBmeCA9IGEvNTAwICsgZnksIGZ4MyA9IGZ4KmZ4KmZ4O1xyXG5cdFx0XHR2YXIgenIgPSBmejM+ZSA/IGZ6MyA6ICgxMTYqZnotMTYpL2s7XHJcblx0XHRcdHZhciB5ciA9IGZ5Mz5lID8gZnkzIDogKDExNipmeS0xNikvaztcclxuXHRcdFx0dmFyIHhyID0gZngzPmUgPyBmeDMgOiAoMTE2KmZ4LTE2KS9rO1xyXG5cdFx0XHRcdFxyXG5cdFx0XHR2YXIgWCA9IHhyKjk2LjcyLCBZID0geXIqMTAwLCBaID0genIqODEuNDI3LCB4eXogPSBbWC8xMDAsWS8xMDAsWi8xMDBdO1xyXG5cdFx0XHR2YXIgeDJzID0gWzMuMTMzODU2MSwgLTEuNjE2ODY2NywgLTAuNDkwNjE0NiwgLTAuOTc4NzY4NCwgIDEuOTE2MTQxNSwgIDAuMDMzNDU0MCwgMC4wNzE5NDUzLCAtMC4yMjg5OTE0LCAgMS40MDUyNDI3XTtcclxuXHRcdFx0XHJcblx0XHRcdHZhciByZ2IgPSBbIHgyc1swXSp4eXpbMF0gKyB4MnNbMV0qeHl6WzFdICsgeDJzWzJdKnh5elsyXSxcclxuXHRcdFx0XHRcdFx0eDJzWzNdKnh5elswXSArIHgyc1s0XSp4eXpbMV0gKyB4MnNbNV0qeHl6WzJdLFxyXG5cdFx0XHRcdFx0XHR4MnNbNl0qeHl6WzBdICsgeDJzWzddKnh5elsxXSArIHgyc1s4XSp4eXpbMl0gIF07XHJcblx0XHRcdGZvcih2YXIgaT0wOyBpPDM7IGkrKykgcmdiW2ldID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgVURPQy5DLnNyZ2JHYW1tYShyZ2JbaV0pKSk7XHJcblx0XHRcdHJldHVybiByZ2I7XHJcblx0XHR9XHJcblx0fVxyXG5cdFxyXG5cdFVET0MuZ2V0U3RhdGUgPSBmdW5jdGlvbihjcmRzOmFueSk6YW55IHtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdGZvbnQgOiBVRE9DLmdldEZvbnQoKSxcclxuXHRcdFx0ZGQ6IHtmbGF0OjF9LCAgLy8gZGV2aWNlLWRlcGVuZGVudFxyXG5cdFx0XHRzcGFjZSA6XCIvRGV2aWNlR3JheVwiLFxyXG5cdFx0XHQvLyBmaWxsXHJcblx0XHRcdGNhOiAxLFxyXG5cdFx0XHRjb2xyICA6IFswLDAsMF0sXHJcblx0XHRcdHNzcGFjZTpcIi9EZXZpY2VHcmF5XCIsXHJcblx0XHRcdC8vIHN0cm9rZVxyXG5cdFx0XHRDQTogMSxcclxuXHRcdFx0Q09MUiA6IFswLDAsMF0sXHJcblx0XHRcdGJtb2RlOiBcIi9Ob3JtYWxcIixcclxuXHRcdFx0U0E6ZmFsc2UsIE9QTTowLCBBSVM6ZmFsc2UsIE9QOmZhbHNlLCBvcDpmYWxzZSwgU01hc2s6XCIvTm9uZVwiLFxyXG5cdFx0XHRsd2lkdGggOiAxLFxyXG5cdFx0XHRsY2FwOiAwLFxyXG5cdFx0XHRsam9pbjogMCxcclxuXHRcdFx0bWxpbWl0OiAxMCxcclxuXHRcdFx0U00gOiAwLjEsXHJcblx0XHRcdGRvZmY6IDAsXHJcblx0XHRcdGRhc2g6IFtdLFxyXG5cdFx0XHRjdG0gOiBbMSwwLDAsMSwwLDBdLFxyXG5cdFx0XHRjcG9zOiBbMCwwXSxcclxuXHRcdFx0cHRoIDoge2NtZHM6W10sY3JkczpbXX0sIFxyXG5cdFx0XHRjcHRoOiBjcmRzID8gVURPQy5HLnJlY3RUb1BhdGgoY3JkcykgOiBudWxsICAvLyBjbGlwcGluZyBwYXRoXHJcblx0XHR9O1xyXG5cdH1cclxuXHRcclxuXHRVRE9DLmdldEZvbnQgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdFRjOiAwLCAvLyBjaGFyYWN0ZXIgc3BhY2luZ1xyXG5cdFx0XHRUdzogMCwgLy8gd29yZCBzcGFjaW5nXHJcblx0XHRcdFRoOjEwMCwgLy8gaG9yaXpvbnRhbCBzY2FsZVxyXG5cdFx0XHRUbDogMCwgLy8gbGVhZGluZ1xyXG5cdFx0XHRUZjpcIkhlbHZldGljYS1Cb2xkXCIsIFxyXG5cdFx0XHRUZnM6MSwgLy8gZm9udCBzaXplXHJcblx0XHRcdFRtb2RlOjAsIC8vIHJlbmRlcmluZyBtb2RlXHJcblx0XHRcdFRyaXNlOjAsIC8vIHJpc2VcclxuXHRcdFx0VGs6IDAsICAvLyBrbm9ja291dFxyXG5cdFx0XHRUYWw6MCwgIC8vIGFsaWduLCAwOiBsZWZ0LCAxOiByaWdodCwgMjogY2VudGVyXHJcblx0XHRcdFR1bjowLCAgLy8gMDogbm8sIDE6IHVuZGVybGluZVxyXG5cdFx0XHRcclxuXHRcdFx0VG0gOlsxLDAsMCwxLDAsMF0sXHJcblx0XHRcdFRsbTpbMSwwLDAsMSwwLDBdLFxyXG5cdFx0XHRUcm06WzEsMCwwLDEsMCwwXVxyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cclxuZXhwb3J0IGxldCBGcm9tRU1GOmFueSA9IGZ1bmN0aW9uKClcclxue1xyXG59XHJcblxyXG5Gcm9tRU1GLlBhcnNlID0gZnVuY3Rpb24oYnVmZjphbnksIGdlbnY6YW55KVxyXG57XHJcbiAgICBidWZmID0gbmV3IFVpbnQ4QXJyYXkoYnVmZik7ICB2YXIgb2ZmPTA7XHJcbiAgICAvL2NvbnNvbGUubG9nKGJ1ZmYuc2xpY2UoMCwzMikpO1xyXG4gICAgdmFyIHBybXM6YW55ID0ge2ZpbGw6ZmFsc2UsIHN0cms6ZmFsc2UsIGJiOlswLDAsMSwxXSwgd2JiOlswLDAsMSwxXSwgZm50OntuYW06XCJBcmlhbFwiLGhnaDoyNSx1bmQ6ZmFsc2Usb3JuOjB9LCB0Y2xyOlswLDAsMF0sIHRhbGc6MH0sIGdzdCwgdGFiID0gW10sIHN0cz1bXTtcclxuICAgIFxyXG4gICAgdmFyIHJJID0gRnJvbUVNRi5CLnJlYWRTaG9ydCwgclUgPSBGcm9tRU1GLkIucmVhZFVzaG9ydCwgckkzMiA9IEZyb21FTUYuQi5yZWFkSW50LCByVTMyID0gRnJvbUVNRi5CLnJlYWRVaW50LCByRjMyID0gRnJvbUVNRi5CLnJlYWRGbG9hdDtcdFxyXG4gICAgXHJcbiAgICB2YXIgb3BuPTA7XHJcbiAgICB3aGlsZSh0cnVlKSB7XHJcbiAgICAgICAgdmFyIGZuYyA9IHJVMzIoYnVmZiwgb2ZmKTsgIG9mZis9NDtcclxuICAgICAgICB2YXIgZm5tID0gRnJvbUVNRi5LW2ZuY107IFxyXG4gICAgICAgIHZhciBzaXogPSByVTMyKGJ1ZmYsIG9mZik7ICBvZmYrPTQ7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy9pZihnc3QgJiYgaXNOYU4oZ3N0LmN0bVswXSkpIHRocm93IFwiZVwiO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coZm5jLGZubSxzaXopO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBsb2ZmID0gb2ZmO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vaWYob3BuKys9PTI1MykgYnJlYWs7XHJcbiAgICAgICAgdmFyIG9iajphbnkgPSBudWxsLCBvaWQgPSAwO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coZm5tLCBzaXopO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKGZhbHNlKSB7fVxyXG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIkVPRlwiKSB7ICBicmVhazsgIH1cclxuICAgICAgICBlbHNlIGlmKGZubT09XCJIRUFERVJcIikge1xyXG4gICAgICAgICAgICBwcm1zLmJiID0gRnJvbUVNRi5fcmVhZEJveChidWZmLGxvZmYpOyAgIGxvZmYrPTE2OyAgLy9jb25zb2xlLmxvZyhmbm0sIHBybXMuYmIpO1xyXG4gICAgICAgICAgICBnZW52LlN0YXJ0UGFnZShwcm1zLmJiWzBdLHBybXMuYmJbMV0scHJtcy5iYlsyXSxwcm1zLmJiWzNdKTtcclxuICAgICAgICAgICAgZ3N0ID0gVURPQy5nZXRTdGF0ZShwcm1zLmJiKTtcdFxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKGZubT09XCJTQVZFRENcIikgc3RzLnB1c2goSlNPTi5zdHJpbmdpZnkoZ3N0KSwgSlNPTi5zdHJpbmdpZnkocHJtcykpO1xyXG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIlJFU1RPUkVEQ1wiKSB7XHJcbiAgICAgICAgICAgIHZhciBkaWYgPSBySTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcclxuICAgICAgICAgICAgd2hpbGUoZGlmPC0xKSB7ICBzdHMucG9wKCk7ICBzdHMucG9wKCk7ICB9XHJcbiAgICAgICAgICAgIHBybXMgPSBKU09OLnBhcnNlKHN0cy5wb3AoKSk7ICBnc3QgPSBKU09OLnBhcnNlKHN0cy5wb3AoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIlNFTEVDVENMSVBQQVRIXCIpIHsgIGdzdC5jcHRoID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShnc3QucHRoKSk7ICB9XHJcbiAgICAgICAgZWxzZSBpZihbXCJTRVRNQVBNT0RFXCIsXCJTRVRQT0xZRklMTE1PREVcIixcIlNFVEJLTU9ERVwiLyosXCJTRVRWSUVXUE9SVEVYVEVYXCIqLyxcIlNFVElDTU1PREVcIixcIlNFVFJPUDJcIixcIkVYVFNFTEVDVENMSVBSR05cIl0uaW5kZXhPZihmbm0pIT0tMSkge31cclxuICAgICAgICAvL2Vsc2UgaWYoZm5tPT1cIklOVEVSU0VDVENMSVBSRUNUXCIpIHsgIHZhciByPXBybXMuY3JjdD1Gcm9tRU1GLl9yZWFkQm94KGJ1ZmYsIGxvZmYpOyAgLyp2YXIgeTA9clsxXSx5MT1yWzNdOyBpZih5MD55MSl7clsxXT15MTsgclszXT15MDt9Ki8gY29uc29sZS5sb2cocHJtcy5jcmN0KTsgIH1cclxuICAgICAgICBlbHNlIGlmKGZubT09XCJTRVRNSVRFUkxJTUlUXCIpIGdzdC5tbGltaXQgPSByVTMyKGJ1ZmYsIGxvZmYpO1xyXG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIlNFVFRFWFRDT0xPUlwiKSBwcm1zLnRjbHIgPSBbYnVmZltsb2ZmXS8yNTUsIGJ1ZmZbbG9mZisxXS8yNTUsIGJ1ZmZbbG9mZisyXS8yNTVdOyBcclxuICAgICAgICBlbHNlIGlmKGZubT09XCJTRVRURVhUQUxJR05cIikgcHJtcy50YWxnID0gclUzMihidWZmLCBsb2ZmKTtcclxuICAgICAgICBlbHNlIGlmKGZubT09XCJTRVRWSUVXUE9SVEVYVEVYXCIgfHwgZm5tPT1cIlNFVFZJRVdQT1JUT1JHRVhcIikge1xyXG4gICAgICAgICAgICBpZihwcm1zLnZiYj09bnVsbCkgcHJtcy52YmI9W107XHJcbiAgICAgICAgICAgIHZhciBjb2ZmID0gZm5tPT1cIlNFVFZJRVdQT1JUT1JHRVhcIiA/IDAgOiAyO1xyXG4gICAgICAgICAgICBwcm1zLnZiYltjb2ZmICBdID0gckkzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XHJcbiAgICAgICAgICAgIHBybXMudmJiW2NvZmYrMV0gPSBySTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhwcm1zLnZiYik7XHJcbiAgICAgICAgICAgIGlmKGZubT09XCJTRVRWSUVXUE9SVEVYVEVYXCIpIEZyb21FTUYuX3VwZGF0ZUN0bShwcm1zLCBnc3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKGZubT09XCJTRVRXSU5ET1dFWFRFWFwiIHx8IGZubT09XCJTRVRXSU5ET1dPUkdFWFwiKSB7XHJcbiAgICAgICAgICAgIHZhciBjb2ZmID0gZm5tPT1cIlNFVFdJTkRPV09SR0VYXCIgPyAwIDogMjtcclxuICAgICAgICAgICAgcHJtcy53YmJbY29mZiAgXSA9IHJJMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00O1xyXG4gICAgICAgICAgICBwcm1zLndiYltjb2ZmKzFdID0gckkzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XHJcbiAgICAgICAgICAgIGlmKGZubT09XCJTRVRXSU5ET1dFWFRFWFwiKSBGcm9tRU1GLl91cGRhdGVDdG0ocHJtcywgZ3N0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy9lbHNlIGlmKGZubT09XCJTRVRNRVRBUkdOXCIpIHt9XHJcbiAgICAgICAgZWxzZSBpZihmbm09PVwiQ09NTUVOVFwiKSB7ICB2YXIgZHMgPSByVTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDsgIH1cclxuICAgICAgICBcclxuICAgICAgICBlbHNlIGlmKGZubT09XCJTRUxFQ1RPQkpFQ1RcIikge1xyXG4gICAgICAgICAgICB2YXIgaW5kID0gclUzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coaW5kLnRvU3RyaW5nKDE2KSwgdGFiLCB0YWJbaW5kXSk7XHJcbiAgICAgICAgICAgIGlmICAgICAoaW5kPT0weDgwMDAwMDAwKSB7ICBwcm1zLmZpbGw9dHJ1ZSA7ICBnc3QuY29scj1bMSwxLDFdOyAgfSAvLyB3aGl0ZSBicnVzaFxyXG4gICAgICAgICAgICBlbHNlIGlmKGluZD09MHg4MDAwMDAwNSkgeyAgcHJtcy5maWxsPWZhbHNlOyAgfSAvLyBudWxsIGJydXNoXHJcbiAgICAgICAgICAgIGVsc2UgaWYoaW5kPT0weDgwMDAwMDA3KSB7ICBwcm1zLnN0cms9dHJ1ZSA7ICBwcm1zLmx3aWR0aD0xOyAgZ3N0LkNPTFI9WzAsMCwwXTsgIH0gLy8gYmxhY2sgcGVuXHJcbiAgICAgICAgICAgIGVsc2UgaWYoaW5kPT0weDgwMDAwMDA4KSB7ICBwcm1zLnN0cms9ZmFsc2U7ICB9IC8vIG51bGwgIHBlblxyXG4gICAgICAgICAgICBlbHNlIGlmKGluZD09MHg4MDAwMDAwZCkge30gLy8gc3lzdGVtIGZvbnRcclxuICAgICAgICAgICAgZWxzZSBpZihpbmQ9PTB4ODAwMDAwMGUpIHt9ICAvLyBkZXZpY2UgZGVmYXVsdCBmb250XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvOmFueSA9IHRhYltpbmRdOyAgLy9jb25zb2xlLmxvZyhpbmQsIGNvKTtcclxuICAgICAgICAgICAgICAgIGlmKGNvLnQ9PVwiYlwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJtcy5maWxsPWNvLnN0bCE9MTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAgICAgKGNvLnN0bD09MCkge31cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGNvLnN0bD09MSkge31cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHRocm93IGNvLnN0bCtcIiBlXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3N0LmNvbHI9Y28uY2xyO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZihjby50PT1cInBcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHBybXMuc3Ryaz1jby5zdGwhPTU7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3N0Lmx3aWR0aCA9IGNvLndpZDtcclxuICAgICAgICAgICAgICAgICAgICBnc3QuQ09MUj1jby5jbHI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmKGNvLnQ9PVwiZlwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJtcy5mbnQgPSBjbztcclxuICAgICAgICAgICAgICAgICAgICBnc3QuZm9udC5UZiA9IGNvLm5hbTtcclxuICAgICAgICAgICAgICAgICAgICBnc3QuZm9udC5UZnMgPSBNYXRoLmFicyhjby5oZ2gpO1xyXG4gICAgICAgICAgICAgICAgICAgIGdzdC5mb250LlR1biA9IGNvLnVuZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgdGhyb3cgXCJlXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihmbm09PVwiREVMRVRFT0JKRUNUXCIpIHtcclxuICAgICAgICAgICAgdmFyIGluZCA9IHJVMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00O1xyXG4gICAgICAgICAgICBpZih0YWJbaW5kXSE9bnVsbCkgdGFiW2luZF09bnVsbDtcclxuICAgICAgICAgICAgZWxzZSB0aHJvdyBcImVcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihmbm09PVwiQ1JFQVRFQlJVU0hJTkRJUkVDVFwiKSB7XHJcbiAgICAgICAgICAgIG9pZCA9IHJVMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00O1xyXG4gICAgICAgICAgICBvYmogPSB7dDpcImJcIn07XHJcbiAgICAgICAgICAgIG9iai5zdGwgPSByVTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcclxuICAgICAgICAgICAgb2JqLmNsciA9IFtidWZmW2xvZmZdLzI1NSwgYnVmZltsb2ZmKzFdLzI1NSwgYnVmZltsb2ZmKzJdLzI1NV07ICBsb2ZmKz00O1xyXG4gICAgICAgICAgICBvYmouaHRjID0gclUzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2cob2lkLCBvYmopO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmKGZubT09XCJDUkVBVEVQRU5cIiB8fCBmbm09PVwiRVhUQ1JFQVRFUEVOXCIpIHtcclxuICAgICAgICAgICAgb2lkID0gclUzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XHJcbiAgICAgICAgICAgIG9iaiA9IHt0OlwicFwifTtcclxuICAgICAgICAgICAgaWYoZm5tPT1cIkVYVENSRUFURVBFTlwiKSB7XHJcbiAgICAgICAgICAgICAgICBsb2ZmKz0xNjtcclxuICAgICAgICAgICAgICAgIG9iai5zdGwgPSByVTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcclxuICAgICAgICAgICAgICAgIG9iai53aWQgPSByVTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcclxuICAgICAgICAgICAgICAgIC8vb2JqLnN0bCA9IHJVMzIoYnVmZiwgbG9mZik7ICBcclxuICAgICAgICAgICAgICAgIGxvZmYrPTQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvYmouc3RsID0gclUzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XHJcbiAgICAgICAgICAgICAgICBvYmoud2lkID0gclUzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7ICBsb2ZmKz00O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9iai5jbHIgPSBbYnVmZltsb2ZmXS8yNTUsIGJ1ZmZbbG9mZisxXS8yNTUsIGJ1ZmZbbG9mZisyXS8yNTVdOyAgbG9mZis9NDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihmbm09PVwiRVhUQ1JFQVRFRk9OVElORElSRUNUV1wiKSB7XHJcbiAgICAgICAgICAgIG9pZCA9IHJVMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00O1xyXG4gICAgICAgICAgICBvYmogPSB7dDpcImZcIiwgbmFtOlwiXCJ9O1xyXG4gICAgICAgICAgICBvYmouaGdoID0gckkzMihidWZmLCBsb2ZmKTsgIGxvZmYgKz0gNDtcclxuICAgICAgICAgICAgbG9mZiArPSA0KjI7XHJcbiAgICAgICAgICAgIG9iai5vcm4gPSBySTMyKGJ1ZmYsIGxvZmYpLzEwOyAgbG9mZis9NDtcclxuICAgICAgICAgICAgdmFyIHdnaCA9IHJVMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00OyAgLy9jb25zb2xlLmxvZyhmbm0sIG9iai5vcm4sIHdnaCk7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coclUzMihidWZmLGxvZmYpLCByVTMyKGJ1ZmYsbG9mZis0KSwgYnVmZi5zbGljZShsb2ZmLGxvZmYrOCkpO1xyXG4gICAgICAgICAgICBvYmoudW5kID0gYnVmZltsb2ZmKzFdOyAgb2JqLnN0ayA9IGJ1ZmZbbG9mZisyXTsgIGxvZmYgKz0gNCoyO1xyXG4gICAgICAgICAgICB3aGlsZShyVShidWZmLGxvZmYpIT0wKSB7ICBvYmoubmFtKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHJVKGJ1ZmYsbG9mZikpOyAgbG9mZis9MjsgIH1cclxuICAgICAgICAgICAgaWYod2doPjUwMCkgb2JqLm5hbSs9XCItQm9sZFwiO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHdnaCwgb2JqLm5hbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIkVYVFRFWFRPVVRXXCIpIHtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhidWZmLnNsaWNlKGxvZmYtOCwgbG9mZi04K3NpeikpO1xyXG4gICAgICAgICAgICBsb2ZmKz0xNjtcclxuICAgICAgICAgICAgdmFyIG1vZCA9IHJVMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00OyAgLy9jb25zb2xlLmxvZyhtb2QpO1xyXG4gICAgICAgICAgICB2YXIgc2N4ID0gckYzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XHJcbiAgICAgICAgICAgIHZhciBzY3kgPSByRjMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcclxuICAgICAgICAgICAgdmFyIHJmeCA9IHJJMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00O1xyXG4gICAgICAgICAgICB2YXIgcmZ5ID0gckkzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2cobW9kLCBzY3gsIHNjeSxyZngscmZ5KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGdzdC5mb250LlRtID0gWzEsMCwwLC0xLDAsMF07XHJcbiAgICAgICAgICAgIFVET0MuTS5yb3RhdGUoZ3N0LmZvbnQuVG0sIHBybXMuZm50Lm9ybipNYXRoLlBJLzE4MCk7XHJcbiAgICAgICAgICAgIFVET0MuTS50cmFuc2xhdGUoZ3N0LmZvbnQuVG0sIHJmeCwgcmZ5KTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBhbGcgPSBwcm1zLnRhbGc7ICAvL2NvbnNvbGUubG9nKGFsZy50b1N0cmluZygyKSk7XHJcbiAgICAgICAgICAgIGlmICAgICAoKGFsZyY2KT09NikgZ3N0LmZvbnQuVGFsID0gMjtcclxuICAgICAgICAgICAgZWxzZSBpZigoYWxnJjcpPT0wKSBnc3QuZm9udC5UYWwgPSAwO1xyXG4gICAgICAgICAgICBlbHNlIHRocm93IGFsZytcIiBlXCI7XHJcbiAgICAgICAgICAgIGlmKChhbGcmMjQpPT0yNCkge30gIC8vIGJhc2VsaW5lXHJcbiAgICAgICAgICAgIGVsc2UgaWYoKGFsZyYyNCk9PTApIFVET0MuTS50cmFuc2xhdGUoZ3N0LmZvbnQuVG0sIDAsIGdzdC5mb250LlRmcyk7XHJcbiAgICAgICAgICAgIGVsc2UgdGhyb3cgXCJlXCI7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIGNycyA9IHJVMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00O1xyXG4gICAgICAgICAgICB2YXIgb2ZzID0gclUzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XHJcbiAgICAgICAgICAgIHZhciBvcHMgPSByVTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDsgIC8vaWYob3BzIT0wKSB0aHJvdyBcImVcIjtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhvZnMsb3BzLGNycyk7XHJcbiAgICAgICAgICAgIGxvZmYrPTE2O1xyXG4gICAgICAgICAgICB2YXIgb2ZEID0gclUzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7ICAvL2NvbnNvbGUubG9nKG9wcywgb2ZELCBsb2ZmLCBvZnMrb2ZmLTgpO1xyXG4gICAgICAgICAgICBvZnMgKz0gb2ZmLTg7ICAvL2NvbnNvbGUubG9nKGNycywgb3BzKTtcclxuICAgICAgICAgICAgdmFyIHN0ciA9IFwiXCI7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPGNyczsgaSsrKSB7ICB2YXIgY2M9clUoYnVmZixvZnMraSoyKTsgIHN0cis9U3RyaW5nLmZyb21DaGFyQ29kZShjYyk7ICB9O1xyXG4gICAgICAgICAgICB2YXIgb2NsciA9IGdzdC5jb2xyOyAgZ3N0LmNvbHIgPSBwcm1zLnRjbHI7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coc3RyLCBnc3QuY29sciwgZ3N0LmZvbnQuVG0pO1xyXG4gICAgICAgICAgICAvL3ZhciBvdGZzID0gZ3N0LmZvbnQuVGZzOyAgZ3N0LmZvbnQuVGZzICo9IDEvZ3N0LmN0bVswXTtcclxuICAgICAgICAgICAgZ2Vudi5QdXRUZXh0KGdzdCwgc3RyLCBzdHIubGVuZ3RoKmdzdC5mb250LlRmcyowLjUpOyAgZ3N0LmNvbHI9b2NscjtcclxuICAgICAgICAgICAgLy9nc3QuZm9udC5UZnMgPSBvdGZzO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHJmeCwgcmZ5LCBzY3gsIG9wcywgcmNYLCByY1ksIHJjVywgcmNILCBvZmZEeCwgc3RyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihmbm09PVwiQkVHSU5QQVRIXCIpIHsgIFVET0MuRy5uZXdQYXRoKGdzdCk7ICB9XHJcbiAgICAgICAgZWxzZSBpZihmbm09PVwiRU5EUEFUSFwiICApIHsgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIkNMT1NFRklHVVJFXCIpIFVET0MuRy5jbG9zZVBhdGgoZ3N0KTtcclxuICAgICAgICBlbHNlIGlmKGZubT09XCJNT1ZFVE9FWFwiICkgeyAgVURPQy5HLm1vdmVUbyhnc3QsIHJJMzIoYnVmZixsb2ZmKSwgckkzMihidWZmLGxvZmYrNCkpOyAgfVxyXG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIkxJTkVUT1wiICAgKSB7ICBcclxuICAgICAgICAgICAgaWYoZ3N0LnB0aC5jbWRzLmxlbmd0aD09MCkgeyAgdmFyIGltPWdzdC5jdG0uc2xpY2UoMCk7ICBVRE9DLk0uaW52ZXJ0KGltKTsgIHZhciBwID0gVURPQy5NLm11bHRQb2ludChpbSwgZ3N0LmNwb3MpOyAgVURPQy5HLm1vdmVUbyhnc3QsIHBbMF0sIHBbMV0pOyAgfSAgXHJcbiAgICAgICAgICAgIFVET0MuRy5saW5lVG8oZ3N0LCBySTMyKGJ1ZmYsbG9mZiksIHJJMzIoYnVmZixsb2ZmKzQpKTsgIH1cclxuICAgICAgICBlbHNlIGlmKGZubT09XCJQT0xZR09OXCIgfHwgZm5tPT1cIlBPTFlHT04xNlwiIHx8IGZubT09XCJQT0xZTElORVwiIHx8IGZubT09XCJQT0xZTElORTE2XCIgfHwgZm5tPT1cIlBPTFlMSU5FVE9cIiB8fCBmbm09PVwiUE9MWUxJTkVUTzE2XCIpIHtcclxuICAgICAgICAgICAgbG9mZis9MTY7XHJcbiAgICAgICAgICAgIHZhciBuZGYgPSBmbm0uc3RhcnRzV2l0aChcIlBPTFlHT05cIiksIGlzVG8gPSBmbm0uaW5kZXhPZihcIlRPXCIpIT0tMTtcclxuICAgICAgICAgICAgdmFyIGNudCA9IHJVMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00O1xyXG4gICAgICAgICAgICBpZighaXNUbykgVURPQy5HLm5ld1BhdGgoZ3N0KTtcclxuICAgICAgICAgICAgbG9mZiA9IEZyb21FTUYuX2RyYXdQb2x5KGJ1ZmYsbG9mZixjbnQsZ3N0LCBmbm0uZW5kc1dpdGgoXCIxNlwiKT8yOjQsICBuZGYsIGlzVG8pO1xyXG4gICAgICAgICAgICBpZighaXNUbykgRnJvbUVNRi5fZHJhdyhnZW52LGdzdCxwcm1zLCBuZGYpO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHBybXMsIGdzdC5sd2lkdGgpO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZ3N0LnB0aCkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihmbm09PVwiUE9MWVBPTFlHT04xNlwiKSB7XHJcbiAgICAgICAgICAgIGxvZmYrPTE2O1xyXG4gICAgICAgICAgICB2YXIgbmRmID0gZm5tLnN0YXJ0c1dpdGgoXCJQT0xZUE9MWUdPTlwiKSwgaXNUbyA9IGZubS5pbmRleE9mKFwiVE9cIikhPS0xO1xyXG4gICAgICAgICAgICB2YXIgbm9wID0gclUzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7ICBsb2ZmKz00O1xyXG4gICAgICAgICAgICB2YXIgcGkgPSBsb2ZmOyAgbG9mZis9IG5vcCo0O1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYoIWlzVG8pIFVET0MuRy5uZXdQYXRoKGdzdCk7XHJcbiAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPG5vcDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHBwID0gclUoYnVmZiwgcGkraSo0KTtcclxuICAgICAgICAgICAgICAgIGxvZmYgPSBGcm9tRU1GLl9kcmF3UG9seShidWZmLGxvZmYscHBwLGdzdCwgZm5tLmVuZHNXaXRoKFwiMTZcIik/Mjo0LCBuZGYsIGlzVG8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmKCFpc1RvKSBGcm9tRU1GLl9kcmF3KGdlbnYsZ3N0LHBybXMsIG5kZik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIlBPTFlCRVpJRVJcIiB8fCBmbm09PVwiUE9MWUJFWklFUjE2XCIgfHwgZm5tPT1cIlBPTFlCRVpJRVJUT1wiIHx8IGZubT09XCJQT0xZQkVaSUVSVE8xNlwiKSB7XHJcbiAgICAgICAgICAgIGxvZmYrPTE2O1xyXG4gICAgICAgICAgICB2YXIgaXMxNiA9IGZubS5lbmRzV2l0aChcIjE2XCIpLCByQyA9IGlzMTY/ckk6ckkzMiwgbmwgPSBpczE2PzI6NDtcclxuICAgICAgICAgICAgdmFyIGNudCA9IHJVMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00O1xyXG4gICAgICAgICAgICBpZihmbm0uaW5kZXhPZihcIlRPXCIpPT0tMSkge1xyXG4gICAgICAgICAgICAgICAgVURPQy5HLm1vdmVUbyhnc3QsIHJDKGJ1ZmYsbG9mZiksIHJDKGJ1ZmYsbG9mZitubCkpOyAgbG9mZis9MipubDsgIGNudC0tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdoaWxlKGNudD4wKSB7XHJcbiAgICAgICAgICAgICAgICBVRE9DLkcuY3VydmVUbyhnc3QsIHJDKGJ1ZmYsbG9mZiksIHJDKGJ1ZmYsbG9mZitubCksIHJDKGJ1ZmYsbG9mZisyKm5sKSwgckMoYnVmZixsb2ZmKzMqbmwpLCByQyhidWZmLGxvZmYrNCpubCksIHJDKGJ1ZmYsbG9mZis1Km5sKSApO1xyXG4gICAgICAgICAgICAgICAgbG9mZis9NipubDtcclxuICAgICAgICAgICAgICAgIGNudC09MztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZ3N0LnB0aCkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihmbm09PVwiUkVDVEFOR0xFXCIgfHwgZm5tPT1cIkVMTElQU0VcIikge1xyXG4gICAgICAgICAgICBVRE9DLkcubmV3UGF0aChnc3QpO1xyXG4gICAgICAgICAgICB2YXIgYnggPSBGcm9tRU1GLl9yZWFkQm94KGJ1ZmYsIGxvZmYpO1xyXG4gICAgICAgICAgICBpZihmbm09PVwiUkVDVEFOR0xFXCIpIHtcclxuICAgICAgICAgICAgICAgIFVET0MuRy5tb3ZlVG8oZ3N0LCBieFswXSxieFsxXSk7XHJcbiAgICAgICAgICAgICAgICBVRE9DLkcubGluZVRvKGdzdCwgYnhbMl0sYnhbMV0pO1xyXG4gICAgICAgICAgICAgICAgVURPQy5HLmxpbmVUbyhnc3QsIGJ4WzJdLGJ4WzNdKTtcclxuICAgICAgICAgICAgICAgIFVET0MuRy5saW5lVG8oZ3N0LCBieFswXSxieFszXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgeCA9IChieFswXStieFsyXSkvMiwgeSA9IChieFsxXStieFszXSkvMjtcclxuICAgICAgICAgICAgICAgIFVET0MuRy5hcmMoZ3N0LHgseSwoYnhbMl0tYnhbMF0pLzIsMCwyKk1hdGguUEksIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBVRE9DLkcuY2xvc2VQYXRoKGdzdCk7XHJcbiAgICAgICAgICAgIEZyb21FTUYuX2RyYXcoZ2Vudixnc3QscHJtcywgdHJ1ZSk7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2cocHJtcywgZ3N0Lmx3aWR0aCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIkZJTExQQVRIXCIgICkgZ2Vudi5GaWxsKGdzdCwgZmFsc2UpO1xyXG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIlNUUk9LRVBBVEhcIikgZ2Vudi5TdHJva2UoZ3N0KTtcclxuICAgICAgICBlbHNlIGlmKGZubT09XCJTVFJPS0VBTkRGSUxMUEFUSFwiKSB7ICBnZW52LkZpbGwoZ3N0LCBmYWxzZSk7ICBnZW52LlN0cm9rZShnc3QpOyAgfVxyXG4gICAgICAgIGVsc2UgaWYoZm5tPT1cIlNFVFdPUkxEVFJBTlNGT1JNXCIgfHwgZm5tPT1cIk1PRElGWVdPUkxEVFJBTlNGT1JNXCIpIHtcclxuICAgICAgICAgICAgdmFyIG1hdCA9IFtdO1xyXG4gICAgICAgICAgICBmb3IodmFyIGk9MDsgaTw2OyBpKyspIG1hdC5wdXNoKHJGMzIoYnVmZixsb2ZmK2kqNCkpOyAgbG9mZis9MjQ7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coZm5tLCBnc3QuY3RtLnNsaWNlKDApLCBtYXQpO1xyXG4gICAgICAgICAgICBpZihmbm09PVwiU0VUV09STERUUkFOU0ZPUk1cIikgZ3N0LmN0bT1tYXQ7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1vZCA9IHJVMzIoYnVmZixsb2ZmKTsgIGxvZmYrPTQ7XHJcbiAgICAgICAgICAgICAgICBpZihtb2Q9PTIpIHsgIHZhciBvbT1nc3QuY3RtOyAgZ3N0LmN0bT1tYXQ7ICBVRE9DLk0uY29uY2F0KGdzdC5jdG0sIG9tKTsgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgdGhyb3cgXCJlXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZihmbm09PVwiU0VUU1RSRVRDSEJMVE1PREVcIikgeyAgdmFyIHNtID0gclUzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7ICB9XHJcbiAgICAgICAgZWxzZSBpZihmbm09PVwiU1RSRVRDSERJQklUU1wiKSB7XHJcbiAgICAgICAgICAgIHZhciBieCA9IEZyb21FTUYuX3JlYWRCb3goYnVmZiwgbG9mZik7ICBsb2ZmKz0xNjtcclxuICAgICAgICAgICAgdmFyIHhEID0gckkzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XHJcbiAgICAgICAgICAgIHZhciB5RCA9IHJJMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00O1xyXG4gICAgICAgICAgICB2YXIgeFMgPSBySTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcclxuICAgICAgICAgICAgdmFyIHlTID0gckkzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XHJcbiAgICAgICAgICAgIHZhciB3UyA9IHJJMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00O1xyXG4gICAgICAgICAgICB2YXIgaFMgPSBySTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDtcclxuICAgICAgICAgICAgdmFyIG9mSCA9IHJVMzIoYnVmZiwgbG9mZikrb2ZmLTg7ICBsb2ZmKz00O1xyXG4gICAgICAgICAgICB2YXIgc3pIID0gclUzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XHJcbiAgICAgICAgICAgIHZhciBvZkIgPSByVTMyKGJ1ZmYsIGxvZmYpK29mZi04OyAgbG9mZis9NDtcclxuICAgICAgICAgICAgdmFyIHN6QiA9IHJVMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00O1xyXG4gICAgICAgICAgICB2YXIgdXNnID0gclUzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7ICBpZih1c2chPTApIHRocm93IFwiZVwiO1xyXG4gICAgICAgICAgICB2YXIgYm9wID0gclUzMihidWZmLCBsb2ZmKTsgIGxvZmYrPTQ7XHJcbiAgICAgICAgICAgIHZhciB3RCA9IHJJMzIoYnVmZiwgbG9mZik7ICBsb2ZmKz00O1xyXG4gICAgICAgICAgICB2YXIgaEQgPSBySTMyKGJ1ZmYsIGxvZmYpOyAgbG9mZis9NDsgIC8vY29uc29sZS5sb2coYm9wLCB3RCwgaEQpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhvZkgsIHN6SCwgb2ZCLCBzekIsIG9mSCs0MCk7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coYngsIHhELHlELHdELGhEKTtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyh4Uyx5Uyx3UyxoUyk7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2cob2ZILHN6SCxvZkIsc3pCLHVzZyxib3ApO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgdmFyIGhsID0gclUzMihidWZmLCBvZkgpOyAgb2ZIKz00O1xyXG4gICAgICAgICAgICB2YXIgdyAgPSByVTMyKGJ1ZmYsIG9mSCk7ICBvZkgrPTQ7XHJcbiAgICAgICAgICAgIHZhciBoICA9IHJVMzIoYnVmZiwgb2ZIKTsgIG9mSCs9NDsgIGlmKHchPXdTIHx8IGghPWhTKSB0aHJvdyBcImVcIjtcclxuICAgICAgICAgICAgdmFyIHBzID0gclUgIChidWZmLCBvZkgpOyAgb2ZIKz0yO1xyXG4gICAgICAgICAgICB2YXIgYmMgPSByVSAgKGJ1ZmYsIG9mSCk7ICBvZkgrPTI7ICBpZihiYyE9OCAmJiBiYyE9MjQgJiYgYmMhPTMyKSB0aHJvdyBiYytcIiBlXCI7XHJcbiAgICAgICAgICAgIHZhciBjcHI9IHJVMzIoYnVmZiwgb2ZIKTsgIG9mSCs9NDsgIGlmKGNwciE9MCkgdGhyb3cgY3ByK1wiIGVcIjtcclxuICAgICAgICAgICAgdmFyIHN6ID0gclUzMihidWZmLCBvZkgpOyAgb2ZIKz00O1xyXG4gICAgICAgICAgICB2YXIgeHBtPSByVTMyKGJ1ZmYsIG9mSCk7ICBvZkgrPTQ7XHJcbiAgICAgICAgICAgIHZhciB5cG09IHJVMzIoYnVmZiwgb2ZIKTsgIG9mSCs9NDtcclxuICAgICAgICAgICAgdmFyIGN1ID0gclUzMihidWZmLCBvZkgpOyAgb2ZIKz00O1xyXG4gICAgICAgICAgICB2YXIgY2kgPSByVTMyKGJ1ZmYsIG9mSCk7ICBvZkgrPTQ7ICAvL2NvbnNvbGUubG9nKGhsLCB3LCBoLCBwcywgYmMsIGNwciwgc3osIHhwbSwgeXBtLCBjdSwgY2kpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhobCx3LGgsXCIsXCIseFMseVMsd1MsaFMsXCIsXCIseEQseUQsd0QsaEQsXCIsXCIseHBtLHlwbSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICB2YXIgcmwgPSBNYXRoLmZsb29yKCgodyAqIHBzICogYmMgKyAzMSkgJiB+MzEpIC8gOCk7XHJcbiAgICAgICAgICAgIHZhciBpbWcgPSBuZXcgVWludDhBcnJheSh3KmgqNCk7XHJcbiAgICAgICAgICAgIGlmKGJjPT04KSB7XHJcbiAgICAgICAgICAgICAgICBmb3IodmFyIHk9MDsgeTxoOyB5KyspIFxyXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgeD0wOyB4PHc7IHgrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcWkgPSAoeSp3K3gpPDwyLCBpbmQ6YW55ID0gYnVmZltvZkIrKGgtMS15KSpybCt4XTw8MjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1nW3FpICBdID0gYnVmZltvZkgraW5kKzJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWdbcWkrMV0gPSBidWZmW29mSCtpbmQrMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltZ1txaSsyXSA9IGJ1ZmZbb2ZIK2luZCswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1nW3FpKzNdID0gMjU1O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihiYz09MjQpIHtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgeT0wOyB5PGg7IHkrKykgXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciB4PTA7IHg8dzsgeCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBxaSA9ICh5KncreCk8PDIsIHRpPW9mQisoaC0xLXkpKnJsK3gqMztcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1nW3FpICBdID0gYnVmZlt0aSsyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1nW3FpKzFdID0gYnVmZlt0aSsxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1nW3FpKzJdID0gYnVmZlt0aSswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1nW3FpKzNdID0gMjU1O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZihiYz09MzIpIHtcclxuICAgICAgICAgICAgICAgIGZvcih2YXIgeT0wOyB5PGg7IHkrKykgXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciB4PTA7IHg8dzsgeCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBxaSA9ICh5KncreCk8PDIsIHRpPW9mQisoaC0xLXkpKnJsK3gqNDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1nW3FpICBdID0gYnVmZlt0aSsyXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1nW3FpKzFdID0gYnVmZlt0aSsxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1nW3FpKzJdID0gYnVmZlt0aSswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1nW3FpKzNdID0gYnVmZlt0aSszXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHZhciBjdG0gPSBnc3QuY3RtLnNsaWNlKDApO1xyXG4gICAgICAgICAgICBnc3QuY3RtID0gWzEsMCwwLDEsMCwwXTtcclxuICAgICAgICAgICAgVURPQy5NLnNjYWxlKGdzdC5jdG0sIHdELCAtaEQpO1xyXG4gICAgICAgICAgICBVRE9DLk0udHJhbnNsYXRlKGdzdC5jdG0sIHhELCB5RCtoRCk7XHJcbiAgICAgICAgICAgIFVET0MuTS5jb25jYXQoZ3N0LmN0bSwgY3RtKTtcclxuICAgICAgICAgICAgZ2Vudi5QdXRJbWFnZShnc3QsIGltZywgdywgaCk7XHJcbiAgICAgICAgICAgIGdzdC5jdG0gPSBjdG07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhmbm0sIHNpeik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmKG9iaiE9bnVsbCkgdGFiW29pZF09b2JqO1xyXG4gICAgICAgIFxyXG4gICAgICAgIG9mZis9c2l6LTg7XHJcbiAgICB9XHJcbiAgICAvL2dlbnYuU3Ryb2tlKGdzdCk7XHJcbiAgICBnZW52LlNob3dQYWdlKCk7ICBnZW52LkRvbmUoKTtcclxufVxyXG5Gcm9tRU1GLl9yZWFkQm94ID0gZnVuY3Rpb24oYnVmZjphbnksIG9mZjphbnkpIHsgIHZhciBiPVtdOyAgZm9yKHZhciBpPTA7IGk8NDsgaSsrKSBiW2ldID0gRnJvbUVNRi5CLnJlYWRJbnQoYnVmZixvZmYraSo0KTsgIHJldHVybiBiOyAgfVx0XHJcblxyXG5Gcm9tRU1GLl91cGRhdGVDdG0gPSBmdW5jdGlvbihwcm1zOmFueSwgZ3N0OmFueSkge1xyXG4gICAgdmFyIG1hdCA9IFsxLDAsMCwxLDAsMF07XHJcbiAgICB2YXIgd2JiID0gcHJtcy53YmIsIGJiID0gcHJtcy5iYiwgdmJiPShwcm1zLnZiYiAmJiBwcm1zLnZiYi5sZW5ndGg9PTQpID8gcHJtcy52YmI6cHJtcy5iYjtcclxuICAgIFxyXG4gICAgLy92YXIgeTAgPSBiYlsxXSwgeTEgPSBiYlszXTsgIGJiWzFdPU1hdGgubWluKHkwLHkxKTsgIGJiWzNdPU1hdGgubWF4KHkwLHkxKTtcclxuICAgIFxyXG4gICAgVURPQy5NLnRyYW5zbGF0ZShtYXQsIC13YmJbMF0sLXdiYlsxXSk7XHJcbiAgICBVRE9DLk0uc2NhbGUobWF0LCAxL3diYlsyXSwgMS93YmJbM10pO1xyXG4gICAgXHJcbiAgICBVRE9DLk0uc2NhbGUobWF0LCB2YmJbMl0sIHZiYlszXSk7XHJcbiAgICAvL1VET0MuTS5zY2FsZShtYXQsIHZiYlsyXS8oYmJbMl0tYmJbMF0pLCB2YmJbM10vKGJiWzNdLWJiWzFdKSk7XHJcbiAgICBcclxuICAgIC8vVURPQy5NLnNjYWxlKG1hdCwgYmJbMl0tYmJbMF0sYmJbM10tYmJbMV0pO1xyXG4gICAgXHJcbiAgICBnc3QuY3RtID0gbWF0O1xyXG59XHJcbkZyb21FTUYuX2RyYXcgPSBmdW5jdGlvbihnZW52OmFueSwgZ3N0OmFueSwgcHJtczphbnksIG5lZWRGaWxsOmFueSkge1xyXG4gICAgaWYocHJtcy5maWxsICYmIG5lZWRGaWxsICAgICApIGdlbnYuRmlsbCAgKGdzdCwgZmFsc2UpO1xyXG4gICAgaWYocHJtcy5zdHJrICYmIGdzdC5sd2lkdGghPTApIGdlbnYuU3Ryb2tlKGdzdCk7XHJcbn1cclxuRnJvbUVNRi5fZHJhd1BvbHkgPSBmdW5jdGlvbihidWZmOmFueSwgb2ZmOmFueSwgcHBwOmFueSwgZ3N0OmFueSwgbmw6YW55LCBjbG9zOmFueSwganVzdExpbmU6YW55KSB7XHJcbiAgICB2YXIgclMgPSBubD09MiA/IEZyb21FTUYuQi5yZWFkU2hvcnQgOiBGcm9tRU1GLkIucmVhZEludDtcclxuICAgIGZvcih2YXIgaj0wOyBqPHBwcDsgaisrKSB7XHJcbiAgICAgICAgdmFyIHB4ID0gclMoYnVmZiwgb2ZmKTsgIG9mZis9bmw7ICBcclxuICAgICAgICB2YXIgcHkgPSByUyhidWZmLCBvZmYpOyAgb2ZmKz1ubDtcclxuICAgICAgICBpZihqPT0wICYmICFqdXN0TGluZSkgVURPQy5HLm1vdmVUbyhnc3QscHgscHkpOyAgZWxzZSBVRE9DLkcubGluZVRvKGdzdCxweCxweSk7XHJcbiAgICB9XHJcbiAgICBpZihjbG9zKSBVRE9DLkcuY2xvc2VQYXRoKGdzdCk7XHJcbiAgICByZXR1cm4gb2ZmO1xyXG59XHJcblxyXG5Gcm9tRU1GLkIgPSB7XHJcbiAgICB1aW50OCA6IG5ldyBVaW50OEFycmF5KDQpLFxyXG4gICAgcmVhZFNob3J0ICA6IGZ1bmN0aW9uKGJ1ZmY6YW55LHA6YW55KTphbnkgIHsgIHZhciB1OD1Gcm9tRU1GLkIudWludDg7ICB1OFswXT1idWZmW3BdOyAgdThbMV09YnVmZltwKzFdOyAgcmV0dXJuIEZyb21FTUYuQi5pbnQxNiBbMF07ICB9LFxyXG4gICAgcmVhZFVzaG9ydCA6IGZ1bmN0aW9uKGJ1ZmY6YW55LHA6YW55KTphbnkgIHsgIHZhciB1OD1Gcm9tRU1GLkIudWludDg7ICB1OFswXT1idWZmW3BdOyAgdThbMV09YnVmZltwKzFdOyAgcmV0dXJuIEZyb21FTUYuQi51aW50MTZbMF07ICB9LFxyXG4gICAgcmVhZEludCAgICA6IGZ1bmN0aW9uKGJ1ZmY6YW55LHA6YW55KTphbnkgIHsgIHZhciB1OD1Gcm9tRU1GLkIudWludDg7ICB1OFswXT1idWZmW3BdOyAgdThbMV09YnVmZltwKzFdOyAgdThbMl09YnVmZltwKzJdOyAgdThbM109YnVmZltwKzNdOyAgcmV0dXJuIEZyb21FTUYuQi5pbnQzMiBbMF07ICB9LFxyXG4gICAgcmVhZFVpbnQgICA6IGZ1bmN0aW9uKGJ1ZmY6YW55LHA6YW55KTphbnkgIHsgIHZhciB1OD1Gcm9tRU1GLkIudWludDg7ICB1OFswXT1idWZmW3BdOyAgdThbMV09YnVmZltwKzFdOyAgdThbMl09YnVmZltwKzJdOyAgdThbM109YnVmZltwKzNdOyAgcmV0dXJuIEZyb21FTUYuQi51aW50MzJbMF07ICB9LFxyXG4gICAgcmVhZEZsb2F0ICA6IGZ1bmN0aW9uKGJ1ZmY6YW55LHA6YW55KTphbnkgIHsgIHZhciB1OD1Gcm9tRU1GLkIudWludDg7ICB1OFswXT1idWZmW3BdOyAgdThbMV09YnVmZltwKzFdOyAgdThbMl09YnVmZltwKzJdOyAgdThbM109YnVmZltwKzNdOyAgcmV0dXJuIEZyb21FTUYuQi5mbG90MzJbMF07ICB9LFxyXG4gICAgcmVhZEFTQ0lJICA6IGZ1bmN0aW9uKGJ1ZmY6YW55LHA6YW55LGw6YW55KTphbnkgeyAgdmFyIHMgPSBcIlwiOyAgZm9yKHZhciBpPTA7IGk8bDsgaSsrKSBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmZltwK2ldKTsgIHJldHVybiBzOyAgICB9XHJcbn1cclxuRnJvbUVNRi5CLmludDE2ICA9IG5ldyBJbnQxNkFycmF5IChGcm9tRU1GLkIudWludDguYnVmZmVyKTtcclxuRnJvbUVNRi5CLnVpbnQxNiA9IG5ldyBVaW50MTZBcnJheShGcm9tRU1GLkIudWludDguYnVmZmVyKTtcclxuRnJvbUVNRi5CLmludDMyICA9IG5ldyBJbnQzMkFycmF5IChGcm9tRU1GLkIudWludDguYnVmZmVyKTtcclxuRnJvbUVNRi5CLnVpbnQzMiA9IG5ldyBVaW50MzJBcnJheShGcm9tRU1GLkIudWludDguYnVmZmVyKTtcclxuRnJvbUVNRi5CLmZsb3QzMiA9IG5ldyBGbG9hdDMyQXJyYXkoRnJvbUVNRi5CLnVpbnQ4LmJ1ZmZlcik7XHJcblxyXG5cclxuRnJvbUVNRi5DID0ge1xyXG4gICAgRU1SX0hFQURFUiA6IDB4MDAwMDAwMDEsXHJcbiAgICBFTVJfUE9MWUJFWklFUiA6IDB4MDAwMDAwMDIsXHJcbiAgICBFTVJfUE9MWUdPTiA6IDB4MDAwMDAwMDMsXHJcbiAgICBFTVJfUE9MWUxJTkUgOiAweDAwMDAwMDA0LFxyXG4gICAgRU1SX1BPTFlCRVpJRVJUTyA6IDB4MDAwMDAwMDUsXHJcbiAgICBFTVJfUE9MWUxJTkVUTyA6IDB4MDAwMDAwMDYsXHJcbiAgICBFTVJfUE9MWVBPTFlMSU5FIDogMHgwMDAwMDAwNyxcclxuICAgIEVNUl9QT0xZUE9MWUdPTiA6IDB4MDAwMDAwMDgsXHJcbiAgICBFTVJfU0VUV0lORE9XRVhURVggOiAweDAwMDAwMDA5LFxyXG4gICAgRU1SX1NFVFdJTkRPV09SR0VYIDogMHgwMDAwMDAwQSxcclxuICAgIEVNUl9TRVRWSUVXUE9SVEVYVEVYIDogMHgwMDAwMDAwQixcclxuICAgIEVNUl9TRVRWSUVXUE9SVE9SR0VYIDogMHgwMDAwMDAwQyxcclxuICAgIEVNUl9TRVRCUlVTSE9SR0VYIDogMHgwMDAwMDAwRCxcclxuICAgIEVNUl9FT0YgOiAweDAwMDAwMDBFLFxyXG4gICAgRU1SX1NFVFBJWEVMViA6IDB4MDAwMDAwMEYsXHJcbiAgICBFTVJfU0VUTUFQUEVSRkxBR1MgOiAweDAwMDAwMDEwLFxyXG4gICAgRU1SX1NFVE1BUE1PREUgOiAweDAwMDAwMDExLFxyXG4gICAgRU1SX1NFVEJLTU9ERSA6IDB4MDAwMDAwMTIsXHJcbiAgICBFTVJfU0VUUE9MWUZJTExNT0RFIDogMHgwMDAwMDAxMyxcclxuICAgIEVNUl9TRVRST1AyIDogMHgwMDAwMDAxNCxcclxuICAgIEVNUl9TRVRTVFJFVENIQkxUTU9ERSA6IDB4MDAwMDAwMTUsXHJcbiAgICBFTVJfU0VUVEVYVEFMSUdOIDogMHgwMDAwMDAxNixcclxuICAgIEVNUl9TRVRDT0xPUkFESlVTVE1FTlQgOiAweDAwMDAwMDE3LFxyXG4gICAgRU1SX1NFVFRFWFRDT0xPUiA6IDB4MDAwMDAwMTgsXHJcbiAgICBFTVJfU0VUQktDT0xPUiA6IDB4MDAwMDAwMTksXHJcbiAgICBFTVJfT0ZGU0VUQ0xJUFJHTiA6IDB4MDAwMDAwMUEsXHJcbiAgICBFTVJfTU9WRVRPRVggOiAweDAwMDAwMDFCLFxyXG4gICAgRU1SX1NFVE1FVEFSR04gOiAweDAwMDAwMDFDLFxyXG4gICAgRU1SX0VYQ0xVREVDTElQUkVDVCA6IDB4MDAwMDAwMUQsXHJcbiAgICBFTVJfSU5URVJTRUNUQ0xJUFJFQ1QgOiAweDAwMDAwMDFFLFxyXG4gICAgRU1SX1NDQUxFVklFV1BPUlRFWFRFWCA6IDB4MDAwMDAwMUYsXHJcbiAgICBFTVJfU0NBTEVXSU5ET1dFWFRFWCA6IDB4MDAwMDAwMjAsXHJcbiAgICBFTVJfU0FWRURDIDogMHgwMDAwMDAyMSxcclxuICAgIEVNUl9SRVNUT1JFREMgOiAweDAwMDAwMDIyLFxyXG4gICAgRU1SX1NFVFdPUkxEVFJBTlNGT1JNIDogMHgwMDAwMDAyMyxcclxuICAgIEVNUl9NT0RJRllXT1JMRFRSQU5TRk9STSA6IDB4MDAwMDAwMjQsXHJcbiAgICBFTVJfU0VMRUNUT0JKRUNUIDogMHgwMDAwMDAyNSxcclxuICAgIEVNUl9DUkVBVEVQRU4gOiAweDAwMDAwMDI2LFxyXG4gICAgRU1SX0NSRUFURUJSVVNISU5ESVJFQ1QgOiAweDAwMDAwMDI3LFxyXG4gICAgRU1SX0RFTEVURU9CSkVDVCA6IDB4MDAwMDAwMjgsXHJcbiAgICBFTVJfQU5HTEVBUkMgOiAweDAwMDAwMDI5LFxyXG4gICAgRU1SX0VMTElQU0UgOiAweDAwMDAwMDJBLFxyXG4gICAgRU1SX1JFQ1RBTkdMRSA6IDB4MDAwMDAwMkIsXHJcbiAgICBFTVJfUk9VTkRSRUNUIDogMHgwMDAwMDAyQyxcclxuICAgIEVNUl9BUkMgOiAweDAwMDAwMDJELFxyXG4gICAgRU1SX0NIT1JEIDogMHgwMDAwMDAyRSxcclxuICAgIEVNUl9QSUUgOiAweDAwMDAwMDJGLFxyXG4gICAgRU1SX1NFTEVDVFBBTEVUVEUgOiAweDAwMDAwMDMwLFxyXG4gICAgRU1SX0NSRUFURVBBTEVUVEUgOiAweDAwMDAwMDMxLFxyXG4gICAgRU1SX1NFVFBBTEVUVEVFTlRSSUVTIDogMHgwMDAwMDAzMixcclxuICAgIEVNUl9SRVNJWkVQQUxFVFRFIDogMHgwMDAwMDAzMyxcclxuICAgIEVNUl9SRUFMSVpFUEFMRVRURSA6IDB4MDAwMDAwMzQsXHJcbiAgICBFTVJfRVhURkxPT0RGSUxMIDogMHgwMDAwMDAzNSxcclxuICAgIEVNUl9MSU5FVE8gOiAweDAwMDAwMDM2LFxyXG4gICAgRU1SX0FSQ1RPIDogMHgwMDAwMDAzNyxcclxuICAgIEVNUl9QT0xZRFJBVyA6IDB4MDAwMDAwMzgsXHJcbiAgICBFTVJfU0VUQVJDRElSRUNUSU9OIDogMHgwMDAwMDAzOSxcclxuICAgIEVNUl9TRVRNSVRFUkxJTUlUIDogMHgwMDAwMDAzQSxcclxuICAgIEVNUl9CRUdJTlBBVEggOiAweDAwMDAwMDNCLFxyXG4gICAgRU1SX0VORFBBVEggOiAweDAwMDAwMDNDLFxyXG4gICAgRU1SX0NMT1NFRklHVVJFIDogMHgwMDAwMDAzRCxcclxuICAgIEVNUl9GSUxMUEFUSCA6IDB4MDAwMDAwM0UsXHJcbiAgICBFTVJfU1RST0tFQU5ERklMTFBBVEggOiAweDAwMDAwMDNGLFxyXG4gICAgRU1SX1NUUk9LRVBBVEggOiAweDAwMDAwMDQwLFxyXG4gICAgRU1SX0ZMQVRURU5QQVRIIDogMHgwMDAwMDA0MSxcclxuICAgIEVNUl9XSURFTlBBVEggOiAweDAwMDAwMDQyLFxyXG4gICAgRU1SX1NFTEVDVENMSVBQQVRIIDogMHgwMDAwMDA0MyxcclxuICAgIEVNUl9BQk9SVFBBVEggOiAweDAwMDAwMDQ0LFxyXG4gICAgRU1SX0NPTU1FTlQgOiAweDAwMDAwMDQ2LFxyXG4gICAgRU1SX0ZJTExSR04gOiAweDAwMDAwMDQ3LFxyXG4gICAgRU1SX0ZSQU1FUkdOIDogMHgwMDAwMDA0OCxcclxuICAgIEVNUl9JTlZFUlRSR04gOiAweDAwMDAwMDQ5LFxyXG4gICAgRU1SX1BBSU5UUkdOIDogMHgwMDAwMDA0QSxcclxuICAgIEVNUl9FWFRTRUxFQ1RDTElQUkdOIDogMHgwMDAwMDA0QixcclxuICAgIEVNUl9CSVRCTFQgOiAweDAwMDAwMDRDLFxyXG4gICAgRU1SX1NUUkVUQ0hCTFQgOiAweDAwMDAwMDRELFxyXG4gICAgRU1SX01BU0tCTFQgOiAweDAwMDAwMDRFLFxyXG4gICAgRU1SX1BMR0JMVCA6IDB4MDAwMDAwNEYsXHJcbiAgICBFTVJfU0VURElCSVRTVE9ERVZJQ0UgOiAweDAwMDAwMDUwLFxyXG4gICAgRU1SX1NUUkVUQ0hESUJJVFMgOiAweDAwMDAwMDUxLFxyXG4gICAgRU1SX0VYVENSRUFURUZPTlRJTkRJUkVDVFcgOiAweDAwMDAwMDUyLFxyXG4gICAgRU1SX0VYVFRFWFRPVVRBIDogMHgwMDAwMDA1MyxcclxuICAgIEVNUl9FWFRURVhUT1VUVyA6IDB4MDAwMDAwNTQsXHJcbiAgICBFTVJfUE9MWUJFWklFUjE2IDogMHgwMDAwMDA1NSxcclxuICAgIEVNUl9QT0xZR09OMTYgOiAweDAwMDAwMDU2LFxyXG4gICAgRU1SX1BPTFlMSU5FMTYgOiAweDAwMDAwMDU3LFxyXG4gICAgRU1SX1BPTFlCRVpJRVJUTzE2IDogMHgwMDAwMDA1OCxcclxuICAgIEVNUl9QT0xZTElORVRPMTYgOiAweDAwMDAwMDU5LFxyXG4gICAgRU1SX1BPTFlQT0xZTElORTE2IDogMHgwMDAwMDA1QSxcclxuICAgIEVNUl9QT0xZUE9MWUdPTjE2IDogMHgwMDAwMDA1QixcclxuICAgIEVNUl9QT0xZRFJBVzE2IDogMHgwMDAwMDA1QyxcclxuICAgIEVNUl9DUkVBVEVNT05PQlJVU0ggOiAweDAwMDAwMDVELFxyXG4gICAgRU1SX0NSRUFURURJQlBBVFRFUk5CUlVTSFBUIDogMHgwMDAwMDA1RSxcclxuICAgIEVNUl9FWFRDUkVBVEVQRU4gOiAweDAwMDAwMDVGLFxyXG4gICAgRU1SX1BPTFlURVhUT1VUQSA6IDB4MDAwMDAwNjAsXHJcbiAgICBFTVJfUE9MWVRFWFRPVVRXIDogMHgwMDAwMDA2MSxcclxuICAgIEVNUl9TRVRJQ01NT0RFIDogMHgwMDAwMDA2MixcclxuICAgIEVNUl9DUkVBVEVDT0xPUlNQQUNFIDogMHgwMDAwMDA2MyxcclxuICAgIEVNUl9TRVRDT0xPUlNQQUNFIDogMHgwMDAwMDA2NCxcclxuICAgIEVNUl9ERUxFVEVDT0xPUlNQQUNFIDogMHgwMDAwMDA2NSxcclxuICAgIEVNUl9HTFNSRUNPUkQgOiAweDAwMDAwMDY2LFxyXG4gICAgRU1SX0dMU0JPVU5ERURSRUNPUkQgOiAweDAwMDAwMDY3LFxyXG4gICAgRU1SX1BJWEVMRk9STUFUIDogMHgwMDAwMDA2OCxcclxuICAgIEVNUl9EUkFXRVNDQVBFIDogMHgwMDAwMDA2OSxcclxuICAgIEVNUl9FWFRFU0NBUEUgOiAweDAwMDAwMDZBLFxyXG4gICAgRU1SX1NNQUxMVEVYVE9VVCA6IDB4MDAwMDAwNkMsXHJcbiAgICBFTVJfRk9SQ0VVRklNQVBQSU5HIDogMHgwMDAwMDA2RCxcclxuICAgIEVNUl9OQU1FREVTQ0FQRSA6IDB4MDAwMDAwNkUsXHJcbiAgICBFTVJfQ09MT1JDT1JSRUNUUEFMRVRURSA6IDB4MDAwMDAwNkYsXHJcbiAgICBFTVJfU0VUSUNNUFJPRklMRUEgOiAweDAwMDAwMDcwLFxyXG4gICAgRU1SX1NFVElDTVBST0ZJTEVXIDogMHgwMDAwMDA3MSxcclxuICAgIEVNUl9BTFBIQUJMRU5EIDogMHgwMDAwMDA3MixcclxuICAgIEVNUl9TRVRMQVlPVVQgOiAweDAwMDAwMDczLFxyXG4gICAgRU1SX1RSQU5TUEFSRU5UQkxUIDogMHgwMDAwMDA3NCxcclxuICAgIEVNUl9HUkFESUVOVEZJTEwgOiAweDAwMDAwMDc2LFxyXG4gICAgRU1SX1NFVExJTktFRFVGSVMgOiAweDAwMDAwMDc3LFxyXG4gICAgRU1SX1NFVFRFWFRKVVNUSUZJQ0FUSU9OIDogMHgwMDAwMDA3OCxcclxuICAgIEVNUl9DT0xPUk1BVENIVE9UQVJHRVRXIDogMHgwMDAwMDA3OSxcclxuICAgIEVNUl9DUkVBVEVDT0xPUlNQQUNFVyA6IDB4MDAwMDAwN0FcclxufTtcclxuRnJvbUVNRi5LID0gW107XHJcblxyXG4vLyAoZnVuY3Rpb24oKSB7XHJcbi8vICAgICB2YXIgaW5wLCBvdXQsIHN0dDtcclxuLy8gICAgIGlucCA9IEZyb21FTUYuQzsgICBvdXQgPSBGcm9tRU1GLks7ICAgc3R0PTQ7XHJcbi8vICAgICBmb3IodmFyIHAgaW4gaW5wKSBvdXRbaW5wW3BdXSA9IHAuc2xpY2Uoc3R0KTtcclxuLy8gfSAgKSgpO1xyXG5cclxuXHJcblxyXG5leHBvcnQgbGV0IFRvQ29udGV4dDJEOmFueSA9IGZ1bmN0aW9uIChuZWVkUGFnZTphbnksIHNjYWxlOmFueSlcclxue1xyXG4gICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xyXG4gICAgdGhpcy5jdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XHJcbiAgICB0aGlzLmJiID0gbnVsbDtcclxuICAgIHRoaXMuY3VyclBhZ2UgPSAwO1xyXG4gICAgdGhpcy5uZWVkUGFnZSA9IG5lZWRQYWdlO1xyXG4gICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xyXG59XHJcblRvQ29udGV4dDJELnByb3RvdHlwZS5TdGFydFBhZ2UgPSBmdW5jdGlvbih4OmFueSx5OmFueSx3OmFueSxoOmFueSkge1xyXG4gICAgaWYodGhpcy5jdXJyUGFnZSE9dGhpcy5uZWVkUGFnZSkgcmV0dXJuO1xyXG4gICAgdGhpcy5iYiA9IFt4LHksdyxoXTtcclxuICAgIHZhciBzY2wgPSB0aGlzLnNjYWxlLCBkcHIgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcclxuICAgIHZhciBjbnYgPSB0aGlzLmNhbnZhcywgY3R4ID0gdGhpcy5jdHg7XHJcbiAgICBjbnYud2lkdGggPSBNYXRoLnJvdW5kKHcqc2NsKTsgIGNudi5oZWlnaHQgPSBNYXRoLnJvdW5kKGgqc2NsKTtcclxuICAgIGN0eC50cmFuc2xhdGUoMCxoKnNjbCk7ICBjdHguc2NhbGUoc2NsLC1zY2wpO1xyXG4gICAgY252LnNldEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiYm9yZGVyOjFweCBzb2xpZDsgd2lkdGg6XCIrKGNudi53aWR0aC9kcHIpK1wicHg7IGhlaWdodDpcIisoY252LmhlaWdodC9kcHIpK1wicHhcIik7XHJcbn1cclxuVG9Db250ZXh0MkQucHJvdG90eXBlLkZpbGwgPSBmdW5jdGlvbihnc3Q6YW55LCBldmVuT2RkOmFueSkge1xyXG4gICAgaWYodGhpcy5jdXJyUGFnZSE9dGhpcy5uZWVkUGFnZSkgcmV0dXJuO1xyXG4gICAgdmFyIGN0eCA9IHRoaXMuY3R4O1xyXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgdGhpcy5fc2V0U3R5bGUoZ3N0LCBjdHgpO1xyXG4gICAgdGhpcy5fZHJhdyhnc3QucHRoLCBjdHgpO1xyXG4gICAgY3R4LmZpbGwoKTtcclxufVxyXG5Ub0NvbnRleHQyRC5wcm90b3R5cGUuU3Ryb2tlID0gZnVuY3Rpb24oZ3N0OmFueSkge1xyXG4gICAgaWYodGhpcy5jdXJyUGFnZSE9dGhpcy5uZWVkUGFnZSkgcmV0dXJuO1xyXG4gICAgdmFyIGN0eCA9IHRoaXMuY3R4O1xyXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgdGhpcy5fc2V0U3R5bGUoZ3N0LCBjdHgpO1xyXG4gICAgdGhpcy5fZHJhdyhnc3QucHRoLCBjdHgpO1xyXG4gICAgY3R4LnN0cm9rZSgpO1xyXG59XHJcblRvQ29udGV4dDJELnByb3RvdHlwZS5QdXRUZXh0ID0gZnVuY3Rpb24oZ3N0OmFueSwgc3RyOmFueSwgc3R3OmFueSkge1xyXG4gICAgaWYodGhpcy5jdXJyUGFnZSE9dGhpcy5uZWVkUGFnZSkgcmV0dXJuO1xyXG4gICAgdmFyIHNjbCA9IHRoaXMuX3NjYWxlKGdzdC5jdG0pO1xyXG4gICAgdmFyIGN0eCA9IHRoaXMuY3R4O1xyXG4gICAgdGhpcy5fc2V0U3R5bGUoZ3N0LCBjdHgpO1xyXG4gICAgY3R4LnNhdmUoKTtcclxuICAgIHZhciBtID0gWzEsMCwwLC0xLDAsMF07ICB0aGlzLl9jb25jYXQobSwgZ3N0LmZvbnQuVG0pOyAgdGhpcy5fY29uY2F0KG0sIGdzdC5jdG0pO1xyXG4gICAgLy9jb25zb2xlLmxvZyhzdHIsIG0sIGdzdCk7ICB0aHJvdyBcImVcIjtcclxuICAgIGN0eC50cmFuc2Zvcm0obVswXSxtWzFdLG1bMl0sbVszXSxtWzRdLG1bNV0pO1xyXG4gICAgY3R4LmZpbGxUZXh0KHN0ciwwLDApO1xyXG4gICAgY3R4LnJlc3RvcmUoKTtcclxufVxyXG5Ub0NvbnRleHQyRC5wcm90b3R5cGUuUHV0SW1hZ2UgPSBmdW5jdGlvbihnc3Q6YW55LCBidWZmOmFueSwgdzphbnksIGg6YW55LCBtc2s6YW55KSB7XHJcbiAgICBpZih0aGlzLmN1cnJQYWdlIT10aGlzLm5lZWRQYWdlKSByZXR1cm47XHJcbiAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XHJcbiAgICBcclxuICAgIGlmKGJ1ZmYubGVuZ3RoPT13KmgqNCkge1xyXG4gICAgICAgIGJ1ZmYgPSBidWZmLnNsaWNlKDApO1xyXG4gICAgICAgIGlmKG1zayAmJiBtc2subGVuZ3RoPT13KmgqNCkgZm9yKHZhciBpPTA7IGk8YnVmZi5sZW5ndGg7IGkrPTQpIGJ1ZmZbaSszXSA9IG1za1tpKzFdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHZhciBjbnYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLCBjY3R4ID0gY252LmdldENvbnRleHQoXCIyZFwiKTtcclxuICAgICAgICBjbnYud2lkdGggPSB3OyAgY252LmhlaWdodCA9IGg7XHJcbiAgICAgICAgdmFyIGltZ2QgPSBjY3R4LmNyZWF0ZUltYWdlRGF0YSh3LGgpO1xyXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPGJ1ZmYubGVuZ3RoOyBpKyspIGltZ2QuZGF0YVtpXT1idWZmW2ldO1xyXG4gICAgICAgIGNjdHgucHV0SW1hZ2VEYXRhKGltZ2QsMCwwKTtcclxuICAgICAgICBcclxuICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgIHZhciBtID0gWzEsMCwwLDEsMCwwXTsgIHRoaXMuX2NvbmNhdChtLCBbMS93LDAsMCwtMS9oLDAsMV0pOyAgdGhpcy5fY29uY2F0KG0sIGdzdC5jdG0pO1xyXG4gICAgICAgIGN0eC50cmFuc2Zvcm0obVswXSxtWzFdLG1bMl0sbVszXSxtWzRdLG1bNV0pO1xyXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoY252LDAsMCk7XHJcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgIH1cclxufVxyXG5Ub0NvbnRleHQyRC5wcm90b3R5cGUuU2hvd1BhZ2UgPSBmdW5jdGlvbigpIHsgIHRoaXMuY3VyclBhZ2UrKzsgIH1cclxuVG9Db250ZXh0MkQucHJvdG90eXBlLkRvbmUgPSBmdW5jdGlvbigpIHt9XHJcblxyXG5cclxuZnVuY3Rpb24gX2ZsdChuOmFueSkgIHsgIHJldHVybiBcIlwiK3BhcnNlRmxvYXQobi50b0ZpeGVkKDIpKTsgIH1cclxuXHJcblRvQ29udGV4dDJELnByb3RvdHlwZS5fc2V0U3R5bGUgPSBmdW5jdGlvbihnc3Q6YW55LCBjdHg6YW55KSB7XHJcbiAgICB2YXIgc2NsID0gdGhpcy5fc2NhbGUoZ3N0LmN0bSk7XHJcbiAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5fZ2V0RmlsbChnc3QuY29sciwgZ3N0LmNhLCBjdHgpO1xyXG4gICAgY3R4LnN0cm9rZVN0eWxlPXRoaXMuX2dldEZpbGwoZ3N0LkNPTFIsIGdzdC5DQSwgY3R4KTtcclxuICAgIFxyXG4gICAgY3R4LmxpbmVDYXAgPSBbXCJidXR0XCIsXCJyb3VuZFwiLFwic3F1YXJlXCJdW2dzdC5sY2FwXTtcclxuICAgIGN0eC5saW5lSm9pbj0gW1wibWl0ZXJcIixcInJvdW5kXCIsXCJiZXZlbFwiXVtnc3QubGpvaW5dO1xyXG4gICAgY3R4LmxpbmVXaWR0aD1nc3QubHdpZHRoKnNjbDtcclxuICAgIHZhciBkc2ggPSBnc3QuZGFzaC5zbGljZSgwKTsgIGZvcih2YXIgaT0wOyBpPGRzaC5sZW5ndGg7IGkrKykgZHNoW2ldID0gX2ZsdChkc2hbaV0qc2NsKTtcclxuICAgIGN0eC5zZXRMaW5lRGFzaChkc2gpOyBcclxuICAgIGN0eC5taXRlckxpbWl0ID0gZ3N0Lm1saW1pdCpzY2w7XHJcbiAgICBcclxuICAgIHZhciBmbiA9IGdzdC5mb250LlRmLCBsbiA9IGZuLnRvTG93ZXJDYXNlKCk7XHJcbiAgICB2YXIgcDAgPSBsbi5pbmRleE9mKFwiYm9sZFwiKSE9LTEgPyBcImJvbGQgXCIgOiBcIlwiO1xyXG4gICAgdmFyIHAxID0gKGxuLmluZGV4T2YoXCJpdGFsaWNcIikhPS0xIHx8IGxuLmluZGV4T2YoXCJvYmxpcXVlXCIpIT0tMSkgPyBcIml0YWxpYyBcIiA6IFwiXCI7XHJcbiAgICBjdHguZm9udCA9IHAwK3AxICsgZ3N0LmZvbnQuVGZzK1wicHggXFxcIlwiK2ZuK1wiXFxcIlwiO1xyXG59XHJcblRvQ29udGV4dDJELnByb3RvdHlwZS5fZ2V0RmlsbCA9IGZ1bmN0aW9uKGNvbHI6YW55LCBjYTphbnksIGN0eDphbnkpXHJcbntcclxuICAgIGlmKGNvbHIudHlwPT1udWxsKSByZXR1cm4gdGhpcy5fY29scihjb2xyLGNhKTtcclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBncmQgPSBjb2xyLCBjcmQgPSBncmQuY3JkcywgbWF0ID0gZ3JkLm1hdCwgc2NsPXRoaXMuX3NjYWxlKG1hdCksIGdmO1xyXG4gICAgICAgIGlmICAgICAoZ3JkLnR5cD09XCJsaW5cIikge1xyXG4gICAgICAgICAgICB2YXIgcDAgPSB0aGlzLl9tdWx0UG9pbnQobWF0LGNyZC5zbGljZSgwLDIpKSwgcDEgPSB0aGlzLl9tdWx0UG9pbnQobWF0LGNyZC5zbGljZSgyKSk7XHJcbiAgICAgICAgICAgIGdmPWN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudChwMFswXSxwMFsxXSxwMVswXSxwMVsxXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYoZ3JkLnR5cD09XCJyYWRcIikge1xyXG4gICAgICAgICAgICB2YXIgcDAgPSB0aGlzLl9tdWx0UG9pbnQobWF0LGNyZC5zbGljZSgwLDIpKSwgcDEgPSB0aGlzLl9tdWx0UG9pbnQobWF0LGNyZC5zbGljZSgzKSk7XHJcbiAgICAgICAgICAgIGdmPWN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudChwMFswXSxwMFsxXSxjcmRbMl0qc2NsLHAxWzBdLHAxWzFdLGNyZFs1XSpzY2wpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IodmFyIGk9MDsgaTxncmQuZ3JhZC5sZW5ndGg7IGkrKykgIGdmLmFkZENvbG9yU3RvcChncmQuZ3JhZFtpXVswXSx0aGlzLl9jb2xyKGdyZC5ncmFkW2ldWzFdLCBjYSkpO1xyXG4gICAgICAgIHJldHVybiBnZjtcclxuICAgIH1cclxufVxyXG5Ub0NvbnRleHQyRC5wcm90b3R5cGUuX2NvbHIgID0gZnVuY3Rpb24oYzphbnksYTphbnkpIHsgIHJldHVybiBcInJnYmEoXCIrTWF0aC5yb3VuZChjWzBdKjI1NSkrXCIsXCIrTWF0aC5yb3VuZChjWzFdKjI1NSkrXCIsXCIrTWF0aC5yb3VuZChjWzJdKjI1NSkrXCIsXCIrYStcIilcIjsgIH07XHJcblRvQ29udGV4dDJELnByb3RvdHlwZS5fc2NhbGUgPSBmdW5jdGlvbihtOmFueSkgIHsgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5hYnMobVswXSptWzNdLW1bMV0qbVsyXSkpOyAgfTtcclxuVG9Db250ZXh0MkQucHJvdG90eXBlLl9jb25jYXQ9IGZ1bmN0aW9uKG06YW55LHc6YW55ICApIHsgIFxyXG4gICAgICAgIHZhciBhPW1bMF0sYj1tWzFdLGM9bVsyXSxkPW1bM10sdHg9bVs0XSx0eT1tWzVdO1xyXG4gICAgICAgIG1bMF0gPSAoYSAqd1swXSkrKGIgKndbMl0pOyAgICAgICBtWzFdID0gKGEgKndbMV0pKyhiICp3WzNdKTtcclxuICAgICAgICBtWzJdID0gKGMgKndbMF0pKyhkICp3WzJdKTsgICAgICAgbVszXSA9IChjICp3WzFdKSsoZCAqd1szXSk7XHJcbiAgICAgICAgbVs0XSA9ICh0eCp3WzBdKSsodHkqd1syXSkrd1s0XTsgIG1bNV0gPSAodHgqd1sxXSkrKHR5KndbM10pK3dbNV07IFxyXG59XHJcblRvQ29udGV4dDJELnByb3RvdHlwZS5fbXVsdFBvaW50PSBmdW5jdGlvbihtOmFueSwgcDphbnkpIHsgIHZhciB4PXBbMF0seT1wWzFdOyAgcmV0dXJuIFt4Km1bMF0reSptWzJdK21bNF0sICAgeCptWzFdK3kqbVszXSttWzVdXTsgIH0sXHJcblRvQ29udGV4dDJELnByb3RvdHlwZS5fZHJhdyAgPSBmdW5jdGlvbihwYXRoOmFueSwgY3R4OmFueSlcclxue1xyXG4gICAgdmFyIGMgPSAwLCBjcmRzID0gcGF0aC5jcmRzO1xyXG4gICAgZm9yKHZhciBqPTA7IGo8cGF0aC5jbWRzLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgdmFyIGNtZCA9IHBhdGguY21kc1tqXTtcclxuICAgICAgICBpZiAgICAgKGNtZD09XCJNXCIpIHsgIGN0eC5tb3ZlVG8oY3Jkc1tjXSwgY3Jkc1tjKzFdKTsgIGMrPTI7ICB9XHJcbiAgICAgICAgZWxzZSBpZihjbWQ9PVwiTFwiKSB7ICBjdHgubGluZVRvKGNyZHNbY10sIGNyZHNbYysxXSk7ICBjKz0yOyAgfVxyXG4gICAgICAgIGVsc2UgaWYoY21kPT1cIkNcIikgeyAgY3R4LmJlemllckN1cnZlVG8oY3Jkc1tjXSwgY3Jkc1tjKzFdLCBjcmRzW2MrMl0sIGNyZHNbYyszXSwgY3Jkc1tjKzRdLCBjcmRzW2MrNV0pOyAgYys9NjsgIH1cclxuICAgICAgICBlbHNlIGlmKGNtZD09XCJRXCIpIHsgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKGNyZHNbY10sIGNyZHNbYysxXSwgY3Jkc1tjKzJdLCBjcmRzW2MrM10pOyAgYys9NDsgIH1cclxuICAgICAgICBlbHNlIGlmKGNtZD09XCJaXCIpIHsgIGN0eC5jbG9zZVBhdGgoKTsgIH1cclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBjb2x1bWVIZWFkZXJfd29yZCwgY29sdW1lSGVhZGVyX3dvcmRfaW5kZXggfSBmcm9tIFwiLi9jb25zdGFudFwiO1xyXG5pbXBvcnQgeyBJbHVja3lTaGVldFNlbGVjdGlvbiB9IGZyb20gXCIuLi9Ub0x1Y2t5U2hlZXQvSUx1Y2tcIjtcclxuaW1wb3J0IHsgSWF0dHJpYnV0ZUxpc3QsIHN0cmluZ1RvTnVtfSBmcm9tIFwiLi4vSUNvbW1vblwiO1xyXG5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRSYW5nZXR4dChyYW5nZTpJbHVja3lTaGVldFNlbGVjdGlvbiwgc2hlZXR0eHQ6c3RyaW5nKSB7XHJcblxyXG4gICAgbGV0IHJvdzAgPSByYW5nZVtcInJvd1wiXVswXSwgcm93MSA9IHJhbmdlW1wicm93XCJdWzFdO1xyXG4gICAgbGV0IGNvbHVtbjAgPSByYW5nZVtcImNvbHVtblwiXVswXSwgY29sdW1uMSA9IHJhbmdlW1wiY29sdW1uXCJdWzFdO1xyXG5cclxuICAgIGlmIChyb3cwID09IG51bGwgJiYgcm93MSA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHNoZWV0dHh0ICsgY2hhdGF0QUJDKGNvbHVtbjApICsgXCI6XCIgKyBjaGF0YXRBQkMoY29sdW1uMSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChjb2x1bW4wID09IG51bGwgJiYgY29sdW1uMSA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHNoZWV0dHh0ICsgKHJvdzAgKyAxKSArIFwiOlwiICsgKHJvdzEgKyAxKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChjb2x1bW4wID09IGNvbHVtbjEgJiYgcm93MCA9PSByb3cxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzaGVldHR4dCArIGNoYXRhdEFCQyhjb2x1bW4wKSArIChyb3cwICsgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gc2hlZXR0eHQgKyBjaGF0YXRBQkMoY29sdW1uMCkgKyAocm93MCArIDEpICsgXCI6XCIgKyBjaGF0YXRBQkMoY29sdW1uMSkgKyAocm93MSArIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRjZWxscmFuZ2UgKHR4dDpzdHJpbmcsIHNoZWV0czpJYXR0cmlidXRlTGlzdD17fSwgc2hlZXRJZDpzdHJpbmc9XCIxXCIpIHtcclxuICAgIGxldCB2YWwgPSB0eHQuc3BsaXQoXCIhXCIpO1xyXG5cclxuICAgIGxldCBzaGVldHR4dCA9IFwiXCIsXHJcbiAgICAgICAgcmFuZ2V0eHQgPSBcIlwiLFxyXG4gICAgICAgIHNoZWV0SW5kZXggPSAtMTtcclxuXHJcbiAgICBpZiAodmFsLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICBzaGVldHR4dCA9IHZhbFswXTtcclxuICAgICAgICByYW5nZXR4dCA9IHZhbFsxXTtcclxuICAgICAgICBcclxuICAgICAgICBsZXQgc2kgPSBzaGVldHNbc2hlZXR0eHRdO1xyXG4gICAgICAgIGlmKHNpPT1udWxsKXtcclxuICAgICAgICAgICAgc2hlZXRJbmRleCA9IHBhcnNlSW50KHNoZWV0SWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICBzaGVldEluZGV4ID0gcGFyc2VJbnQoc2kpO1xyXG4gICAgICAgIH1cclxuICAgIH0gXHJcbiAgICBlbHNlIHtcclxuICAgICAgICBzaGVldEluZGV4ID0gcGFyc2VJbnQoc2hlZXRJZCk7XHJcbiAgICAgICAgcmFuZ2V0eHQgPSB2YWxbMF07XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmIChyYW5nZXR4dC5pbmRleE9mKFwiOlwiKSA9PSAtMSkge1xyXG4gICAgICAgIGxldCByb3cgPSBwYXJzZUludChyYW5nZXR4dC5yZXBsYWNlKC9bXjAtOV0vZywgXCJcIikpIC0gMTtcclxuICAgICAgICBsZXQgY29sID0gQUJDYXROdW0ocmFuZ2V0eHQucmVwbGFjZSgvW15BLVphLXpdL2csIFwiXCIpKTtcclxuXHJcbiAgICAgICAgaWYgKCFpc05hTihyb3cpICYmICFpc05hTihjb2wpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBcInJvd1wiOiBbcm93LCByb3ddLFxyXG4gICAgICAgICAgICAgICAgXCJjb2x1bW5cIjogW2NvbCwgY29sXSxcclxuICAgICAgICAgICAgICAgIFwic2hlZXRJbmRleFwiOiBzaGVldEluZGV4XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9IFxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbGV0IHJhbmdldHh0QXJyYXk6c3RyaW5nW10gPSByYW5nZXR4dC5zcGxpdChcIjpcIik7XHJcbiAgICAgICAgbGV0IHJvdyA9IFtdLGNvbCA9IFtdO1xyXG4gICAgICAgIHJvd1swXSA9IHBhcnNlSW50KHJhbmdldHh0QXJyYXlbMF0ucmVwbGFjZSgvW14wLTldL2csIFwiXCIpKSAtIDE7XHJcbiAgICAgICAgcm93WzFdID0gcGFyc2VJbnQocmFuZ2V0eHRBcnJheVsxXS5yZXBsYWNlKC9bXjAtOV0vZywgXCJcIikpIC0gMTtcclxuICAgICAgICAvLyBpZiAoaXNOYU4ocm93WzBdKSkge1xyXG4gICAgICAgIC8vICAgICByb3dbMF0gPSAwO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICAvLyBpZiAoaXNOYU4ocm93WzFdKSkge1xyXG4gICAgICAgIC8vICAgICByb3dbMV0gPSBzaGVldGRhdGEubGVuZ3RoIC0gMTtcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgaWYgKHJvd1swXSA+IHJvd1sxXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29sWzBdID0gQUJDYXROdW0ocmFuZ2V0eHRBcnJheVswXS5yZXBsYWNlKC9bXkEtWmEtel0vZywgXCJcIikpO1xyXG4gICAgICAgIGNvbFsxXSA9IEFCQ2F0TnVtKHJhbmdldHh0QXJyYXlbMV0ucmVwbGFjZSgvW15BLVphLXpdL2csIFwiXCIpKTtcclxuICAgICAgICAvLyBpZiAoaXNOYU4oY29sWzBdKSkge1xyXG4gICAgICAgIC8vICAgICBjb2xbMF0gPSAwO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICAvLyBpZiAoaXNOYU4oY29sWzFdKSkge1xyXG4gICAgICAgIC8vICAgICBjb2xbMV0gPSBzaGVldGRhdGFbMF0ubGVuZ3RoIC0gMTtcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgaWYgKGNvbFswXSA+IGNvbFsxXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIFwicm93XCI6IHJvdyxcclxuICAgICAgICAgICAgXCJjb2x1bW5cIjogY29sLFxyXG4gICAgICAgICAgICBcInNoZWV0SW5kZXhcIjogc2hlZXRJbmRleFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbi8v5YiX5LiL5qCHICDlrZfmr43ovazmlbDlrZdcclxuZnVuY3Rpb24gQUJDYXROdW0oYWJjOnN0cmluZykge1xyXG4gICAgYWJjID0gYWJjLnRvVXBwZXJDYXNlKCk7XHJcblxyXG4gICAgbGV0IGFiY19sZW4gPSBhYmMubGVuZ3RoO1xyXG4gICAgaWYgKGFiY19sZW4gPT0gMCkge1xyXG4gICAgICAgIHJldHVybiBOYU47XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGFiY19hcnJheSA9IGFiYy5zcGxpdChcIlwiKTtcclxuICAgIGxldCB3b3JkbGVuID0gY29sdW1lSGVhZGVyX3dvcmQubGVuZ3RoO1xyXG4gICAgbGV0IHJldCA9IDA7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IGFiY19sZW4gLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgIGlmIChpID09IGFiY19sZW4gLSAxKSB7XHJcbiAgICAgICAgICAgIHJldCArPSBjb2x1bWVIZWFkZXJfd29yZF9pbmRleFthYmNfYXJyYXlbaV1dO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0ICs9IE1hdGgucG93KHdvcmRsZW4sIGFiY19sZW4gLSBpIC0gMSkgKiAoY29sdW1lSGVhZGVyX3dvcmRfaW5kZXhbYWJjX2FycmF5W2ldXSArIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmV0O1xyXG59XHJcblxyXG4vL+WIl+S4i+aghyAg5pWw5a2X6L2s5a2X5q+NXHJcbmZ1bmN0aW9uIGNoYXRhdEFCQyhpbmRleDpudW1iZXIpIHtcclxuICAgIGxldCB3b3JkbGVuID0gY29sdW1lSGVhZGVyX3dvcmQubGVuZ3RoO1xyXG5cclxuICAgIGlmIChpbmRleCA8IHdvcmRsZW4pIHtcclxuICAgICAgICByZXR1cm4gY29sdW1lSGVhZGVyX3dvcmRbaW5kZXhdO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbGV0IGxhc3QgPSAwLCBwcmUgPSAwLCByZXQgPSBcIlwiO1xyXG4gICAgICAgIGxldCBpID0gMSwgbiA9IDA7XHJcblxyXG4gICAgICAgIHdoaWxlIChpbmRleCA+PSAod29yZGxlbiAvICh3b3JkbGVuIC0gMSkpICogKE1hdGgucG93KHdvcmRsZW4sIGkrKykgLSAxKSkge1xyXG4gICAgICAgICAgICBuID0gaTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCBpbmRleF9hYiA9IGluZGV4IC0gKHdvcmRsZW4gLyAod29yZGxlbiAtIDEpKSAqIChNYXRoLnBvdyh3b3JkbGVuLCBuIC0gMSkgLSAxKTsvLzk3MFxyXG4gICAgICAgIGxhc3QgPSBpbmRleF9hYiArIDE7XHJcblxyXG4gICAgICAgIGZvciAobGV0IHggPSBuOyB4ID4gMDsgeC0tKSB7XHJcbiAgICAgICAgICAgIGxldCBsYXN0MSA9IGxhc3QsIHgxID0geDsvLy03MDI9MjY4LCAzXHJcblxyXG4gICAgICAgICAgICBpZiAoeCA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBsYXN0MSA9IGxhc3QxICUgd29yZGxlbjtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobGFzdDEgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3QxID0gMjY7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldCArIGNvbHVtZUhlYWRlcl93b3JkW2xhc3QxIC0gMV07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGxhc3QxID0gTWF0aC5jZWlsKGxhc3QxIC8gTWF0aC5wb3cod29yZGxlbiwgeCAtIDEpKTtcclxuICAgICAgICAgICAgLy9sYXN0MSA9IGxhc3QxICUgd29yZGxlbjtcclxuICAgICAgICAgICAgcmV0ICs9IGNvbHVtZUhlYWRlcl93b3JkW2xhc3QxIC0gMV07XHJcblxyXG4gICAgICAgICAgICBpZiAoeCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIGxhc3QgPSBsYXN0IC0gKGxhc3QxIC0gMSkgKiB3b3JkbGVuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG4vKiogXHJcbiAqIEByZXR1cm4gcmF0aW8sIGRlZmF1bHQgMC43NSAxaW4gPSAyLjU0Y20gPSAyNS40bW0gPSA3MnB0ID0gNnBjLCAgcHQgPSAxLzcyIEluLCBweCA9IDEvZHBpIEluXHJcbiovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRwdFRvUHhSYXRpb0J5RFBJKCk6bnVtYmVye1xyXG4gICAgcmV0dXJuIDcyLzk2O1xyXG59XHJcblxyXG4vKiogXHJcbiAqIEBlbXVzIEVNVXMsIEV4Y2VsIGRyYXdpbmcgdW5pdFxyXG4gKiBAcmV0dXJuIHBpeGVsXHJcbiovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRQeEJ5RU1VcyhlbXVzOm51bWJlcil7XHJcbiAgICBpZihlbXVzPT1udWxsKXtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIGxldCBpbmNoID0gZW11cy85MTQ0MDA7XHJcbiAgICBsZXQgcHQgPSBpbmNoKjcyO1xyXG4gICAgbGV0IHB4ID0gcHQgLyBnZXRwdFRvUHhSYXRpb0J5RFBJKCk7XHJcbiAgICByZXR1cm4gcHg7XHJcbn1cclxuXHJcbi8qKiBcclxuICogQGRvbSB4bWwgYXR0cmlidXRlIG9iamVjdFxyXG4gKiBAYXR0ciBhdHRyaWJ1dGUgbmFtZVxyXG4gKiBAZCBpZiBhdHRyaWJ1dGUgaXMgbnVsbCwgcmV0dXJuIGRlZmF1bHQgdmFsdWUgXHJcbiAqIEByZXR1cm4gYXR0cmlidXRlIHZhbHVlXHJcbiovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRYbWxBdHRpYnV0ZShkb206SWF0dHJpYnV0ZUxpc3QsIGF0dHI6c3RyaW5nLCBkOnN0cmluZyl7XHJcbiAgICBsZXQgdmFsdWUgPSBkb21bYXR0cl07XHJcbiAgICB2YWx1ZSA9IHZhbHVlPT1udWxsP2Q6dmFsdWU7XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cclxuXHJcbi8qKiBcclxuICogQGNvbHVtbldpZHRoIEV4Y2VsIGNvbHVtbiB3aWR0aFxyXG4gKiBAcmV0dXJuIHBpeGVsIGNvbHVtbiB3aWR0aFxyXG4qL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29sdW1uV2lkdGhQaXhlbChjb2x1bW5XaWR0aDpudW1iZXIpe1xyXG4gICAgbGV0IHBpeCA9IE1hdGgucm91bmQoKGNvbHVtbldpZHRoLTAuODMpICogOCArIDUpO1xyXG4gICAgcmV0dXJuIHBpeDtcclxufVxyXG5cclxuLyoqIFxyXG4gKiBAcm93SGVpZ2h0IEV4Y2VsIHJvdyBoZWlnaHRcclxuICogQHJldHVybiBwaXhlbCByb3cgaGVpZ2h0XHJcbiovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRSb3dIZWlnaHRQaXhlbChyb3dIZWlnaHQ6bnVtYmVyKXtcclxuICAgIGxldCBwaXggPSBNYXRoLnJvdW5kKHJvd0hlaWdodC9nZXRwdFRvUHhSYXRpb0J5RFBJKCkpO1xyXG4gICAgcmV0dXJuIHBpeDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIExpZ2h0ZW5EYXJrZW5Db2xvcihzaXhDb2xvcjpzdHJpbmcsIHRpbnQ6bnVtYmVyKXtcclxuICAgIGxldCBoZXg6c3RyaW5nID0gc2l4Q29sb3Iuc3Vic3RyaW5nKHNpeENvbG9yLmxlbmd0aC02LHNpeENvbG9yLmxlbmd0aCk7XHJcbiAgICBsZXQgcmdiQXJyYXk6bnVtYmVyW10gPSBoZXhUb1JnYkFycmF5KFwiI1wiK2hleCk7XHJcbiAgICBsZXQgaHNsQXJyYXkgPSByZ2JUb0hzbChyZ2JBcnJheVswXSwgcmdiQXJyYXlbMV0scmdiQXJyYXlbMl0pO1xyXG4gICAgaWYodGludD4wKXtcclxuICAgICAgICBoc2xBcnJheVsyXSA9IGhzbEFycmF5WzJdICogKDEuMC10aW50KSArIHRpbnQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmKHRpbnQ8MCl7XHJcbiAgICAgICAgaHNsQXJyYXlbMl0gPSBoc2xBcnJheVsyXSAqICgxLjAgKyB0aW50KVxyXG4gICAgfVxyXG4gICAgZWxzZXtcclxuICAgICAgICByZXR1cm4gXCIjXCIraGV4O1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBuZXdSZ2JBcnJheSA9IGhzbFRvUmdiKGhzbEFycmF5WzBdLGhzbEFycmF5WzFdLGhzbEFycmF5WzJdKTtcclxuXHJcbiAgICByZXR1cm4gcmdiVG9IZXgoXCJSR0IoXCIgKyBuZXdSZ2JBcnJheS5qb2luKFwiLFwiKSArIFwiKVwiKTtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIHJnYlRvSGV4KHJnYjpzdHJpbmcpe1xyXG4gICAgLy/ljYHlha3ov5vliLbpopzoibLlgLznmoTmraPliJnooajovr7lvI9cclxuICAgIHZhciByZWcgPSAvXiMoWzAtOWEtZkEtZl17M318WzAtOWEtZkEtZl17Nn0pJC87XHJcbiAgICAvLyDlpoLmnpzmmK9yZ2LpopzoibLooajnpLpcclxuICAgIGlmICgvXihyZ2J8UkdCKS8udGVzdChyZ2IpKSB7XHJcbiAgICAgICAgdmFyIGFDb2xvciA9IHJnYi5yZXBsYWNlKC8oPzpcXCh8XFwpfHJnYnxSR0IpKi9nLCBcIlwiKS5zcGxpdChcIixcIik7XHJcbiAgICAgICAgdmFyIHN0ckhleCA9IFwiI1wiO1xyXG4gICAgICAgIGZvciAodmFyIGk9MDsgaTxhQ29sb3IubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdmFyIGhleCA9IE51bWJlcihhQ29sb3JbaV0pLnRvU3RyaW5nKDE2KTtcclxuICAgICAgICAgICAgaWYgKGhleC5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgICAgICAgICBoZXggPSAnMCcgKyBoZXg7ICAgIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN0ckhleCArPSBoZXg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdHJIZXgubGVuZ3RoICE9PSA3KSB7XHJcbiAgICAgICAgICAgIHN0ckhleCA9IHJnYjsgICAgXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdHJIZXg7XHJcbiAgICB9IGVsc2UgaWYgKHJlZy50ZXN0KHJnYikpIHtcclxuICAgICAgICB2YXIgYU51bSA9IHJnYi5yZXBsYWNlKC8jLyxcIlwiKS5zcGxpdChcIlwiKTtcclxuICAgICAgICBpZiAoYU51bS5sZW5ndGggPT09IDYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJnYjsgICAgXHJcbiAgICAgICAgfSBlbHNlIGlmKGFOdW0ubGVuZ3RoID09PSAzKSB7XHJcbiAgICAgICAgICAgIHZhciBudW1IZXggPSBcIiNcIjtcclxuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPGFOdW0ubGVuZ3RoOyBpKz0xKSB7XHJcbiAgICAgICAgICAgICAgICBudW1IZXggKz0gKGFOdW1baV0gKyBhTnVtW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVtSGV4O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZ2I7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhleFRvUmdiKGhleDpzdHJpbmcpe1xyXG4gICAgdmFyIHNDb2xvciA9IGhleC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgLy/ljYHlha3ov5vliLbpopzoibLlgLznmoTmraPliJnooajovr7lvI9cclxuICAgIHZhciByZWcgPSAvXiMoWzAtOWEtZkEtZl17M318WzAtOWEtZkEtZl17Nn0pJC87XHJcbiAgICAvLyDlpoLmnpzmmK8xNui/m+WItuminOiJslxyXG4gICAgaWYgKHNDb2xvciAmJiByZWcudGVzdChzQ29sb3IpKSB7XHJcbiAgICAgICAgaWYgKHNDb2xvci5sZW5ndGggPT09IDQpIHtcclxuICAgICAgICAgICAgdmFyIHNDb2xvck5ldyA9IFwiI1wiO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpPTE7IGk8NDsgaSs9MSkge1xyXG4gICAgICAgICAgICAgICAgc0NvbG9yTmV3ICs9IHNDb2xvci5zbGljZShpLCBpKzEpLmNvbmNhdChzQ29sb3Iuc2xpY2UoaSwgaSsxKSk7ICAgIFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNDb2xvciA9IHNDb2xvck5ldztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy/lpITnkIblha3kvY3nmoTpopzoibLlgLxcclxuICAgICAgICB2YXIgc0NvbG9yQ2hhbmdlID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgaT0xOyBpPDc7IGkrPTIpIHtcclxuICAgICAgICAgICAgc0NvbG9yQ2hhbmdlLnB1c2gocGFyc2VJbnQoXCIweFwiK3NDb2xvci5zbGljZShpLCBpKzIpKSk7ICAgIFxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gXCJSR0IoXCIgKyBzQ29sb3JDaGFuZ2Uuam9pbihcIixcIikgKyBcIilcIjtcclxuICAgIH1cclxuICAgIHJldHVybiBzQ29sb3I7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGhleFRvUmdiQXJyYXkoaGV4OnN0cmluZyl7XHJcbiAgICB2YXIgc0NvbG9yID0gaGV4LnRvTG93ZXJDYXNlKCk7XHJcbiAgICAvL+WNgeWFrei/m+WItuminOiJsuWAvOeahOato+WImeihqOi+vuW8j1xyXG4gICAgdmFyIHJlZyA9IC9eIyhbMC05YS1mQS1mXXszfXxbMC05YS1mQS1mXXs2fSkkLztcclxuICAgIC8vIOWmguaenOaYrzE26L+b5Yi26aKc6ImyXHJcbiAgICBpZiAoc0NvbG9yICYmIHJlZy50ZXN0KHNDb2xvcikpIHtcclxuICAgICAgICBpZiAoc0NvbG9yLmxlbmd0aCA9PT0gNCkge1xyXG4gICAgICAgICAgICB2YXIgc0NvbG9yTmV3ID0gXCIjXCI7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGk9MTsgaTw0OyBpKz0xKSB7XHJcbiAgICAgICAgICAgICAgICBzQ29sb3JOZXcgKz0gc0NvbG9yLnNsaWNlKGksIGkrMSkuY29uY2F0KHNDb2xvci5zbGljZShpLCBpKzEpKTsgICAgXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc0NvbG9yID0gc0NvbG9yTmV3O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL+WkhOeQhuWFreS9jeeahOminOiJsuWAvFxyXG4gICAgICAgIHZhciBzQ29sb3JDaGFuZ2U6bnVtYmVyW10gPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBpPTE7IGk8NzsgaSs9Mikge1xyXG4gICAgICAgICAgICBzQ29sb3JDaGFuZ2UucHVzaChwYXJzZUludChcIjB4XCIrc0NvbG9yLnNsaWNlKGksIGkrMikpKTsgICAgXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAgc0NvbG9yQ2hhbmdlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBIU0zpopzoibLlgLzovazmjaLkuLpSR0IuIFxyXG4gKiDmjaLnrpflhazlvI/mlLnnvJboh6ogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IU0xfY29sb3Jfc3BhY2UuXHJcbiAqIGgsIHMsIOWSjCBsIOiuvuWumuWcqCBbMCwgMV0g5LmL6Ze0XHJcbiAqIOi/lOWbnueahCByLCBnLCDlkowgYiDlnKggWzAsIDI1NV3kuYvpl7RcclxuICpcclxuICogQHBhcmFtICAgTnVtYmVyICBoICAgICAgIOiJsuebuFxyXG4gKiBAcGFyYW0gICBOdW1iZXIgIHMgICAgICAg6aWx5ZKM5bqmXHJcbiAqIEBwYXJhbSAgIE51bWJlciAgbCAgICAgICDkuq7luqZcclxuICogQHJldHVybiAgQXJyYXkgICAgICAgICAgIFJHQuiJsuWAvOaVsOWAvFxyXG4gKi9cclxuZnVuY3Rpb24gaHNsVG9SZ2IoaDpudW1iZXIsIHM6bnVtYmVyLCBsOm51bWJlcikge1xyXG4gICAgdmFyIHIsIGcsIGI7XHJcblxyXG4gICAgaWYocyA9PSAwKSB7XHJcbiAgICAgICAgciA9IGcgPSBiID0gbDsgLy8gYWNocm9tYXRpY1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIgaHVlMnJnYiA9IGZ1bmN0aW9uIGh1ZTJyZ2IocDpudW1iZXIsIHE6bnVtYmVyLCB0Om51bWJlcikge1xyXG4gICAgICAgICAgICBpZih0IDwgMCkgdCArPSAxO1xyXG4gICAgICAgICAgICBpZih0ID4gMSkgdCAtPSAxO1xyXG4gICAgICAgICAgICBpZih0IDwgMS82KSByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDtcclxuICAgICAgICAgICAgaWYodCA8IDEvMikgcmV0dXJuIHE7XHJcbiAgICAgICAgICAgIGlmKHQgPCAyLzMpIHJldHVybiBwICsgKHEgLSBwKSAqICgyLzMgLSB0KSAqIDY7XHJcbiAgICAgICAgICAgIHJldHVybiBwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdmFyIHEgPSBsIDwgMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzO1xyXG4gICAgICAgIHZhciBwID0gMiAqIGwgLSBxO1xyXG4gICAgICAgIHIgPSBodWUycmdiKHAsIHEsIGggKyAxLzMpO1xyXG4gICAgICAgIGcgPSBodWUycmdiKHAsIHEsIGgpO1xyXG4gICAgICAgIGIgPSBodWUycmdiKHAsIHEsIGggLSAxLzMpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBbTWF0aC5yb3VuZChyICogMjU1KSwgTWF0aC5yb3VuZChnICogMjU1KSwgTWF0aC5yb3VuZChiICogMjU1KV07XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogUkdCIOminOiJsuWAvOi9rOaNouS4uiBIU0wuXHJcbiAqIOi9rOaNouWFrOW8j+WPguiAg+iHqiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hTTF9jb2xvcl9zcGFjZS5cclxuICogciwgZywg5ZKMIGIg6ZyA6KaB5ZyoIFswLCAyNTVdIOiMg+WbtOWGhVxyXG4gKiDov5Tlm57nmoQgaCwgcywg5ZKMIGwg5ZyoIFswLCAxXSDkuYvpl7RcclxuICpcclxuICogQHBhcmFtICAgTnVtYmVyICByICAgICAgIOe6ouiJsuiJsuWAvFxyXG4gKiBAcGFyYW0gICBOdW1iZXIgIGcgICAgICAg57u/6Imy6Imy5YC8XHJcbiAqIEBwYXJhbSAgIE51bWJlciAgYiAgICAgICDok53oibLoibLlgLxcclxuICogQHJldHVybiAgQXJyYXkgICAgICAgICAgIEhTTOWQhOWAvOaVsOe7hFxyXG4gKi9cclxuZnVuY3Rpb24gcmdiVG9Ic2wocjpudW1iZXIsIGc6bnVtYmVyLCBiOm51bWJlcikge1xyXG4gICAgciAvPSAyNTUsIGcgLz0gMjU1LCBiIC89IDI1NTtcclxuICAgIHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKSwgbWluID0gTWF0aC5taW4ociwgZywgYik7XHJcbiAgICB2YXIgaCwgcywgbCA9IChtYXggKyBtaW4pIC8gMjtcclxuXHJcbiAgICBpZiAobWF4ID09IG1pbil7IFxyXG4gICAgICAgIGggPSBzID0gMDsgLy8gYWNocm9tYXRpY1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICB2YXIgZCA9IG1heCAtIG1pbjtcclxuICAgICAgICBzID0gbCA+IDAuNSA/IGQgLyAoMiAtIG1heCAtIG1pbikgOiBkIC8gKG1heCArIG1pbik7XHJcbiAgICAgICAgc3dpdGNoKG1heCkge1xyXG4gICAgICAgICAgICBjYXNlIHI6IGggPSAoZyAtIGIpIC8gZCArIChnIDwgYiA/IDYgOiAwKTsgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgZzogaCA9IChiIC0gcikgLyBkICsgMjsgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgYjogaCA9IChyIC0gZykgLyBkICsgNDsgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGggLz0gNjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gW2gsIHMsIGxdO1xyXG59XHJcbiBcclxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUmFuZG9tSW5kZXgocHJlZml4OnN0cmluZyk6c3RyaW5nIHtcclxuICAgIGlmKHByZWZpeCA9PSBudWxsKXtcclxuICAgICAgICBwcmVmaXggPSBcIlNoZWV0XCI7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHVzZXJBZ2VudCA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnJlcGxhY2UoL1teYS16QS1aMC05XS9nLCBcIlwiKS5zcGxpdChcIlwiKTtcclxuXHJcbiAgICBsZXQgbWlkID0gXCJcIjtcclxuXHJcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgNTsgaSsrKXtcclxuICAgICAgICBtaWQgKz0gdXNlckFnZW50W01hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqICh1c2VyQWdlbnQubGVuZ3RoIC0gMSkpXTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG5cclxuICAgIHJldHVybiBwcmVmaXggKyBcIl9cIiArIG1pZCArIFwiX1wiICsgdGltZTtcclxufVxyXG5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVDaGFyYWN0ZXIoc3RyOnN0cmluZyl7XHJcbiAgICBpZihzdHI9PW51bGwgfHwgc3RyLmxlbmd0aD09MCl7XHJcbiAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyZhbXA7L2csIFwiJlwiKS5yZXBsYWNlKC8mcXVvdDsvZywgJ1wiJykucmVwbGFjZSgvJmx0Oy9nLCAnPCcpLnJlcGxhY2UoLyZndDsvZywgJz4nKS5yZXBsYWNlKC8mbmJzcDsvZywgJyAnKS5yZXBsYWNlKC8mYXBvczsvZywgXCInXCIpLnJlcGxhY2UoLyZpZXhjbDsvZywgXCLCoVwiKS5yZXBsYWNlKC8mY2VudDsvZywgXCLColwiKS5yZXBsYWNlKC8mcG91bmQ7L2csIFwiwqNcIikucmVwbGFjZSgvJmN1cnJlbjsvZywgXCLCpFwiKS5yZXBsYWNlKC8meWVuOy9nLCBcIsKlXCIpLnJlcGxhY2UoLyZicnZiYXI7L2csIFwiwqZcIikucmVwbGFjZSgvJnNlY3Q7L2csIFwiwqdcIikucmVwbGFjZSgvJnVtbDsvZywgXCLCqFwiKS5yZXBsYWNlKC8mY29weTsvZywgXCLCqVwiKS5yZXBsYWNlKC8mb3JkZjsvZywgXCLCqlwiKS5yZXBsYWNlKC8mbGFxdW87L2csIFwiwqtcIikucmVwbGFjZSgvJm5vdDsvZywgXCLCrFwiKS5yZXBsYWNlKC8mc2h5Oy9nLCBcIsKtXCIpLnJlcGxhY2UoLyZyZWc7L2csIFwiwq5cIikucmVwbGFjZSgvJm1hY3I7L2csIFwiwq9cIikucmVwbGFjZSgvJmRlZzsvZywgXCLCsFwiKS5yZXBsYWNlKC8mcGx1c21uOy9nLCBcIsKxXCIpLnJlcGxhY2UoLyZzdXAyOy9nLCBcIsKyXCIpLnJlcGxhY2UoLyZzdXAzOy9nLCBcIsKzXCIpLnJlcGxhY2UoLyZhY3V0ZTsvZywgXCLCtFwiKS5yZXBsYWNlKC8mbWljcm87L2csIFwiwrVcIikucmVwbGFjZSgvJnBhcmE7L2csIFwiwrZcIikucmVwbGFjZSgvJm1pZGRvdDsvZywgXCLCt1wiKS5yZXBsYWNlKC8mY2VkaWw7L2csIFwiwrhcIikucmVwbGFjZSgvJnN1cDE7L2csIFwiwrlcIikucmVwbGFjZSgvJm9yZG07L2csIFwiwrpcIikucmVwbGFjZSgvJnJhcXVvOy9nLCBcIsK7XCIpLnJlcGxhY2UoLyZmcmFjMTQ7L2csIFwiwrxcIikucmVwbGFjZSgvJmZyYWMxMjsvZywgXCLCvVwiKS5yZXBsYWNlKC8mZnJhYzM0Oy9nLCBcIsK+XCIpLnJlcGxhY2UoLyZpcXVlc3Q7L2csIFwiwr9cIikucmVwbGFjZSgvJnRpbWVzOy9nLCBcIsOXXCIpLnJlcGxhY2UoLyZkaXZpZGU7L2csIFwiw7dcIikucmVwbGFjZSgvJkFncmF2ZTsvZywgXCLDgFwiKS5yZXBsYWNlKC8mQWFjdXRlOy9nLCBcIsOBXCIpLnJlcGxhY2UoLyZBY2lyYzsvZywgXCLDglwiKS5yZXBsYWNlKC8mQXRpbGRlOy9nLCBcIsODXCIpLnJlcGxhY2UoLyZBdW1sOy9nLCBcIsOEXCIpLnJlcGxhY2UoLyZBcmluZzsvZywgXCLDhVwiKS5yZXBsYWNlKC8mQUVsaWc7L2csIFwiw4ZcIikucmVwbGFjZSgvJkNjZWRpbDsvZywgXCLDh1wiKS5yZXBsYWNlKC8mRWdyYXZlOy9nLCBcIsOIXCIpLnJlcGxhY2UoLyZFYWN1dGU7L2csIFwiw4lcIikucmVwbGFjZSgvJkVjaXJjOy9nLCBcIsOKXCIpLnJlcGxhY2UoLyZFdW1sOy9nLCBcIsOLXCIpLnJlcGxhY2UoLyZJZ3JhdmU7L2csIFwiw4xcIikucmVwbGFjZSgvJklhY3V0ZTsvZywgXCLDjVwiKS5yZXBsYWNlKC8mSWNpcmM7L2csIFwiw45cIikucmVwbGFjZSgvJkl1bWw7L2csIFwiw49cIikucmVwbGFjZSgvJkVUSDsvZywgXCLDkFwiKS5yZXBsYWNlKC8mTnRpbGRlOy9nLCBcIsORXCIpLnJlcGxhY2UoLyZPZ3JhdmU7L2csIFwiw5JcIikucmVwbGFjZSgvJk9hY3V0ZTsvZywgXCLDk1wiKS5yZXBsYWNlKC8mT2NpcmM7L2csIFwiw5RcIikucmVwbGFjZSgvJk90aWxkZTsvZywgXCLDlVwiKS5yZXBsYWNlKC8mT3VtbDsvZywgXCLDllwiKS5yZXBsYWNlKC8mT3NsYXNoOy9nLCBcIsOYXCIpLnJlcGxhY2UoLyZVZ3JhdmU7L2csIFwiw5lcIikucmVwbGFjZSgvJlVhY3V0ZTsvZywgXCLDmlwiKS5yZXBsYWNlKC8mVWNpcmM7L2csIFwiw5tcIikucmVwbGFjZSgvJlV1bWw7L2csIFwiw5xcIikucmVwbGFjZSgvJllhY3V0ZTsvZywgXCLDnVwiKS5yZXBsYWNlKC8mVEhPUk47L2csIFwiw55cIikucmVwbGFjZSgvJnN6bGlnOy9nLCBcIsOfXCIpLnJlcGxhY2UoLyZhZ3JhdmU7L2csIFwiw6BcIikucmVwbGFjZSgvJmFhY3V0ZTsvZywgXCLDoVwiKS5yZXBsYWNlKC8mYWNpcmM7L2csIFwiw6JcIikucmVwbGFjZSgvJmF0aWxkZTsvZywgXCLDo1wiKS5yZXBsYWNlKC8mYXVtbDsvZywgXCLDpFwiKS5yZXBsYWNlKC8mYXJpbmc7L2csIFwiw6VcIikucmVwbGFjZSgvJmFlbGlnOy9nLCBcIsOmXCIpLnJlcGxhY2UoLyZjY2VkaWw7L2csIFwiw6dcIikucmVwbGFjZSgvJmVncmF2ZTsvZywgXCLDqFwiKS5yZXBsYWNlKC8mZWFjdXRlOy9nLCBcIsOpXCIpLnJlcGxhY2UoLyZlY2lyYzsvZywgXCLDqlwiKS5yZXBsYWNlKC8mZXVtbDsvZywgXCLDq1wiKS5yZXBsYWNlKC8maWdyYXZlOy9nLCBcIsOsXCIpLnJlcGxhY2UoLyZpYWN1dGU7L2csIFwiw61cIikucmVwbGFjZSgvJmljaXJjOy9nLCBcIsOuXCIpLnJlcGxhY2UoLyZpdW1sOy9nLCBcIsOvXCIpLnJlcGxhY2UoLyZldGg7L2csIFwiw7BcIikucmVwbGFjZSgvJm50aWxkZTsvZywgXCLDsVwiKS5yZXBsYWNlKC8mb2dyYXZlOy9nLCBcIsOyXCIpLnJlcGxhY2UoLyZvYWN1dGU7L2csIFwiw7NcIikucmVwbGFjZSgvJm9jaXJjOy9nLCBcIsO0XCIpLnJlcGxhY2UoLyZvdGlsZGU7L2csIFwiw7VcIikucmVwbGFjZSgvJm91bWw7L2csIFwiw7ZcIikucmVwbGFjZSgvJm9zbGFzaDsvZywgXCLDuFwiKS5yZXBsYWNlKC8mdWdyYXZlOy9nLCBcIsO5XCIpLnJlcGxhY2UoLyZ1YWN1dGU7L2csIFwiw7pcIikucmVwbGFjZSgvJnVjaXJjOy9nLCBcIsO7XCIpLnJlcGxhY2UoLyZ1dW1sOy9nLCBcIsO8XCIpLnJlcGxhY2UoLyZ5YWN1dGU7L2csIFwiw71cIikucmVwbGFjZSgvJnRob3JuOy9nLCBcIsO+XCIpLnJlcGxhY2UoLyZ5dW1sOy9nLCBcIsO/XCIpO1xyXG5cclxufVxyXG5cclxuXHJcbmV4cG9ydCBjbGFzcyBmcm9tdWxhUmVmIHtcclxuXHJcbiAgICBzdGF0aWMgb3BlcmF0b3IgPSAnPT18IT18PD58PD18Pj18PXwrfC18Pnw8fC98KnwlfCZ8XidcclxuICAgIHN0YXRpYyBlcnJvciA9IHtcclxuICAgICAgICB2OiBcIiNWQUxVRSFcIiwgICAgLy/plJnor6/nmoTlj4LmlbDmiJbov5DnrpfnrKZcclxuICAgICAgICBuOiBcIiNOQU1FP1wiLCAgICAgLy/lhazlvI/lkI3np7DplJnor69cclxuICAgICAgICBuYTogXCIjTi9BXCIsICAgICAgLy/lh73mlbDmiJblhazlvI/kuK3msqHmnInlj6/nlKjmlbDlgLxcclxuICAgICAgICByOiBcIiNSRUYhXCIsICAgICAgLy/liKDpmaTkuobnlLHlhbbku5blhazlvI/lvJXnlKjnmoTljZXlhYPmoLxcclxuICAgICAgICBkOiBcIiNESVYvMCFcIiwgICAgLy/pmaTmlbDmmK8w5oiW56m65Y2V5YWD5qC8XHJcbiAgICAgICAgbm06IFwiI05VTSFcIiwgICAgIC8v5b2T5YWs5byP5oiW5Ye95pWw5Lit5p+Q5Liq5pWw5a2X5pyJ6Zeu6aKY5pe2XHJcbiAgICAgICAgbmw6IFwiI05VTEwhXCIsICAgIC8v5Lqk5Y+J6L+Q566X56ym77yI56m65qC877yJ5L2/55So5LiN5q2j56GuXHJcbiAgICAgICAgc3A6IFwiI1NQSUxMIVwiICAgIC8v5pWw57uE6IyD5Zu05pyJ5YW25a6D5YC8XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIG9wZXJhdG9yanNvbjpzdHJpbmdUb051bSA9IG51bGxcclxuXHJcbiAgICBzdGF0aWMgdHJpbShzdHI6c3RyaW5nKSB7ICBcclxuICAgICAgICBpZihzdHIgPT0gbnVsbCl7ICBcclxuICAgICAgICAgICAgc3RyID0gXCJcIjsgIFxyXG4gICAgICAgIH0gIFxyXG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvKF5cXHMqKXwoXFxzKiQpL2csIFwiXCIpOyAgXHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIGZ1bmN0aW9uQ29weSh0eHQ6c3RyaW5nLCBtb2RlOnN0cmluZywgc3RlcDpudW1iZXIpIHtcclxuICAgICAgICBsZXQgX3RoaXMgPSB0aGlzO1xyXG5cclxuICAgICAgICBpZiAoX3RoaXMub3BlcmF0b3Jqc29uID09IG51bGwpIHtcclxuICAgICAgICAgICAgbGV0IGFyciA9IF90aGlzLm9wZXJhdG9yLnNwbGl0KFwifFwiKSxcclxuICAgICAgICAgICAgICAgIG9wOnN0cmluZ1RvTnVtID0ge307XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgb3BbYXJyW2ldLnRvU3RyaW5nKCldID0gMTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgX3RoaXMub3BlcmF0b3Jqc29uID0gb3A7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAobW9kZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIG1vZGUgPSBcImRvd25cIjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChzdGVwID09IG51bGwpIHtcclxuICAgICAgICAgICAgc3RlcCA9IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHh0LnN1YnN0cigwLCAxKSA9PSBcIj1cIikge1xyXG4gICAgICAgICAgICB0eHQgPSB0eHQuc3Vic3RyKDEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGV0IGZ1bmNzdGFjayA9IHR4dC5zcGxpdChcIlwiKTtcclxuICAgICAgICBsZXQgaSA9IDAsXHJcbiAgICAgICAgICAgIHN0ciA9IFwiXCIsXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uX3N0ciA9IFwiXCIsXHJcbiAgICAgICAgICAgIGlzcGFzc2J5ID0gdHJ1ZTtcclxuICAgICAgICBcclxuICAgICAgICBsZXQgbWF0Y2hDb25maWcgPSB7XHJcbiAgICAgICAgICAgIFwiYnJhY2tldFwiOiAwLFxyXG4gICAgICAgICAgICBcImNvbW1hXCI6IDAsXHJcbiAgICAgICAgICAgIFwic3F1b3RlXCI6IDAsXHJcbiAgICAgICAgICAgIFwiZHF1b3RlXCI6IDBcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB3aGlsZSAoaSA8IGZ1bmNzdGFjay5sZW5ndGgpIHtcclxuICAgICAgICAgICAgbGV0IHMgPSBmdW5jc3RhY2tbaV07XHJcblxyXG4gICAgICAgICAgICBpZiAocyA9PSBcIihcIiAmJiBtYXRjaENvbmZpZy5kcXVvdGUgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgbWF0Y2hDb25maWcuYnJhY2tldCArPSAxO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzdHIubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uX3N0ciArPSBzdHIgKyBcIihcIjtcclxuICAgICAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbl9zdHIgKz0gXCIoXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgc3RyID0gXCJcIjtcclxuICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgZWxzZSBpZiAocyA9PSBcIilcIiAmJiBtYXRjaENvbmZpZy5kcXVvdGUgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgbWF0Y2hDb25maWcuYnJhY2tldCAtPSAxO1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25fc3RyICs9IF90aGlzLmZ1bmN0aW9uQ29weShzdHIsIG1vZGUsIHN0ZXApICsgXCIpXCI7XHJcbiAgICAgICAgICAgICAgICBzdHIgPSBcIlwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHMgPT0gJ1wiJyAmJiBtYXRjaENvbmZpZy5zcXVvdGUgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoQ29uZmlnLmRxdW90ZSA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbl9zdHIgKz0gc3RyICsgJ1wiJztcclxuICAgICAgICAgICAgICAgICAgICBtYXRjaENvbmZpZy5kcXVvdGUgLT0gMTtcclxuICAgICAgICAgICAgICAgICAgICBzdHIgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoQ29uZmlnLmRxdW90ZSArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0ciArPSAnXCInO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICBlbHNlIGlmIChzID09ICcsJyAmJiBtYXRjaENvbmZpZy5kcXVvdGUgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25fc3RyICs9IF90aGlzLmZ1bmN0aW9uQ29weShzdHIsIG1vZGUsIHN0ZXApICsgJywnO1xyXG4gICAgICAgICAgICAgICAgc3RyID0gXCJcIjtcclxuICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgZWxzZSBpZiAocyA9PSAnJicgJiYgbWF0Y2hDb25maWcuZHF1b3RlID09IDApIHtcclxuICAgICAgICAgICAgICAgIGlmIChzdHIubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uX3N0ciArPSBfdGhpcy5mdW5jdGlvbkNvcHkoc3RyLCBtb2RlLCBzdGVwKSArIFwiJlwiO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25fc3RyICs9IFwiJlwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICBlbHNlIGlmIChzIGluIF90aGlzLm9wZXJhdG9yanNvbiAmJiBtYXRjaENvbmZpZy5kcXVvdGUgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHNfbmV4dCA9IFwiXCI7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKChpICsgMSkgPCBmdW5jc3RhY2subGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc19uZXh0ID0gZnVuY3N0YWNrW2kgKyAxXTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgcCA9IGkgLSAxLCBcclxuICAgICAgICAgICAgICAgICAgICBzX3ByZSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYocCA+PSAwKXtcclxuICAgICAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNfcHJlID0gZnVuY3N0YWNrW3AtLV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwPj0wICYmIHNfcHJlID09XCIgXCIpXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKChzICsgc19uZXh0KSBpbiBfdGhpcy5vcGVyYXRvcmpzb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25fc3RyICs9IF90aGlzLmZ1bmN0aW9uQ29weShzdHIsIG1vZGUsIHN0ZXApICsgcyArIHNfbmV4dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbl9zdHIgKz0gcyArIHNfbmV4dDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYoISgvW14wLTldLy50ZXN0KHNfbmV4dCkpICYmIHM9PVwiLVwiICYmIChzX3ByZT09XCIoXCIgfHwgc19wcmUgPT0gbnVsbCB8fCBzX3ByZSA9PSBcIixcIiB8fCBzX3ByZSA9PSBcIiBcIiB8fCBzX3ByZSBpbiBfdGhpcy5vcGVyYXRvcmpzb24gKSApe1xyXG4gICAgICAgICAgICAgICAgICAgIHN0ciArPSBzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0ci5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uX3N0ciArPSBfdGhpcy5mdW5jdGlvbkNvcHkoc3RyLCBtb2RlLCBzdGVwKSArIHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25fc3RyICs9IHM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN0ciArPSBzO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoaSA9PSBmdW5jc3RhY2subGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmlzY2VsbGRhdGEoX3RoaXMudHJpbShzdHIpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlID09IFwiZG93blwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uX3N0ciArPSBfdGhpcy5kb3ducGFyYW0oX3RoaXMudHJpbShzdHIpLCBzdGVwKTtcclxuICAgICAgICAgICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1vZGUgPT0gXCJ1cFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uX3N0ciArPSBfdGhpcy51cHBhcmFtKF90aGlzLnRyaW0oc3RyKSwgc3RlcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtb2RlID09IFwibGVmdFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uX3N0ciArPSBfdGhpcy5sZWZ0cGFyYW0oX3RoaXMudHJpbShzdHIpLCBzdGVwKTtcclxuICAgICAgICAgICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1vZGUgPT0gXCJyaWdodFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uX3N0ciArPSBfdGhpcy5yaWdodHBhcmFtKF90aGlzLnRyaW0oc3RyKSwgc3RlcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uX3N0ciArPSBfdGhpcy50cmltKHN0cik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbl9zdHI7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHN0YXRpYyBkb3ducGFyYW0odHh0OnN0cmluZywgc3RlcDpudW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVwYXJhbShcImRcIiwgdHh0LCBzdGVwKTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgdXBwYXJhbSh0eHQ6c3RyaW5nLCBzdGVwOm51bWJlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZXBhcmFtKFwidVwiLCB0eHQsIHN0ZXApO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBsZWZ0cGFyYW0odHh0OnN0cmluZywgc3RlcDpudW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVwYXJhbShcImxcIiwgdHh0LCBzdGVwKTtcclxuICAgIH1cclxuXHJcbiAgICBzdGF0aWMgcmlnaHRwYXJhbSAodHh0OnN0cmluZywgc3RlcDpudW1iZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVwYXJhbShcInJcIiwgdHh0LCBzdGVwKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgc3RhdGljIHVwZGF0ZXBhcmFtIChvcmllbnQ6c3RyaW5nLCB0eHQ6c3RyaW5nLCBzdGVwOm51bWJlcikge1xyXG4gICAgICAgIGxldCBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgbGV0IHZhbCA9IHR4dC5zcGxpdChcIiFcIiksXHJcbiAgICAgICAgICAgIHJhbmdldHh0LCBwcmVmaXggPSBcIlwiO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICh2YWwubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICByYW5nZXR4dCA9IHZhbFsxXTtcclxuICAgICAgICAgICAgcHJlZml4ID0gdmFsWzBdICsgXCIhXCI7XHJcbiAgICAgICAgfSBcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmFuZ2V0eHQgPSB2YWxbMF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocmFuZ2V0eHQuaW5kZXhPZihcIjpcIikgPT0gLTEpIHtcclxuICAgICAgICAgICAgbGV0IHJvdyA9IHBhcnNlSW50KHJhbmdldHh0LnJlcGxhY2UoL1teMC05XS9nLCBcIlwiKSk7XHJcbiAgICAgICAgICAgIGxldCBjb2wgPSBBQkNhdE51bShyYW5nZXR4dC5yZXBsYWNlKC9bXkEtWmEtel0vZywgXCJcIikpO1xyXG4gICAgICAgICAgICBsZXQgZnJlZXpvbkZ1YyA9IF90aGlzLmlzZnJlZXpvbkZ1YyhyYW5nZXR4dCk7XHJcbiAgICAgICAgICAgIGxldCAkcm93ID0gZnJlZXpvbkZ1Y1swXSA/IFwiJFwiIDogXCJcIixcclxuICAgICAgICAgICAgICAgICRjb2wgPSBmcmVlem9uRnVjWzFdID8gXCIkXCIgOiBcIlwiO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKG9yaWVudCA9PSBcInVcIiAmJiAhZnJlZXpvbkZ1Y1swXSkge1xyXG4gICAgICAgICAgICAgICAgcm93IC09IHN0ZXA7XHJcbiAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9yaWVudCA9PSBcInJcIiAmJiAhZnJlZXpvbkZ1Y1sxXSkge1xyXG4gICAgICAgICAgICAgICAgY29sICs9IHN0ZXA7XHJcbiAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9yaWVudCA9PSBcImxcIiAmJiAhZnJlZXpvbkZ1Y1sxXSkge1xyXG4gICAgICAgICAgICAgICAgY29sIC09IHN0ZXA7XHJcbiAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFmcmVlem9uRnVjWzBdKSB7XHJcbiAgICAgICAgICAgICAgICByb3cgKz0gc3RlcDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYocm93IDwgMCB8fCBjb2wgPCAwKXtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5lcnJvci5yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoIWlzTmFOKHJvdykgJiYgIWlzTmFOKGNvbCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcmVmaXggKyAkY29sICsgY2hhdGF0QUJDKGNvbCkgKyAkcm93ICsgKHJvdyk7XHJcbiAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc05hTihyb3cpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJlZml4ICsgJHJvdyArIChyb3cpO1xyXG4gICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICBlbHNlIGlmICghaXNOYU4oY29sKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZWZpeCArICRjb2wgKyBjaGF0YXRBQkMoY29sKTtcclxuICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmFuZ2V0eHQgPSByYW5nZXR4dC5zcGxpdChcIjpcIik7XHJcbiAgICAgICAgICAgIGxldCByb3cgPSBbXSxcclxuICAgICAgICAgICAgICAgIGNvbCA9IFtdO1xyXG5cclxuICAgICAgICAgICAgcm93WzBdID0gcGFyc2VJbnQocmFuZ2V0eHRbMF0ucmVwbGFjZSgvW14wLTldL2csIFwiXCIpKTtcclxuICAgICAgICAgICAgcm93WzFdID0gcGFyc2VJbnQocmFuZ2V0eHRbMV0ucmVwbGFjZSgvW14wLTldL2csIFwiXCIpKTtcclxuICAgICAgICAgICAgaWYgKHJvd1swXSA+IHJvd1sxXSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY29sWzBdID0gQUJDYXROdW0ocmFuZ2V0eHRbMF0ucmVwbGFjZSgvW15BLVphLXpdL2csIFwiXCIpKTtcclxuICAgICAgICAgICAgY29sWzFdID0gQUJDYXROdW0ocmFuZ2V0eHRbMV0ucmVwbGFjZSgvW15BLVphLXpdL2csIFwiXCIpKTtcclxuICAgICAgICAgICAgaWYgKGNvbFswXSA+IGNvbFsxXSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR4dDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGV0IGZyZWV6b25GdWMwID0gX3RoaXMuaXNmcmVlem9uRnVjKHJhbmdldHh0WzBdKTtcclxuICAgICAgICAgICAgbGV0IGZyZWV6b25GdWMxID0gX3RoaXMuaXNmcmVlem9uRnVjKHJhbmdldHh0WzFdKTtcclxuICAgICAgICAgICAgbGV0ICRyb3cwID0gZnJlZXpvbkZ1YzBbMF0gPyBcIiRcIiA6IFwiXCIsXHJcbiAgICAgICAgICAgICAgICAkY29sMCA9IGZyZWV6b25GdWMwWzFdID8gXCIkXCIgOiBcIlwiO1xyXG4gICAgICAgICAgICBsZXQgJHJvdzEgPSBmcmVlem9uRnVjMVswXSA/IFwiJFwiIDogXCJcIixcclxuICAgICAgICAgICAgICAgICRjb2wxID0gZnJlZXpvbkZ1YzFbMV0gPyBcIiRcIiA6IFwiXCI7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAob3JpZW50ID09IFwidVwiKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWZyZWV6b25GdWMwWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcm93WzBdIC09IHN0ZXA7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFmcmVlem9uRnVjMVswXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJvd1sxXSAtPSBzdGVwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICBlbHNlIGlmIChvcmllbnQgPT0gXCJyXCIpIHtcclxuICAgICAgICAgICAgICAgIGlmICghZnJlZXpvbkZ1YzBbMV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xbMF0gKz0gc3RlcDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWZyZWV6b25GdWMxWzFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sWzFdICs9IHN0ZXA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9yaWVudCA9PSBcImxcIikge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFmcmVlem9uRnVjMFsxXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbFswXSAtPSBzdGVwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICghZnJlZXpvbkZ1YzFbMV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xbMV0gLT0gc3RlcDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWZyZWV6b25GdWMwWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcm93WzBdICs9IHN0ZXA7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCFmcmVlem9uRnVjMVswXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJvd1sxXSArPSBzdGVwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZihyb3dbMF0gPCAwIHx8IGNvbFswXSA8IDApe1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmVycm9yLnI7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChpc05hTihjb2xbMF0pICYmIGlzTmFOKGNvbFsxXSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcmVmaXggKyAkcm93MCArIChyb3dbMF0pICsgXCI6XCIgKyAkcm93MSArIChyb3dbMV0pO1xyXG4gICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc05hTihyb3dbMF0pICYmIGlzTmFOKHJvd1sxXSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcmVmaXggKyAkY29sMCArIGNoYXRhdEFCQyhjb2xbMF0pICsgXCI6XCIgKyAkY29sMSArIGNoYXRhdEFCQyhjb2xbMV0pO1xyXG4gICAgICAgICAgICB9IFxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcmVmaXggKyAkY29sMCArIGNoYXRhdEFCQyhjb2xbMF0pICsgJHJvdzAgKyAocm93WzBdKSArIFwiOlwiICsgJGNvbDEgKyBjaGF0YXRBQkMoY29sWzFdKSArICRyb3cxICsgKHJvd1sxXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHN0YXRpYyBpc2NlbGxkYXRhKHR4dDpzdHJpbmcpIHsgLy/liKTmlq3mmK/lkKbkuLrljZXlhYPmoLzmoLzlvI9cclxuICAgICAgICBsZXQgdmFsID0gdHh0LnNwbGl0KFwiIVwiKSxcclxuICAgICAgICAgICAgcmFuZ2V0eHQ7XHJcblxyXG4gICAgICAgIGlmICh2YWwubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICByYW5nZXR4dCA9IHZhbFsxXTtcclxuICAgICAgICB9IFxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByYW5nZXR4dCA9IHZhbFswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxldCByZWdfY2VsbCA9IC9eKChbYS16QS1aXSspfChbJF1bYS16QS1aXSspKSgoWzAtOV0rKXwoWyRdWzAtOV0rKSkkL2c7IC8v5aKe5Yqg5q2j5YiZ5Yik5pat5Y2V5YWD5qC85Li65a2X5q+NK+aVsOWtl+eahOagvOW8j++8muWmgiBBMTpCM1xyXG4gICAgICAgIGxldCByZWdfY2VsbFJhbmdlID0gL14oKCgoW2EtekEtWl0rKXwoWyRdW2EtekEtWl0rKSkoKFswLTldKyl8KFskXVswLTldKykpKXwoKChbYS16QS1aXSspfChbJF1bYS16QS1aXSspKSkpJC9nOyAvL+WinuWKoOato+WImeWIpOaWreWNleWFg+agvOS4uuWtl+avjSvmlbDlrZfmiJblrZfmr43nmoTmoLzlvI/vvJrlpoIgQTE6QjPvvIxBOkFcclxuICAgICAgICBcclxuICAgICAgICBpZiAocmFuZ2V0eHQuaW5kZXhPZihcIjpcIikgPT0gLTEpIHtcclxuICAgICAgICAgICAgbGV0IHJvdyA9IHBhcnNlSW50KHJhbmdldHh0LnJlcGxhY2UoL1teMC05XS9nLCBcIlwiKSkgLSAxO1xyXG4gICAgICAgICAgICBsZXQgY29sID0gQUJDYXROdW0ocmFuZ2V0eHQucmVwbGFjZSgvW15BLVphLXpdL2csIFwiXCIpKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmICghaXNOYU4ocm93KSAmJiAhaXNOYU4oY29sKSAmJiByYW5nZXR4dC50b1N0cmluZygpLm1hdGNoKHJlZ19jZWxsKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc05hTihyb3cpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc05hTihjb2wpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH0gXHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVnX2NlbGxSYW5nZSA9IC9eKCgoKFthLXpBLVpdKyl8KFskXVthLXpBLVpdKykpKChbMC05XSspfChbJF1bMC05XSspKSl8KCgoW2EtekEtWl0rKXwoWyRdW2EtekEtWl0rKSkpfCgoKFswLTldKyl8KFskXVswLTldK3MpKSkpJC9nO1xyXG5cclxuICAgICAgICAgICAgcmFuZ2V0eHQgPSByYW5nZXR4dC5zcGxpdChcIjpcIik7XHJcblxyXG4gICAgICAgICAgICBsZXQgcm93ID0gW10sY29sID0gW107XHJcbiAgICAgICAgICAgIHJvd1swXSA9IHBhcnNlSW50KHJhbmdldHh0WzBdLnJlcGxhY2UoL1teMC05XS9nLCBcIlwiKSkgLSAxO1xyXG4gICAgICAgICAgICByb3dbMV0gPSBwYXJzZUludChyYW5nZXR4dFsxXS5yZXBsYWNlKC9bXjAtOV0vZywgXCJcIikpIC0gMTtcclxuICAgICAgICAgICAgaWYgKHJvd1swXSA+IHJvd1sxXSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb2xbMF0gPSBBQkNhdE51bShyYW5nZXR4dFswXS5yZXBsYWNlKC9bXkEtWmEtel0vZywgXCJcIikpO1xyXG4gICAgICAgICAgICBjb2xbMV0gPSBBQkNhdE51bShyYW5nZXR4dFsxXS5yZXBsYWNlKC9bXkEtWmEtel0vZywgXCJcIikpO1xyXG4gICAgICAgICAgICBpZiAoY29sWzBdID4gY29sWzFdKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmKHJhbmdldHh0WzBdLnRvU3RyaW5nKCkubWF0Y2gocmVnX2NlbGxSYW5nZSkgJiYgcmFuZ2V0eHRbMV0udG9TdHJpbmcoKS5tYXRjaChyZWdfY2VsbFJhbmdlKSl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNle1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyBpc2ZyZWV6b25GdWModHh0OnN0cmluZykge1xyXG4gICAgICAgIGxldCByb3cgPSB0eHQucmVwbGFjZSgvW14wLTldL2csIFwiXCIpO1xyXG4gICAgICAgIGxldCBjb2wgPSB0eHQucmVwbGFjZSgvW15BLVphLXpdL2csIFwiXCIpO1xyXG4gICAgICAgIGxldCByb3ckID0gdHh0LnN1YnN0cih0eHQuaW5kZXhPZihyb3cpIC0gMSwgMSk7XHJcbiAgICAgICAgbGV0IGNvbCQgPSB0eHQuc3Vic3RyKHR4dC5pbmRleE9mKGNvbCkgLSAxLCAxKTtcclxuICAgICAgICBsZXQgcmV0ID0gW2ZhbHNlLCBmYWxzZV07XHJcblxyXG4gICAgICAgIGlmIChyb3ckID09IFwiJFwiKSB7XHJcbiAgICAgICAgICAgIHJldFswXSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb2wkID09IFwiJFwiKSB7XHJcbiAgICAgICAgICAgIHJldFsxXSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfVxyXG5cclxufVxyXG5cclxuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNDaGluZXNlKHRlbXA6c3RyaW5nKTpib29sZWFuXHJcbnsgXHJcbiAgICB2YXIgcmUgPSAvW15cXHU0ZTAwLVxcdTlmYTVdLzsgXHJcbiAgICB2YXIgcmVnID0gL1tcXHUzMDAyfFxcdWZmMWZ8XFx1ZmYwMXxcXHVmZjBjfFxcdTMwMDF8XFx1ZmYxYnxcXHVmZjFhfFxcdTIwMWN8XFx1MjAxZHxcXHUyMDE4fFxcdTIwMTl8XFx1ZmYwOHxcXHVmZjA5fFxcdTMwMGF8XFx1MzAwYnxcXHUzMDA4fFxcdTMwMDl8XFx1MzAxMHxcXHUzMDExfFxcdTMwMGV8XFx1MzAwZnxcXHUzMDBjfFxcdTMwMGR8XFx1ZmU0M3xcXHVmZTQ0fFxcdTMwMTR8XFx1MzAxNXxcXHUyMDI2fFxcdTIwMTR8XFx1ZmY1ZXxcXHVmZTRmfFxcdWZmZTVdLztcclxuICAgIGlmKHJlZy50ZXN0KHRlbXApKSByZXR1cm4gdHJ1ZTsgXHJcbiAgICBpZihyZS50ZXN0KHRlbXApKSByZXR1cm4gZmFsc2U7IFxyXG5cdHJldHVybiB0cnVlOyBcclxufVxyXG4gXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0phcGFuZXNlKHRlbXA6c3RyaW5nKTpib29sZWFuXHJcbnsgXHJcblx0dmFyIHJlID0gL1teXFx1MDgwMC1cXHU0ZTAwXS87IFxyXG5cdGlmKHJlLnRlc3QodGVtcCkpIHJldHVybiBmYWxzZTsgXHJcblx0cmV0dXJuIHRydWU7IFxyXG59XHJcbiBcclxuZXhwb3J0IGZ1bmN0aW9uIGlzS29lcmEoY2hyOmFueSk6Ym9vbGVhbiB7XHJcblx0XHJcblx0aWYoKChjaHIgPiAweDMxMzAgJiYgY2hyIDwgMHgzMThGKSB8fCBcclxuXHQgICAgKGNociA+PSAweEFDMDAgJiYgY2hyIDw9IDB4RDdBMykpKSBcclxuXHR7XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblx0cmV0dXJuIGZhbHNlO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNDb250YWluTXVsdGlUeXBlKHN0cjpzdHJpbmcpOmJvb2xlYW4ge1xyXG5cdFxyXG4gICAgbGV0IGlzVW5pY29kZSA9IGZhbHNlO1xyXG4gICAgaWYoZXNjYXBlKHN0cikuaW5kZXhPZihcIiV1XCIpPi0xKXtcclxuICAgICAgICBpc1VuaWNvZGUgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBpc05vdCA9IGZhbHNlO1xyXG4gICAgbGV0IHJlZyA9IC9bMC05YS16XS9naTsgXHJcbiAgICBpZihyZWcudGVzdChzdHIpKXtcclxuICAgICAgICBpc05vdCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IHJlRW5TaWduID0gL1tcXHgwMC1cXHhmZl0rL2c7XHJcbiAgICBpZihyZUVuU2lnbi50ZXN0KHN0cikpe1xyXG4gICAgICAgIGlzTm90ID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZihpc1VuaWNvZGUgJiYgaXNOb3Qpe1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmYWxzZTtcclxuXHJcbn1cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0QmluYXJ5Q29udGVudCAocGF0aDphbnksIG9wdGlvbnM6YW55KSB7XHJcbiAgICBsZXQgcHJvbWlzZSwgcmVzb2x2ZTphbnksIHJlamVjdDphbnk7XHJcbiAgICBsZXQgY2FsbGJhY2s6YW55O1xyXG5cclxuICAgIGlmICghb3B0aW9ucykge1xyXG4gICAgICAgIG9wdGlvbnMgPSB7fTtcclxuICAgIH1cclxuXHJcbiAgICAvLyB0YWtlbiBmcm9tIGpRdWVyeVxyXG4gICAgbGV0IGNyZWF0ZVN0YW5kYXJkWEhSID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgfSBjYXRjaCggZSApIHt9XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGNyZWF0ZUFjdGl2ZVhIUiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IHdpbmRvdy5BY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTEhUVFBcIik7XHJcbiAgICAgICAgfSBjYXRjaCggZSApIHt9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ3JlYXRlIHRoZSByZXF1ZXN0IG9iamVjdFxyXG4gICAgdmFyIGNyZWF0ZVhIUiA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5BY3RpdmVYT2JqZWN0KSA/XHJcbiAgICAgICAgLyogTWljcm9zb2Z0IGZhaWxlZCB0byBwcm9wZXJseVxyXG4gICAgICAgICogaW1wbGVtZW50IHRoZSBYTUxIdHRwUmVxdWVzdCBpbiBJRTcgKGNhbid0IHJlcXVlc3QgbG9jYWwgZmlsZXMpLFxyXG4gICAgICAgICogc28gd2UgdXNlIHRoZSBBY3RpdmVYT2JqZWN0IHdoZW4gaXQgaXMgYXZhaWxhYmxlXHJcbiAgICAgICAgKiBBZGRpdGlvbmFsbHkgWE1MSHR0cFJlcXVlc3QgY2FuIGJlIGRpc2FibGVkIGluIElFNy9JRTggc29cclxuICAgICAgICAqIHdlIG5lZWQgYSBmYWxsYmFjay5cclxuICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVTdGFuZGFyZFhIUigpIHx8IGNyZWF0ZUFjdGl2ZVhIUigpO1xyXG4gICAgfSA6XHJcbiAgICAgICAgLy8gRm9yIGFsbCBvdGhlciBicm93c2VycywgdXNlIHRoZSBzdGFuZGFyZCBYTUxIdHRwUmVxdWVzdCBvYmplY3RcclxuICAgICAgICBjcmVhdGVTdGFuZGFyZFhIUjtcclxuXHJcbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmxlIGNhbGxiYWNrXHJcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcclxuICAgICAgICBvcHRpb25zID0ge307XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgLy8gY2FsbGJhY2sgaW5zaWRlIG9wdGlvbnMgb2JqZWN0XHJcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrO1xyXG4gICAgfVxyXG5cclxuICAgIHJlc29sdmUgPSBmdW5jdGlvbiAoZGF0YTphbnkpIHsgY2FsbGJhY2sobnVsbCwgZGF0YSk7IH07XHJcbiAgICByZWplY3QgPSBmdW5jdGlvbiAoZXJyOmFueSkgeyBjYWxsYmFjayhlcnIsIG51bGwpOyB9O1xyXG5cclxuICAgIHRyeSB7XHJcbiAgICAgICAgdmFyIHhociA9IGNyZWF0ZVhIUigpO1xyXG5cclxuICAgICAgICB4aHIub3BlbignR0VUJywgcGF0aCwgdHJ1ZSk7XHJcblxyXG4gICAgICAgIC8vIHJlY2VudCBicm93c2Vyc1xyXG4gICAgICAgIGlmIChcInJlc3BvbnNlVHlwZVwiIGluIHhocikge1xyXG4gICAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gb2xkZXIgYnJvd3NlclxyXG4gICAgICAgIGlmKHhoci5vdmVycmlkZU1pbWVUeXBlKSB7XHJcbiAgICAgICAgICAgIHhoci5vdmVycmlkZU1pbWVUeXBlKFwidGV4dC9wbGFpbjsgY2hhcnNldD14LXVzZXItZGVmaW5lZFwiKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoZXZlbnQ6RXZlbnQpIHtcclxuICAgICAgICAgICAgLy8gdXNlIGB4aHJgIGFuZCBub3QgYHRoaXNgLi4uIHRoYW5rcyBJRVxyXG4gICAgICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzID09PSAyMDAgfHwgeGhyLnN0YXR1cyA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZnVuY3Rpb24gKHhocjpYTUxIdHRwUmVxdWVzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIHhoci5yZXNwb25zZVRleHQsIHRoZSAweEZGIG1hc2sgaXMgYXBwbGllZCBieSBKU1ppcFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHhoci5yZXNwb25zZSB8fCB4aHIucmVzcG9uc2VUZXh0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KHhocikpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2goZXJyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoZXJyKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiQWpheCBlcnJvciBmb3IgXCIgKyBwYXRoICsgXCIgOiBcIiArIHRoaXMuc3RhdHVzICsgXCIgXCIgKyB0aGlzLnN0YXR1c1RleHQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmKG9wdGlvbnMucHJvZ3Jlc3MpIHtcclxuICAgICAgICAgICAgeGhyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbihlOmFueSkge1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wcm9ncmVzcyh7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcclxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxyXG4gICAgICAgICAgICAgICAgICAgIHBlcmNlbnQ6IGUubG9hZGVkIC8gZS50b3RhbCAqIDEwMCxcclxuICAgICAgICAgICAgICAgICAgICBsb2FkZWQ6IGUubG9hZGVkLFxyXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsOiBlLnRvdGFsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHhoci5zZW5kKCk7XHJcblxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoZSksIG51bGwpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHJldHVybnMgYSBwcm9taXNlIG9yIHVuZGVmaW5lZCBkZXBlbmRpbmcgb24gd2hldGhlciBhIGNhbGxiYWNrIHdhc1xyXG4gICAgLy8gcHJvdmlkZWRcclxuICAgIHJldHVybiBwcm9taXNlO1xyXG59XHJcblxyXG4vKipcclxuICogbXVsdGkgc2VxdWVuY2UgY29udmVyc2lvblxyXG4gKiBleGFtcGxlOlxyXG4gKiAgMeOAgUUxNCAtPiAxM180XHJcbiAqICAy44CBRTE0IEoxNCBPMTQgVDE0IFkxNCBBRDE0IEFJMTQgQU4xNCBBUzE0IEFYMTQgLT5cclxuICogICAgIFsnMTNfNCcsICcxM185JywnMTNfMTQnLCAnMTNfMTknLCAnMTNfMjQnLCAnMTNfMycsICcxM184JywgICcxM18xMycsICcxM18xOCcsICcxM18yMyddXHJcbiAqICAz44CBRTQ2OkU0NyAtPiBbJzQ1XzQnLCAgJzQ2XzQnXVxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3FyZWYgLSBiZWZvcmUgc2VxdWVuY2VcclxuICogQHJldHVybnMge3N0cmluZ1tdfVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldE11bHRpU2VxdWVuY2VUb051bShzcXJlZjogc3RyaW5nKTogc3RyaW5nW10ge1xyXG4gIGlmICghc3FyZWYgfHwgc3FyZWY/Lmxlbmd0aCA8PSAwKSByZXR1cm4gW107XHJcbiAgc3FyZWYgPSBzcXJlZi50b1VwcGVyQ2FzZSgpO1xyXG4gIGxldCBzcXJlZlJhd0FyciA9IHNxcmVmLnNwbGl0KFwiIFwiKTtcclxuICBsZXQgc3FyZWZBcnIgPSBzcXJlZlJhd0Fyci5maWx0ZXIoKGUpID0+IGUgJiYgZS50cmltKCkpO1xyXG4gIGxldCBzcXJlZkxhc3RBcnIgPSBnZXRTcXJlZlJhd0FyckZvcm1hdChzcXJlZkFycik7XHJcblxyXG4gIGxldCByZXNBcnI6IHN0cmluZ1tdID0gW107XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcXJlZkxhc3RBcnIubGVuZ3RoOyBpKyspIHtcclxuICAgIGxldCBfcmVzID0gZ2V0U2luZ2xlU2VxdWVuY2VUb051bShzcXJlZkxhc3RBcnJbaV0pO1xyXG4gICAgaWYgKF9yZXMpIHJlc0Fyci5wdXNoKF9yZXMpO1xyXG4gIH1cclxuICByZXR1cm4gcmVzQXJyO1xyXG59XHJcblxyXG4vKipcclxuICogZ2V0IHJlZ2lvbiBzZXF1ZW5jZVxyXG4gKiBleGFtcGxlOlxyXG4gKiAgMeOAgVtBMTpDMiddIC0+IFsnQTEnLCAnQTInLCAnQjEnLCAnQjInLCAnQzEnLCAnQzInXVxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBhcnIgLSBmb3JtYXRzIGFyclxyXG4gKiBAcmV0dXJucyB7c3RyaW5nW119IC0gYWZ0ZXIgYXJyXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVnaW9uU2VxdWVuY2UoYXJyOiBzdHJpbmdbXSk6IHN0cmluZ1tdIHtcclxuICBsZXQgZm9ybWF0QXJyOiBzdHJpbmdbXSA9IFtdO1xyXG4gIFxyXG4gIGNvbnN0IHJlZ0VuID0gbmV3IFJlZ0V4cCgvW0EtWl0rfFswLTldKy9nKTtcclxuICBjb25zdCBzdGFydEFyciA9IGFyclswXT8ubWF0Y2gocmVnRW4pO1xyXG4gIGNvbnN0IGxhc3RBcnIgPSBhcnJbMV0/Lm1hdGNoKHJlZ0VuKTtcclxuICBjb25zdCBjb2x1bW5NYXggPSBNYXRoLm1heCguLi5bQUJDYXROdW0oc3RhcnRBcnJbMF0pLCBBQkNhdE51bShsYXN0QXJyWzBdKV0pO1xyXG4gIGNvbnN0IGNvbHVtbk1pbiA9IE1hdGgubWluKC4uLltBQkNhdE51bShzdGFydEFyclswXSksIEFCQ2F0TnVtKGxhc3RBcnJbMF0pXSk7XHJcbiAgY29uc3Qgcm93TWF4ID0gTWF0aC5tYXgoLi4uW3BhcnNlSW50KHN0YXJ0QXJyWzFdKSwgcGFyc2VJbnQobGFzdEFyclsxXSldKTtcclxuICBjb25zdCByb3dNaW4gPSBNYXRoLm1pbiguLi5bcGFyc2VJbnQoc3RhcnRBcnJbMV0pLCBwYXJzZUludChsYXN0QXJyWzFdKV0pO1xyXG4gIFxyXG4gIGZvciAobGV0IGkgPSBjb2x1bW5NaW47IGkgPD0gY29sdW1uTWF4OyBpKyspIHtcclxuICAgIGZvciAobGV0IGogPSByb3dNaW47IGogPD0gcm93TWF4OyBqKyspIHtcclxuICAgICAgZm9ybWF0QXJyLnB1c2goYCR7Y2hhdGF0QUJDKGkpfSR7an1gKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBmb3JtYXRBcnI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiB1bmlmaWVkIHByb2Nlc3Npbmcgb2YgY29udmVyc2lvbiBmb3JtYXRzXHJcbiAqIGV4YW1wbGU6XHJcbiAqICAx44CBWydFMzgnLCAnQTE6QzInXSAtPiBbJ0UzOCcsICdBMScsICdBMicsICdCMScsICdCMicsICdDMScsICdDMiddXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nW119IGFyciAtIGZvcm1hdHMgYXJyXHJcbiAqIEByZXR1cm5zIHtzdHJpbmdbXX0gLSBhZnRlciBhcnJcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRTcXJlZlJhd0FyckZvcm1hdChhcnI6IHN0cmluZ1tdKTogc3RyaW5nW10ge1xyXG4gIGFycj8ubWFwKChlbCkgPT4ge1xyXG4gICAgaWYgKGVsLmluY2x1ZGVzKFwiOlwiKSkge1xyXG4gICAgICBsZXQgdGVtcEFycjogc3RyaW5nW10gPSBlbC5zcGxpdChcIjpcIik7XHJcbiAgICAgIGlmICh0ZW1wQXJyPy5sZW5ndGggPT09IDIpIHtcclxuICAgICAgICBhcnIgPSBhcnIuY29uY2F0KGdldFJlZ2lvblNlcXVlbmNlKHRlbXBBcnIpKTtcclxuICAgICAgICBhcnIuc3BsaWNlKGFyci5pbmRleE9mKGVsKSwgMSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgY29uc3QgcmVzdWx0QXJyID0gYXJyLmZpbHRlcihcclxuICAgICh2YWx1ZSwgaW5kZXgsIGFycmF5KSA9PiBhcnJheS5pbmRleE9mKHZhbHVlKSA9PT0gaW5kZXhcclxuICApO1xyXG5cclxuICByZXR1cm4gcmVzdWx0QXJyO1xyXG59XHJcblxyXG4vKipcclxuICogc2luZ2xlIHNlcXVlbmNlIHRvIG51bWJlclxyXG4gKiBleGFtcGxlOlxyXG4gKiAgMeOAgUExIC0+IDBfMFxyXG4gKiAgMuOAgUVTMTQgLT4gMTNfNFxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3FyZWYgLSBiZWZvcmUgc2VxdWVuY2VcclxuICogQHJldHVybnMge3N0cmluZ30gLSBhZnRlciBzZXF1ZW5jZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNpbmdsZVNlcXVlbmNlVG9OdW0oc3FyZWY6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgbGV0IHNxcmVmQXJyYXkgPSBzcXJlZi5tYXRjaCgvW0EtWl0rfFswLTldKy9nKTtcclxuICBsZXQgc3FyZWZMZW4gPSBzcXJlZkFycmF5Lmxlbmd0aDtcclxuICBsZXQgcmVnRW4gPSBuZXcgUmVnRXhwKFwiXltBLVpdKyRcIik7XHJcbiAgbGV0IHJldCA9IFwiXCI7XHJcbiAgZm9yIChsZXQgaSA9IHNxcmVmTGVuIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgIGxldCBjdXIgPSBzcXJlZkFycmF5W2ldO1xyXG4gICAgaWYgKHJlZ0VuLnRlc3QoY3VyKSkge1xyXG4gICAgICByZXQgKz0gQUJDYXROdW0oY3VyKSArIFwiX1wiO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0ICs9IHBhcnNlSW50KGN1cikgLSAxICsgXCJfXCI7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZXQuc3Vic3RyaW5nKDAsIHJldC5sZW5ndGggLSAxKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFIxQzEgdG8gU2VxdWVuY2VcclxuICogZXhhbXBsZTogc2hlZXQyIVIxQzEgPT4gc2hlZXQhQTFcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gUjFDMSB2YWx1ZVxyXG4gKiBAcmV0dXJuc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFRyYW5zUjFDMVRvU2VxdWVuY2UodmFsdWU6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgaWYgKCF2YWx1ZSAmJiB2YWx1ZT8ubGVuZ3RoIDw9IDApIHJldHVybiBcIlwiO1xyXG5cclxuICBjb25zdCBsZW4gPSB2YWx1ZS5sZW5ndGg7XHJcbiAgY29uc3QgaW5kZXggPSB2YWx1ZS5sYXN0SW5kZXhPZihcIiFcIik7XHJcbiAgY29uc3QgdmFsdWVBcnIgPSBbdmFsdWUuc2xpY2UoMCwgaW5kZXgpLCB2YWx1ZS5zbGljZShpbmRleCArIDEsIGxlbildO1xyXG4gIGNvbnN0IHJlcFN0ciA9IHZhbHVlQXJyWzFdIHx8IFwiXCI7XHJcbiAgY29uc3QgaW5kZXhSID0gcmVwU3RyLmluZGV4T2YoXCJSXCIpO1xyXG4gIGNvbnN0IGluZGV4QyA9IHJlcFN0ci5pbmRleE9mKFwiQ1wiKTtcclxuICBcclxuICBjb25zdCByb3cgPSBOdW1iZXIocmVwU3RyLnNsaWNlKGluZGV4UiArIDEsIGluZGV4QykpO1xyXG4gIGNvbnN0IGNvbHVtbiA9IGNoYXRhdEFCQyhOdW1iZXIocmVwU3RyLnNsaWNlKGluZGV4QyArIDEsIHJlcFN0cj8ubGVuZ3RoKSkgLSAxKTtcclxuXHJcbiAgcmV0dXJuIGAke3ZhbHVlQXJyWzBdfSEke2NvbHVtbn0ke3Jvd31gO1xyXG59XHJcblxyXG4vKipcclxuICogc3RyaXAgeDE0IGZvcm1hdCBkYXRhXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSAtIHsgZm9ybXVsYSwgc3FyZWYgfVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFBlZWxPZmZYMTQodmFsdWU6IHN0cmluZyk6IHsgIFtrZXk6IHN0cmluZ106IGFueX0ge1xyXG4gIGlmICghdmFsdWUgfHwgdmFsdWU/Lmxlbmd0aCA8PSAwKSByZXR1cm4ge307XHJcblxyXG4gIC8vIGZvcm11bGFcclxuICBjb25zdCBmb3JtdWxhUmVnID0gbmV3IFJlZ0V4cChcIjwveDE0OmZvcm11bGFbXl0+XCIsIFwiZ1wiKTtcclxuICBjb25zdCBsYXN0SW5kZXggPSB2YWx1ZS5tYXRjaChmb3JtdWxhUmVnKT8ubGVuZ3RoO1xyXG4gIGNvbnN0IGxhc3RWYWx1ZSA9IGA8L3gxNDpmb3JtdWxhJHtsYXN0SW5kZXh9PmA7XHJcbiAgY29uc3QgbGFzdFZhbHVlRW5kID0gdmFsdWUuaW5kZXhPZihsYXN0VmFsdWUpO1xyXG4gIGxldCBmb3JtdWxhVmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgbGFzdFZhbHVlRW5kICsgbGFzdFZhbHVlLmxlbmd0aCk7XHJcbiAgZm9ybXVsYVZhbHVlID0gZm9ybXVsYVZhbHVlXHJcbiAgICAucmVwbGFjZSgvPHhtOmY+L2csIFwiXCIpXHJcbiAgICAucmVwbGFjZSgvPFxcL3htOmY+L2csIFwiXCIpXHJcbiAgICAucmVwbGFjZSgveDE0Oi9nLCBcIlwiKVxyXG4gICAgLnJlcGxhY2UoL1xcL3gxNDovZywgXCJcIik7XHJcbiAgY29uc3QgZm9ybXVsYSA9IGZvcm11bGFWYWx1ZTtcclxuICBcclxuICAvLyBzcXJlZlxyXG4gIGNvbnN0IHhtU3FyZWZMZW4gPSBcIjx4bTpzcXJlZj5cIi5sZW5ndGg7XHJcbiAgY29uc3Qgc3FyZWZTdGFydCA9IHZhbHVlLmluZGV4T2YoXCI8eG06c3FyZWY+XCIpO1xyXG4gIGNvbnN0IHNxcmVmRW5kID0gdmFsdWUuaW5kZXhPZihcIjwveG06c3FyZWY+XCIpO1xyXG4gIGNvbnN0IHNxcmVmID0gdmFsdWUuc3Vic3RyaW5nKHNxcmVmU3RhcnQgKyB4bVNxcmVmTGVuLCBzcXJlZkVuZCk7XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICBmb3JtdWxhLFxyXG4gICAgc3FyZWYsXHJcbiAgfTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBnZXQgdGhlIHZhbHVlIGluIHRoZSBmb3JtdWxhXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIGV4dHJhY3RlZCB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7c3RyaW5nW119XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TXVsdGlGb3JtdWxhVmFsdWUodmFsdWU6IHN0cmluZyk6IHN0cmluZ1tdIHtcclxuICBpZiAoIXZhbHVlIHx8IHZhbHVlPy5sZW5ndGggPD0gMCkgcmV0dXJuIFtdO1xyXG4gIFxyXG4gIGNvbnN0IGxlblJlZyA9IG5ldyBSZWdFeHAoXCJmb3JtdWxhXCIsIFwiZ1wiKTtcclxuICBjb25zdCBsZW4gPSAodmFsdWUubWF0Y2gobGVuUmVnKT8ubGVuZ3RoIHx8IDApIC8gMjtcclxuICBcclxuICBpZiAobGVuID09PSAwKSByZXR1cm4gW107XHJcbiAgXHJcbiAgbGV0IHJldEFycjogYW55ID0gW107XHJcbiAgZm9yIChsZXQgaSA9IDE7IGkgPD0gbGVuOyBpKyspIHtcclxuICAgIGNvbnN0IHN0YXJ0TGVuID0gYDxmb3JtdWxhJHtpfT5gPy5sZW5ndGg7XHJcbiAgICBjb25zdCBzdGFydCA9IHZhbHVlLmluZGV4T2YoYDxmb3JtdWxhJHtpfT5gKTtcclxuICAgIGNvbnN0IGVuZCA9IHZhbHVlLmluZGV4T2YoYDwvZm9ybXVsYSR7aX0+YCk7XHJcbiAgICBjb25zdCBfdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoc3RhcnQgKyBzdGFydExlbiwgZW5kKTtcclxuICAgIHJldEFyci5wdXNoKGVzY2FwZUNoYXJhY3RlcihfdmFsdWUucmVwbGFjZSgvJnF1b3Q7fF5cXFwifFxcXCIkL2csIFwiXCIpKSk7XHJcbiAgfVxyXG4gIHJldHVybiByZXRBcnI7XHJcbn0iLCJpbXBvcnQgeyBMdWNreUZpbGUgfSBmcm9tIFwiLi9Ub0x1Y2t5U2hlZXQvTHVja3lGaWxlXCI7XHJcbi8vIGltcG9ydCB7U2VjdXJpdHlEb29yLENhcn0gZnJvbSAnLi9jb250ZW50JztcclxuXHJcbmltcG9ydCB7SGFuZGxlWmlwfSBmcm9tICcuL0hhbmRsZVppcCc7XHJcblxyXG5pbXBvcnQge0l1cGxvYWRmaWxlTGlzdH0gZnJvbSBcIi4vSUNvbW1vblwiO1xyXG5pbXBvcnQgeyBmc3RhdCB9IGZyb20gXCJmc1wiO1xyXG5cclxuLy8gLy9kZW1vXHJcbi8vIGZ1bmN0aW9uIGRlbW9IYW5kbGVyKCl7XHJcbi8vICAgICBsZXQgdXBsb2FkID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJMdWNreWV4Y2VsLWRlbW8tZmlsZVwiKTtcclxuLy8gICAgIGxldCBzZWxlY3RBRGVtbyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiTHVja3lleGNlbC1zZWxlY3QtZGVtb1wiKTtcclxuLy8gICAgIGxldCBkb3dubG9kRGVtbyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiTHVja3lleGNlbC1kb3dubG9kLWZpbGVcIik7XHJcbi8vICAgICBsZXQgbWFzayA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibHVja3ktbWFzay1kZW1vXCIpO1xyXG4vLyAgICAgaWYodXBsb2FkKXtcclxuICAgICAgICBcclxuLy8gICAgICAgICB3aW5kb3cub25sb2FkID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBcclxuLy8gICAgICAgICAgICAgdXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgZnVuY3Rpb24oZXZ0KXtcclxuLy8gICAgICAgICAgICAgICAgIHZhciBmaWxlczpGaWxlTGlzdCA9IChldnQudGFyZ2V0IGFzIGFueSkuZmlsZXM7XHJcbi8vICAgICAgICAgICAgICAgICBpZihmaWxlcz09bnVsbCB8fCBmaWxlcy5sZW5ndGg9PTApe1xyXG4vLyAgICAgICAgICAgICAgICAgICAgIGFsZXJ0KFwiTm8gZmlsZXMgd2FpdCBmb3IgaW1wb3J0XCIpO1xyXG4vLyAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuLy8gICAgICAgICAgICAgICAgIH1cclxuXHJcbi8vICAgICAgICAgICAgICAgICBsZXQgbmFtZSA9IGZpbGVzWzBdLm5hbWU7XHJcbi8vICAgICAgICAgICAgICAgICBsZXQgc3VmZml4QXJyID0gbmFtZS5zcGxpdChcIi5cIiksIHN1ZmZpeCA9IHN1ZmZpeEFycltzdWZmaXhBcnIubGVuZ3RoLTFdO1xyXG4vLyAgICAgICAgICAgICAgICAgaWYoc3VmZml4IT1cInhsc3hcIil7XHJcbi8vICAgICAgICAgICAgICAgICAgICAgYWxlcnQoXCJDdXJyZW50bHkgb25seSBzdXBwb3J0cyB0aGUgaW1wb3J0IG9mIHhsc3ggZmlsZXNcIik7XHJcbi8vICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4vLyAgICAgICAgICAgICAgICAgfVxyXG4vLyAgICAgICAgICAgICAgICAgTHVja3lFeGNlbC50cmFuc2Zvcm1FeGNlbFRvTHVja3koZmlsZXNbMF0sIGZ1bmN0aW9uKGV4cG9ydEpzb246YW55LCBsdWNreXNoZWV0ZmlsZTpzdHJpbmcpe1xyXG4gICAgICAgICAgICAgICAgICAgIFxyXG4vLyAgICAgICAgICAgICAgICAgICAgIGlmKGV4cG9ydEpzb24uc2hlZXRzPT1udWxsIHx8IGV4cG9ydEpzb24uc2hlZXRzLmxlbmd0aD09MCl7XHJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGFsZXJ0KFwiRmFpbGVkIHRvIHJlYWQgdGhlIGNvbnRlbnQgb2YgdGhlIGV4Y2VsIGZpbGUsIGN1cnJlbnRseSBkb2VzIG5vdCBzdXBwb3J0IHhscyBmaWxlcyFcIik7XHJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuLy8gICAgICAgICAgICAgICAgICAgICB9XHJcbi8vICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXhwb3J0SnNvbiwgbHVja3lzaGVldGZpbGUpO1xyXG4vLyAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sdWNreXNoZWV0LmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgICAgICBcclxuLy8gICAgICAgICAgICAgICAgICAgICB3aW5kb3cubHVja3lzaGVldC5jcmVhdGUoe1xyXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6ICdsdWNreXNoZWV0JywgLy9sdWNreXNoZWV0IGlzIHRoZSBjb250YWluZXIgaWRcclxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgc2hvd2luZm9iYXI6ZmFsc2UsXHJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6ZXhwb3J0SnNvbi5zaGVldHMsXHJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHRpdGxlOmV4cG9ydEpzb24uaW5mby5uYW1lLFxyXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB1c2VySW5mbzpleHBvcnRKc29uLmluZm8ubmFtZS5jcmVhdG9yXHJcbi8vICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbi8vICAgICAgICAgICAgICAgICB9KTtcclxuLy8gICAgICAgICAgICAgfSk7XHJcblxyXG4vLyAgICAgICAgICAgICBzZWxlY3RBRGVtby5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGZ1bmN0aW9uKGV2dCl7XHJcbi8vICAgICAgICAgICAgICAgICB2YXIgb2JqOmFueSA9IHNlbGVjdEFEZW1vO1xyXG4vLyAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gb2JqLnNlbGVjdGVkSW5kZXg7XHJcbi8vICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBvYmoub3B0aW9uc1tpbmRleF0udmFsdWU7XHJcbi8vICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IG9iai5vcHRpb25zW2luZGV4XS5pbm5lckhUTUw7XHJcbi8vICAgICAgICAgICAgICAgICBpZih2YWx1ZT09XCJcIil7XHJcbi8vICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4vLyAgICAgICAgICAgICAgICAgfVxyXG4vLyAgICAgICAgICAgICAgICAgbWFzay5zdHlsZS5kaXNwbGF5ID0gXCJmbGV4XCI7XHJcbi8vICAgICAgICAgICAgICAgICBMdWNreUV4Y2VsLnRyYW5zZm9ybUV4Y2VsVG9MdWNreUJ5VXJsKHZhbHVlLCBuYW1lLCBmdW5jdGlvbihleHBvcnRKc29uOmFueSwgbHVja3lzaGVldGZpbGU6c3RyaW5nKXtcclxuICAgICAgICAgICAgICAgICAgICBcclxuLy8gICAgICAgICAgICAgICAgICAgICBpZihleHBvcnRKc29uLnNoZWV0cz09bnVsbCB8fCBleHBvcnRKc29uLnNoZWV0cy5sZW5ndGg9PTApe1xyXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBhbGVydChcIkZhaWxlZCB0byByZWFkIHRoZSBjb250ZW50IG9mIHRoZSBleGNlbCBmaWxlLCBjdXJyZW50bHkgZG9lcyBub3Qgc3VwcG9ydCB4bHMgZmlsZXMhXCIpO1xyXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbi8vICAgICAgICAgICAgICAgICAgICAgfVxyXG4vLyAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGV4cG9ydEpzb24sIGx1Y2t5c2hlZXRmaWxlKTtcclxuLy8gICAgICAgICAgICAgICAgICAgICBtYXNrLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcclxuLy8gICAgICAgICAgICAgICAgICAgICB3aW5kb3cubHVja3lzaGVldC5kZXN0cm95KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXHJcbi8vICAgICAgICAgICAgICAgICAgICAgd2luZG93Lmx1Y2t5c2hlZXQuY3JlYXRlKHtcclxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiAnbHVja3lzaGVldCcsIC8vbHVja3lzaGVldCBpcyB0aGUgY29udGFpbmVyIGlkXHJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgIHNob3dpbmZvYmFyOmZhbHNlLFxyXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOmV4cG9ydEpzb24uc2hlZXRzLFxyXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTpleHBvcnRKc29uLmluZm8ubmFtZSxcclxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgdXNlckluZm86ZXhwb3J0SnNvbi5pbmZvLm5hbWUuY3JlYXRvclxyXG4vLyAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4vLyAgICAgICAgICAgICAgICAgfSk7XHJcbi8vICAgICAgICAgICAgIH0pO1xyXG5cclxuLy8gICAgICAgICAgICAgZG93bmxvZERlbW8uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGV2dCl7XHJcbi8vICAgICAgICAgICAgICAgICB2YXIgb2JqOmFueSA9IHNlbGVjdEFEZW1vO1xyXG4vLyAgICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gb2JqLnNlbGVjdGVkSW5kZXg7XHJcbi8vICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBvYmoub3B0aW9uc1tpbmRleF0udmFsdWU7XHJcblxyXG4vLyAgICAgICAgICAgICAgICAgaWYodmFsdWUubGVuZ3RoPT0wKXtcclxuLy8gICAgICAgICAgICAgICAgICAgICBhbGVydChcIlBsZWFzZSBzZWxlY3QgYSBkZW1vIGZpbGVcIik7XHJcbi8vICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4vLyAgICAgICAgICAgICAgICAgfVxyXG5cclxuLy8gICAgICAgICAgICAgICAgIHZhciBlbGVtSUY6YW55ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJMdWNreS1kb3dubG9hZC1mcmFtZVwiKTtcclxuLy8gICAgICAgICAgICAgICAgIGlmKGVsZW1JRj09bnVsbCl7XHJcbi8vICAgICAgICAgICAgICAgICAgICAgZWxlbUlGID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtcclxuLy8gICAgICAgICAgICAgICAgICAgICBlbGVtSUYuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG4vLyAgICAgICAgICAgICAgICAgICAgIGVsZW1JRi5pZCA9IFwiTHVja3ktZG93bmxvYWQtZnJhbWVcIjtcclxuLy8gICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsZW1JRik7XHJcbi8vICAgICAgICAgICAgICAgICB9XHJcbi8vICAgICAgICAgICAgICAgICBlbGVtSUYuc3JjID0gdmFsdWU7XHJcblxyXG4vLyAgICAgICAgICAgICAgICAgLy8gZWxlbUlGLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbUlGKTtcclxuLy8gICAgICAgICAgICAgfSk7XHJcbi8vICAgICAgICAgfVxyXG4vLyAgICAgfVxyXG4vLyB9XHJcbi8vIGRlbW9IYW5kbGVyKCk7XHJcblxyXG4vLyBhcGlcclxuZXhwb3J0IGNsYXNzIGV4Y2VsZXJ7XHJcbiAgICBzdGF0aWMgdHJhbnNmb3JtRXhjZWxUb0x1Y2t5KGV4Y2VsRmlsZTogRmlsZSxcclxuICAgICAgICBjYWxsYmFjaz86IChmaWxlczogSXVwbG9hZGZpbGVMaXN0LCBmcz86IHN0cmluZykgPT4gdm9pZCxcclxuICAgICAgICBlcnJvckhhbmRsZXI/OiAoZXJyOiBFcnJvcikgPT4gdm9pZCkge1xyXG4gICAgICAgIGxldCBoYW5kbGVaaXA6SGFuZGxlWmlwID0gbmV3IEhhbmRsZVppcChleGNlbEZpbGUpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGhhbmRsZVppcC51bnppcEZpbGUoZnVuY3Rpb24gKGZpbGVzOiBJdXBsb2FkZmlsZUxpc3QpIHtcclxuICAgICAgICAgICAgbGV0IGx1Y2t5RmlsZSA9IG5ldyBMdWNreUZpbGUoZmlsZXMsIGV4Y2VsRmlsZS5uYW1lKTtcclxuICAgICAgICAgICAgbGV0IGx1Y2t5c2hlZXRmaWxlID0gbHVja3lGaWxlLlBhcnNlKCk7XHJcbiAgICAgICAgICAgIGxldCBleHBvcnRKc29uID0gSlNPTi5wYXJzZShsdWNreXNoZWV0ZmlsZSk7XHJcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGV4cG9ydEpzb24sIGx1Y2t5c2hlZXRmaWxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZnVuY3Rpb24oZXJyOkVycm9yKXtcclxuICAgICAgICAgICAgaWYgKGVycm9ySGFuZGxlcikge1xyXG4gICAgICAgICAgICAgICAgZXJyb3JIYW5kbGVyKGVycik7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGljIHRyYW5zZm9ybUV4Y2VsVG9MdWNreUJ5VXJsKFxyXG4gICAgICAgIHVybDogc3RyaW5nLFxyXG4gICAgICAgIG5hbWU6IHN0cmluZyxcclxuICAgICAgICBjYWxsQmFjaz86IChmaWxlczogSXVwbG9hZGZpbGVMaXN0LCBmcz86IHN0cmluZykgPT4gdm9pZCxcclxuICAgICAgICBlcnJvckhhbmRsZXI/OiAoZXJyOiBFcnJvcikgPT4gdm9pZCkge1xyXG4gICAgICAgIGxldCBoYW5kbGVaaXA6SGFuZGxlWmlwID0gbmV3IEhhbmRsZVppcCgpO1xyXG4gICAgICAgIGhhbmRsZVppcC51bnppcEZpbGVCeVVybCh1cmwsIGZ1bmN0aW9uKGZpbGVzOkl1cGxvYWRmaWxlTGlzdCl7XHJcbiAgICAgICAgICAgIGxldCBsdWNreUZpbGUgPSBuZXcgTHVja3lGaWxlKGZpbGVzLCBuYW1lKTtcclxuICAgICAgICAgICAgbGV0IGx1Y2t5c2hlZXRmaWxlID0gbHVja3lGaWxlLlBhcnNlKCk7XHJcbiAgICAgICAgICAgIGxldCBleHBvcnRKc29uID0gSlNPTi5wYXJzZShsdWNreXNoZWV0ZmlsZSk7XHJcbiAgICAgICAgICAgIGlmKGNhbGxCYWNrICE9IHVuZGVmaW5lZCl7XHJcbiAgICAgICAgICAgICAgICBjYWxsQmFjayhleHBvcnRKc29uLCBsdWNreXNoZWV0ZmlsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGZ1bmN0aW9uKGVycjpFcnJvcil7XHJcbiAgICAgICAgICAgIGlmIChlcnJvckhhbmRsZXIpIHtcclxuICAgICAgICAgICAgICAgIGVycm9ySGFuZGxlcihlcnIpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRpYyB0cmFuc2Zvcm1MdWNreVRvRXhjZWwoXHJcbiAgICAgICAgTHVja3lGaWxlOiBhbnksXHJcbiAgICAgICAgY2FsbEJhY2s/OiAoZmlsZXM6IHN0cmluZykgPT4gdm9pZCAsXHJcbiAgICAgICAgZXJyb3JIYW5kbGVyPzogKGVycjogRXJyb3IpID0+IHZvaWQpeyB9XHJcbn0iLCJpbXBvcnQge2V4Y2VsZXJ9IGZyb20gXCIuL21haW5cIlxyXG4vLyBleHBvcnQgTm9kZSBtb2R1bGVcclxuZXhwb3J0ID0gZXhjZWxlcjsiXX0=

//# sourceMappingURL=exceler.umd.js.map
